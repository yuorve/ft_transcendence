// node_modules/@babylonjs/core/Misc/decorators.functions.js
var __mergedStore = {};
var __decoratorInitialStore = {};
function GetDirectStore(target) {
  const classKey = target.getClassName();
  if (!__decoratorInitialStore[classKey]) {
    __decoratorInitialStore[classKey] = {};
  }
  return __decoratorInitialStore[classKey];
}
function GetMergedStore(target) {
  const classKey = target.getClassName();
  if (__mergedStore[classKey]) {
    return __mergedStore[classKey];
  }
  __mergedStore[classKey] = {};
  const store = __mergedStore[classKey];
  let currentTarget = target;
  let currentKey = classKey;
  while (currentKey) {
    const initialStore = __decoratorInitialStore[currentKey];
    for (const property in initialStore) {
      store[property] = initialStore[property];
    }
    let parent;
    let done = false;
    do {
      parent = Object.getPrototypeOf(currentTarget);
      if (!parent.getClassName) {
        done = true;
        break;
      }
      if (parent.getClassName() !== currentKey) {
        break;
      }
      currentTarget = parent;
    } while (parent);
    if (done) {
      break;
    }
    currentKey = parent.getClassName();
    currentTarget = parent;
  }
  return store;
}

// node_modules/@babylonjs/core/Misc/decorators.js
function generateSerializableMember(type, sourceName) {
  return (target, propertyKey) => {
    const classStore = GetDirectStore(target);
    if (!classStore[propertyKey]) {
      classStore[propertyKey] = { type, sourceName };
    }
  };
}
function generateExpandMember(setCallback, targetKey = null) {
  return (target, propertyKey) => {
    const key = targetKey || "_" + propertyKey;
    Object.defineProperty(target, propertyKey, {
      get: function() {
        return this[key];
      },
      set: function(value) {
        var _a;
        if (typeof ((_a = this[key]) == null ? void 0 : _a.equals) === "function") {
          if (this[key].equals(value)) {
            return;
          }
        }
        if (this[key] === value) {
          return;
        }
        this[key] = value;
        target[setCallback].apply(this);
      },
      enumerable: true,
      configurable: true
    });
  };
}
function expandToProperty(callback, targetKey = null) {
  return generateExpandMember(callback, targetKey);
}
function serialize(sourceName) {
  return generateSerializableMember(0, sourceName);
}
function serializeAsTexture(sourceName) {
  return generateSerializableMember(1, sourceName);
}
function serializeAsColor3(sourceName) {
  return generateSerializableMember(2, sourceName);
}
function serializeAsFresnelParameters(sourceName) {
  return generateSerializableMember(3, sourceName);
}
function serializeAsVector2(sourceName) {
  return generateSerializableMember(4, sourceName);
}
function serializeAsVector3(sourceName) {
  return generateSerializableMember(5, sourceName);
}
function serializeAsMeshReference(sourceName) {
  return generateSerializableMember(6, sourceName);
}
function serializeAsColorCurves(sourceName) {
  return generateSerializableMember(7, sourceName);
}
function serializeAsColor4(sourceName) {
  return generateSerializableMember(8, sourceName);
}
function serializeAsImageProcessingConfiguration(sourceName) {
  return generateSerializableMember(9, sourceName);
}
function serializeAsQuaternion(sourceName) {
  return generateSerializableMember(10, sourceName);
}
function serializeAsMatrix(sourceName) {
  return generateSerializableMember(12, sourceName);
}
function serializeAsCameraReference(sourceName) {
  return generateSerializableMember(11, sourceName);
}
function nativeOverride(target, propertyKey, descriptor, predicate) {
  const jsFunc = descriptor.value;
  descriptor.value = (...params) => {
    let func = jsFunc;
    if (typeof _native !== "undefined" && _native[propertyKey]) {
      const nativeFunc = _native[propertyKey];
      if (predicate) {
        func = (...params2) => predicate(...params2) ? nativeFunc(...params2) : jsFunc(...params2);
      } else {
        func = nativeFunc;
      }
    }
    target[propertyKey] = func;
    return func(...params);
  };
}
nativeOverride.filter = function(predicate) {
  return (target, propertyKey, descriptor) => nativeOverride(target, propertyKey, descriptor, predicate);
};

// node_modules/@babylonjs/core/tslib.es6.js
function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}

export {
  __decorate,
  GetMergedStore,
  expandToProperty,
  serialize,
  serializeAsTexture,
  serializeAsColor3,
  serializeAsFresnelParameters,
  serializeAsVector2,
  serializeAsVector3,
  serializeAsMeshReference,
  serializeAsColorCurves,
  serializeAsColor4,
  serializeAsImageProcessingConfiguration,
  serializeAsQuaternion,
  serializeAsMatrix,
  serializeAsCameraReference,
  nativeOverride
};
//# sourceMappingURL=chunk-3FJRTHLS.js.map
