{
  "version": 3,
  "sources": ["../../../dev/core/src/Maths/math.functions.ts", "../../../dev/core/src/Materials/clipPlaneMaterialHelper.ts", "../../../dev/core/src/Materials/materialHelper.functions.ts"],
  "sourcesContent": ["import type { FloatArray, Nullable, IndicesArray } from \"../types\";\r\nimport type { Vector2 } from \"./math.vector\";\r\nimport { Vector3 } from \"./math.vector\";\r\nimport { nativeOverride } from \"../Misc/decorators\";\r\n\r\n// This helper class is only here so we can apply the nativeOverride decorator to functions.\r\nclass MathHelpers {\r\n    @nativeOverride.filter((...[positions, indices]: Parameters<typeof MathHelpers.extractMinAndMaxIndexed>) => !Array.isArray(positions) && !Array.isArray(indices))\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public static extractMinAndMaxIndexed(positions: FloatArray, indices: IndicesArray, indexStart: number, indexCount: number, minimum: Vector3, maximum: Vector3): void {\r\n        for (let index = indexStart; index < indexStart + indexCount; index++) {\r\n            const offset = indices[index] * 3;\r\n            const x = positions[offset];\r\n            const y = positions[offset + 1];\r\n            const z = positions[offset + 2];\r\n            minimum.minimizeInPlaceFromFloats(x, y, z);\r\n            maximum.maximizeInPlaceFromFloats(x, y, z);\r\n        }\r\n    }\r\n\r\n    @nativeOverride.filter((...[positions]: Parameters<typeof MathHelpers.extractMinAndMax>) => !Array.isArray(positions))\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public static extractMinAndMax(positions: FloatArray, start: number, count: number, stride: number, minimum: Vector3, maximum: Vector3): void {\r\n        for (let index = start, offset = start * stride; index < start + count; index++, offset += stride) {\r\n            const x = positions[offset];\r\n            const y = positions[offset + 1];\r\n            const z = positions[offset + 2];\r\n            minimum.minimizeInPlaceFromFloats(x, y, z);\r\n            maximum.maximizeInPlaceFromFloats(x, y, z);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Extracts minimum and maximum values from a list of indexed positions\r\n * @param positions defines the positions to use\r\n * @param indices defines the indices to the positions\r\n * @param indexStart defines the start index\r\n * @param indexCount defines the end index\r\n * @param bias defines bias value to add to the result\r\n * @returns minimum and maximum values\r\n */\r\nexport function extractMinAndMaxIndexed(\r\n    positions: FloatArray,\r\n    indices: IndicesArray,\r\n    indexStart: number,\r\n    indexCount: number,\r\n    bias: Nullable<Vector2> = null\r\n): { minimum: Vector3; maximum: Vector3 } {\r\n    const minimum = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n    const maximum = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\r\n\r\n    MathHelpers.extractMinAndMaxIndexed(positions, indices, indexStart, indexCount, minimum, maximum);\r\n\r\n    if (bias) {\r\n        minimum.x -= minimum.x * bias.x + bias.y;\r\n        minimum.y -= minimum.y * bias.x + bias.y;\r\n        minimum.z -= minimum.z * bias.x + bias.y;\r\n        maximum.x += maximum.x * bias.x + bias.y;\r\n        maximum.y += maximum.y * bias.x + bias.y;\r\n        maximum.z += maximum.z * bias.x + bias.y;\r\n    }\r\n\r\n    return {\r\n        minimum: minimum,\r\n        maximum: maximum,\r\n    };\r\n}\r\n\r\n/**\r\n * Extracts minimum and maximum values from a list of positions\r\n * @param positions defines the positions to use\r\n * @param start defines the start index in the positions array\r\n * @param count defines the number of positions to handle\r\n * @param bias defines bias value to add to the result\r\n * @param stride defines the stride size to use (distance between two positions in the positions array)\r\n * @returns minimum and maximum values\r\n */\r\nexport function extractMinAndMax(positions: FloatArray, start: number, count: number, bias: Nullable<Vector2> = null, stride?: number): { minimum: Vector3; maximum: Vector3 } {\r\n    const minimum = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n    const maximum = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\r\n\r\n    if (!stride) {\r\n        stride = 3;\r\n    }\r\n\r\n    MathHelpers.extractMinAndMax(positions, start, count, stride, minimum, maximum);\r\n\r\n    if (bias) {\r\n        minimum.x -= minimum.x * bias.x + bias.y;\r\n        minimum.y -= minimum.y * bias.x + bias.y;\r\n        minimum.z -= minimum.z * bias.x + bias.y;\r\n        maximum.x += maximum.x * bias.x + bias.y;\r\n        maximum.y += maximum.y * bias.x + bias.y;\r\n        maximum.z += maximum.z * bias.x + bias.y;\r\n    }\r\n\r\n    return {\r\n        minimum: minimum,\r\n        maximum: maximum,\r\n    };\r\n}\r\n\r\n/**\r\n * Flip flipped faces\r\n * @param positions defines the positions to use\r\n * @param indices defines the indices to use and update\r\n */\r\nexport function FixFlippedFaces(positions: FloatArray, indices: IndicesArray): void {\r\n    const boundingInfo = extractMinAndMax(positions!, 0, positions!.length / 3);\r\n\r\n    const inside = boundingInfo.maximum.subtract(boundingInfo.minimum).scale(0.5).add(boundingInfo.minimum);\r\n    const tmpVectorA = new Vector3();\r\n    const tmpVectorB = new Vector3();\r\n    const tmpVectorC = new Vector3();\r\n    const tmpVectorAB = new Vector3();\r\n    const tmpVectorAC = new Vector3();\r\n    const tmpVectorNormal = new Vector3();\r\n    const tmpVectorAvgNormal = new Vector3();\r\n\r\n    // Clean indices\r\n    for (let index = 0; index < indices.length; index += 3) {\r\n        const a = indices[index];\r\n        const b = indices[index + 1];\r\n        const c = indices[index + 2];\r\n\r\n        // Evaluate face normal\r\n        tmpVectorA.fromArray(positions, a * 3);\r\n        tmpVectorB.fromArray(positions, b * 3);\r\n        tmpVectorC.fromArray(positions, c * 3);\r\n\r\n        tmpVectorB.subtractToRef(tmpVectorA, tmpVectorAB);\r\n        tmpVectorC.subtractToRef(tmpVectorA, tmpVectorAC);\r\n\r\n        Vector3.CrossToRef(tmpVectorAB, tmpVectorAC, tmpVectorNormal);\r\n\r\n        tmpVectorNormal.normalize();\r\n\r\n        // Calculate normal from face center to the inside of the geometry\r\n        const avgX = tmpVectorA.x + tmpVectorB.x + tmpVectorC.x;\r\n        const avgY = tmpVectorA.y + tmpVectorB.y + tmpVectorC.y;\r\n        const avgZ = tmpVectorA.z + tmpVectorB.z + tmpVectorC.z;\r\n\r\n        tmpVectorAvgNormal.set(avgX / 3, avgY / 3, avgZ / 3);\r\n        tmpVectorAvgNormal.subtractInPlace(inside);\r\n        tmpVectorAvgNormal.normalize();\r\n\r\n        if (Vector3.Dot(tmpVectorNormal, tmpVectorAvgNormal) >= 0) {\r\n            // Flip!\r\n            indices[index] = c;\r\n            indices[index + 2] = a;\r\n        }\r\n    }\r\n}\r\n", "import type { Effect } from \"./effect\";\r\nimport type { IClipPlanesHolder } from \"../Misc/interfaces/iClipPlanesHolder\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Plane } from \"../Maths/math.plane\";\r\n\r\n/** @internal */\r\nexport function addClipPlaneUniforms(uniforms: string[]): void {\r\n    if (uniforms.indexOf(\"vClipPlane\") === -1) {\r\n        uniforms.push(\"vClipPlane\");\r\n    }\r\n    if (uniforms.indexOf(\"vClipPlane2\") === -1) {\r\n        uniforms.push(\"vClipPlane2\");\r\n    }\r\n    if (uniforms.indexOf(\"vClipPlane3\") === -1) {\r\n        uniforms.push(\"vClipPlane3\");\r\n    }\r\n    if (uniforms.indexOf(\"vClipPlane4\") === -1) {\r\n        uniforms.push(\"vClipPlane4\");\r\n    }\r\n    if (uniforms.indexOf(\"vClipPlane5\") === -1) {\r\n        uniforms.push(\"vClipPlane5\");\r\n    }\r\n    if (uniforms.indexOf(\"vClipPlane6\") === -1) {\r\n        uniforms.push(\"vClipPlane6\");\r\n    }\r\n}\r\n\r\n/** @internal */\r\nexport function prepareStringDefinesForClipPlanes(primaryHolder: IClipPlanesHolder, secondaryHolder: IClipPlanesHolder, defines: string[]): void {\r\n    const clipPlane = !!(primaryHolder.clipPlane ?? secondaryHolder.clipPlane);\r\n    const clipPlane2 = !!(primaryHolder.clipPlane2 ?? secondaryHolder.clipPlane2);\r\n    const clipPlane3 = !!(primaryHolder.clipPlane3 ?? secondaryHolder.clipPlane3);\r\n    const clipPlane4 = !!(primaryHolder.clipPlane4 ?? secondaryHolder.clipPlane4);\r\n    const clipPlane5 = !!(primaryHolder.clipPlane5 ?? secondaryHolder.clipPlane5);\r\n    const clipPlane6 = !!(primaryHolder.clipPlane6 ?? secondaryHolder.clipPlane6);\r\n\r\n    if (clipPlane) defines.push(\"#define CLIPPLANE\");\r\n    if (clipPlane2) defines.push(\"#define CLIPPLANE2\");\r\n    if (clipPlane3) defines.push(\"#define CLIPPLANE3\");\r\n    if (clipPlane4) defines.push(\"#define CLIPPLANE4\");\r\n    if (clipPlane5) defines.push(\"#define CLIPPLANE5\");\r\n    if (clipPlane6) defines.push(\"#define CLIPPLANE6\");\r\n}\r\n\r\n/** @internal */\r\nexport function prepareDefinesForClipPlanes(primaryHolder: IClipPlanesHolder, secondaryHolder: IClipPlanesHolder, defines: Record<string, any>): boolean {\r\n    let changed = false;\r\n\r\n    const clipPlane = !!(primaryHolder.clipPlane ?? secondaryHolder.clipPlane);\r\n    const clipPlane2 = !!(primaryHolder.clipPlane2 ?? secondaryHolder.clipPlane2);\r\n    const clipPlane3 = !!(primaryHolder.clipPlane3 ?? secondaryHolder.clipPlane3);\r\n    const clipPlane4 = !!(primaryHolder.clipPlane4 ?? secondaryHolder.clipPlane4);\r\n    const clipPlane5 = !!(primaryHolder.clipPlane5 ?? secondaryHolder.clipPlane5);\r\n    const clipPlane6 = !!(primaryHolder.clipPlane6 ?? secondaryHolder.clipPlane6);\r\n\r\n    // Do not factorize this code, it breaks browsers optimizations.\r\n    if (defines[\"CLIPPLANE\"] !== clipPlane) {\r\n        defines[\"CLIPPLANE\"] = clipPlane;\r\n        changed = true;\r\n    }\r\n    if (defines[\"CLIPPLANE2\"] !== clipPlane2) {\r\n        defines[\"CLIPPLANE2\"] = clipPlane2;\r\n        changed = true;\r\n    }\r\n    if (defines[\"CLIPPLANE3\"] !== clipPlane3) {\r\n        defines[\"CLIPPLANE3\"] = clipPlane3;\r\n        changed = true;\r\n    }\r\n    if (defines[\"CLIPPLANE4\"] !== clipPlane4) {\r\n        defines[\"CLIPPLANE4\"] = clipPlane4;\r\n        changed = true;\r\n    }\r\n    if (defines[\"CLIPPLANE5\"] !== clipPlane5) {\r\n        defines[\"CLIPPLANE5\"] = clipPlane5;\r\n        changed = true;\r\n    }\r\n    if (defines[\"CLIPPLANE6\"] !== clipPlane6) {\r\n        defines[\"CLIPPLANE6\"] = clipPlane6;\r\n        changed = true;\r\n    }\r\n\r\n    return changed;\r\n}\r\n\r\n/** @internal */\r\nexport function bindClipPlane(effect: Effect, primaryHolder: IClipPlanesHolder, secondaryHolder: IClipPlanesHolder): void {\r\n    let clipPlane = primaryHolder.clipPlane ?? secondaryHolder.clipPlane;\r\n    setClipPlane(effect, \"vClipPlane\", clipPlane);\r\n    clipPlane = primaryHolder.clipPlane2 ?? secondaryHolder.clipPlane2;\r\n    setClipPlane(effect, \"vClipPlane2\", clipPlane);\r\n    clipPlane = primaryHolder.clipPlane3 ?? secondaryHolder.clipPlane3;\r\n    setClipPlane(effect, \"vClipPlane3\", clipPlane);\r\n    clipPlane = primaryHolder.clipPlane4 ?? secondaryHolder.clipPlane4;\r\n    setClipPlane(effect, \"vClipPlane4\", clipPlane);\r\n    clipPlane = primaryHolder.clipPlane5 ?? secondaryHolder.clipPlane5;\r\n    setClipPlane(effect, \"vClipPlane5\", clipPlane);\r\n    clipPlane = primaryHolder.clipPlane6 ?? secondaryHolder.clipPlane6;\r\n    setClipPlane(effect, \"vClipPlane6\", clipPlane);\r\n}\r\n\r\nfunction setClipPlane(effect: Effect, uniformName: string, clipPlane: Nullable<Plane>): void {\r\n    if (clipPlane) {\r\n        effect.setFloat4(uniformName, clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.d);\r\n    }\r\n}\r\n", "import { Logger } from \"../Misc/logger\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { Effect, IEffectCreationOptions } from \"./effect\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { Color3 } from \"../Maths/math.color\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport type { UniformBuffer } from \"./uniformBuffer\";\r\nimport type { BaseTexture } from \"./Textures/baseTexture\";\r\nimport type { PrePassConfiguration } from \"./prePassConfiguration\";\r\nimport type { Light } from \"../Lights/light\";\r\nimport type { MaterialDefines } from \"./materialDefines\";\r\nimport type { EffectFallbacks } from \"./effectFallbacks\";\r\nimport { LightConstants } from \"../Lights/lightConstants\";\r\nimport type { AbstractEngine } from \"../Engines/abstractEngine\";\r\nimport type { Material } from \"./material\";\r\nimport type { Nullable } from \"../types\";\r\nimport { prepareDefinesForClipPlanes } from \"./clipPlaneMaterialHelper\";\r\nimport type { MorphTargetManager } from \"core/Morph/morphTargetManager\";\r\n\r\n// Temps\r\nconst _TempFogColor = Color3.Black();\r\nconst _TmpMorphInfluencers = {\r\n    NUM_MORPH_INFLUENCERS: 0,\r\n    NORMAL: false,\r\n    TANGENT: false,\r\n    UV: false,\r\n    UV2: false,\r\n    COLOR: false,\r\n};\r\n\r\n/**\r\n * Binds the logarithmic depth information from the scene to the effect for the given defines.\r\n * @param defines The generated defines used in the effect\r\n * @param effect The effect we are binding the data to\r\n * @param scene The scene we are willing to render with logarithmic scale for\r\n */\r\nexport function BindLogDepth(defines: any, effect: Effect, scene: Scene): void {\r\n    if (!defines || defines[\"LOGARITHMICDEPTH\"] || (defines.indexOf && defines.indexOf(\"LOGARITHMICDEPTH\") >= 0)) {\r\n        const camera = scene.activeCamera as Camera;\r\n        if (camera.mode === Constants.ORTHOGRAPHIC_CAMERA) {\r\n            Logger.Error(\"Logarithmic depth is not compatible with orthographic cameras!\", 20);\r\n        }\r\n        effect.setFloat(\"logarithmicDepthConstant\", 2.0 / (Math.log(camera.maxZ + 1.0) / Math.LN2));\r\n    }\r\n}\r\n\r\n/**\r\n * Binds the fog information from the scene to the effect for the given mesh.\r\n * @param scene The scene the lights belongs to\r\n * @param mesh The mesh we are binding the information to render\r\n * @param effect The effect we are binding the data to\r\n * @param linearSpace Defines if the fog effect is applied in linear space\r\n */\r\nexport function BindFogParameters(scene: Scene, mesh?: AbstractMesh, effect?: Effect, linearSpace = false): void {\r\n    if (effect && scene.fogEnabled && (!mesh || mesh.applyFog) && scene.fogMode !== Constants.FOGMODE_NONE) {\r\n        effect.setFloat4(\"vFogInfos\", scene.fogMode, scene.fogStart, scene.fogEnd, scene.fogDensity);\r\n        // Convert fog color to linear space if used in a linear space computed shader.\r\n        if (linearSpace) {\r\n            scene.fogColor.toLinearSpaceToRef(_TempFogColor, scene.getEngine().useExactSrgbConversions);\r\n            effect.setColor3(\"vFogColor\", _TempFogColor);\r\n        } else {\r\n            effect.setColor3(\"vFogColor\", scene.fogColor);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Prepares the list of attributes and defines required for morph targets.\r\n * @param morphTargetManager The manager for the morph targets\r\n * @param defines The current list of defines\r\n * @param attribs The current list of attributes\r\n * @param mesh The mesh to prepare the defines and attributes for\r\n * @param usePositionMorph Whether the position morph target is used\r\n * @param useNormalMorph Whether the normal morph target is used\r\n * @param useTangentMorph Whether the tangent morph target is used\r\n * @param useUVMorph Whether the UV morph target is used\r\n * @param useUV2Morph Whether the UV2 morph target is used\r\n * @param useColorMorph Whether the color morph target is used\r\n * @returns The maxSimultaneousMorphTargets for the effect\r\n */\r\nexport function PrepareDefinesAndAttributesForMorphTargets(\r\n    morphTargetManager: MorphTargetManager,\r\n    defines: string[],\r\n    attribs: string[],\r\n    mesh: AbstractMesh,\r\n    usePositionMorph: boolean,\r\n    useNormalMorph: boolean,\r\n    useTangentMorph: boolean,\r\n    useUVMorph: boolean,\r\n    useUV2Morph: boolean,\r\n    useColorMorph: boolean\r\n): number {\r\n    const numMorphInfluencers = morphTargetManager.numMaxInfluencers || morphTargetManager.numInfluencers;\r\n    if (numMorphInfluencers <= 0) {\r\n        return 0;\r\n    }\r\n\r\n    defines.push(\"#define MORPHTARGETS\");\r\n\r\n    if (morphTargetManager.hasPositions) defines.push(\"#define MORPHTARGETTEXTURE_HASPOSITIONS\");\r\n    if (morphTargetManager.hasNormals) defines.push(\"#define MORPHTARGETTEXTURE_HASNORMALS\");\r\n    if (morphTargetManager.hasTangents) defines.push(\"#define MORPHTARGETTEXTURE_HASTANGENTS\");\r\n    if (morphTargetManager.hasUVs) defines.push(\"#define MORPHTARGETTEXTURE_HASUVS\");\r\n    if (morphTargetManager.hasUV2s) defines.push(\"#define MORPHTARGETTEXTURE_HASUV2S\");\r\n    if (morphTargetManager.hasColors) defines.push(\"#define MORPHTARGETTEXTURE_HASCOLORS\");\r\n\r\n    if (morphTargetManager.supportsPositions && usePositionMorph) defines.push(\"#define MORPHTARGETS_POSITION\");\r\n    if (morphTargetManager.supportsNormals && useNormalMorph) defines.push(\"#define MORPHTARGETS_NORMAL\");\r\n    if (morphTargetManager.supportsTangents && useTangentMorph) defines.push(\"#define MORPHTARGETS_TANGENT\");\r\n    if (morphTargetManager.supportsUVs && useUVMorph) defines.push(\"#define MORPHTARGETS_UV\");\r\n    if (morphTargetManager.supportsUV2s && useUV2Morph) defines.push(\"#define MORPHTARGETS_UV2\");\r\n    if (morphTargetManager.supportsColors && useColorMorph) defines.push(\"#define MORPHTARGETS_COLOR\");\r\n\r\n    defines.push(\"#define NUM_MORPH_INFLUENCERS \" + numMorphInfluencers);\r\n\r\n    if (morphTargetManager.isUsingTextureForTargets) {\r\n        defines.push(\"#define MORPHTARGETS_TEXTURE\");\r\n    }\r\n\r\n    _TmpMorphInfluencers.NUM_MORPH_INFLUENCERS = numMorphInfluencers;\r\n    _TmpMorphInfluencers.NORMAL = useNormalMorph;\r\n    _TmpMorphInfluencers.TANGENT = useTangentMorph;\r\n    _TmpMorphInfluencers.UV = useUVMorph;\r\n    _TmpMorphInfluencers.UV2 = useUV2Morph;\r\n    _TmpMorphInfluencers.COLOR = useColorMorph;\r\n\r\n    PrepareAttributesForMorphTargets(attribs, mesh, _TmpMorphInfluencers, usePositionMorph);\r\n    return numMorphInfluencers;\r\n}\r\n\r\n/**\r\n * Prepares the list of attributes required for morph targets according to the effect defines.\r\n * @param attribs The current list of supported attribs\r\n * @param mesh The mesh to prepare the morph targets attributes for\r\n * @param influencers The number of influencers\r\n */\r\nexport function PrepareAttributesForMorphTargetsInfluencers(attribs: string[], mesh: AbstractMesh, influencers: number): void {\r\n    _TmpMorphInfluencers.NUM_MORPH_INFLUENCERS = influencers;\r\n    _TmpMorphInfluencers.NORMAL = false;\r\n    _TmpMorphInfluencers.TANGENT = false;\r\n    _TmpMorphInfluencers.UV = false;\r\n    _TmpMorphInfluencers.UV2 = false;\r\n    _TmpMorphInfluencers.COLOR = false;\r\n    PrepareAttributesForMorphTargets(attribs, mesh, _TmpMorphInfluencers, true);\r\n}\r\n\r\n/**\r\n * Prepares the list of attributes required for morph targets according to the effect defines.\r\n * @param attribs The current list of supported attribs\r\n * @param mesh The mesh to prepare the morph targets attributes for\r\n * @param defines The current Defines of the effect\r\n * @param usePositionMorph Whether the position morph target is used\r\n */\r\nexport function PrepareAttributesForMorphTargets(attribs: string[], mesh: AbstractMesh, defines: any, usePositionMorph = true): void {\r\n    const influencers = defines[\"NUM_MORPH_INFLUENCERS\"];\r\n\r\n    if (influencers > 0 && EngineStore.LastCreatedEngine) {\r\n        const maxAttributesCount = EngineStore.LastCreatedEngine.getCaps().maxVertexAttribs;\r\n        const manager = (mesh as Mesh).morphTargetManager;\r\n        if (manager?.isUsingTextureForTargets) {\r\n            return;\r\n        }\r\n        const position = manager && manager.supportsPositions && usePositionMorph;\r\n        const normal = manager && manager.supportsNormals && defines[\"NORMAL\"];\r\n        const tangent = manager && manager.supportsTangents && defines[\"TANGENT\"];\r\n        const uv = manager && manager.supportsUVs && defines[\"UV1\"];\r\n        const uv2 = manager && manager.supportsUV2s && defines[\"UV2\"];\r\n        const color = manager && manager.supportsColors && defines[\"COLOR\"];\r\n        for (let index = 0; index < influencers; index++) {\r\n            if (position) {\r\n                attribs.push(Constants.PositionKind + index);\r\n            }\r\n\r\n            if (normal) {\r\n                attribs.push(Constants.NormalKind + index);\r\n            }\r\n\r\n            if (tangent) {\r\n                attribs.push(Constants.TangentKind + index);\r\n            }\r\n\r\n            if (uv) {\r\n                attribs.push(Constants.UVKind + \"_\" + index);\r\n            }\r\n\r\n            if (uv2) {\r\n                attribs.push(Constants.UV2Kind + \"_\" + index);\r\n            }\r\n\r\n            if (color) {\r\n                attribs.push(Constants.ColorKind + index);\r\n            }\r\n\r\n            if (attribs.length > maxAttributesCount) {\r\n                Logger.Error(\"Cannot add more vertex attributes for mesh \" + mesh.name);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Add the list of attributes required for instances to the attribs array.\r\n * @param attribs The current list of supported attribs\r\n * @param needsPreviousMatrices If the shader needs previous matrices\r\n */\r\nexport function PushAttributesForInstances(attribs: string[], needsPreviousMatrices: boolean = false): void {\r\n    attribs.push(\"world0\");\r\n    attribs.push(\"world1\");\r\n    attribs.push(\"world2\");\r\n    attribs.push(\"world3\");\r\n    if (needsPreviousMatrices) {\r\n        attribs.push(\"previousWorld0\");\r\n        attribs.push(\"previousWorld1\");\r\n        attribs.push(\"previousWorld2\");\r\n        attribs.push(\"previousWorld3\");\r\n    }\r\n}\r\n\r\n/**\r\n * Binds the morph targets information from the mesh to the effect.\r\n * @param abstractMesh The mesh we are binding the information to render\r\n * @param effect The effect we are binding the data to\r\n */\r\nexport function BindMorphTargetParameters(abstractMesh: AbstractMesh, effect: Effect): void {\r\n    const manager = (<Mesh>abstractMesh).morphTargetManager;\r\n    if (!abstractMesh || !manager) {\r\n        return;\r\n    }\r\n\r\n    effect.setFloatArray(\"morphTargetInfluences\", manager.influences);\r\n}\r\n\r\n/**\r\n * Binds the scene's uniform buffer to the effect.\r\n * @param effect defines the effect to bind to the scene uniform buffer\r\n * @param sceneUbo defines the uniform buffer storing scene data\r\n */\r\nexport function BindSceneUniformBuffer(effect: Effect, sceneUbo: UniformBuffer): void {\r\n    sceneUbo.bindToEffect(effect, \"Scene\");\r\n}\r\n\r\n/**\r\n * Helps preparing the defines values about the UVs in used in the effect.\r\n * UVs are shared as much as we can across channels in the shaders.\r\n * @param texture The texture we are preparing the UVs for\r\n * @param defines The defines to update\r\n * @param key The channel key \"diffuse\", \"specular\"... used in the shader\r\n */\r\nexport function PrepareDefinesForMergedUV(texture: BaseTexture, defines: any, key: string): void {\r\n    defines._needUVs = true;\r\n    defines[key] = true;\r\n    if (texture.optimizeUVAllocation && texture.getTextureMatrix().isIdentityAs3x2()) {\r\n        defines[key + \"DIRECTUV\"] = texture.coordinatesIndex + 1;\r\n        defines[\"MAINUV\" + (texture.coordinatesIndex + 1)] = true;\r\n    } else {\r\n        defines[key + \"DIRECTUV\"] = 0;\r\n    }\r\n}\r\n\r\n/**\r\n * Binds a texture matrix value to its corresponding uniform\r\n * @param texture The texture to bind the matrix for\r\n * @param uniformBuffer The uniform buffer receiving the data\r\n * @param key The channel key \"diffuse\", \"specular\"... used in the shader\r\n */\r\nexport function BindTextureMatrix(texture: BaseTexture, uniformBuffer: UniformBuffer, key: string): void {\r\n    const matrix = texture.getTextureMatrix();\r\n\r\n    uniformBuffer.updateMatrix(key + \"Matrix\", matrix);\r\n}\r\n\r\n/**\r\n * Prepares the list of attributes required for baked vertex animations according to the effect defines.\r\n * @param attribs The current list of supported attribs\r\n * @param mesh The mesh to prepare for baked vertex animations\r\n * @param defines The current Defines of the effect\r\n */\r\nexport function PrepareAttributesForBakedVertexAnimation(attribs: string[], mesh: AbstractMesh, defines: any): void {\r\n    const enabled = defines[\"BAKED_VERTEX_ANIMATION_TEXTURE\"] && defines[\"INSTANCES\"];\r\n\r\n    if (enabled) {\r\n        attribs.push(\"bakedVertexAnimationSettingsInstanced\");\r\n    }\r\n}\r\n\r\n// Copies the bones transformation matrices into the target array and returns the target's reference\r\nfunction _CopyBonesTransformationMatrices(source: Float32Array, target: Float32Array): Float32Array {\r\n    target.set(source);\r\n\r\n    return target;\r\n}\r\n\r\n/**\r\n * Binds the bones information from the mesh to the effect.\r\n * @param mesh The mesh we are binding the information to render\r\n * @param effect The effect we are binding the data to\r\n * @param prePassConfiguration Configuration for the prepass, in case prepass is activated\r\n */\r\nexport function BindBonesParameters(mesh?: AbstractMesh, effect?: Effect, prePassConfiguration?: PrePassConfiguration): void {\r\n    if (!effect || !mesh) {\r\n        return;\r\n    }\r\n    if (mesh.computeBonesUsingShaders && effect._bonesComputationForcedToCPU) {\r\n        mesh.computeBonesUsingShaders = false;\r\n    }\r\n\r\n    if (mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {\r\n        const skeleton = mesh.skeleton;\r\n\r\n        if (skeleton.isUsingTextureForMatrices && effect.getUniformIndex(\"boneTextureWidth\") > -1) {\r\n            const boneTexture = skeleton.getTransformMatrixTexture(mesh);\r\n            effect.setTexture(\"boneSampler\", boneTexture);\r\n            effect.setFloat(\"boneTextureWidth\", 4.0 * (skeleton.bones.length + 1));\r\n        } else {\r\n            const matrices = skeleton.getTransformMatrices(mesh);\r\n\r\n            if (matrices) {\r\n                effect.setMatrices(\"mBones\", matrices);\r\n                if (prePassConfiguration && mesh.getScene().prePassRenderer && mesh.getScene().prePassRenderer!.getIndex(Constants.PREPASS_VELOCITY_TEXTURE_TYPE)) {\r\n                    if (!prePassConfiguration.previousBones[mesh.uniqueId]) {\r\n                        prePassConfiguration.previousBones[mesh.uniqueId] = matrices.slice();\r\n                    }\r\n                    effect.setMatrices(\"mPreviousBones\", prePassConfiguration.previousBones[mesh.uniqueId]);\r\n                    _CopyBonesTransformationMatrices(matrices, prePassConfiguration.previousBones[mesh.uniqueId]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Binds the light information to the effect.\r\n * @param light The light containing the generator\r\n * @param effect The effect we are binding the data to\r\n * @param lightIndex The light index in the effect used to render\r\n */\r\nexport function BindLightProperties(light: Light, effect: Effect, lightIndex: number): void {\r\n    light.transferToEffect(effect, lightIndex + \"\");\r\n}\r\n\r\n/**\r\n * Binds the lights information from the scene to the effect for the given mesh.\r\n * @param light Light to bind\r\n * @param lightIndex Light index\r\n * @param scene The scene where the light belongs to\r\n * @param effect The effect we are binding the data to\r\n * @param useSpecular Defines if specular is supported\r\n * @param receiveShadows Defines if the effect (mesh) we bind the light for receives shadows\r\n */\r\nexport function BindLight(light: Light, lightIndex: number, scene: Scene, effect: Effect, useSpecular: boolean, receiveShadows = true): void {\r\n    light._bindLight(lightIndex, scene, effect, useSpecular, receiveShadows);\r\n}\r\n\r\n/**\r\n * Binds the lights information from the scene to the effect for the given mesh.\r\n * @param scene The scene the lights belongs to\r\n * @param mesh The mesh we are binding the information to render\r\n * @param effect The effect we are binding the data to\r\n * @param defines The generated defines for the effect\r\n * @param maxSimultaneousLights The maximum number of light that can be bound to the effect\r\n */\r\nexport function BindLights(scene: Scene, mesh: AbstractMesh, effect: Effect, defines: any, maxSimultaneousLights = 4): void {\r\n    const len = Math.min(mesh.lightSources.length, maxSimultaneousLights);\r\n\r\n    for (let i = 0; i < len; i++) {\r\n        const light = mesh.lightSources[i];\r\n        BindLight(light, i, scene, effect, typeof defines === \"boolean\" ? defines : defines[\"SPECULARTERM\"], mesh.receiveShadows);\r\n    }\r\n}\r\n\r\n/**\r\n * Prepares the list of attributes required for bones according to the effect defines.\r\n * @param attribs The current list of supported attribs\r\n * @param mesh The mesh to prepare the bones attributes for\r\n * @param defines The current Defines of the effect\r\n * @param fallbacks The current effect fallback strategy\r\n */\r\nexport function PrepareAttributesForBones(attribs: string[], mesh: AbstractMesh, defines: any, fallbacks: EffectFallbacks): void {\r\n    if (defines[\"NUM_BONE_INFLUENCERS\"] > 0) {\r\n        fallbacks.addCPUSkinningFallback(0, mesh);\r\n\r\n        attribs.push(Constants.MatricesIndicesKind);\r\n        attribs.push(Constants.MatricesWeightsKind);\r\n        if (defines[\"NUM_BONE_INFLUENCERS\"] > 4) {\r\n            attribs.push(Constants.MatricesIndicesExtraKind);\r\n            attribs.push(Constants.MatricesWeightsExtraKind);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Check and prepare the list of attributes required for instances according to the effect defines.\r\n * @param attribs The current list of supported attribs\r\n * @param defines The current MaterialDefines of the effect\r\n */\r\nexport function PrepareAttributesForInstances(attribs: string[], defines: MaterialDefines): void {\r\n    if (defines[\"INSTANCES\"] || defines[\"THIN_INSTANCES\"]) {\r\n        PushAttributesForInstances(attribs, !!defines[\"PREPASS_VELOCITY\"]);\r\n    }\r\n\r\n    if (defines.INSTANCESCOLOR) {\r\n        attribs.push(Constants.ColorInstanceKind);\r\n    }\r\n}\r\n\r\n/**\r\n * This helps decreasing rank by rank the shadow quality (0 being the highest rank and quality)\r\n * @param defines The defines to update while falling back\r\n * @param fallbacks The authorized effect fallbacks\r\n * @param maxSimultaneousLights The maximum number of lights allowed\r\n * @param rank the current rank of the Effect\r\n * @returns The newly affected rank\r\n */\r\nexport function HandleFallbacksForShadows(defines: any, fallbacks: EffectFallbacks, maxSimultaneousLights = 4, rank = 0): number {\r\n    let lightFallbackRank = 0;\r\n    for (let lightIndex = 0; lightIndex < maxSimultaneousLights; lightIndex++) {\r\n        if (!defines[\"LIGHT\" + lightIndex]) {\r\n            break;\r\n        }\r\n\r\n        if (lightIndex > 0) {\r\n            lightFallbackRank = rank + lightIndex;\r\n            fallbacks.addFallback(lightFallbackRank, \"LIGHT\" + lightIndex);\r\n        }\r\n\r\n        if (!defines[\"SHADOWS\"]) {\r\n            if (defines[\"SHADOW\" + lightIndex]) {\r\n                fallbacks.addFallback(rank, \"SHADOW\" + lightIndex);\r\n            }\r\n\r\n            if (defines[\"SHADOWPCF\" + lightIndex]) {\r\n                fallbacks.addFallback(rank, \"SHADOWPCF\" + lightIndex);\r\n            }\r\n\r\n            if (defines[\"SHADOWPCSS\" + lightIndex]) {\r\n                fallbacks.addFallback(rank, \"SHADOWPCSS\" + lightIndex);\r\n            }\r\n\r\n            if (defines[\"SHADOWPOISSON\" + lightIndex]) {\r\n                fallbacks.addFallback(rank, \"SHADOWPOISSON\" + lightIndex);\r\n            }\r\n\r\n            if (defines[\"SHADOWESM\" + lightIndex]) {\r\n                fallbacks.addFallback(rank, \"SHADOWESM\" + lightIndex);\r\n            }\r\n\r\n            if (defines[\"SHADOWCLOSEESM\" + lightIndex]) {\r\n                fallbacks.addFallback(rank, \"SHADOWCLOSEESM\" + lightIndex);\r\n            }\r\n        }\r\n    }\r\n    return lightFallbackRank++;\r\n}\r\n\r\n/**\r\n * Gets the current status of the fog (should it be enabled?)\r\n * @param mesh defines the mesh to evaluate for fog support\r\n * @param scene defines the hosting scene\r\n * @returns true if fog must be enabled\r\n */\r\nexport function GetFogState(mesh: AbstractMesh, scene: Scene) {\r\n    return scene.fogEnabled && mesh.applyFog && scene.fogMode !== Constants.FOGMODE_NONE;\r\n}\r\n\r\n/**\r\n * Helper used to prepare the list of defines associated with misc. values for shader compilation\r\n * @param mesh defines the current mesh\r\n * @param scene defines the current scene\r\n * @param useLogarithmicDepth defines if logarithmic depth has to be turned on\r\n * @param pointsCloud defines if point cloud rendering has to be turned on\r\n * @param fogEnabled defines if fog has to be turned on\r\n * @param alphaTest defines if alpha testing has to be turned on\r\n * @param defines defines the current list of defines\r\n * @param applyDecalAfterDetail Defines if the decal is applied after or before the detail\r\n */\r\nexport function PrepareDefinesForMisc(\r\n    mesh: AbstractMesh,\r\n    scene: Scene,\r\n    useLogarithmicDepth: boolean,\r\n    pointsCloud: boolean,\r\n    fogEnabled: boolean,\r\n    alphaTest: boolean,\r\n    defines: any,\r\n    applyDecalAfterDetail: boolean = false\r\n): void {\r\n    if (defines._areMiscDirty) {\r\n        defines[\"LOGARITHMICDEPTH\"] = useLogarithmicDepth;\r\n        defines[\"POINTSIZE\"] = pointsCloud;\r\n        defines[\"FOG\"] = fogEnabled && GetFogState(mesh, scene);\r\n        defines[\"NONUNIFORMSCALING\"] = mesh.nonUniformScaling;\r\n        defines[\"ALPHATEST\"] = alphaTest;\r\n        defines[\"DECAL_AFTER_DETAIL\"] = applyDecalAfterDetail;\r\n    }\r\n}\r\n\r\n/**\r\n * Prepares the defines related to the light information passed in parameter\r\n * @param scene The scene we are intending to draw\r\n * @param mesh The mesh the effect is compiling for\r\n * @param defines The defines to update\r\n * @param specularSupported Specifies whether specular is supported or not (override lights data)\r\n * @param maxSimultaneousLights Specifies how manuy lights can be added to the effect at max\r\n * @param disableLighting Specifies whether the lighting is disabled (override scene and light)\r\n * @returns true if normals will be required for the rest of the effect\r\n */\r\nexport function PrepareDefinesForLights(scene: Scene, mesh: AbstractMesh, defines: any, specularSupported: boolean, maxSimultaneousLights = 4, disableLighting = false): boolean {\r\n    if (!defines._areLightsDirty) {\r\n        return defines._needNormals;\r\n    }\r\n\r\n    let lightIndex = 0;\r\n    const state = {\r\n        needNormals: defines._needNormals, // prevents overriding previous reflection or other needs for normals\r\n        needRebuild: false,\r\n        lightmapMode: false,\r\n        shadowEnabled: false,\r\n        specularEnabled: false,\r\n    };\r\n\r\n    if (scene.lightsEnabled && !disableLighting) {\r\n        for (const light of mesh.lightSources) {\r\n            PrepareDefinesForLight(scene, mesh, light, lightIndex, defines, specularSupported, state);\r\n\r\n            lightIndex++;\r\n            if (lightIndex === maxSimultaneousLights) {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    defines[\"SPECULARTERM\"] = state.specularEnabled;\r\n    defines[\"SHADOWS\"] = state.shadowEnabled;\r\n\r\n    // Resetting all other lights if any\r\n    for (let index = lightIndex; index < maxSimultaneousLights; index++) {\r\n        if (defines[\"LIGHT\" + index] !== undefined) {\r\n            defines[\"LIGHT\" + index] = false;\r\n            defines[\"HEMILIGHT\" + index] = false;\r\n            defines[\"POINTLIGHT\" + index] = false;\r\n            defines[\"DIRLIGHT\" + index] = false;\r\n            defines[\"SPOTLIGHT\" + index] = false;\r\n            defines[\"AREALIGHT\" + index] = false;\r\n            defines[\"SHADOW\" + index] = false;\r\n            defines[\"SHADOWCSM\" + index] = false;\r\n            defines[\"SHADOWCSMDEBUG\" + index] = false;\r\n            defines[\"SHADOWCSMNUM_CASCADES\" + index] = false;\r\n            defines[\"SHADOWCSMUSESHADOWMAXZ\" + index] = false;\r\n            defines[\"SHADOWCSMNOBLEND\" + index] = false;\r\n            defines[\"SHADOWCSM_RIGHTHANDED\" + index] = false;\r\n            defines[\"SHADOWPCF\" + index] = false;\r\n            defines[\"SHADOWPCSS\" + index] = false;\r\n            defines[\"SHADOWPOISSON\" + index] = false;\r\n            defines[\"SHADOWESM\" + index] = false;\r\n            defines[\"SHADOWCLOSEESM\" + index] = false;\r\n            defines[\"SHADOWCUBE\" + index] = false;\r\n            defines[\"SHADOWLOWQUALITY\" + index] = false;\r\n            defines[\"SHADOWMEDIUMQUALITY\" + index] = false;\r\n        }\r\n    }\r\n\r\n    const caps = scene.getEngine().getCaps();\r\n\r\n    if (defines[\"SHADOWFLOAT\"] === undefined) {\r\n        state.needRebuild = true;\r\n    }\r\n\r\n    defines[\"SHADOWFLOAT\"] =\r\n        state.shadowEnabled && ((caps.textureFloatRender && caps.textureFloatLinearFiltering) || (caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering));\r\n    defines[\"LIGHTMAPEXCLUDED\"] = state.lightmapMode;\r\n\r\n    if (state.needRebuild) {\r\n        defines.rebuild();\r\n    }\r\n\r\n    return state.needNormals;\r\n}\r\n\r\n/**\r\n * Prepares the defines related to the light information passed in parameter\r\n * @param scene The scene we are intending to draw\r\n * @param mesh The mesh the effect is compiling for\r\n * @param light The light the effect is compiling for\r\n * @param lightIndex The index of the light\r\n * @param defines The defines to update\r\n * @param specularSupported Specifies whether specular is supported or not (override lights data)\r\n * @param state Defines the current state regarding what is needed (normals, etc...)\r\n * @param state.needNormals\r\n * @param state.needRebuild\r\n * @param state.shadowEnabled\r\n * @param state.specularEnabled\r\n * @param state.lightmapMode\r\n */\r\nexport function PrepareDefinesForLight(\r\n    scene: Scene,\r\n    mesh: AbstractMesh,\r\n    light: Light,\r\n    lightIndex: number,\r\n    defines: any,\r\n    specularSupported: boolean,\r\n    state: {\r\n        needNormals: boolean;\r\n        needRebuild: boolean;\r\n        shadowEnabled: boolean;\r\n        specularEnabled: boolean;\r\n        lightmapMode: boolean;\r\n    }\r\n) {\r\n    state.needNormals = true;\r\n\r\n    if (defines[\"LIGHT\" + lightIndex] === undefined) {\r\n        state.needRebuild = true;\r\n    }\r\n\r\n    defines[\"LIGHT\" + lightIndex] = true;\r\n\r\n    defines[\"SPOTLIGHT\" + lightIndex] = false;\r\n    defines[\"HEMILIGHT\" + lightIndex] = false;\r\n    defines[\"POINTLIGHT\" + lightIndex] = false;\r\n    defines[\"DIRLIGHT\" + lightIndex] = false;\r\n    defines[\"AREALIGHT\" + lightIndex] = false;\r\n\r\n    light.prepareLightSpecificDefines(defines, lightIndex);\r\n\r\n    // FallOff.\r\n    defines[\"LIGHT_FALLOFF_PHYSICAL\" + lightIndex] = false;\r\n    defines[\"LIGHT_FALLOFF_GLTF\" + lightIndex] = false;\r\n    defines[\"LIGHT_FALLOFF_STANDARD\" + lightIndex] = false;\r\n\r\n    switch (light.falloffType) {\r\n        case LightConstants.FALLOFF_GLTF:\r\n            defines[\"LIGHT_FALLOFF_GLTF\" + lightIndex] = true;\r\n            break;\r\n        case LightConstants.FALLOFF_PHYSICAL:\r\n            defines[\"LIGHT_FALLOFF_PHYSICAL\" + lightIndex] = true;\r\n            break;\r\n        case LightConstants.FALLOFF_STANDARD:\r\n            defines[\"LIGHT_FALLOFF_STANDARD\" + lightIndex] = true;\r\n            break;\r\n    }\r\n\r\n    // Specular\r\n    if (specularSupported && !light.specular.equalsFloats(0, 0, 0)) {\r\n        state.specularEnabled = true;\r\n    }\r\n\r\n    // Shadows\r\n    defines[\"SHADOW\" + lightIndex] = false;\r\n    defines[\"SHADOWCSM\" + lightIndex] = false;\r\n    defines[\"SHADOWCSMDEBUG\" + lightIndex] = false;\r\n    defines[\"SHADOWCSMNUM_CASCADES\" + lightIndex] = false;\r\n    defines[\"SHADOWCSMUSESHADOWMAXZ\" + lightIndex] = false;\r\n    defines[\"SHADOWCSMNOBLEND\" + lightIndex] = false;\r\n    defines[\"SHADOWCSM_RIGHTHANDED\" + lightIndex] = false;\r\n    defines[\"SHADOWPCF\" + lightIndex] = false;\r\n    defines[\"SHADOWPCSS\" + lightIndex] = false;\r\n    defines[\"SHADOWPOISSON\" + lightIndex] = false;\r\n    defines[\"SHADOWESM\" + lightIndex] = false;\r\n    defines[\"SHADOWCLOSEESM\" + lightIndex] = false;\r\n    defines[\"SHADOWCUBE\" + lightIndex] = false;\r\n    defines[\"SHADOWLOWQUALITY\" + lightIndex] = false;\r\n    defines[\"SHADOWMEDIUMQUALITY\" + lightIndex] = false;\r\n\r\n    if (mesh && mesh.receiveShadows && scene.shadowsEnabled && light.shadowEnabled) {\r\n        const shadowGenerator = light.getShadowGenerator(scene.activeCamera) ?? light.getShadowGenerator();\r\n        if (shadowGenerator) {\r\n            const shadowMap = shadowGenerator.getShadowMap();\r\n            if (shadowMap) {\r\n                if (shadowMap.renderList && shadowMap.renderList.length > 0) {\r\n                    state.shadowEnabled = true;\r\n                    shadowGenerator.prepareDefines(defines, lightIndex);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    if (light.lightmapMode != LightConstants.LIGHTMAP_DEFAULT) {\r\n        state.lightmapMode = true;\r\n        defines[\"LIGHTMAPEXCLUDED\" + lightIndex] = true;\r\n        defines[\"LIGHTMAPNOSPECULAR\" + lightIndex] = light.lightmapMode == LightConstants.LIGHTMAP_SHADOWSONLY;\r\n    } else {\r\n        defines[\"LIGHTMAPEXCLUDED\" + lightIndex] = false;\r\n        defines[\"LIGHTMAPNOSPECULAR\" + lightIndex] = false;\r\n    }\r\n}\r\n\r\n/**\r\n * Helper used to prepare the list of defines associated with frame values for shader compilation\r\n * @param scene defines the current scene\r\n * @param engine defines the current engine\r\n * @param material defines the material we are compiling the shader for\r\n * @param defines specifies the list of active defines\r\n * @param useInstances defines if instances have to be turned on\r\n * @param useClipPlane defines if clip plane have to be turned on\r\n * @param useThinInstances defines if thin instances have to be turned on\r\n */\r\nexport function PrepareDefinesForFrameBoundValues(\r\n    scene: Scene,\r\n    engine: AbstractEngine,\r\n    material: Material,\r\n    defines: any,\r\n    useInstances: boolean,\r\n    useClipPlane: Nullable<boolean> = null,\r\n    useThinInstances: boolean = false\r\n): void {\r\n    let changed = PrepareDefinesForCamera(scene, defines);\r\n\r\n    if (useClipPlane !== false) {\r\n        changed = prepareDefinesForClipPlanes(material, scene, defines);\r\n    }\r\n\r\n    if (defines[\"DEPTHPREPASS\"] !== !engine.getColorWrite()) {\r\n        defines[\"DEPTHPREPASS\"] = !defines[\"DEPTHPREPASS\"];\r\n        changed = true;\r\n    }\r\n\r\n    if (defines[\"INSTANCES\"] !== useInstances) {\r\n        defines[\"INSTANCES\"] = useInstances;\r\n        changed = true;\r\n    }\r\n\r\n    if (defines[\"THIN_INSTANCES\"] !== useThinInstances) {\r\n        defines[\"THIN_INSTANCES\"] = useThinInstances;\r\n        changed = true;\r\n    }\r\n\r\n    if (changed) {\r\n        defines.markAsUnprocessed();\r\n    }\r\n}\r\n\r\n/**\r\n * Prepares the defines for bones\r\n * @param mesh The mesh containing the geometry data we will draw\r\n * @param defines The defines to update\r\n */\r\nexport function PrepareDefinesForBones(mesh: AbstractMesh, defines: any) {\r\n    if (mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {\r\n        defines[\"NUM_BONE_INFLUENCERS\"] = mesh.numBoneInfluencers;\r\n\r\n        const materialSupportsBoneTexture = defines[\"BONETEXTURE\"] !== undefined;\r\n\r\n        if (mesh.skeleton.isUsingTextureForMatrices && materialSupportsBoneTexture) {\r\n            defines[\"BONETEXTURE\"] = true;\r\n        } else {\r\n            defines[\"BonesPerMesh\"] = mesh.skeleton.bones.length + 1;\r\n            defines[\"BONETEXTURE\"] = materialSupportsBoneTexture ? false : undefined;\r\n\r\n            const prePassRenderer = mesh.getScene().prePassRenderer;\r\n            if (prePassRenderer && prePassRenderer.enabled) {\r\n                const nonExcluded = prePassRenderer.excludedSkinnedMesh.indexOf(mesh) === -1;\r\n                defines[\"BONES_VELOCITY_ENABLED\"] = nonExcluded;\r\n            }\r\n        }\r\n    } else {\r\n        defines[\"NUM_BONE_INFLUENCERS\"] = 0;\r\n        defines[\"BonesPerMesh\"] = 0;\r\n        if (defines[\"BONETEXTURE\"] !== undefined) {\r\n            defines[\"BONETEXTURE\"] = false;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Prepares the defines for morph targets\r\n * @param mesh The mesh containing the geometry data we will draw\r\n * @param defines The defines to update\r\n */\r\nexport function PrepareDefinesForMorphTargets(mesh: AbstractMesh, defines: any) {\r\n    const manager = (<Mesh>mesh).morphTargetManager;\r\n    if (manager) {\r\n        defines[\"MORPHTARGETS_UV\"] = manager.supportsUVs && defines[\"UV1\"];\r\n        defines[\"MORPHTARGETS_UV2\"] = manager.supportsUV2s && defines[\"UV2\"];\r\n        defines[\"MORPHTARGETS_TANGENT\"] = manager.supportsTangents && defines[\"TANGENT\"];\r\n        defines[\"MORPHTARGETS_NORMAL\"] = manager.supportsNormals && defines[\"NORMAL\"];\r\n        defines[\"MORPHTARGETS_POSITION\"] = manager.supportsPositions;\r\n        defines[\"MORPHTARGETS_COLOR\"] = manager.supportsColors;\r\n\r\n        defines[\"MORPHTARGETTEXTURE_HASUVS\"] = manager.hasUVs;\r\n        defines[\"MORPHTARGETTEXTURE_HASUV2S\"] = manager.hasUV2s;\r\n        defines[\"MORPHTARGETTEXTURE_HASTANGENTS\"] = manager.hasTangents;\r\n        defines[\"MORPHTARGETTEXTURE_HASNORMALS\"] = manager.hasNormals;\r\n        defines[\"MORPHTARGETTEXTURE_HASPOSITIONS\"] = manager.hasPositions;\r\n        defines[\"MORPHTARGETTEXTURE_HASCOLORS\"] = manager.hasColors;\r\n\r\n        defines[\"NUM_MORPH_INFLUENCERS\"] = manager.numMaxInfluencers || manager.numInfluencers;\r\n        defines[\"MORPHTARGETS\"] = defines[\"NUM_MORPH_INFLUENCERS\"] > 0;\r\n\r\n        defines[\"MORPHTARGETS_TEXTURE\"] = manager.isUsingTextureForTargets;\r\n    } else {\r\n        defines[\"MORPHTARGETS_UV\"] = false;\r\n        defines[\"MORPHTARGETS_UV2\"] = false;\r\n        defines[\"MORPHTARGETS_TANGENT\"] = false;\r\n        defines[\"MORPHTARGETS_NORMAL\"] = false;\r\n        defines[\"MORPHTARGETS_POSITION\"] = false;\r\n        defines[\"MORPHTARGETS_COLOR\"] = false;\r\n\r\n        defines[\"MORPHTARGETTEXTURE_HASUVS\"] = false;\r\n        defines[\"MORPHTARGETTEXTURE_HASUV2S\"] = false;\r\n        defines[\"MORPHTARGETTEXTURE_HASTANGENTS\"] = false;\r\n        defines[\"MORPHTARGETTEXTURE_HASNORMALS\"] = false;\r\n        defines[\"MORPHTARGETTEXTURE_HASPOSITIONS\"] = false;\r\n        defines[\"MORPHTARGETTEXTURE_HAS_COLORS\"] = false;\r\n\r\n        defines[\"MORPHTARGETS\"] = false;\r\n        defines[\"NUM_MORPH_INFLUENCERS\"] = 0;\r\n    }\r\n}\r\n\r\n/**\r\n * Prepares the defines for baked vertex animation\r\n * @param mesh The mesh containing the geometry data we will draw\r\n * @param defines The defines to update\r\n */\r\nexport function PrepareDefinesForBakedVertexAnimation(mesh: AbstractMesh, defines: any) {\r\n    const manager = (<Mesh>mesh).bakedVertexAnimationManager;\r\n    defines[\"BAKED_VERTEX_ANIMATION_TEXTURE\"] = manager && manager.isEnabled ? true : false;\r\n}\r\n\r\n/**\r\n * Prepares the defines used in the shader depending on the attributes data available in the mesh\r\n * @param mesh The mesh containing the geometry data we will draw\r\n * @param defines The defines to update\r\n * @param useVertexColor Precise whether vertex colors should be used or not (override mesh info)\r\n * @param useBones Precise whether bones should be used or not (override mesh info)\r\n * @param useMorphTargets Precise whether morph targets should be used or not (override mesh info)\r\n * @param useVertexAlpha Precise whether vertex alpha should be used or not (override mesh info)\r\n * @param useBakedVertexAnimation Precise whether baked vertex animation should be used or not (override mesh info)\r\n * @returns false if defines are considered not dirty and have not been checked\r\n */\r\nexport function PrepareDefinesForAttributes(\r\n    mesh: AbstractMesh,\r\n    defines: any,\r\n    useVertexColor: boolean,\r\n    useBones: boolean,\r\n    useMorphTargets = false,\r\n    useVertexAlpha = true,\r\n    useBakedVertexAnimation = true\r\n): boolean {\r\n    if (!defines._areAttributesDirty && defines._needNormals === defines._normals && defines._needUVs === defines._uvs) {\r\n        return false;\r\n    }\r\n\r\n    defines._normals = defines._needNormals;\r\n    defines._uvs = defines._needUVs;\r\n\r\n    defines[\"NORMAL\"] = defines._needNormals && mesh.isVerticesDataPresent(Constants.NormalKind);\r\n\r\n    if (defines._needNormals && mesh.isVerticesDataPresent(Constants.TangentKind)) {\r\n        defines[\"TANGENT\"] = true;\r\n    }\r\n\r\n    for (let i = 1; i <= Constants.MAX_SUPPORTED_UV_SETS; ++i) {\r\n        defines[\"UV\" + i] = defines._needUVs ? mesh.isVerticesDataPresent(`uv${i === 1 ? \"\" : i}`) : false;\r\n    }\r\n\r\n    if (useVertexColor) {\r\n        const hasVertexColors = mesh.useVertexColors && mesh.isVerticesDataPresent(Constants.ColorKind);\r\n        defines[\"VERTEXCOLOR\"] = hasVertexColors;\r\n        defines[\"VERTEXALPHA\"] = mesh.hasVertexAlpha && hasVertexColors && useVertexAlpha;\r\n    }\r\n\r\n    if (mesh.isVerticesDataPresent(Constants.ColorInstanceKind) && (mesh.hasInstances || mesh.hasThinInstances)) {\r\n        defines[\"INSTANCESCOLOR\"] = true;\r\n    }\r\n\r\n    if (useBones) {\r\n        PrepareDefinesForBones(mesh, defines);\r\n    }\r\n\r\n    if (useMorphTargets) {\r\n        PrepareDefinesForMorphTargets(mesh, defines);\r\n    }\r\n\r\n    if (useBakedVertexAnimation) {\r\n        PrepareDefinesForBakedVertexAnimation(mesh, defines);\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n/**\r\n * Prepares the defines related to multiview\r\n * @param scene The scene we are intending to draw\r\n * @param defines The defines to update\r\n */\r\nexport function PrepareDefinesForMultiview(scene: Scene, defines: any) {\r\n    if (scene.activeCamera) {\r\n        const previousMultiview = defines.MULTIVIEW;\r\n        defines.MULTIVIEW = scene.activeCamera.outputRenderTarget !== null && scene.activeCamera.outputRenderTarget.getViewCount() > 1;\r\n        if (defines.MULTIVIEW != previousMultiview) {\r\n            defines.markAsUnprocessed();\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Prepares the defines related to order independant transparency\r\n * @param scene The scene we are intending to draw\r\n * @param defines The defines to update\r\n * @param needAlphaBlending Determines if the material needs alpha blending\r\n */\r\nexport function PrepareDefinesForOIT(scene: Scene, defines: any, needAlphaBlending: boolean) {\r\n    const previousDefine = defines.ORDER_INDEPENDENT_TRANSPARENCY;\r\n    const previousDefine16Bits = defines.ORDER_INDEPENDENT_TRANSPARENCY_16BITS;\r\n\r\n    defines.ORDER_INDEPENDENT_TRANSPARENCY = scene.useOrderIndependentTransparency && needAlphaBlending;\r\n    defines.ORDER_INDEPENDENT_TRANSPARENCY_16BITS = !scene.getEngine().getCaps().textureFloatLinearFiltering;\r\n\r\n    if (previousDefine !== defines.ORDER_INDEPENDENT_TRANSPARENCY || previousDefine16Bits !== defines.ORDER_INDEPENDENT_TRANSPARENCY_16BITS) {\r\n        defines.markAsUnprocessed();\r\n    }\r\n}\r\n\r\n/**\r\n * Prepares the defines related to the prepass\r\n * @param scene The scene we are intending to draw\r\n * @param defines The defines to update\r\n * @param canRenderToMRT Indicates if this material renders to several textures in the prepass\r\n */\r\nexport function PrepareDefinesForPrePass(scene: Scene, defines: any, canRenderToMRT: boolean) {\r\n    const previousPrePass = defines.PREPASS;\r\n\r\n    if (!defines._arePrePassDirty) {\r\n        return;\r\n    }\r\n\r\n    const texturesList = [\r\n        {\r\n            type: Constants.PREPASS_POSITION_TEXTURE_TYPE,\r\n            define: \"PREPASS_POSITION\",\r\n            index: \"PREPASS_POSITION_INDEX\",\r\n        },\r\n        {\r\n            type: Constants.PREPASS_LOCAL_POSITION_TEXTURE_TYPE,\r\n            define: \"PREPASS_LOCAL_POSITION\",\r\n            index: \"PREPASS_LOCAL_POSITION_INDEX\",\r\n        },\r\n        {\r\n            type: Constants.PREPASS_VELOCITY_TEXTURE_TYPE,\r\n            define: \"PREPASS_VELOCITY\",\r\n            index: \"PREPASS_VELOCITY_INDEX\",\r\n        },\r\n        {\r\n            type: Constants.PREPASS_VELOCITY_LINEAR_TEXTURE_TYPE,\r\n            define: \"PREPASS_VELOCITY_LINEAR\",\r\n            index: \"PREPASS_VELOCITY_LINEAR_INDEX\",\r\n        },\r\n        {\r\n            type: Constants.PREPASS_REFLECTIVITY_TEXTURE_TYPE,\r\n            define: \"PREPASS_REFLECTIVITY\",\r\n            index: \"PREPASS_REFLECTIVITY_INDEX\",\r\n        },\r\n        {\r\n            type: Constants.PREPASS_IRRADIANCE_TEXTURE_TYPE,\r\n            define: \"PREPASS_IRRADIANCE\",\r\n            index: \"PREPASS_IRRADIANCE_INDEX\",\r\n        },\r\n        {\r\n            type: Constants.PREPASS_ALBEDO_SQRT_TEXTURE_TYPE,\r\n            define: \"PREPASS_ALBEDO_SQRT\",\r\n            index: \"PREPASS_ALBEDO_SQRT_INDEX\",\r\n        },\r\n        {\r\n            type: Constants.PREPASS_DEPTH_TEXTURE_TYPE,\r\n            define: \"PREPASS_DEPTH\",\r\n            index: \"PREPASS_DEPTH_INDEX\",\r\n        },\r\n        {\r\n            type: Constants.PREPASS_SCREENSPACE_DEPTH_TEXTURE_TYPE,\r\n            define: \"PREPASS_SCREENSPACE_DEPTH\",\r\n            index: \"PREPASS_SCREENSPACE_DEPTH_INDEX\",\r\n        },\r\n        {\r\n            type: Constants.PREPASS_NORMAL_TEXTURE_TYPE,\r\n            define: \"PREPASS_NORMAL\",\r\n            index: \"PREPASS_NORMAL_INDEX\",\r\n        },\r\n        {\r\n            type: Constants.PREPASS_WORLD_NORMAL_TEXTURE_TYPE,\r\n            define: \"PREPASS_WORLD_NORMAL\",\r\n            index: \"PREPASS_WORLD_NORMAL_INDEX\",\r\n        },\r\n    ];\r\n\r\n    if (scene.prePassRenderer && scene.prePassRenderer.enabled && canRenderToMRT) {\r\n        defines.PREPASS = true;\r\n        defines.SCENE_MRT_COUNT = scene.prePassRenderer.mrtCount;\r\n        defines.PREPASS_NORMAL_WORLDSPACE = scene.prePassRenderer.generateNormalsInWorldSpace;\r\n        defines.PREPASS_COLOR = true;\r\n        defines.PREPASS_COLOR_INDEX = 0;\r\n\r\n        for (let i = 0; i < texturesList.length; i++) {\r\n            const index = scene.prePassRenderer.getIndex(texturesList[i].type);\r\n            if (index !== -1) {\r\n                defines[texturesList[i].define] = true;\r\n                defines[texturesList[i].index] = index;\r\n            } else {\r\n                defines[texturesList[i].define] = false;\r\n            }\r\n        }\r\n    } else {\r\n        defines.PREPASS = false;\r\n        for (let i = 0; i < texturesList.length; i++) {\r\n            defines[texturesList[i].define] = false;\r\n        }\r\n    }\r\n\r\n    if (defines.PREPASS != previousPrePass) {\r\n        defines.markAsUnprocessed();\r\n        defines.markAsImageProcessingDirty();\r\n    }\r\n}\r\n\r\n/**\r\n * Helper used to prepare the defines relative to the active camera\r\n * @param scene defines the current scene\r\n * @param defines specifies the list of active defines\r\n * @returns true if the defines have been updated, else false\r\n */\r\nexport function PrepareDefinesForCamera(scene: Scene, defines: any): boolean {\r\n    let changed = false;\r\n\r\n    if (scene.activeCamera) {\r\n        const wasOrtho = defines[\"CAMERA_ORTHOGRAPHIC\"] ? 1 : 0;\r\n        const wasPersp = defines[\"CAMERA_PERSPECTIVE\"] ? 1 : 0;\r\n        const isOrtho = scene.activeCamera.mode === Constants.ORTHOGRAPHIC_CAMERA ? 1 : 0;\r\n        const isPersp = scene.activeCamera.mode === Constants.PERSPECTIVE_CAMERA ? 1 : 0;\r\n\r\n        if (wasOrtho ^ isOrtho || wasPersp ^ isPersp) {\r\n            defines[\"CAMERA_ORTHOGRAPHIC\"] = isOrtho === 1;\r\n            defines[\"CAMERA_PERSPECTIVE\"] = isPersp === 1;\r\n            changed = true;\r\n        }\r\n    }\r\n\r\n    return changed;\r\n}\r\n\r\n/**\r\n * Prepares the uniforms and samplers list to be used in the effect (for a specific light)\r\n * @param lightIndex defines the light index\r\n * @param uniformsList The uniform list\r\n * @param samplersList The sampler list\r\n * @param projectedLightTexture defines if projected texture must be used\r\n * @param uniformBuffersList defines an optional list of uniform buffers\r\n * @param updateOnlyBuffersList True to only update the uniformBuffersList array\r\n * @param iesLightTexture defines if IES texture must be used\r\n */\r\nexport function PrepareUniformsAndSamplersForLight(\r\n    lightIndex: number,\r\n    uniformsList: string[],\r\n    samplersList: string[],\r\n    projectedLightTexture?: any,\r\n    uniformBuffersList: Nullable<string[]> = null,\r\n    updateOnlyBuffersList = false,\r\n    iesLightTexture = false\r\n) {\r\n    if (uniformBuffersList) {\r\n        uniformBuffersList.push(\"Light\" + lightIndex);\r\n    }\r\n\r\n    if (updateOnlyBuffersList) {\r\n        return;\r\n    }\r\n\r\n    uniformsList.push(\r\n        \"vLightData\" + lightIndex,\r\n        \"vLightDiffuse\" + lightIndex,\r\n        \"vLightSpecular\" + lightIndex,\r\n        \"vLightDirection\" + lightIndex,\r\n        \"vLightWidth\" + lightIndex,\r\n        \"vLightHeight\" + lightIndex,\r\n        \"vLightFalloff\" + lightIndex,\r\n        \"vLightGround\" + lightIndex,\r\n        \"lightMatrix\" + lightIndex,\r\n        \"shadowsInfo\" + lightIndex,\r\n        \"depthValues\" + lightIndex\r\n    );\r\n\r\n    samplersList.push(\"shadowTexture\" + lightIndex);\r\n    samplersList.push(\"depthTexture\" + lightIndex);\r\n\r\n    uniformsList.push(\r\n        \"viewFrustumZ\" + lightIndex,\r\n        \"cascadeBlendFactor\" + lightIndex,\r\n        \"lightSizeUVCorrection\" + lightIndex,\r\n        \"depthCorrection\" + lightIndex,\r\n        \"penumbraDarkness\" + lightIndex,\r\n        \"frustumLengths\" + lightIndex\r\n    );\r\n\r\n    if (projectedLightTexture) {\r\n        samplersList.push(\"projectionLightTexture\" + lightIndex);\r\n        uniformsList.push(\"textureProjectionMatrix\" + lightIndex);\r\n    }\r\n    if (iesLightTexture) {\r\n        samplersList.push(\"iesLightTexture\" + lightIndex);\r\n    }\r\n}\r\n\r\n/**\r\n * Prepares the uniforms and samplers list to be used in the effect\r\n * @param uniformsListOrOptions The uniform names to prepare or an EffectCreationOptions containing the list and extra information\r\n * @param samplersList The sampler list\r\n * @param defines The defines helping in the list generation\r\n * @param maxSimultaneousLights The maximum number of simultaneous light allowed in the effect\r\n */\r\nexport function PrepareUniformsAndSamplersList(uniformsListOrOptions: string[] | IEffectCreationOptions, samplersList?: string[], defines?: any, maxSimultaneousLights = 4): void {\r\n    let uniformsList: string[];\r\n    let uniformBuffersList: string[] | undefined;\r\n\r\n    if ((<IEffectCreationOptions>uniformsListOrOptions).uniformsNames) {\r\n        const options = <IEffectCreationOptions>uniformsListOrOptions;\r\n        uniformsList = options.uniformsNames;\r\n        uniformBuffersList = options.uniformBuffersNames;\r\n        samplersList = options.samplers;\r\n        defines = options.defines;\r\n        maxSimultaneousLights = options.maxSimultaneousLights || 0;\r\n    } else {\r\n        uniformsList = <string[]>uniformsListOrOptions;\r\n        if (!samplersList) {\r\n            samplersList = [];\r\n        }\r\n    }\r\n\r\n    for (let lightIndex = 0; lightIndex < maxSimultaneousLights; lightIndex++) {\r\n        if (!defines[\"LIGHT\" + lightIndex]) {\r\n            break;\r\n        }\r\n        PrepareUniformsAndSamplersForLight(\r\n            lightIndex,\r\n            uniformsList,\r\n            samplersList,\r\n            defines[\"PROJECTEDLIGHTTEXTURE\" + lightIndex],\r\n            uniformBuffersList,\r\n            false,\r\n            defines[\"IESLIGHTTEXTURE\" + lightIndex]\r\n        );\r\n    }\r\n\r\n    if (defines[\"NUM_MORPH_INFLUENCERS\"]) {\r\n        uniformsList.push(\"morphTargetInfluences\");\r\n        uniformsList.push(\"morphTargetCount\");\r\n    }\r\n\r\n    if (defines[\"BAKED_VERTEX_ANIMATION_TEXTURE\"]) {\r\n        uniformsList.push(\"bakedVertexAnimationSettings\");\r\n        uniformsList.push(\"bakedVertexAnimationTextureSizeInverted\");\r\n        uniformsList.push(\"bakedVertexAnimationTime\");\r\n        samplersList.push(\"bakedVertexAnimationTexture\");\r\n    }\r\n}\r\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;AAMA,IAAM,cAAN,MAAiB;EAGN,OAAO,wBAAwB,WAAuB,SAAuB,YAAoB,YAAoB,SAAkB,SAAgB;AAC1J,aAAS,QAAQ,YAAY,QAAQ,aAAa,YAAY,SAAS;AACnE,YAAM,SAAS,QAAQ,KAAK,IAAI;AAChC,YAAM,IAAI,UAAU,MAAM;AAC1B,YAAM,IAAI,UAAU,SAAS,CAAC;AAC9B,YAAM,IAAI,UAAU,SAAS,CAAC;AAC9B,cAAQ,0BAA0B,GAAG,GAAG,CAAC;AACzC,cAAQ,0BAA0B,GAAG,GAAG,CAAC;IAC7C;EACJ;EAIO,OAAO,iBAAiB,WAAuB,OAAe,OAAe,QAAgB,SAAkB,SAAgB;AAClI,aAAS,QAAQ,OAAO,SAAS,QAAQ,QAAQ,QAAQ,QAAQ,OAAO,SAAS,UAAU,QAAQ;AAC/F,YAAM,IAAI,UAAU,MAAM;AAC1B,YAAM,IAAI,UAAU,SAAS,CAAC;AAC9B,YAAM,IAAI,UAAU,SAAS,CAAC;AAC9B,cAAQ,0BAA0B,GAAG,GAAG,CAAC;AACzC,cAAQ,0BAA0B,GAAG,GAAG,CAAC;IAC7C;EACJ;;AArBc,WAAA;EAFb,eAAe,OAAO,IAAI,CAAC,WAAW,OAAO,MAA8D,CAAC,MAAM,QAAQ,SAAS,KAAK,CAAC,MAAM,QAAQ,OAAO,CAAC;;;AAelJ,WAAA;EAFb,eAAe,OAAO,IAAI,CAAC,SAAS,MAAuD,CAAC,MAAM,QAAQ,SAAS,CAAC;;;AAsBnH,SAAU,wBACZ,WACA,SACA,YACA,YACA,OAA0B,MAAI;AAE9B,QAAM,UAAU,IAAI,QAAQ,OAAO,WAAW,OAAO,WAAW,OAAO,SAAS;AAChF,QAAM,UAAU,IAAI,QAAQ,CAAC,OAAO,WAAW,CAAC,OAAO,WAAW,CAAC,OAAO,SAAS;AAEnF,cAAY,wBAAwB,WAAW,SAAS,YAAY,YAAY,SAAS,OAAO;AAEhG,MAAI,MAAM;AACN,YAAQ,KAAK,QAAQ,IAAI,KAAK,IAAI,KAAK;AACvC,YAAQ,KAAK,QAAQ,IAAI,KAAK,IAAI,KAAK;AACvC,YAAQ,KAAK,QAAQ,IAAI,KAAK,IAAI,KAAK;AACvC,YAAQ,KAAK,QAAQ,IAAI,KAAK,IAAI,KAAK;AACvC,YAAQ,KAAK,QAAQ,IAAI,KAAK,IAAI,KAAK;AACvC,YAAQ,KAAK,QAAQ,IAAI,KAAK,IAAI,KAAK;EAC3C;AAEA,SAAO;IACH;IACA;;AAER;AAWM,SAAU,iBAAiB,WAAuB,OAAe,OAAe,OAA0B,MAAM,QAAe;AACjI,QAAM,UAAU,IAAI,QAAQ,OAAO,WAAW,OAAO,WAAW,OAAO,SAAS;AAChF,QAAM,UAAU,IAAI,QAAQ,CAAC,OAAO,WAAW,CAAC,OAAO,WAAW,CAAC,OAAO,SAAS;AAEnF,MAAI,CAAC,QAAQ;AACT,aAAS;EACb;AAEA,cAAY,iBAAiB,WAAW,OAAO,OAAO,QAAQ,SAAS,OAAO;AAE9E,MAAI,MAAM;AACN,YAAQ,KAAK,QAAQ,IAAI,KAAK,IAAI,KAAK;AACvC,YAAQ,KAAK,QAAQ,IAAI,KAAK,IAAI,KAAK;AACvC,YAAQ,KAAK,QAAQ,IAAI,KAAK,IAAI,KAAK;AACvC,YAAQ,KAAK,QAAQ,IAAI,KAAK,IAAI,KAAK;AACvC,YAAQ,KAAK,QAAQ,IAAI,KAAK,IAAI,KAAK;AACvC,YAAQ,KAAK,QAAQ,IAAI,KAAK,IAAI,KAAK;EAC3C;AAEA,SAAO;IACH;IACA;;AAER;AAOM,SAAU,gBAAgB,WAAuB,SAAqB;AACxE,QAAM,eAAe,iBAAiB,WAAY,GAAG,UAAW,SAAS,CAAC;AAE1E,QAAM,SAAS,aAAa,QAAQ,SAAS,aAAa,OAAO,EAAE,MAAM,GAAG,EAAE,IAAI,aAAa,OAAO;AACtG,QAAM,aAAa,IAAI,QAAO;AAC9B,QAAM,aAAa,IAAI,QAAO;AAC9B,QAAM,aAAa,IAAI,QAAO;AAC9B,QAAM,cAAc,IAAI,QAAO;AAC/B,QAAM,cAAc,IAAI,QAAO;AAC/B,QAAM,kBAAkB,IAAI,QAAO;AACnC,QAAM,qBAAqB,IAAI,QAAO;AAGtC,WAAS,QAAQ,GAAG,QAAQ,QAAQ,QAAQ,SAAS,GAAG;AACpD,UAAM,IAAI,QAAQ,KAAK;AACvB,UAAM,IAAI,QAAQ,QAAQ,CAAC;AAC3B,UAAM,IAAI,QAAQ,QAAQ,CAAC;AAG3B,eAAW,UAAU,WAAW,IAAI,CAAC;AACrC,eAAW,UAAU,WAAW,IAAI,CAAC;AACrC,eAAW,UAAU,WAAW,IAAI,CAAC;AAErC,eAAW,cAAc,YAAY,WAAW;AAChD,eAAW,cAAc,YAAY,WAAW;AAEhD,YAAQ,WAAW,aAAa,aAAa,eAAe;AAE5D,oBAAgB,UAAS;AAGzB,UAAM,OAAO,WAAW,IAAI,WAAW,IAAI,WAAW;AACtD,UAAM,OAAO,WAAW,IAAI,WAAW,IAAI,WAAW;AACtD,UAAM,OAAO,WAAW,IAAI,WAAW,IAAI,WAAW;AAEtD,uBAAmB,IAAI,OAAO,GAAG,OAAO,GAAG,OAAO,CAAC;AACnD,uBAAmB,gBAAgB,MAAM;AACzC,uBAAmB,UAAS;AAE5B,QAAI,QAAQ,IAAI,iBAAiB,kBAAkB,KAAK,GAAG;AAEvD,cAAQ,KAAK,IAAI;AACjB,cAAQ,QAAQ,CAAC,IAAI;IACzB;EACJ;AACJ;;;ACnJM,SAAU,qBAAqB,UAAkB;AACnD,MAAI,SAAS,QAAQ,YAAY,MAAM,IAAI;AACvC,aAAS,KAAK,YAAY;EAC9B;AACA,MAAI,SAAS,QAAQ,aAAa,MAAM,IAAI;AACxC,aAAS,KAAK,aAAa;EAC/B;AACA,MAAI,SAAS,QAAQ,aAAa,MAAM,IAAI;AACxC,aAAS,KAAK,aAAa;EAC/B;AACA,MAAI,SAAS,QAAQ,aAAa,MAAM,IAAI;AACxC,aAAS,KAAK,aAAa;EAC/B;AACA,MAAI,SAAS,QAAQ,aAAa,MAAM,IAAI;AACxC,aAAS,KAAK,aAAa;EAC/B;AACA,MAAI,SAAS,QAAQ,aAAa,MAAM,IAAI;AACxC,aAAS,KAAK,aAAa;EAC/B;AACJ;AAGM,SAAU,kCAAkC,eAAkC,iBAAoC,SAAiB;AACrI,QAAM,YAAY,CAAC,EAAE,cAAc,aAAa,gBAAgB;AAChE,QAAM,aAAa,CAAC,EAAE,cAAc,cAAc,gBAAgB;AAClE,QAAM,aAAa,CAAC,EAAE,cAAc,cAAc,gBAAgB;AAClE,QAAM,aAAa,CAAC,EAAE,cAAc,cAAc,gBAAgB;AAClE,QAAM,aAAa,CAAC,EAAE,cAAc,cAAc,gBAAgB;AAClE,QAAM,aAAa,CAAC,EAAE,cAAc,cAAc,gBAAgB;AAElE,MAAI;AAAW,YAAQ,KAAK,mBAAmB;AAC/C,MAAI;AAAY,YAAQ,KAAK,oBAAoB;AACjD,MAAI;AAAY,YAAQ,KAAK,oBAAoB;AACjD,MAAI;AAAY,YAAQ,KAAK,oBAAoB;AACjD,MAAI;AAAY,YAAQ,KAAK,oBAAoB;AACjD,MAAI;AAAY,YAAQ,KAAK,oBAAoB;AACrD;AAGM,SAAU,4BAA4B,eAAkC,iBAAoC,SAA4B;AAC1I,MAAI,UAAU;AAEd,QAAM,YAAY,CAAC,EAAE,cAAc,aAAa,gBAAgB;AAChE,QAAM,aAAa,CAAC,EAAE,cAAc,cAAc,gBAAgB;AAClE,QAAM,aAAa,CAAC,EAAE,cAAc,cAAc,gBAAgB;AAClE,QAAM,aAAa,CAAC,EAAE,cAAc,cAAc,gBAAgB;AAClE,QAAM,aAAa,CAAC,EAAE,cAAc,cAAc,gBAAgB;AAClE,QAAM,aAAa,CAAC,EAAE,cAAc,cAAc,gBAAgB;AAGlE,MAAI,QAAQ,WAAW,MAAM,WAAW;AACpC,YAAQ,WAAW,IAAI;AACvB,cAAU;EACd;AACA,MAAI,QAAQ,YAAY,MAAM,YAAY;AACtC,YAAQ,YAAY,IAAI;AACxB,cAAU;EACd;AACA,MAAI,QAAQ,YAAY,MAAM,YAAY;AACtC,YAAQ,YAAY,IAAI;AACxB,cAAU;EACd;AACA,MAAI,QAAQ,YAAY,MAAM,YAAY;AACtC,YAAQ,YAAY,IAAI;AACxB,cAAU;EACd;AACA,MAAI,QAAQ,YAAY,MAAM,YAAY;AACtC,YAAQ,YAAY,IAAI;AACxB,cAAU;EACd;AACA,MAAI,QAAQ,YAAY,MAAM,YAAY;AACtC,YAAQ,YAAY,IAAI;AACxB,cAAU;EACd;AAEA,SAAO;AACX;AAGM,SAAU,cAAc,QAAgB,eAAkC,iBAAkC;AAC9G,MAAI,YAAY,cAAc,aAAa,gBAAgB;AAC3D,eAAa,QAAQ,cAAc,SAAS;AAC5C,cAAY,cAAc,cAAc,gBAAgB;AACxD,eAAa,QAAQ,eAAe,SAAS;AAC7C,cAAY,cAAc,cAAc,gBAAgB;AACxD,eAAa,QAAQ,eAAe,SAAS;AAC7C,cAAY,cAAc,cAAc,gBAAgB;AACxD,eAAa,QAAQ,eAAe,SAAS;AAC7C,cAAY,cAAc,cAAc,gBAAgB;AACxD,eAAa,QAAQ,eAAe,SAAS;AAC7C,cAAY,cAAc,cAAc,gBAAgB;AACxD,eAAa,QAAQ,eAAe,SAAS;AACjD;AAEA,SAAS,aAAa,QAAgB,aAAqB,WAA0B;AACjF,MAAI,WAAW;AACX,WAAO,UAAU,aAAa,UAAU,OAAO,GAAG,UAAU,OAAO,GAAG,UAAU,OAAO,GAAG,UAAU,CAAC;EACzG;AACJ;;;ACjFA,IAAM,gBAAgB,OAAO,MAAK;AAClC,IAAM,uBAAuB;EACzB,uBAAuB;EACvB,QAAQ;EACR,SAAS;EACT,IAAI;EACJ,KAAK;EACL,OAAO;;AASL,SAAU,aAAa,SAAc,QAAgB,OAAY;AACnE,MAAI,CAAC,WAAW,QAAQ,kBAAkB,KAAM,QAAQ,WAAW,QAAQ,QAAQ,kBAAkB,KAAK,GAAI;AAC1G,UAAM,SAAS,MAAM;AACrB,QAAI,OAAO,SAAS,GAAA;AAChB,aAAO,MAAM,kEAAkE,EAAE;IACrF;AACA,WAAO,SAAS,4BAA4B,KAAO,KAAK,IAAI,OAAO,OAAO,CAAG,IAAI,KAAK,IAAI;EAC9F;AACJ;AASM,SAAU,kBAAkB,OAAc,MAAqB,QAAiB,cAAc,OAAK;AACrG,MAAI,UAAU,MAAM,eAAe,CAAC,QAAQ,KAAK,aAAa,MAAM,YAAY,GAAA;AAC5E,WAAO,UAAU,aAAa,MAAM,SAAS,MAAM,UAAU,MAAM,QAAQ,MAAM,UAAU;AAE3F,QAAI,aAAa;AACb,YAAM,SAAS,mBAAmB,eAAe,MAAM,UAAS,EAAG,uBAAuB;AAC1F,aAAO,UAAU,aAAa,aAAa;IAC/C,OAAO;AACH,aAAO,UAAU,aAAa,MAAM,QAAQ;IAChD;EACJ;AACJ;AAgBM,SAAU,2CACZ,oBACA,SACA,SACA,MACA,kBACA,gBACA,iBACA,YACA,aACA,eAAsB;AAEtB,QAAM,sBAAsB,mBAAmB,qBAAqB,mBAAmB;AACvF,MAAI,uBAAuB,GAAG;AAC1B,WAAO;EACX;AAEA,UAAQ,KAAK,sBAAsB;AAEnC,MAAI,mBAAmB;AAAc,YAAQ,KAAK,yCAAyC;AAC3F,MAAI,mBAAmB;AAAY,YAAQ,KAAK,uCAAuC;AACvF,MAAI,mBAAmB;AAAa,YAAQ,KAAK,wCAAwC;AACzF,MAAI,mBAAmB;AAAQ,YAAQ,KAAK,mCAAmC;AAC/E,MAAI,mBAAmB;AAAS,YAAQ,KAAK,oCAAoC;AACjF,MAAI,mBAAmB;AAAW,YAAQ,KAAK,sCAAsC;AAErF,MAAI,mBAAmB,qBAAqB;AAAkB,YAAQ,KAAK,+BAA+B;AAC1G,MAAI,mBAAmB,mBAAmB;AAAgB,YAAQ,KAAK,6BAA6B;AACpG,MAAI,mBAAmB,oBAAoB;AAAiB,YAAQ,KAAK,8BAA8B;AACvG,MAAI,mBAAmB,eAAe;AAAY,YAAQ,KAAK,yBAAyB;AACxF,MAAI,mBAAmB,gBAAgB;AAAa,YAAQ,KAAK,0BAA0B;AAC3F,MAAI,mBAAmB,kBAAkB;AAAe,YAAQ,KAAK,4BAA4B;AAEjG,UAAQ,KAAK,mCAAmC,mBAAmB;AAEnE,MAAI,mBAAmB,0BAA0B;AAC7C,YAAQ,KAAK,8BAA8B;EAC/C;AAEA,uBAAqB,wBAAwB;AAC7C,uBAAqB,SAAS;AAC9B,uBAAqB,UAAU;AAC/B,uBAAqB,KAAK;AAC1B,uBAAqB,MAAM;AAC3B,uBAAqB,QAAQ;AAE7B,mCAAiC,SAAS,MAAM,sBAAsB,gBAAgB;AACtF,SAAO;AACX;AAQM,SAAU,4CAA4C,SAAmB,MAAoB,aAAmB;AAClH,uBAAqB,wBAAwB;AAC7C,uBAAqB,SAAS;AAC9B,uBAAqB,UAAU;AAC/B,uBAAqB,KAAK;AAC1B,uBAAqB,MAAM;AAC3B,uBAAqB,QAAQ;AAC7B,mCAAiC,SAAS,MAAM,sBAAsB,IAAI;AAC9E;AASM,SAAU,iCAAiC,SAAmB,MAAoB,SAAc,mBAAmB,MAAI;AACzH,QAAM,cAAc,QAAQ,uBAAuB;AAEnD,MAAI,cAAc,KAAK,YAAY,mBAAmB;AAClD,UAAM,qBAAqB,YAAY,kBAAkB,QAAO,EAAG;AACnE,UAAM,UAAW,KAAc;AAC/B,QAAI,mCAAS,0BAA0B;AACnC;IACJ;AACA,UAAM,WAAW,WAAW,QAAQ,qBAAqB;AACzD,UAAM,SAAS,WAAW,QAAQ,mBAAmB,QAAQ,QAAQ;AACrE,UAAM,UAAU,WAAW,QAAQ,oBAAoB,QAAQ,SAAS;AACxE,UAAM,KAAK,WAAW,QAAQ,eAAe,QAAQ,KAAK;AAC1D,UAAM,MAAM,WAAW,QAAQ,gBAAgB,QAAQ,KAAK;AAC5D,UAAM,QAAQ,WAAW,QAAQ,kBAAkB,QAAQ,OAAO;AAClE,aAAS,QAAQ,GAAG,QAAQ,aAAa,SAAS;AAC9C,UAAI,UAAU;AACV,gBAAQ,KAAK,aAAU,KAAA;MAC3B;AAEA,UAAI,QAAQ;AACR,gBAAQ,KAAK,WAAU,KAAA;MAC3B;AAEA,UAAI,SAAS;AACT,gBAAQ,KAAK,YAAU,KAAA;MAC3B;AAEA,UAAI,IAAI;AACJ,gBAAQ,KAAK,QAAU,KAAM;MACjC;AAEA,UAAI,KAAK;AACL,gBAAQ,KAAK,SAAU,KAAO;MAClC;AAEA,UAAI,OAAO;AACP,gBAAQ,KAAK,UAAU,KAAA;MAC3B;AAEA,UAAI,QAAQ,SAAS,oBAAoB;AACrC,eAAO,MAAM,gDAAgD,KAAK,IAAI;MAC1E;IACJ;EACJ;AACJ;AAOM,SAAU,2BAA2B,SAAmB,wBAAiC,OAAK;AAChG,UAAQ,KAAK,QAAQ;AACrB,UAAQ,KAAK,QAAQ;AACrB,UAAQ,KAAK,QAAQ;AACrB,UAAQ,KAAK,QAAQ;AACrB,MAAI,uBAAuB;AACvB,YAAQ,KAAK,gBAAgB;AAC7B,YAAQ,KAAK,gBAAgB;AAC7B,YAAQ,KAAK,gBAAgB;AAC7B,YAAQ,KAAK,gBAAgB;EACjC;AACJ;AAOM,SAAU,0BAA0B,cAA4B,QAAc;AAChF,QAAM,UAAiB,aAAc;AACrC,MAAI,CAAC,gBAAgB,CAAC,SAAS;AAC3B;EACJ;AAEA,SAAO,cAAc,yBAAyB,QAAQ,UAAU;AACpE;AAOM,SAAU,uBAAuB,QAAgB,UAAuB;AAC1E,WAAS,aAAa,QAAQ,OAAO;AACzC;AASM,SAAU,0BAA0B,SAAsB,SAAc,KAAW;AACrF,UAAQ,WAAW;AACnB,UAAQ,GAAG,IAAI;AACf,MAAI,QAAQ,wBAAwB,QAAQ,iBAAgB,EAAG,gBAAe,GAAI;AAC9E,YAAQ,MAAM,UAAU,IAAI,QAAQ,mBAAmB;AACvD,YAAQ,YAAY,QAAQ,mBAAmB,EAAE,IAAI;EACzD,OAAO;AACH,YAAQ,MAAM,UAAU,IAAI;EAChC;AACJ;AAQM,SAAU,kBAAkB,SAAsB,eAA8B,KAAW;AAC7F,QAAM,SAAS,QAAQ,iBAAgB;AAEvC,gBAAc,aAAa,MAAM,UAAU,MAAM;AACrD;AAQM,SAAU,yCAAyC,SAAmB,MAAoB,SAAY;AACxG,QAAM,UAAU,QAAQ,gCAAgC,KAAK,QAAQ,WAAW;AAEhF,MAAI,SAAS;AACT,YAAQ,KAAK,uCAAuC;EACxD;AACJ;AAGA,SAAS,iCAAiC,QAAsB,QAAoB;AAChF,SAAO,IAAI,MAAM;AAEjB,SAAO;AACX;AAQM,SAAU,oBAAoB,MAAqB,QAAiB,sBAA2C;AACjH,MAAI,CAAC,UAAU,CAAC,MAAM;AAClB;EACJ;AACA,MAAI,KAAK,4BAA4B,OAAO,8BAA8B;AACtE,SAAK,2BAA2B;EACpC;AAEA,MAAI,KAAK,YAAY,KAAK,4BAA4B,KAAK,UAAU;AACjE,UAAM,WAAW,KAAK;AAEtB,QAAI,SAAS,6BAA6B,OAAO,gBAAgB,kBAAkB,IAAI,IAAI;AACvF,YAAM,cAAc,SAAS,0BAA0B,IAAI;AAC3D,aAAO,WAAW,eAAe,WAAW;AAC5C,aAAO,SAAS,oBAAoB,KAAO,SAAS,MAAM,SAAS,EAAE;IACzE,OAAO;AACH,YAAM,WAAW,SAAS,qBAAqB,IAAI;AAEnD,UAAI,UAAU;AACV,eAAO,YAAY,UAAU,QAAQ;AACrC,YAAI,wBAAwB,KAAK,SAAQ,EAAG,mBAAmB,KAAK,SAAQ,EAAG,gBAAiB,SAAS,CAAA,GAAA;AACrG,cAAI,CAAC,qBAAqB,cAAc,KAAK,QAAQ,GAAG;AACpD,iCAAqB,cAAc,KAAK,QAAQ,IAAI,SAAS,MAAK;UACtE;AACA,iBAAO,YAAY,kBAAkB,qBAAqB,cAAc,KAAK,QAAQ,CAAC;AACtF,2CAAiC,UAAU,qBAAqB,cAAc,KAAK,QAAQ,CAAC;QAChG;MACJ;IACJ;EACJ;AACJ;AAQM,SAAU,oBAAoB,OAAc,QAAgB,YAAkB;AAChF,QAAM,iBAAiB,QAAQ,aAAa,EAAE;AAClD;AAWM,SAAU,UAAU,OAAc,YAAoB,OAAc,QAAgB,aAAsB,iBAAiB,MAAI;AACjI,QAAM,WAAW,YAAY,OAAO,QAAQ,aAAa,cAAc;AAC3E;AAUM,SAAU,WAAW,OAAc,MAAoB,QAAgB,SAAc,wBAAwB,GAAC;AAChH,QAAM,MAAM,KAAK,IAAI,KAAK,aAAa,QAAQ,qBAAqB;AAEpE,WAAS,IAAI,GAAG,IAAI,KAAK,KAAK;AAC1B,UAAM,QAAQ,KAAK,aAAa,CAAC;AACjC,cAAU,OAAO,GAAG,OAAO,QAAQ,OAAO,YAAY,YAAY,UAAU,QAAQ,cAAc,GAAG,KAAK,cAAc;EAC5H;AACJ;AASM,SAAU,0BAA0B,SAAmB,MAAoB,SAAc,WAA0B;AACrH,MAAI,QAAQ,sBAAsB,IAAI,GAAG;AACrC,cAAU,uBAAuB,GAAG,IAAI;AAExC,YAAQ,KAAK,iBAAU;AACvB,YAAQ,KAAK,iBAAU;AACvB,QAAI,QAAQ,sBAAsB,IAAI,GAAG;AACrC,cAAQ,KAAK,sBAAU;AACvB,cAAQ,KAAK,sBAAU;IAC3B;EACJ;AACJ;AAOM,SAAU,8BAA8B,SAAmB,SAAwB;AACrF,MAAI,QAAQ,WAAW,KAAK,QAAQ,gBAAgB,GAAG;AACnD,+BAA2B,SAAS,CAAC,CAAC,QAAQ,kBAAkB,CAAC;EACrE;AAEA,MAAI,QAAQ,gBAAgB;AACxB,YAAQ,KAAK,eAAU;EAC3B;AACJ;AAUM,SAAU,0BAA0B,SAAc,WAA4B,wBAAwB,GAAG,OAAO,GAAC;AACnH,MAAI,oBAAoB;AACxB,WAAS,aAAa,GAAG,aAAa,uBAAuB,cAAc;AACvE,QAAI,CAAC,QAAQ,UAAU,UAAU,GAAG;AAChC;IACJ;AAEA,QAAI,aAAa,GAAG;AAChB,0BAAoB,OAAO;AAC3B,gBAAU,YAAY,mBAAmB,UAAU,UAAU;IACjE;AAEA,QAAI,CAAC,QAAQ,SAAS,GAAG;AACrB,UAAI,QAAQ,WAAW,UAAU,GAAG;AAChC,kBAAU,YAAY,MAAM,WAAW,UAAU;MACrD;AAEA,UAAI,QAAQ,cAAc,UAAU,GAAG;AACnC,kBAAU,YAAY,MAAM,cAAc,UAAU;MACxD;AAEA,UAAI,QAAQ,eAAe,UAAU,GAAG;AACpC,kBAAU,YAAY,MAAM,eAAe,UAAU;MACzD;AAEA,UAAI,QAAQ,kBAAkB,UAAU,GAAG;AACvC,kBAAU,YAAY,MAAM,kBAAkB,UAAU;MAC5D;AAEA,UAAI,QAAQ,cAAc,UAAU,GAAG;AACnC,kBAAU,YAAY,MAAM,cAAc,UAAU;MACxD;AAEA,UAAI,QAAQ,mBAAmB,UAAU,GAAG;AACxC,kBAAU,YAAY,MAAM,mBAAmB,UAAU;MAC7D;IACJ;EACJ;AACA,SAAO;AACX;AAQM,SAAU,YAAY,MAAoB,OAAY;AACxD,SAAO,MAAM,cAAc,KAAK,YAAY,MAAM,YAAY;AAClE;AAaM,SAAU,sBACZ,MACA,OACA,qBACA,aACA,YACA,WACA,SACA,wBAAiC,OAAK;AAEtC,MAAI,QAAQ,eAAe;AACvB,YAAQ,kBAAkB,IAAI;AAC9B,YAAQ,WAAW,IAAI;AACvB,YAAQ,KAAK,IAAI,cAAc,YAAY,MAAM,KAAK;AACtD,YAAQ,mBAAmB,IAAI,KAAK;AACpC,YAAQ,WAAW,IAAI;AACvB,YAAQ,oBAAoB,IAAI;EACpC;AACJ;AAYM,SAAU,wBAAwB,OAAc,MAAoB,SAAc,mBAA4B,wBAAwB,GAAG,kBAAkB,OAAK;AAClK,MAAI,CAAC,QAAQ,iBAAiB;AAC1B,WAAO,QAAQ;EACnB;AAEA,MAAI,aAAa;AACjB,QAAM,QAAQ;IACV,aAAa,QAAQ;;IACrB,aAAa;IACb,cAAc;IACd,eAAe;IACf,iBAAiB;;AAGrB,MAAI,MAAM,iBAAiB,CAAC,iBAAiB;AACzC,eAAW,SAAS,KAAK,cAAc;AACnC,6BAAuB,OAAO,MAAM,OAAO,YAAY,SAAS,mBAAmB,KAAK;AAExF;AACA,UAAI,eAAe,uBAAuB;AACtC;MACJ;IACJ;EACJ;AAEA,UAAQ,cAAc,IAAI,MAAM;AAChC,UAAQ,SAAS,IAAI,MAAM;AAG3B,WAAS,QAAQ,YAAY,QAAQ,uBAAuB,SAAS;AACjE,QAAI,QAAQ,UAAU,KAAK,MAAM,QAAW;AACxC,cAAQ,UAAU,KAAK,IAAI;AAC3B,cAAQ,cAAc,KAAK,IAAI;AAC/B,cAAQ,eAAe,KAAK,IAAI;AAChC,cAAQ,aAAa,KAAK,IAAI;AAC9B,cAAQ,cAAc,KAAK,IAAI;AAC/B,cAAQ,cAAc,KAAK,IAAI;AAC/B,cAAQ,WAAW,KAAK,IAAI;AAC5B,cAAQ,cAAc,KAAK,IAAI;AAC/B,cAAQ,mBAAmB,KAAK,IAAI;AACpC,cAAQ,0BAA0B,KAAK,IAAI;AAC3C,cAAQ,2BAA2B,KAAK,IAAI;AAC5C,cAAQ,qBAAqB,KAAK,IAAI;AACtC,cAAQ,0BAA0B,KAAK,IAAI;AAC3C,cAAQ,cAAc,KAAK,IAAI;AAC/B,cAAQ,eAAe,KAAK,IAAI;AAChC,cAAQ,kBAAkB,KAAK,IAAI;AACnC,cAAQ,cAAc,KAAK,IAAI;AAC/B,cAAQ,mBAAmB,KAAK,IAAI;AACpC,cAAQ,eAAe,KAAK,IAAI;AAChC,cAAQ,qBAAqB,KAAK,IAAI;AACtC,cAAQ,wBAAwB,KAAK,IAAI;IAC7C;EACJ;AAEA,QAAM,OAAO,MAAM,UAAS,EAAG,QAAO;AAEtC,MAAI,QAAQ,aAAa,MAAM,QAAW;AACtC,UAAM,cAAc;EACxB;AAEA,UAAQ,aAAa,IACjB,MAAM,kBAAmB,KAAK,sBAAsB,KAAK,+BAAiC,KAAK,0BAA0B,KAAK;AAClI,UAAQ,kBAAkB,IAAI,MAAM;AAEpC,MAAI,MAAM,aAAa;AACnB,YAAQ,QAAO;EACnB;AAEA,SAAO,MAAM;AACjB;AAiBM,SAAU,uBACZ,OACA,MACA,OACA,YACA,SACA,mBACA,OAMC;AAED,QAAM,cAAc;AAEpB,MAAI,QAAQ,UAAU,UAAU,MAAM,QAAW;AAC7C,UAAM,cAAc;EACxB;AAEA,UAAQ,UAAU,UAAU,IAAI;AAEhC,UAAQ,cAAc,UAAU,IAAI;AACpC,UAAQ,cAAc,UAAU,IAAI;AACpC,UAAQ,eAAe,UAAU,IAAI;AACrC,UAAQ,aAAa,UAAU,IAAI;AACnC,UAAQ,cAAc,UAAU,IAAI;AAEpC,QAAM,4BAA4B,SAAS,UAAU;AAGrD,UAAQ,2BAA2B,UAAU,IAAI;AACjD,UAAQ,uBAAuB,UAAU,IAAI;AAC7C,UAAQ,2BAA2B,UAAU,IAAI;AAEjD,UAAQ,MAAM,aAAa;IACvB,KAAK,eAAe;AAChB,cAAQ,uBAAuB,UAAU,IAAI;AAC7C;IACJ,KAAK,eAAe;AAChB,cAAQ,2BAA2B,UAAU,IAAI;AACjD;IACJ,KAAK,eAAe;AAChB,cAAQ,2BAA2B,UAAU,IAAI;AACjD;EACR;AAGA,MAAI,qBAAqB,CAAC,MAAM,SAAS,aAAa,GAAG,GAAG,CAAC,GAAG;AAC5D,UAAM,kBAAkB;EAC5B;AAGA,UAAQ,WAAW,UAAU,IAAI;AACjC,UAAQ,cAAc,UAAU,IAAI;AACpC,UAAQ,mBAAmB,UAAU,IAAI;AACzC,UAAQ,0BAA0B,UAAU,IAAI;AAChD,UAAQ,2BAA2B,UAAU,IAAI;AACjD,UAAQ,qBAAqB,UAAU,IAAI;AAC3C,UAAQ,0BAA0B,UAAU,IAAI;AAChD,UAAQ,cAAc,UAAU,IAAI;AACpC,UAAQ,eAAe,UAAU,IAAI;AACrC,UAAQ,kBAAkB,UAAU,IAAI;AACxC,UAAQ,cAAc,UAAU,IAAI;AACpC,UAAQ,mBAAmB,UAAU,IAAI;AACzC,UAAQ,eAAe,UAAU,IAAI;AACrC,UAAQ,qBAAqB,UAAU,IAAI;AAC3C,UAAQ,wBAAwB,UAAU,IAAI;AAE9C,MAAI,QAAQ,KAAK,kBAAkB,MAAM,kBAAkB,MAAM,eAAe;AAC5E,UAAM,kBAAkB,MAAM,mBAAmB,MAAM,YAAY,KAAK,MAAM,mBAAkB;AAChG,QAAI,iBAAiB;AACjB,YAAM,YAAY,gBAAgB,aAAY;AAC9C,UAAI,WAAW;AACX,YAAI,UAAU,cAAc,UAAU,WAAW,SAAS,GAAG;AACzD,gBAAM,gBAAgB;AACtB,0BAAgB,eAAe,SAAS,UAAU;QACtD;MACJ;IACJ;EACJ;AAEA,MAAI,MAAM,gBAAgB,eAAe,kBAAkB;AACvD,UAAM,eAAe;AACrB,YAAQ,qBAAqB,UAAU,IAAI;AAC3C,YAAQ,uBAAuB,UAAU,IAAI,MAAM,gBAAgB,eAAe;EACtF,OAAO;AACH,YAAQ,qBAAqB,UAAU,IAAI;AAC3C,YAAQ,uBAAuB,UAAU,IAAI;EACjD;AACJ;AAYM,SAAU,kCACZ,OACA,QACA,UACA,SACA,cACA,eAAkC,MAClC,mBAA4B,OAAK;AAEjC,MAAI,UAAU,wBAAwB,OAAO,OAAO;AAEpD,MAAI,iBAAiB,OAAO;AACxB,cAAU,4BAA4B,UAAU,OAAO,OAAO;EAClE;AAEA,MAAI,QAAQ,cAAc,MAAM,CAAC,OAAO,cAAa,GAAI;AACrD,YAAQ,cAAc,IAAI,CAAC,QAAQ,cAAc;AACjD,cAAU;EACd;AAEA,MAAI,QAAQ,WAAW,MAAM,cAAc;AACvC,YAAQ,WAAW,IAAI;AACvB,cAAU;EACd;AAEA,MAAI,QAAQ,gBAAgB,MAAM,kBAAkB;AAChD,YAAQ,gBAAgB,IAAI;AAC5B,cAAU;EACd;AAEA,MAAI,SAAS;AACT,YAAQ,kBAAiB;EAC7B;AACJ;AAOM,SAAU,uBAAuB,MAAoB,SAAY;AACnE,MAAI,KAAK,YAAY,KAAK,4BAA4B,KAAK,UAAU;AACjE,YAAQ,sBAAsB,IAAI,KAAK;AAEvC,UAAM,8BAA8B,QAAQ,aAAa,MAAM;AAE/D,QAAI,KAAK,SAAS,6BAA6B,6BAA6B;AACxE,cAAQ,aAAa,IAAI;IAC7B,OAAO;AACH,cAAQ,cAAc,IAAI,KAAK,SAAS,MAAM,SAAS;AACvD,cAAQ,aAAa,IAAI,8BAA8B,QAAQ;AAE/D,YAAM,kBAAkB,KAAK,SAAQ,EAAG;AACxC,UAAI,mBAAmB,gBAAgB,SAAS;AAC5C,cAAM,cAAc,gBAAgB,oBAAoB,QAAQ,IAAI,MAAM;AAC1E,gBAAQ,wBAAwB,IAAI;MACxC;IACJ;EACJ,OAAO;AACH,YAAQ,sBAAsB,IAAI;AAClC,YAAQ,cAAc,IAAI;AAC1B,QAAI,QAAQ,aAAa,MAAM,QAAW;AACtC,cAAQ,aAAa,IAAI;IAC7B;EACJ;AACJ;AAOM,SAAU,8BAA8B,MAAoB,SAAY;AAC1E,QAAM,UAAiB,KAAM;AAC7B,MAAI,SAAS;AACT,YAAQ,iBAAiB,IAAI,QAAQ,eAAe,QAAQ,KAAK;AACjE,YAAQ,kBAAkB,IAAI,QAAQ,gBAAgB,QAAQ,KAAK;AACnE,YAAQ,sBAAsB,IAAI,QAAQ,oBAAoB,QAAQ,SAAS;AAC/E,YAAQ,qBAAqB,IAAI,QAAQ,mBAAmB,QAAQ,QAAQ;AAC5E,YAAQ,uBAAuB,IAAI,QAAQ;AAC3C,YAAQ,oBAAoB,IAAI,QAAQ;AAExC,YAAQ,2BAA2B,IAAI,QAAQ;AAC/C,YAAQ,4BAA4B,IAAI,QAAQ;AAChD,YAAQ,gCAAgC,IAAI,QAAQ;AACpD,YAAQ,+BAA+B,IAAI,QAAQ;AACnD,YAAQ,iCAAiC,IAAI,QAAQ;AACrD,YAAQ,8BAA8B,IAAI,QAAQ;AAElD,YAAQ,uBAAuB,IAAI,QAAQ,qBAAqB,QAAQ;AACxE,YAAQ,cAAc,IAAI,QAAQ,uBAAuB,IAAI;AAE7D,YAAQ,sBAAsB,IAAI,QAAQ;EAC9C,OAAO;AACH,YAAQ,iBAAiB,IAAI;AAC7B,YAAQ,kBAAkB,IAAI;AAC9B,YAAQ,sBAAsB,IAAI;AAClC,YAAQ,qBAAqB,IAAI;AACjC,YAAQ,uBAAuB,IAAI;AACnC,YAAQ,oBAAoB,IAAI;AAEhC,YAAQ,2BAA2B,IAAI;AACvC,YAAQ,4BAA4B,IAAI;AACxC,YAAQ,gCAAgC,IAAI;AAC5C,YAAQ,+BAA+B,IAAI;AAC3C,YAAQ,iCAAiC,IAAI;AAC7C,YAAQ,+BAA+B,IAAI;AAE3C,YAAQ,cAAc,IAAI;AAC1B,YAAQ,uBAAuB,IAAI;EACvC;AACJ;AAOM,SAAU,sCAAsC,MAAoB,SAAY;AAClF,QAAM,UAAiB,KAAM;AAC7B,UAAQ,gCAAgC,IAAI,WAAW,QAAQ,YAAY,OAAO;AACtF;AAaM,SAAU,4BACZ,MACA,SACA,gBACA,UACA,kBAAkB,OAClB,iBAAiB,MACjB,0BAA0B,MAAI;AAE9B,MAAI,CAAC,QAAQ,uBAAuB,QAAQ,iBAAiB,QAAQ,YAAY,QAAQ,aAAa,QAAQ,MAAM;AAChH,WAAO;EACX;AAEA,UAAQ,WAAW,QAAQ;AAC3B,UAAQ,OAAO,QAAQ;AAEvB,UAAQ,QAAQ,IAAI,QAAQ,gBAAgB,KAAK,sBAAsB,QAAA;AAEvE,MAAI,QAAQ,gBAAgB,KAAK,sBAAsB,SAAS,GAAC;AAC7D,YAAQ,SAAS,IAAI;EACzB;AAEA,WAAS,IAAI,GAAG,KAAK,GAAA,EAAA,GAAA;AACjB,YAAQ,OAAO,CAAC,IAAI,QAAQ,WAAW,KAAK,sBAAsB,KAAK,MAAM,IAAI,KAAK,CAAC,EAAE,IAAI;EACjG;AAEA,MAAI,gBAAgB;AAChB,UAAM,kBAAkB,KAAK,mBAAmB,KAAK,sBAAsB,OAAA;AAC3E,YAAQ,aAAa,IAAI;AACzB,YAAQ,aAAa,IAAI,KAAK,kBAAkB,mBAAmB;EACvE;AAEA,MAAI,KAAK,sBAAsB,eAAU,MAAA,KAAA,gBAA4B,KAAA,mBAAqB;AACtF,YAAQ,gBAAgB,IAAI;EAChC;AAEA,MAAI,UAAU;AACV,2BAAuB,MAAM,OAAO;EACxC;AAEA,MAAI,iBAAiB;AACjB,kCAA8B,MAAM,OAAO;EAC/C;AAEA,MAAI,yBAAyB;AACzB,0CAAsC,MAAM,OAAO;EACvD;AAEA,SAAO;AACX;AAOM,SAAU,2BAA2B,OAAc,SAAY;AACjE,MAAI,MAAM,cAAc;AACpB,UAAM,oBAAoB,QAAQ;AAClC,YAAQ,YAAY,MAAM,aAAa,uBAAuB,QAAQ,MAAM,aAAa,mBAAmB,aAAY,IAAK;AAC7H,QAAI,QAAQ,aAAa,mBAAmB;AACxC,cAAQ,kBAAiB;IAC7B;EACJ;AACJ;AAQM,SAAU,qBAAqB,OAAc,SAAc,mBAA0B;AACvF,QAAM,iBAAiB,QAAQ;AAC/B,QAAM,uBAAuB,QAAQ;AAErC,UAAQ,iCAAiC,MAAM,mCAAmC;AAClF,UAAQ,wCAAwC,CAAC,MAAM,UAAS,EAAG,QAAO,EAAG;AAE7E,MAAI,mBAAmB,QAAQ,kCAAkC,yBAAyB,QAAQ,uCAAuC;AACrI,YAAQ,kBAAiB;EAC7B;AACJ;AAQM,SAAU,yBAAyB,OAAc,SAAc,gBAAuB;AACxF,QAAM,kBAAkB,QAAQ;AAEhC,MAAI,CAAC,QAAQ,kBAAkB;AAC3B;EACJ;AAEA,QAAM,eAAe;IACjB;MACI,MAAM;MACN,QAAQ;MACR,OAAO;;IAEX;MACI,MAAM;MACN,QAAQ;MACR,OAAO;;IAEX;MACI,MAAM;MACN,QAAQ;MACR,OAAO;;IAEX;MACI,MAAM;MACN,QAAQ;MACR,OAAO;;IAEX;MACI,MAAM;MACN,QAAQ;MACR,OAAO;;IAEX;MACI,MAAM;MACN,QAAQ;MACR,OAAO;;IAEX;MACI,MAAM;MACN,QAAQ;MACR,OAAO;;IAEX;MACI,MAAM;MACN,QAAQ;MACR,OAAO;;IAEX;MACI,MAAM;MACN,QAAQ;MACR,OAAO;;IAEX;MACI,MAAM;MACN,QAAQ;MACR,OAAO;;IAEX;MACI,MAAM;MACN,QAAQ;MACR,OAAO;;;AAIf,MAAI,MAAM,mBAAmB,MAAM,gBAAgB,WAAW,gBAAgB;AAC1E,YAAQ,UAAU;AAClB,YAAQ,kBAAkB,MAAM,gBAAgB;AAChD,YAAQ,4BAA4B,MAAM,gBAAgB;AAC1D,YAAQ,gBAAgB;AACxB,YAAQ,sBAAsB;AAE9B,aAAS,IAAI,GAAG,IAAI,aAAa,QAAQ,KAAK;AAC1C,YAAM,QAAQ,MAAM,gBAAgB,SAAS,aAAa,CAAC,EAAE,IAAI;AACjE,UAAI,UAAU,IAAI;AACd,gBAAQ,aAAa,CAAC,EAAE,MAAM,IAAI;AAClC,gBAAQ,aAAa,CAAC,EAAE,KAAK,IAAI;MACrC,OAAO;AACH,gBAAQ,aAAa,CAAC,EAAE,MAAM,IAAI;MACtC;IACJ;EACJ,OAAO;AACH,YAAQ,UAAU;AAClB,aAAS,IAAI,GAAG,IAAI,aAAa,QAAQ,KAAK;AAC1C,cAAQ,aAAa,CAAC,EAAE,MAAM,IAAI;IACtC;EACJ;AAEA,MAAI,QAAQ,WAAW,iBAAiB;AACpC,YAAQ,kBAAiB;AACzB,YAAQ,2BAA0B;EACtC;AACJ;AAQM,SAAU,wBAAwB,OAAc,SAAY;AAC9D,MAAI,UAAU;AAEd,MAAI,MAAM,cAAc;AACpB,UAAM,WAAW,QAAQ,qBAAqB,IAAI,IAAI;AACtD,UAAM,WAAW,QAAQ,oBAAoB,IAAI,IAAI;AACrD,UAAM,UAAU,MAAM,aAAa,SAAS,IAAA,IAAA;AAC5C,UAAM,UAAU,MAAM,aAAa,SAAS,IAAA,IAAA;AAE5C,QAAI,WAAW,WAAW,WAAW,SAAS;AAC1C,cAAQ,qBAAqB,IAAI,YAAY;AAC7C,cAAQ,oBAAoB,IAAI,YAAY;AAC5C,gBAAU;IACd;EACJ;AAEA,SAAO;AACX;AAYM,SAAU,mCACZ,YACA,cACA,cACA,uBACA,qBAAyC,MACzC,wBAAwB,OACxB,kBAAkB,OAAK;AAEvB,MAAI,oBAAoB;AACpB,uBAAmB,KAAK,UAAU,UAAU;EAChD;AAEA,MAAI,uBAAuB;AACvB;EACJ;AAEA,eAAa,KACT,eAAe,YACf,kBAAkB,YAClB,mBAAmB,YACnB,oBAAoB,YACpB,gBAAgB,YAChB,iBAAiB,YACjB,kBAAkB,YAClB,iBAAiB,YACjB,gBAAgB,YAChB,gBAAgB,YAChB,gBAAgB,UAAU;AAG9B,eAAa,KAAK,kBAAkB,UAAU;AAC9C,eAAa,KAAK,iBAAiB,UAAU;AAE7C,eAAa,KACT,iBAAiB,YACjB,uBAAuB,YACvB,0BAA0B,YAC1B,oBAAoB,YACpB,qBAAqB,YACrB,mBAAmB,UAAU;AAGjC,MAAI,uBAAuB;AACvB,iBAAa,KAAK,2BAA2B,UAAU;AACvD,iBAAa,KAAK,4BAA4B,UAAU;EAC5D;AACA,MAAI,iBAAiB;AACjB,iBAAa,KAAK,oBAAoB,UAAU;EACpD;AACJ;AASM,SAAU,+BAA+B,uBAA0D,cAAyB,SAAe,wBAAwB,GAAC;AACtK,MAAI;AACJ,MAAI;AAEJ,MAA6B,sBAAuB,eAAe;AAC/D,UAAM,UAAkC;AACxC,mBAAe,QAAQ;AACvB,yBAAqB,QAAQ;AAC7B,mBAAe,QAAQ;AACvB,cAAU,QAAQ;AAClB,4BAAwB,QAAQ,yBAAyB;EAC7D,OAAO;AACH,mBAAyB;AACzB,QAAI,CAAC,cAAc;AACf,qBAAe,CAAA;IACnB;EACJ;AAEA,WAAS,aAAa,GAAG,aAAa,uBAAuB,cAAc;AACvE,QAAI,CAAC,QAAQ,UAAU,UAAU,GAAG;AAChC;IACJ;AACA,uCACI,YACA,cACA,cACA,QAAQ,0BAA0B,UAAU,GAC5C,oBACA,OACA,QAAQ,oBAAoB,UAAU,CAAC;EAE/C;AAEA,MAAI,QAAQ,uBAAuB,GAAG;AAClC,iBAAa,KAAK,uBAAuB;AACzC,iBAAa,KAAK,kBAAkB;EACxC;AAEA,MAAI,QAAQ,gCAAgC,GAAG;AAC3C,iBAAa,KAAK,8BAA8B;AAChD,iBAAa,KAAK,yCAAyC;AAC3D,iBAAa,KAAK,0BAA0B;AAC5C,iBAAa,KAAK,6BAA6B;EACnD;AACJ;",
  "names": []
}
