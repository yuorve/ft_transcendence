import {
  BindBonesParameters,
  BindMorphTargetParameters,
  PrepareAttributesForBakedVertexAnimation,
  PrepareDefinesAndAttributesForMorphTargets,
  extractMinAndMax
} from "./chunk-F3SXY57Y.js";
import {
  Vector3
} from "./chunk-PY7JDJIY.js";
import {
  Buffer,
  VertexBuffer
} from "./chunk-SGWWALOD.js";
import {
  ShaderStore
} from "./chunk-FX6MN5HL.js";

// node_modules/@babylonjs/core/Shaders/gpuTransform.vertex.js
var name = "gpuTransformVertexShader";
var shader = `attribute vec3 position;
#include<bonesDeclaration>
#include<bakedVertexAnimationDeclaration>
#include<morphTargetsVertexGlobalDeclaration>
#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]
out vec3 outPosition;const mat4 identity=mat4(
vec4(1.0,0.0,0.0,0.0),
vec4(0.0,1.0,0.0,0.0),
vec4(0.0,0.0,1.0,0.0),
vec4(0.0,0.0,0.0,1.0)
);void main(void) {vec3 positionUpdated=position;
#include<morphTargetsVertexGlobal>
#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]
mat4 finalWorld=identity;
#include<bonesVertex>
#include<bakedVertexAnimation>
vec4 worldPos=finalWorld*vec4(positionUpdated,1.0);outPosition=worldPos.xyz;}`;
ShaderStore.ShadersStore[name] = shader;

// node_modules/@babylonjs/core/Shaders/gpuTransform.fragment.js
var name2 = "gpuTransformPixelShader";
var shader2 = `#version 300 es
void main() {discard;}
`;
ShaderStore.ShadersStore[name2] = shader2;

// node_modules/@babylonjs/core/Culling/Helper/transformFeedbackBoundingHelper.js
var TransformFeedbackBoundingHelper = class _TransformFeedbackBoundingHelper {
  /**
   * Creates a new TransformFeedbackBoundingHelper
   * @param engine defines the engine to use
   */
  constructor(engine) {
    this._buffers = {};
    this._effects = {};
    this._meshListCounter = 0;
    this._engine = engine;
  }
  /** @internal */
  processAsync(meshes) {
    if (!Array.isArray(meshes)) {
      meshes = [meshes];
    }
    this._meshListCounter = 0;
    this._processMeshList(meshes);
    return Promise.resolve();
  }
  _processMeshList(meshes) {
    const parallelShaderCompile = this._engine.getCaps().parallelShaderCompile;
    this._engine.getCaps().parallelShaderCompile = void 0;
    for (let i = 0; i < meshes.length; ++i) {
      const mesh = meshes[i];
      const vertexCount = mesh.getTotalVertices();
      if (vertexCount === 0 || !mesh.getVertexBuffer || !mesh.getVertexBuffer(VertexBuffer.PositionKind)) {
        continue;
      }
      let computeEffect;
      const defines = [];
      const attribs = [VertexBuffer.PositionKind];
      if (mesh && mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {
        attribs.push(VertexBuffer.MatricesIndicesKind);
        attribs.push(VertexBuffer.MatricesWeightsKind);
        if (mesh.numBoneInfluencers > 4) {
          attribs.push(VertexBuffer.MatricesIndicesExtraKind);
          attribs.push(VertexBuffer.MatricesWeightsExtraKind);
        }
        defines.push("#define NUM_BONE_INFLUENCERS " + mesh.numBoneInfluencers);
        defines.push("#define BONETEXTURE " + mesh.skeleton.isUsingTextureForMatrices);
        defines.push("#define BonesPerMesh " + (mesh.skeleton.bones.length + 1));
      } else {
        defines.push("#define NUM_BONE_INFLUENCERS 0");
      }
      const numMorphInfluencers = mesh.morphTargetManager ? PrepareDefinesAndAttributesForMorphTargets(
        mesh.morphTargetManager,
        defines,
        attribs,
        mesh,
        true,
        // usePositionMorph
        false,
        // useNormalMorph
        false,
        // useTangentMorph
        false,
        // useUVMorph
        false,
        // useUV2Morph
        false
        // useColorMorph
      ) : 0;
      const bvaManager = mesh.bakedVertexAnimationManager;
      if (bvaManager && bvaManager.isEnabled) {
        defines.push("#define BAKED_VERTEX_ANIMATION_TEXTURE");
        PrepareAttributesForBakedVertexAnimation(attribs, mesh, defines);
      }
      const join = defines.join("\n");
      if (!this._effects[join]) {
        const uniforms = [
          "boneTextureWidth",
          "mBones",
          "morphTargetInfluences",
          "morphTargetCount",
          "morphTargetTextureInfo",
          "morphTargetTextureIndices",
          "bakedVertexAnimationSettings",
          "bakedVertexAnimationTextureSizeInverted",
          "bakedVertexAnimationTime"
        ];
        const samplers = ["boneSampler", "morphTargets", "bakedVertexAnimationTexture"];
        const computeEffectOptions = {
          attributes: attribs,
          uniformsNames: uniforms,
          uniformBuffersNames: [],
          samplers,
          defines: join,
          fallbacks: null,
          onCompiled: null,
          onError: null,
          indexParameters: { maxSimultaneousMorphTargets: numMorphInfluencers },
          maxSimultaneousLights: 0,
          transformFeedbackVaryings: ["outPosition"]
        };
        computeEffect = this._engine.createEffect("gpuTransform", computeEffectOptions, this._engine);
        this._effects[join] = computeEffect;
      } else {
        computeEffect = this._effects[join];
      }
      this._compute(mesh, computeEffect);
    }
    this._engine.getCaps().parallelShaderCompile = parallelShaderCompile;
  }
  _compute(mesh, effect) {
    var _a;
    const engine = this._engine;
    let targetBuffer;
    const vertexCount = mesh.getTotalVertices();
    if (!this._buffers[mesh.uniqueId]) {
      const targetData = new Float32Array(vertexCount * 3);
      targetBuffer = new Buffer(mesh.getEngine(), targetData, true, 3);
      this._buffers[mesh.uniqueId] = targetBuffer;
    } else {
      targetBuffer = this._buffers[mesh.uniqueId];
    }
    effect.getEngine().enableEffect(effect);
    mesh._bindDirect(effect, null, true);
    BindBonesParameters(mesh, effect);
    BindMorphTargetParameters(mesh, effect);
    if (mesh.morphTargetManager && mesh.morphTargetManager.isUsingTextureForTargets) {
      mesh.morphTargetManager._bind(effect);
    }
    const bvaManager = mesh.bakedVertexAnimationManager;
    if (bvaManager && bvaManager.isEnabled) {
      (_a = mesh.bakedVertexAnimationManager) == null ? void 0 : _a.bind(effect, false);
    }
    const arrayBuffer = targetBuffer.getData();
    engine.bindTransformFeedbackBuffer(targetBuffer.getBuffer());
    engine.setRasterizerState(false);
    engine.beginTransformFeedback(true);
    engine.drawArraysType(2, 0, vertexCount);
    engine.endTransformFeedback();
    engine.setRasterizerState(true);
    engine.readTransformFeedbackBuffer(arrayBuffer);
    engine.bindTransformFeedbackBuffer(null);
    if (this._meshListCounter === 0) {
      mesh._refreshBoundingInfo(arrayBuffer, null);
    } else {
      const bb = mesh.getBoundingInfo().boundingBox;
      const extend = extractMinAndMax(arrayBuffer, 0, vertexCount);
      _TransformFeedbackBoundingHelper._Min.copyFrom(bb.minimum).minimizeInPlace(extend.minimum);
      _TransformFeedbackBoundingHelper._Max.copyFrom(bb.maximum).maximizeInPlace(extend.maximum);
      mesh._refreshBoundingInfoDirect({ minimum: _TransformFeedbackBoundingHelper._Min, maximum: _TransformFeedbackBoundingHelper._Max });
    }
  }
  /** @internal */
  registerMeshListAsync(meshes) {
    if (!Array.isArray(meshes)) {
      meshes = [meshes];
    }
    this._meshList = meshes;
    this._meshListCounter = 0;
    return Promise.resolve();
  }
  /** @internal */
  processMeshList() {
    if (this._meshList.length === 0) {
      return;
    }
    this._processMeshList(this._meshList);
    this._meshListCounter++;
  }
  /** @internal */
  fetchResultsForMeshListAsync() {
    this._meshListCounter = 0;
    return Promise.resolve();
  }
  /** @internal */
  dispose() {
    for (const key in this._buffers) {
      this._buffers[key].dispose();
    }
    this._buffers = {};
    this._effects = {};
    this._engine = null;
  }
};
TransformFeedbackBoundingHelper._Min = new Vector3();
TransformFeedbackBoundingHelper._Max = new Vector3();

export {
  TransformFeedbackBoundingHelper
};
//# sourceMappingURL=chunk-64ZRB5CC.js.map
