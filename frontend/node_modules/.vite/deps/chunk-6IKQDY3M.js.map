{
  "version": 3,
  "sources": ["../../../dev/core/src/FlowGraph/Blocks/Data/Math/flowGraphVectorMathBlocks.ts"],
  "sourcesContent": ["import type { IFlowGraphBlockConfiguration } from \"core/FlowGraph/flowGraphBlock\";\nimport { RichTypeVector3, FlowGraphTypes, RichTypeNumber, RichTypeAny, RichTypeVector2, RichTypeMatrix, getRichTypeByFlowGraphType } from \"core/FlowGraph/flowGraphRichTypes\";\nimport { RegisterClass } from \"core/Misc/typeStore\";\nimport { FlowGraphBlockNames } from \"../../flowGraphBlockNames\";\nimport { FlowGraphBinaryOperationBlock } from \"../flowGraphBinaryOperationBlock\";\nimport { FlowGraphUnaryOperationBlock } from \"../flowGraphUnaryOperationBlock\";\nimport { Matrix, Vector2, Vector3, Vector4 } from \"core/Maths/math.vector\";\nimport { FlowGraphTernaryOperationBlock } from \"../flowGraphTernaryOperationBlock\";\nimport type { FlowGraphMatrix2D, FlowGraphMatrix3D } from \"core/FlowGraph/CustomTypes\";\nimport type { FlowGraphMatrix, FlowGraphVector } from \"core/FlowGraph/utils\";\nimport { _getClassNameOf } from \"core/FlowGraph/utils\";\n\n/**\n * Vector length block.\n */\nexport class FlowGraphLengthBlock extends FlowGraphUnaryOperationBlock<FlowGraphVector, number> {\n    constructor(config?: IFlowGraphBlockConfiguration) {\n        super(RichTypeAny, RichTypeNumber, (a) => this._polymorphicLength(a), FlowGraphBlockNames.Length, config);\n    }\n\n    private _polymorphicLength(a: FlowGraphVector) {\n        const aClassName = _getClassNameOf(a);\n        switch (aClassName) {\n            case FlowGraphTypes.Vector2:\n            case FlowGraphTypes.Vector3:\n            case FlowGraphTypes.Vector4:\n            case FlowGraphTypes.Quaternion:\n                return (a as Vector3).length();\n            default:\n                throw new Error(`Cannot compute length of value ${a}`);\n        }\n    }\n}\nRegisterClass(FlowGraphBlockNames.Length, FlowGraphLengthBlock);\n\n/**\n * Configuration for normalized vector\n */\nexport interface IFlowGraphNormalizeBlockConfiguration extends IFlowGraphBlockConfiguration {\n    /**\n     * If true, the block will return NaN if the input vector has a length of 0.\n     * This is the expected behavior for glTF interactivity graphs.\n     */\n    nanOnZeroLength?: boolean;\n}\n\n/**\n * Vector normalize block.\n */\nexport class FlowGraphNormalizeBlock extends FlowGraphUnaryOperationBlock<FlowGraphVector, FlowGraphVector> {\n    constructor(config?: IFlowGraphNormalizeBlockConfiguration) {\n        super(RichTypeAny, RichTypeAny, (a) => this._polymorphicNormalize(a), FlowGraphBlockNames.Normalize, config);\n    }\n\n    private _polymorphicNormalize(a: FlowGraphVector) {\n        const aClassName = _getClassNameOf(a);\n        let normalized: FlowGraphVector;\n        switch (aClassName) {\n            case FlowGraphTypes.Vector2:\n            case FlowGraphTypes.Vector3:\n            case FlowGraphTypes.Vector4:\n            case FlowGraphTypes.Quaternion:\n                normalized = a.normalizeToNew();\n                if (this.config?.nanOnZeroLength) {\n                    const length = a.length();\n                    if (length === 0) {\n                        normalized.setAll(NaN);\n                    }\n                }\n                return normalized;\n            default:\n                throw new Error(`Cannot normalize value ${a}`);\n        }\n    }\n}\nRegisterClass(FlowGraphBlockNames.Normalize, FlowGraphNormalizeBlock);\n\n/**\n * Dot product block.\n */\nexport class FlowGraphDotBlock extends FlowGraphBinaryOperationBlock<FlowGraphVector, FlowGraphVector, number> {\n    constructor(config?: IFlowGraphBlockConfiguration) {\n        super(RichTypeAny, RichTypeAny, RichTypeNumber, (a, b) => this._polymorphicDot(a, b), FlowGraphBlockNames.Dot, config);\n    }\n\n    private _polymorphicDot(a: FlowGraphVector, b: FlowGraphVector) {\n        const className = _getClassNameOf(a);\n        switch (className) {\n            case FlowGraphTypes.Vector2:\n            case FlowGraphTypes.Vector3:\n            case FlowGraphTypes.Vector4:\n            case FlowGraphTypes.Quaternion:\n                // casting is needed because dot requires both to be the same type\n                return (a as Vector3).dot(b as Vector3);\n            default:\n                throw new Error(`Cannot get dot product of ${a} and ${b}`);\n        }\n    }\n}\nRegisterClass(FlowGraphBlockNames.Dot, FlowGraphDotBlock);\n\n/**\n * Cross product block.\n */\nexport class FlowGraphCrossBlock extends FlowGraphBinaryOperationBlock<Vector3, Vector3, Vector3> {\n    constructor(config?: IFlowGraphBlockConfiguration) {\n        super(RichTypeVector3, RichTypeVector3, RichTypeVector3, (a, b) => Vector3.Cross(a, b), FlowGraphBlockNames.Cross, config);\n    }\n}\nRegisterClass(FlowGraphBlockNames.Cross, FlowGraphCrossBlock);\n\n/**\n * 2D rotation block.\n */\nexport class FlowGraphRotate2DBlock extends FlowGraphBinaryOperationBlock<Vector2, number, Vector2> {\n    constructor(config?: IFlowGraphBlockConfiguration) {\n        super(RichTypeVector2, RichTypeNumber, RichTypeVector2, (a, b) => Vector2.Transform(a, Matrix.RotationZ(b)), FlowGraphBlockNames.Rotate2D, config);\n    }\n}\nRegisterClass(FlowGraphBlockNames.Rotate2D, FlowGraphRotate2DBlock);\n\n/**\n * 3D rotation block.\n */\nexport class FlowGraphRotate3DBlock extends FlowGraphTernaryOperationBlock<Vector3, Vector3, number, Vector3> {\n    constructor(config?: IFlowGraphBlockConfiguration) {\n        super(\n            RichTypeVector3,\n            RichTypeVector3,\n            RichTypeNumber,\n            RichTypeVector3,\n            (a, b, c) => Vector3.TransformCoordinates(a, Matrix.RotationAxis(b, c)),\n            FlowGraphBlockNames.Rotate3D,\n            config\n        );\n    }\n}\nRegisterClass(FlowGraphBlockNames.Rotate3D, FlowGraphRotate3DBlock);\n\nfunction _transformVector(a: FlowGraphVector, b: FlowGraphMatrix): FlowGraphVector {\n    const className = _getClassNameOf(a);\n    switch (className) {\n        case FlowGraphTypes.Vector2:\n            return (b as FlowGraphMatrix2D).transformVector(a as Vector2);\n        case FlowGraphTypes.Vector3:\n            return (b as FlowGraphMatrix3D).transformVector(a as Vector3);\n        case FlowGraphTypes.Vector4:\n            a = a as Vector4;\n            // transform the vector 4 with the matrix here. Vector4.TransformCoordinates transforms a 3D coordinate, not Vector4\n            return new Vector4(\n                a.x * b.m[0] + a.y * b.m[1] + a.z * b.m[2] + a.w * b.m[3],\n                a.x * b.m[4] + a.y * b.m[5] + a.z * b.m[6] + a.w * b.m[7],\n                a.x * b.m[8] + a.y * b.m[9] + a.z * b.m[10] + a.w * b.m[11],\n                a.x * b.m[12] + a.y * b.m[13] + a.z * b.m[14] + a.w * b.m[15]\n            );\n        default:\n            throw new Error(`Cannot transform value ${a}`);\n    }\n}\n\n/**\n * Configuration for the transform block.\n */\nexport interface IFlowGraphTransformBlockConfiguration extends IFlowGraphBlockConfiguration {\n    /**\n     * The vector type\n     */\n    vectorType: FlowGraphTypes;\n}\n\n/**\n * Transform a vector3 by a matrix.\n */\nexport class FlowGraphTransformBlock extends FlowGraphBinaryOperationBlock<FlowGraphVector, FlowGraphMatrix, FlowGraphVector> {\n    constructor(config?: IFlowGraphTransformBlockConfiguration) {\n        const vectorType = config?.vectorType || FlowGraphTypes.Vector3;\n        const matrixType =\n            vectorType === FlowGraphTypes.Vector2 ? FlowGraphTypes.Matrix2D : vectorType === FlowGraphTypes.Vector3 ? FlowGraphTypes.Matrix3D : FlowGraphTypes.Matrix;\n        super(\n            getRichTypeByFlowGraphType(vectorType),\n            getRichTypeByFlowGraphType(matrixType),\n            getRichTypeByFlowGraphType(vectorType),\n            _transformVector,\n            FlowGraphBlockNames.TransformVector,\n            config\n        );\n    }\n}\n\nRegisterClass(FlowGraphBlockNames.TransformVector, FlowGraphTransformBlock);\n\n/**\n * Transform a vector3 by a matrix.\n */\nexport class FlowGraphTransformCoordinatesBlock extends FlowGraphBinaryOperationBlock<Vector3, Matrix, Vector3> {\n    constructor(config?: IFlowGraphBlockConfiguration) {\n        super(RichTypeVector3, RichTypeMatrix, RichTypeVector3, (a, b) => Vector3.TransformCoordinates(a, b), FlowGraphBlockNames.TransformCoordinates, config);\n    }\n}\n\nRegisterClass(FlowGraphBlockNames.TransformCoordinates, FlowGraphTransformCoordinatesBlock);\n"],
  "mappings": "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",
  "names": []
}
