{
  "version": 3,
  "sources": ["../../../dev/core/src/ShadersWGSL/ShadersInclude/prePassDeclaration.ts", "../../../dev/core/src/ShadersWGSL/ShadersInclude/oitDeclaration.ts", "../../../dev/core/src/ShadersWGSL/ShadersInclude/decalFragment.ts", "../../../dev/core/src/ShadersWGSL/ShadersInclude/depthPrePass.ts", "../../../dev/core/src/ShadersWGSL/ShadersInclude/oitFragment.ts"],
  "sourcesContent": ["// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"prePassDeclaration\";\nconst shader = `#ifdef PREPASS\n#ifdef PREPASS_LOCAL_POSITION\nvarying vPosition : vec3f;\n#endif\n#ifdef PREPASS_DEPTH\nvarying vViewPos: vec3f;\n#endif\n#if defined(PREPASS_VELOCITY) || defined(PREPASS_VELOCITY_LINEAR)\nvarying vCurrentPosition: vec4f;varying vPreviousPosition: vec4f;\n#endif\n#endif\n`;\n// Sideeffect\nif (!ShaderStore.IncludesShadersStoreWGSL[name]) {\n    ShaderStore.IncludesShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const prePassDeclarationWGSL = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"oitDeclaration\";\nconst shader = `#ifdef ORDER_INDEPENDENT_TRANSPARENCY\n#define MAX_DEPTH 99999.0\nvar oitDepthSamplerSampler: sampler;var oitDepthSampler: texture_2d<f32>;var oitFrontColorSamplerSampler: sampler;var oitFrontColorSampler: texture_2d<f32>;\n#endif\n`;\n// Sideeffect\nif (!ShaderStore.IncludesShadersStoreWGSL[name]) {\n    ShaderStore.IncludesShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const oitDeclarationWGSL = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"decalFragment\";\nconst shader = `#ifdef DECAL\nvar decalTempColor=decalColor.rgb;var decalTempAlpha=decalColor.a;\n#ifdef GAMMADECAL\ndecalTempColor=toLinearSpaceVec3(decalColor.rgb);\n#endif\n#ifdef DECAL_SMOOTHALPHA\ndecalTempAlpha=decalColor.a*decalColor.a;\n#endif\nsurfaceAlbedo=mix(surfaceAlbedo.rgb,decalTempColor,decalTempAlpha);\n#endif\n`;\n// Sideeffect\nif (!ShaderStore.IncludesShadersStoreWGSL[name]) {\n    ShaderStore.IncludesShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const decalFragmentWGSL = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"depthPrePass\";\nconst shader = `#ifdef DEPTHPREPASS\nfragmentOutputs.color= vec4f(0.,0.,0.,1.0);return fragmentOutputs;\n#endif\n`;\n// Sideeffect\nif (!ShaderStore.IncludesShadersStoreWGSL[name]) {\n    ShaderStore.IncludesShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const depthPrePassWGSL = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"oitFragment\";\nconst shader = `#ifdef ORDER_INDEPENDENT_TRANSPARENCY\nvar fragDepth: f32=fragmentInputs.position.z; \n#ifdef ORDER_INDEPENDENT_TRANSPARENCY_16BITS\nvar halfFloat: u32=pack2x16float( vec2f(fragDepth));var full: vec2f=unpack2x16float(halfFloat);fragDepth=full.x;\n#endif\nvar fragCoord: vec2i=vec2i(fragmentInputs.position.xy);var lastDepth: vec2f=textureLoad(oitDepthSampler,fragCoord,0).rg;var lastFrontColor: vec4f=textureLoad(oitFrontColorSampler,fragCoord,0);fragmentOutputs.depth=vec2f(-MAX_DEPTH);fragmentOutputs.frontColor=lastFrontColor;fragmentOutputs.backColor= vec4f(0.0);\n#ifdef USE_REVERSE_DEPTHBUFFER\nvar furthestDepth: f32=-lastDepth.x;var nearestDepth: f32=lastDepth.y;\n#else\nvar nearestDepth: f32=-lastDepth.x;var furthestDepth: f32=lastDepth.y;\n#endif\nvar alphaMultiplier: f32=1.0-lastFrontColor.a;\n#ifdef USE_REVERSE_DEPTHBUFFER\nif (fragDepth>nearestDepth || fragDepth<furthestDepth) {\n#else\nif (fragDepth<nearestDepth || fragDepth>furthestDepth) {\n#endif\nreturn fragmentOutputs;}\n#ifdef USE_REVERSE_DEPTHBUFFER\nif (fragDepth<nearestDepth && fragDepth>furthestDepth) {\n#else\nif (fragDepth>nearestDepth && fragDepth<furthestDepth) {\n#endif\nfragmentOutputs.depth=vec2f(-fragDepth,fragDepth);return fragmentOutputs;}\n#endif\n`;\n// Sideeffect\nif (!ShaderStore.IncludesShadersStoreWGSL[name]) {\n    ShaderStore.IncludesShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const oitFragmentWGSL = { name, shader };\n"],
  "mappings": ";;;;;AAGA,IAAM,OAAO;AACb,IAAM,SAAS;;;;;;;;;;;;AAaf,IAAI,CAAC,YAAY,yBAAyB,IAAI,GAAG;AAC7C,cAAY,yBAAyB,IAAI,IAAI;AACjD;;;AChBA,IAAMA,QAAO;AACb,IAAMC,UAAS;;;;;AAMf,IAAI,CAAC,YAAY,yBAAyBD,KAAI,GAAG;AAC7C,cAAY,yBAAyBA,KAAI,IAAIC;AACjD;;;ACTA,IAAMC,QAAO;AACb,IAAMC,UAAS;;;;;;;;;;;AAYf,IAAI,CAAC,YAAY,yBAAyBD,KAAI,GAAG;AAC7C,cAAY,yBAAyBA,KAAI,IAAIC;AACjD;;;ACfA,IAAMC,QAAO;AACb,IAAMC,UAAS;;;;AAKf,IAAI,CAAC,YAAY,yBAAyBD,KAAI,GAAG;AAC7C,cAAY,yBAAyBA,KAAI,IAAIC;AACjD;;;ACRA,IAAMC,QAAO;AACb,IAAMC,UAAS;;;;;;;;;;;;;;;;;;;;;;;;;;AA2Bf,IAAI,CAAC,YAAY,yBAAyBD,KAAI,GAAG;AAC7C,cAAY,yBAAyBA,KAAI,IAAIC;AACjD;",
  "names": ["name", "shader", "name", "shader", "name", "shader", "name", "shader"]
}
