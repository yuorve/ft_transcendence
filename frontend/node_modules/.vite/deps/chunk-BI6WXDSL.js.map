{
  "version": 3,
  "sources": ["../../../dev/core/src/FlowGraph/flowGraphAsyncExecutionBlock.ts"],
  "sourcesContent": ["import type { IFlowGraphBlockConfiguration } from \"./flowGraphBlock\";\r\nimport type { FlowGraphContext } from \"./flowGraphContext\";\r\nimport { FlowGraphExecutionBlockWithOutSignal } from \"./flowGraphExecutionBlockWithOutSignal\";\r\nimport type { FlowGraphSignalConnection } from \"./flowGraphSignalConnection\";\r\n\r\n/**\r\n * An async execution block can start tasks that will be executed asynchronously.\r\n * It should also be responsible for clearing it in _cancelPendingTasks.\r\n */\r\nexport abstract class FlowGraphAsyncExecutionBlock extends FlowGraphExecutionBlockWithOutSignal {\r\n    /**\r\n     * Output connection: The signal that is triggered when the asynchronous execution of this block is done.\r\n     */\r\n    public done: FlowGraphSignalConnection;\r\n\r\n    protected _eventsSignalOutputs: { [eventName: string]: FlowGraphSignalConnection } = {};\r\n\r\n    constructor(config?: IFlowGraphBlockConfiguration, events?: string[]) {\r\n        super(config);\r\n        this.done = this._registerSignalOutput(\"done\");\r\n        events?.forEach((eventName) => {\r\n            this._eventsSignalOutputs[eventName] = this._registerSignalOutput(eventName + \"Event\");\r\n        });\r\n    }\r\n    /**\r\n     * @internal\r\n     * This function can be overridden to start any\r\n     * pending tasks this node might have, such as\r\n     * timeouts and playing animations.\r\n     * @param context\r\n     */\r\n    public abstract _preparePendingTasks(context: FlowGraphContext): void;\r\n\r\n    /**\r\n     * @internal\r\n     * This function can be overridden to execute any\r\n     * logic that should be executed on every frame\r\n     * while the async task is pending.\r\n     * @param context the context in which it is running\r\n     */\r\n    public _executeOnTick(_context: FlowGraphContext): void {}\r\n\r\n    /**\r\n     * @internal\r\n     * @param context\r\n     */\r\n    public _startPendingTasks(context: FlowGraphContext) {\r\n        if (context._getExecutionVariable(this, \"_initialized\", false)) {\r\n            this._cancelPendingTasks(context);\r\n            this._resetAfterCanceled(context);\r\n        }\r\n\r\n        this._preparePendingTasks(context);\r\n        context._addPendingBlock(this);\r\n        this.out._activateSignal(context);\r\n        context._setExecutionVariable(this, \"_initialized\", true);\r\n    }\r\n\r\n    public _resetAfterCanceled(context: FlowGraphContext) {\r\n        context._deleteExecutionVariable(this, \"_initialized\");\r\n        context._removePendingBlock(this);\r\n    }\r\n\r\n    public abstract _cancelPendingTasks(context: FlowGraphContext): void;\r\n}\r\n"],
  "mappings": ";;;;;AASM,IAAgB,+BAAhB,cAAqD,qCAAoC;EAQ3F,YAAY,QAAuC,QAAiB;AAChE,UAAM,MAAM;AAHN,SAAA,uBAA2E,CAAA;AAIjF,SAAK,OAAO,KAAK,sBAAsB,MAAM;AAC7C,qCAAQ,QAAQ,CAAC,cAAa;AAC1B,WAAK,qBAAqB,SAAS,IAAI,KAAK,sBAAsB,YAAY,OAAO;IACzF;EACJ;;;;;;;;EAiBO,eAAe,UAA0B;EAAS;;;;;EAMlD,mBAAmB,SAAyB;AAC/C,QAAI,QAAQ,sBAAsB,MAAM,gBAAgB,KAAK,GAAG;AAC5D,WAAK,oBAAoB,OAAO;AAChC,WAAK,oBAAoB,OAAO;IACpC;AAEA,SAAK,qBAAqB,OAAO;AACjC,YAAQ,iBAAiB,IAAI;AAC7B,SAAK,IAAI,gBAAgB,OAAO;AAChC,YAAQ,sBAAsB,MAAM,gBAAgB,IAAI;EAC5D;EAEO,oBAAoB,SAAyB;AAChD,YAAQ,yBAAyB,MAAM,cAAc;AACrD,YAAQ,oBAAoB,IAAI;EACpC;;",
  "names": []
}
