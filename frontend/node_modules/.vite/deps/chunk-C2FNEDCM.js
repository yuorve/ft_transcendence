import {
  _AbstractAudioSubNode,
  _GetVolumeAudioSubNode,
  _WebAudioBaseSubGraph
} from "./chunk-MYCR5HYZ.js";
import {
  Matrix,
  Quaternion,
  Vector3
} from "./chunk-NSQZ6PEP.js";
import {
  PrecisionDate
} from "./chunk-AZNEH5GV.js";

// node_modules/@babylonjs/core/AudioV2/abstractAudio/subProperties/abstractSpatialAudio.js
var _SpatialAudioDefaults = {
  coneInnerAngle: 6.28318530718,
  coneOuterAngle: 6.28318530718,
  coneOuterVolume: 0,
  distanceModel: "linear",
  maxDistance: 1e4,
  minDistance: 1,
  panningModel: "equalpower",
  position: Vector3.Zero(),
  rolloffFactor: 1,
  rotation: Vector3.Zero(),
  rotationQuaternion: new Quaternion()
};
function _HasSpatialAudioOptions(options) {
  return options.spatialEnabled || options.spatialAutoUpdate !== void 0 || options.spatialConeInnerAngle !== void 0 || options.spatialConeOuterAngle !== void 0 || options.spatialConeOuterVolume !== void 0 || options.spatialDistanceModel !== void 0 || options.spatialMaxDistance !== void 0 || options.spatialMinDistance !== void 0 || options.spatialMinUpdateTime !== void 0 || options.spatialPanningModel !== void 0 || options.spatialPosition !== void 0 || options.spatialRolloffFactor !== void 0 || options.spatialRotation !== void 0 || options.spatialRotationQuaternion !== void 0;
}
var AbstractSpatialAudio = class {
};

// node_modules/@babylonjs/core/AudioV2/abstractAudio/subProperties/abstractStereoAudio.js
var _StereoAudioDefaults = {
  pan: 0
};
function _HasStereoAudioOptions(options) {
  return options.stereoEnabled || options.stereoPan !== void 0;
}
var AbstractStereoAudio = class {
};

// node_modules/@babylonjs/core/AudioV2/abstractAudio/subNodes/stereoAudioSubNode.js
var _StereoAudioSubNode = class extends _AbstractAudioSubNode {
  constructor(engine) {
    super("Stereo", engine);
  }
  /** @internal */
  setOptions(options) {
    this.pan = options.stereoPan ?? _StereoAudioDefaults.pan;
  }
};
function _GetStereoAudioSubNode(subGraph) {
  return subGraph.getSubNode(
    "Stereo"
    /* AudioSubNode.STEREO */
  );
}
function _GetStereoAudioProperty(subGraph, property) {
  var _a;
  return ((_a = _GetStereoAudioSubNode(subGraph)) == null ? void 0 : _a[property]) ?? _StereoAudioDefaults[property];
}
function _SetStereoAudioProperty(subGraph, property, value) {
  subGraph.callOnSubNode("Stereo", (node) => {
    node[property] = value;
  });
}

// node_modules/@babylonjs/core/AudioV2/abstractAudio/subProperties/stereoAudio.js
var _StereoAudio = class extends AbstractStereoAudio {
  /** @internal */
  constructor(subGraph) {
    super();
    this._subGraph = subGraph;
  }
  /** @internal */
  get pan() {
    return _GetStereoAudioProperty(this._subGraph, "pan");
  }
  set pan(value) {
    _SetStereoAudioProperty(this._subGraph, "pan", value);
  }
};

// node_modules/@babylonjs/core/AudioV2/abstractAudio/components/spatialAudioAttacherComponent.js
var _SpatialAudioAttacherComponent = class {
  /** @internal */
  constructor(spatialAudioNode) {
    this._attachmentType = 3;
    this._position = new Vector3();
    this._rotationQuaternion = new Quaternion();
    this._sceneNode = null;
    this._useBoundingBox = false;
    this.dispose = () => {
      this.detach();
    };
    this._spatialAudioNode = spatialAudioNode;
  }
  /**
   * Returns `true` if attached to a scene node; otherwise returns `false`.
   */
  get isAttached() {
    return this._sceneNode !== null;
  }
  /**
   * Attaches to a scene node.
   *
   * Detaches automatically before attaching to the given scene node.
   * If `sceneNode` is `null` it is the same as calling `detach()`.
   *
   * @param sceneNode The scene node to attach to, or `null` to detach.
   * @param useBoundingBox Whether to use the scene node's bounding box for positioning. Defaults to `false`.
   * @param attachmentType Whether to attach to the scene node's position and/or rotation. Defaults to `PositionAndRotation`.
   */
  attach(sceneNode, useBoundingBox, attachmentType) {
    if (this._sceneNode === sceneNode) {
      return;
    }
    this.detach();
    if (!sceneNode) {
      return;
    }
    this._attachmentType = attachmentType;
    this._sceneNode = sceneNode;
    this._sceneNode.onDisposeObservable.add(this.dispose);
    this._useBoundingBox = useBoundingBox;
  }
  /**
   * Detaches from the scene node if attached.
   */
  detach() {
    var _a;
    (_a = this._sceneNode) == null ? void 0 : _a.onDisposeObservable.removeCallback(this.dispose);
    this._sceneNode = null;
  }
  /**
   * Updates the position and rotation of the associated audio engine object in the audio rendering graph.
   *
   * This is called automatically by default and only needs to be called manually if automatic updates are disabled.
   */
  update() {
    var _a, _b;
    if (this._attachmentType & 1) {
      if (this._useBoundingBox && this._sceneNode.getBoundingInfo) {
        this._position.copyFrom(this._sceneNode.getBoundingInfo().boundingBox.centerWorld);
      } else {
        (_a = this._sceneNode) == null ? void 0 : _a.getWorldMatrix().getTranslationToRef(this._position);
      }
      this._spatialAudioNode.position.copyFrom(this._position);
      this._spatialAudioNode._updatePosition();
    }
    if (this._attachmentType & 2) {
      (_b = this._sceneNode) == null ? void 0 : _b.getWorldMatrix().decompose(void 0, this._rotationQuaternion);
      this._spatialAudioNode.rotationQuaternion.copyFrom(this._rotationQuaternion);
      this._spatialAudioNode._updateRotation();
    }
  }
};

// node_modules/@babylonjs/core/AudioV2/abstractAudio/subNodes/spatialAudioSubNode.js
var _SpatialAudioSubNode = class extends _AbstractAudioSubNode {
  constructor(engine) {
    super("Spatial", engine);
    this._attacherComponent = null;
  }
  /** @internal */
  get isAttached() {
    return this._attacherComponent !== null && this._attacherComponent.isAttached;
  }
  /** @internal */
  attach(sceneNode, useBoundingBox, attachmentType) {
    this.detach();
    if (!this._attacherComponent) {
      this._attacherComponent = new _SpatialAudioAttacherComponent(this);
    }
    this._attacherComponent.attach(sceneNode, useBoundingBox, attachmentType);
  }
  /** @internal */
  detach() {
    var _a;
    (_a = this._attacherComponent) == null ? void 0 : _a.detach();
  }
  /** @internal */
  dispose() {
    var _a;
    super.dispose();
    (_a = this._attacherComponent) == null ? void 0 : _a.dispose();
    this._attacherComponent = null;
  }
  /** @internal */
  setOptions(options) {
    this.coneInnerAngle = options.spatialConeInnerAngle ?? _SpatialAudioDefaults.coneInnerAngle;
    this.coneOuterAngle = options.spatialConeOuterAngle ?? _SpatialAudioDefaults.coneOuterAngle;
    this.coneOuterVolume = options.spatialConeOuterVolume ?? _SpatialAudioDefaults.coneOuterVolume;
    this.distanceModel = options.spatialDistanceModel ?? _SpatialAudioDefaults.distanceModel;
    this.maxDistance = options.spatialMaxDistance ?? _SpatialAudioDefaults.maxDistance;
    this.minDistance = options.spatialMinDistance ?? _SpatialAudioDefaults.minDistance;
    this.panningModel = options.spatialPanningModel ?? _SpatialAudioDefaults.panningModel;
    this.rolloffFactor = options.spatialRolloffFactor ?? _SpatialAudioDefaults.rolloffFactor;
    if (options.spatialPosition) {
      this.position = options.spatialPosition.clone();
    }
    if (options.spatialRotationQuaternion) {
      this.rotationQuaternion = options.spatialRotationQuaternion.clone();
    } else if (options.spatialRotation) {
      this.rotation = options.spatialRotation.clone();
    } else {
      this.rotationQuaternion = _SpatialAudioDefaults.rotationQuaternion.clone();
    }
    this.update();
  }
  /** @internal */
  update() {
    var _a;
    if (this.isAttached) {
      (_a = this._attacherComponent) == null ? void 0 : _a.update();
    } else {
      this._updatePosition();
      this._updateRotation();
    }
  }
};
function _GetSpatialAudioSubNode(subGraph) {
  return subGraph.getSubNode(
    "Spatial"
    /* AudioSubNode.SPATIAL */
  );
}
function _GetSpatialAudioProperty(subGraph, property) {
  var _a;
  return ((_a = _GetSpatialAudioSubNode(subGraph)) == null ? void 0 : _a[property]) ?? _SpatialAudioDefaults[property];
}
function _SetSpatialAudioProperty(subGraph, property, value) {
  subGraph.callOnSubNode("Spatial", (node) => {
    node[property] = value;
  });
}

// node_modules/@babylonjs/core/AudioV2/webAudio/subNodes/spatialWebAudioSubNode.js
var TmpMatrix = Matrix.Zero();
var TmpQuaternion = new Quaternion();
var TmpVector = Vector3.Zero();
function d2r(degrees) {
  return degrees * Math.PI / 180;
}
function r2d(radians) {
  return radians * 180 / Math.PI;
}
async function _CreateSpatialAudioSubNodeAsync(engine) {
  return new _SpatialWebAudioSubNode(engine);
}
var _SpatialWebAudioSubNode = class extends _SpatialAudioSubNode {
  /** @internal */
  constructor(engine) {
    super(engine);
    this._lastPosition = Vector3.Zero();
    this._lastRotation = Vector3.Zero();
    this._lastRotationQuaternion = new Quaternion();
    this.position = _SpatialAudioDefaults.position.clone();
    this.rotation = _SpatialAudioDefaults.rotation.clone();
    this.rotationQuaternion = _SpatialAudioDefaults.rotationQuaternion.clone();
    this.node = new PannerNode(engine._audioContext);
  }
  /** @internal */
  get coneInnerAngle() {
    return d2r(this.node.coneInnerAngle);
  }
  set coneInnerAngle(value) {
    this.node.coneInnerAngle = r2d(value);
  }
  /** @internal */
  get coneOuterAngle() {
    return d2r(this.node.coneOuterAngle);
  }
  set coneOuterAngle(value) {
    this.node.coneOuterAngle = r2d(value);
  }
  /** @internal */
  get coneOuterVolume() {
    return this.node.coneOuterGain;
  }
  set coneOuterVolume(value) {
    this.node.coneOuterGain = value;
  }
  /** @internal */
  get distanceModel() {
    return this.node.distanceModel;
  }
  set distanceModel(value) {
    this.node.distanceModel = value;
    const maxDistance = this.node.maxDistance;
    this.node.maxDistance = maxDistance + 1e-3;
    this.node.maxDistance = maxDistance;
  }
  /** @internal */
  get minDistance() {
    return this.node.refDistance;
  }
  set minDistance(value) {
    this.node.refDistance = value;
  }
  /** @internal */
  get maxDistance() {
    return this.node.maxDistance;
  }
  set maxDistance(value) {
    this.node.maxDistance = value;
  }
  /** @internal */
  get panningModel() {
    return this.node.panningModel;
  }
  set panningModel(value) {
    this.node.panningModel = value;
  }
  /** @internal */
  get rolloffFactor() {
    return this.node.rolloffFactor;
  }
  set rolloffFactor(value) {
    this.node.rolloffFactor = value;
  }
  /** @internal */
  get _inNode() {
    return this.node;
  }
  /** @internal */
  get _outNode() {
    return this.node;
  }
  /** @internal */
  _updatePosition() {
    if (this._lastPosition.equalsWithEpsilon(this.position)) {
      return;
    }
    this.engine._setAudioParam(this.node.positionX, this.position.x);
    this.engine._setAudioParam(this.node.positionY, this.position.y);
    this.engine._setAudioParam(this.node.positionZ, this.position.z);
    this._lastPosition.copyFrom(this.position);
  }
  /** @internal */
  _updateRotation() {
    if (!this._lastRotationQuaternion.equalsWithEpsilon(this.rotationQuaternion)) {
      TmpQuaternion.copyFrom(this.rotationQuaternion);
      this._lastRotationQuaternion.copyFrom(this.rotationQuaternion);
    } else if (!this._lastRotation.equalsWithEpsilon(this.rotation)) {
      Quaternion.FromEulerAnglesToRef(this.rotation.x, this.rotation.y, this.rotation.z, TmpQuaternion);
      this._lastRotation.copyFrom(this.rotation);
    } else {
      return;
    }
    Matrix.FromQuaternionToRef(TmpQuaternion, TmpMatrix);
    Vector3.TransformNormalToRef(Vector3.RightReadOnly, TmpMatrix, TmpVector);
    this.engine._setAudioParam(this.node.orientationX, TmpVector.x);
    this.engine._setAudioParam(this.node.orientationY, TmpVector.y);
    this.engine._setAudioParam(this.node.orientationZ, TmpVector.z);
  }
  _connect(node) {
    const connected = super._connect(node);
    if (!connected) {
      return false;
    }
    if (node._inNode) {
      this.node.connect(node._inNode);
    }
    return true;
  }
  _disconnect(node) {
    const disconnected = super._disconnect(node);
    if (!disconnected) {
      return false;
    }
    if (node._inNode) {
      this.node.disconnect(node._inNode);
    }
    return true;
  }
  /** @internal */
  getClassName() {
    return "_SpatialWebAudioSubNode";
  }
};

// node_modules/@babylonjs/core/AudioV2/webAudio/subNodes/stereoWebAudioSubNode.js
async function _CreateStereoAudioSubNodeAsync(engine) {
  return new _StereoWebAudioSubNode(engine);
}
var _StereoWebAudioSubNode = class extends _StereoAudioSubNode {
  /** @internal */
  constructor(engine) {
    super(engine);
    this._pan = 0;
    this.node = new StereoPannerNode(engine._audioContext);
  }
  /** @internal */
  get pan() {
    return this._pan;
  }
  /** @internal */
  set pan(value) {
    this._pan = value;
    this.engine._setAudioParam(this.node.pan, value);
  }
  /** @internal */
  get _inNode() {
    return this.node;
  }
  /** @internal */
  get _outNode() {
    return this.node;
  }
  /** @internal */
  getClassName() {
    return "_StereoWebAudioSubNode";
  }
  _connect(node) {
    const connected = super._connect(node);
    if (!connected) {
      return false;
    }
    if (node._inNode) {
      this.node.connect(node._inNode);
    }
    return true;
  }
  _disconnect(node) {
    const disconnected = super._disconnect(node);
    if (!disconnected) {
      return false;
    }
    if (node._inNode) {
      this.node.disconnect(node._inNode);
    }
    return true;
  }
};

// node_modules/@babylonjs/core/AudioV2/webAudio/subNodes/webAudioBusAndSoundSubGraph.js
var _WebAudioBusAndSoundSubGraph = class extends _WebAudioBaseSubGraph {
  constructor() {
    super(...arguments);
    this._rootNode = null;
    this._inputNode = null;
  }
  /** @internal */
  async init(options) {
    var _a, _b;
    await super.init(options);
    let hasSpatialOptions = false;
    let hasStereoOptions = false;
    if (hasSpatialOptions = _HasSpatialAudioOptions(options)) {
      await this.createAndAddSubNode(
        "Spatial"
        /* AudioSubNode.SPATIAL */
      );
    }
    if (hasStereoOptions = _HasStereoAudioOptions(options)) {
      await this.createAndAddSubNode(
        "Stereo"
        /* AudioSubNode.STEREO */
      );
    }
    await this._createSubNodePromisesResolved();
    if (hasSpatialOptions) {
      (_a = _GetSpatialAudioSubNode(this)) == null ? void 0 : _a.setOptions(options);
    }
    if (hasStereoOptions) {
      (_b = _GetStereoAudioSubNode(this)) == null ? void 0 : _b.setOptions(options);
    }
  }
  /** @internal */
  get _inNode() {
    return this._inputNode;
  }
  _createSubNode(name) {
    try {
      const node = super._createSubNode(name);
      return node;
    } catch (e) {
    }
    switch (name) {
      case "Spatial":
        return _CreateSpatialAudioSubNodeAsync(this._owner.engine);
      case "Stereo":
        return _CreateStereoAudioSubNodeAsync(this._owner.engine);
      default:
        throw new Error(`Unknown subnode name: ${name}`);
    }
  }
  _onSubNodesChanged() {
    var _a, _b, _c;
    super._onSubNodesChanged();
    const spatialNode = _GetSpatialAudioSubNode(this);
    const stereoNode = _GetStereoAudioSubNode(this);
    const volumeNode = _GetVolumeAudioSubNode(this);
    if (spatialNode && spatialNode.getClassName() !== "_SpatialWebAudioSubNode") {
      throw new Error("Not a WebAudio subnode.");
    }
    if (stereoNode && stereoNode.getClassName() !== "_StereoWebAudioSubNode") {
      throw new Error("Not a WebAudio subnode.");
    }
    if (volumeNode && volumeNode.getClassName() !== "_VolumeWebAudioSubNode") {
      throw new Error("Not a WebAudio subnode.");
    }
    if (spatialNode) {
      spatialNode.disconnectAll();
      if (volumeNode) {
        spatialNode.connect(volumeNode);
      }
    }
    if (stereoNode) {
      stereoNode.disconnectAll();
      if (volumeNode) {
        stereoNode.connect(volumeNode);
      }
    }
    if (spatialNode && stereoNode) {
      this._rootNode = new GainNode(this._owner.engine._audioContext);
      this._rootNode.connect(spatialNode._outNode);
      this._rootNode.connect(stereoNode._outNode);
    } else {
      (_a = this._rootNode) == null ? void 0 : _a.disconnect();
      this._rootNode = null;
    }
    let inSubNode = null;
    let inNode = null;
    if (this._rootNode) {
      inNode = this._rootNode;
    } else {
      if (spatialNode) {
        inSubNode = spatialNode;
      } else if (stereoNode) {
        inSubNode = stereoNode;
      } else if (volumeNode) {
        inSubNode = volumeNode;
      }
      inNode = (inSubNode == null ? void 0 : inSubNode.node) ?? null;
    }
    if (this._inputNode !== inNode) {
      if (this._inputNode && this._upstreamNodes) {
        const it = this._upstreamNodes.values();
        for (let next = it.next(); !next.done; next = it.next()) {
          (_b = next.value._outNode) == null ? void 0 : _b.disconnect(this._inputNode);
        }
      }
      this._inputNode = inNode;
      if (inNode && this._upstreamNodes) {
        const it = this._upstreamNodes.values();
        for (let next = it.next(); !next.done; next = it.next()) {
          (_c = next.value._outNode) == null ? void 0 : _c.connect(inNode);
        }
      }
    }
  }
};

// node_modules/@babylonjs/core/AudioV2/abstractAudio/subProperties/spatialAudio.js
var _SpatialAudio = class extends AbstractSpatialAudio {
  /** @internal */
  constructor(subGraph) {
    super();
    const subNode = _GetSpatialAudioSubNode(subGraph);
    if (subNode) {
      this._position = subNode.position.clone();
      this._rotation = subNode.rotation.clone();
      this._rotationQuaternion = subNode.rotationQuaternion.clone();
    } else {
      this._position = _SpatialAudioDefaults.position.clone();
      this._rotation = _SpatialAudioDefaults.rotation.clone();
      this._rotationQuaternion = _SpatialAudioDefaults.rotationQuaternion.clone();
      subGraph.createAndAddSubNode(
        "Spatial"
        /* AudioSubNode.SPATIAL */
      );
    }
    this._subGraph = subGraph;
  }
  /** @internal */
  get coneInnerAngle() {
    return _GetSpatialAudioProperty(this._subGraph, "coneInnerAngle") ?? _SpatialAudioDefaults.coneInnerAngle;
  }
  set coneInnerAngle(value) {
    _SetSpatialAudioProperty(this._subGraph, "coneInnerAngle", value);
  }
  /** @internal */
  get coneOuterAngle() {
    return _GetSpatialAudioProperty(this._subGraph, "coneOuterAngle");
  }
  set coneOuterAngle(value) {
    _SetSpatialAudioProperty(this._subGraph, "coneOuterAngle", value);
  }
  /** @internal */
  get coneOuterVolume() {
    return _GetSpatialAudioProperty(this._subGraph, "coneOuterVolume");
  }
  set coneOuterVolume(value) {
    _SetSpatialAudioProperty(this._subGraph, "coneOuterVolume", value);
  }
  /** @internal */
  get distanceModel() {
    return _GetSpatialAudioProperty(this._subGraph, "distanceModel");
  }
  set distanceModel(value) {
    _SetSpatialAudioProperty(this._subGraph, "distanceModel", value);
  }
  /** @internal */
  get isAttached() {
    var _a;
    return ((_a = this._subGraph.getSubNode(
      "Spatial"
      /* AudioSubNode.SPATIAL */
    )) == null ? void 0 : _a.isAttached) ?? false;
  }
  /** @internal */
  get maxDistance() {
    return _GetSpatialAudioProperty(this._subGraph, "maxDistance") ?? _SpatialAudioDefaults.maxDistance;
  }
  set maxDistance(value) {
    if (value <= 0) {
      value = 1e-6;
    }
    _SetSpatialAudioProperty(this._subGraph, "maxDistance", value);
  }
  /** @internal */
  get minDistance() {
    return _GetSpatialAudioProperty(this._subGraph, "minDistance");
  }
  set minDistance(value) {
    _SetSpatialAudioProperty(this._subGraph, "minDistance", value);
  }
  /** @internal */
  get panningModel() {
    return _GetSpatialAudioProperty(this._subGraph, "panningModel");
  }
  set panningModel(value) {
    _SetSpatialAudioProperty(this._subGraph, "panningModel", value);
  }
  /** @internal */
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
    this._updatePosition();
  }
  /** @internal */
  get rolloffFactor() {
    return _GetSpatialAudioProperty(this._subGraph, "rolloffFactor");
  }
  set rolloffFactor(value) {
    _SetSpatialAudioProperty(this._subGraph, "rolloffFactor", value);
  }
  /** @internal */
  get rotation() {
    return this._rotation;
  }
  set rotation(value) {
    this._rotation = value;
    this._updateRotation();
  }
  /** @internal */
  get rotationQuaternion() {
    return this._rotationQuaternion;
  }
  set rotationQuaternion(value) {
    this._rotationQuaternion = value;
    this._updateRotation();
  }
  /**
   * Attaches to a scene node.
   *
   * Detaches automatically before attaching to the given scene node.
   * If `sceneNode` is `null` it is the same as calling `detach()`.
   *
   * @param sceneNode The scene node to attach to, or `null` to detach.
   * @param useBoundingBox Whether to use the bounding box of the node for positioning. Defaults to `false`.
   * @param attachmentType Whether to attach to the node's position and/or rotation. Defaults to `PositionAndRotation`.
   */
  attach(sceneNode, useBoundingBox = false, attachmentType = 3) {
    var _a;
    (_a = _GetSpatialAudioSubNode(this._subGraph)) == null ? void 0 : _a.attach(sceneNode, useBoundingBox, attachmentType);
  }
  /**
   * Detaches from the scene node if attached.
   */
  detach() {
    var _a;
    (_a = _GetSpatialAudioSubNode(this._subGraph)) == null ? void 0 : _a.detach();
  }
  /** @internal */
  update() {
    const subNode = _GetSpatialAudioSubNode(this._subGraph);
    if (!subNode) {
      return;
    }
    if (subNode.isAttached) {
      subNode.update();
    } else {
      this._updatePosition(subNode);
      this._updateRotation(subNode);
    }
  }
  _updatePosition(subNode = null) {
    if (!subNode) {
      subNode = _GetSpatialAudioSubNode(this._subGraph);
      if (!subNode) {
        return;
      }
    }
    const position = subNode.position;
    if (!position.equalsWithEpsilon(this._position)) {
      subNode.position.copyFrom(this._position);
      subNode._updatePosition();
    }
  }
  _updateRotation(subNode = null) {
    if (!subNode) {
      subNode = _GetSpatialAudioSubNode(this._subGraph);
      if (!subNode) {
        return;
      }
    }
    if (!subNode.rotationQuaternion.equalsWithEpsilon(this._rotationQuaternion)) {
      subNode.rotationQuaternion.copyFrom(this._rotationQuaternion);
      subNode._updateRotation();
    } else if (!subNode.rotation.equalsWithEpsilon(this._rotation)) {
      subNode.rotation.copyFrom(this._rotation);
      subNode._updateRotation();
    }
  }
};

// node_modules/@babylonjs/core/AudioV2/webAudio/components/spatialWebAudioUpdaterComponent.js
var _SpatialWebAudioUpdaterComponent = class {
  /** @internal */
  constructor(parent, autoUpdate, minUpdateTime) {
    this._autoUpdate = true;
    this._lastUpdateTime = 0;
    this.minUpdateTime = 0;
    if (!autoUpdate) {
      return;
    }
    this.minUpdateTime = minUpdateTime;
    const update = () => {
      if (!this._autoUpdate) {
        return;
      }
      let skipUpdate = false;
      if (0 < this.minUpdateTime) {
        const now = PrecisionDate.Now;
        if (this._lastUpdateTime && now - this._lastUpdateTime < this.minUpdateTime) {
          skipUpdate = true;
        }
        this._lastUpdateTime = now;
      }
      if (!skipUpdate) {
        parent.update();
      }
      requestAnimationFrame(update);
    };
    requestAnimationFrame(update);
  }
  /** @internal */
  dispose() {
    this._autoUpdate = false;
  }
};

// node_modules/@babylonjs/core/AudioV2/webAudio/subProperties/spatialWebAudio.js
var _SpatialWebAudio = class extends _SpatialAudio {
  /** @internal */
  constructor(subGraph, autoUpdate, minUpdateTime) {
    super(subGraph);
    this._updaterComponent = new _SpatialWebAudioUpdaterComponent(this, autoUpdate, minUpdateTime);
  }
  /** @internal */
  get minUpdateTime() {
    return this._updaterComponent.minUpdateTime;
  }
  /** @internal */
  set minUpdateTime(value) {
    this._updaterComponent.minUpdateTime = value;
  }
  /** @internal */
  dispose() {
    this._updaterComponent.dispose();
    this._updaterComponent = null;
  }
};

export {
  _SpatialAudioDefaults,
  _HasSpatialAudioOptions,
  AbstractSpatialAudio,
  _StereoAudioDefaults,
  _HasStereoAudioOptions,
  AbstractStereoAudio,
  _StereoAudio,
  _SpatialAudioAttacherComponent,
  _WebAudioBusAndSoundSubGraph,
  _SpatialWebAudioUpdaterComponent,
  _SpatialWebAudio
};
//# sourceMappingURL=chunk-C2FNEDCM.js.map
