{
  "version": 3,
  "sources": ["../../../dev/core/src/FlowGraph/Blocks/Execution/flowGraphSetPropertyBlock.ts"],
  "sourcesContent": ["import type { AssetType, FlowGraphAssetType } from \"core/FlowGraph/flowGraphAssetsContext\";\nimport type { FlowGraphContext } from \"core/FlowGraph/flowGraphContext\";\nimport type { FlowGraphDataConnection } from \"core/FlowGraph/flowGraphDataConnection\";\nimport { FlowGraphExecutionBlockWithOutSignal } from \"core/FlowGraph/flowGraphExecutionBlockWithOutSignal\";\nimport { RichTypeAny } from \"core/FlowGraph/flowGraphRichTypes\";\nimport type { FlowGraphSignalConnection } from \"core/FlowGraph/flowGraphSignalConnection\";\nimport { RegisterClass } from \"core/Misc/typeStore\";\nimport { FlowGraphBlockNames } from \"../flowGraphBlockNames\";\n\nexport interface IFlowGraphSetPropertyBlockConfiguration<O extends FlowGraphAssetType> {\n    /**\n     * The name of the property that will be set\n     */\n    propertyName?: string;\n\n    /**\n     * The target asset from which the property will be retrieved\n     */\n    target?: AssetType<O>;\n}\n\n/**\n * This block will set a property on a given target asset.\n * The property name can include dots (\".\"), which will be interpreted as a path to the property.\n * The target asset is an input and can be changed at any time.\n * The value of the property is an input and can be changed at any time.\n *\n * For example, with an input of a mesh asset, the property name \"position.x\" will set the x component of the position of the mesh.\n *\n * Note that it is recommended to input the object on which you are working on (i.e. a material) than providing a mesh and then getting the material from it.\n */\nexport class FlowGraphSetPropertyBlock<P extends any, O extends FlowGraphAssetType> extends FlowGraphExecutionBlockWithOutSignal {\n    /**\n     * Input connection: The value to set on the property.\n     */\n    public readonly value: FlowGraphDataConnection<P>;\n\n    /**\n     * Input connection: The target asset from which the property will be retrieved\n     */\n    public readonly object: FlowGraphDataConnection<AssetType<O>>;\n\n    /**\n     * Input connection: The name of the property that will be set\n     */\n    public readonly propertyName: FlowGraphDataConnection<string>;\n\n    /**\n     * Input connection: A function that can be used to set the value of the property.\n     * If set it will be used instead of the default set function.\n     */\n    public readonly customSetFunction: FlowGraphDataConnection<(target: AssetType<O>, propertyName: string, value: P, context: FlowGraphContext) => void>;\n\n    constructor(\n        /**\n         * the configuration of the block\n         */\n        public override config: IFlowGraphSetPropertyBlockConfiguration<O>\n    ) {\n        super(config);\n        this.object = this.registerDataInput(\"object\", RichTypeAny, config.target);\n        this.value = this.registerDataInput(\"value\", RichTypeAny);\n        this.propertyName = this.registerDataInput(\"propertyName\", RichTypeAny, config.propertyName);\n        this.customSetFunction = this.registerDataInput(\"customSetFunction\", RichTypeAny);\n    }\n    public override _execute(context: FlowGraphContext, _callingSignal: FlowGraphSignalConnection): void {\n        try {\n            const target = this.object.getValue(context);\n            const value = this.value.getValue(context);\n\n            const setFunction = this.customSetFunction.getValue(context);\n            if (setFunction) {\n                setFunction(target, this.propertyName.getValue(context), value, context);\n            } else {\n                this._setPropertyValue(target, this.propertyName.getValue(context), value);\n            }\n        } catch (e) {\n            this._reportError(context, e);\n        }\n        this.out._activateSignal(context);\n    }\n\n    private _setPropertyValue(target: AssetType<O>, propertyName: string, value: P): void {\n        const path = propertyName.split(\".\");\n        let obj = target as any;\n        for (let i = 0; i < path.length - 1; i++) {\n            const prop = path[i];\n            if (obj[prop] === undefined) {\n                obj[prop] = {};\n            }\n            obj = obj[prop];\n        }\n        obj[path[path.length - 1]] = value;\n    }\n\n    public override getClassName(): string {\n        return FlowGraphBlockNames.SetProperty;\n    }\n}\n\nRegisterClass(FlowGraphBlockNames.SetProperty, FlowGraphSetPropertyBlock);\n"],
  "mappings": ";;;;;;;;;;;AA+BM,IAAO,4BAAP,cAAsF,qCAAoC;EAsB5H,YAIoB,QAAkD;AAElE,UAAM,MAAM;AAFI,SAAA,SAAA;AAGhB,SAAK,SAAS,KAAK,kBAAkB,UAAU,aAAa,OAAO,MAAM;AACzE,SAAK,QAAQ,KAAK,kBAAkB,SAAS,WAAW;AACxD,SAAK,eAAe,KAAK,kBAAkB,gBAAgB,aAAa,OAAO,YAAY;AAC3F,SAAK,oBAAoB,KAAK,kBAAkB,qBAAqB,WAAW;EACpF;EACgB,SAAS,SAA2B,gBAAyC;AACzF,QAAI;AACA,YAAM,SAAS,KAAK,OAAO,SAAS,OAAO;AAC3C,YAAM,QAAQ,KAAK,MAAM,SAAS,OAAO;AAEzC,YAAM,cAAc,KAAK,kBAAkB,SAAS,OAAO;AAC3D,UAAI,aAAa;AACb,oBAAY,QAAQ,KAAK,aAAa,SAAS,OAAO,GAAG,OAAO,OAAO;MAC3E,OAAO;AACH,aAAK,kBAAkB,QAAQ,KAAK,aAAa,SAAS,OAAO,GAAG,KAAK;MAC7E;IACJ,SAAS,GAAG;AACR,WAAK,aAAa,SAAS,CAAC;IAChC;AACA,SAAK,IAAI,gBAAgB,OAAO;EACpC;EAEQ,kBAAkB,QAAsB,cAAsB,OAAQ;AAC1E,UAAM,OAAO,aAAa,MAAM,GAAG;AACnC,QAAI,MAAM;AACV,aAAS,IAAI,GAAG,IAAI,KAAK,SAAS,GAAG,KAAK;AACtC,YAAM,OAAO,KAAK,CAAC;AACnB,UAAI,IAAI,IAAI,MAAM,QAAW;AACzB,YAAI,IAAI,IAAI,CAAA;MAChB;AACA,YAAM,IAAI,IAAI;IAClB;AACA,QAAI,KAAK,KAAK,SAAS,CAAC,CAAC,IAAI;EACjC;EAEgB,eAAY;AACxB,WAAA;EACJ;;AAGJ,cAAa,6BAAkC,yBAAyB;",
  "names": []
}
