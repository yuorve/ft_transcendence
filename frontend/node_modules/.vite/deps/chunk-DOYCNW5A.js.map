{
  "version": 3,
  "sources": ["../../../dev/core/src/Engines/WebGPU/webgpuPerfCounter.ts", "../../../dev/core/src/Compute/computeShader.ts", "../../../dev/core/src/Buffers/storageBuffer.ts", "../../../dev/core/src/ShadersWGSL/boundingInfo.compute.ts", "../../../dev/core/src/Culling/Helper/computeShaderBoundingHelper.ts"],
  "sourcesContent": ["import { PerfCounter } from \"../../Misc/perfCounter\";\r\n\r\n/**\r\n * Class used to define a WebGPU performance counter\r\n */\r\nexport class WebGPUPerfCounter {\r\n    private _gpuTimeInFrameId = -1;\r\n\r\n    /**\r\n     * The GPU time in nanoseconds spent in the last frame\r\n     */\r\n    public counter = new PerfCounter();\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _addDuration(currentFrameId: number, duration: number) {\r\n        if (currentFrameId < this._gpuTimeInFrameId) {\r\n            return;\r\n        }\r\n        if (this._gpuTimeInFrameId !== currentFrameId) {\r\n            this.counter._fetchResult();\r\n            this.counter.fetchNewFrame();\r\n            this.counter.addCount(duration, false);\r\n            this._gpuTimeInFrameId = currentFrameId;\r\n        } else {\r\n            this.counter.addCount(duration, false);\r\n        }\r\n    }\r\n}\r\n", "import type { UniformBuffer } from \"../Materials/uniformBuffer\";\r\nimport type { WebGPUEngine } from \"../Engines/webgpuEngine\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { Nullable } from \"../types\";\r\nimport { serialize } from \"../Misc/decorators\";\r\nimport { SerializationHelper } from \"../Misc/decorators.serialization\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\nimport type { ComputeEffect, IComputeEffectCreationOptions, IComputeShaderPath } from \"./computeEffect\";\r\nimport type { ComputeBindingMapping } from \"../Engines/Extensions/engine.computeShader\";\r\nimport { ComputeBindingType } from \"../Engines/Extensions/engine.computeShader\";\r\nimport type { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { UniqueIdGenerator } from \"../Misc/uniqueIdGenerator\";\r\nimport type { IComputeContext } from \"./IComputeContext\";\r\nimport type { StorageBuffer } from \"../Buffers/storageBuffer\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { TextureSampler } from \"../Materials/Textures/textureSampler\";\r\nimport type { DataBuffer } from \"core/Buffers/dataBuffer\";\r\nimport type { ExternalTexture } from \"core/Materials/Textures/externalTexture\";\r\nimport type { VideoTexture } from \"core/Materials/Textures/videoTexture\";\r\nimport { WebGPUPerfCounter } from \"core/Engines/WebGPU/webgpuPerfCounter\";\r\nimport type { AbstractEngine } from \"core/Engines/abstractEngine\";\r\nimport { _retryWithInterval } from \"core/Misc/timingTools\";\r\n\r\n/**\r\n * Defines the options associated with the creation of a compute shader.\r\n */\r\nexport interface IComputeShaderOptions {\r\n    /**\r\n     * list of bindings mapping (key is property name, value is binding location)\r\n     * Must be provided because browsers don't support reflection for wgsl shaders yet (so there's no way to query the binding/group from a variable name)\r\n     * TODO: remove this when browsers support reflection for wgsl shaders\r\n     */\r\n    bindingsMapping: ComputeBindingMapping;\r\n\r\n    /**\r\n     * The list of defines used in the shader\r\n     */\r\n    defines?: string[];\r\n\r\n    /**\r\n     * The name of the entry point in the shader source (default: \"main\")\r\n     */\r\n    entryPoint?: string;\r\n\r\n    /**\r\n     * If provided, will be called with the shader code so that this code can be updated before it is compiled by the GPU\r\n     */\r\n    processFinalCode?: Nullable<(code: string) => string>;\r\n}\r\n\r\ntype ComputeBindingListInternal = { [key: string]: { type: ComputeBindingType; object: any; indexInGroupEntries?: number; buffer?: Nullable<DataBuffer> } };\r\n\r\n/**\r\n * The ComputeShader object lets you execute a compute shader on your GPU (if supported by the engine)\r\n */\r\nexport class ComputeShader {\r\n    private _engine: AbstractEngine;\r\n    private _shaderPath: IComputeShaderPath | string;\r\n    private _options: IComputeShaderOptions;\r\n    private _effect: ComputeEffect;\r\n    private _cachedDefines: string;\r\n    private _bindings: ComputeBindingListInternal = {};\r\n    private _samplers: { [key: string]: TextureSampler } = {};\r\n    private _context: IComputeContext;\r\n    private _contextIsDirty = false;\r\n\r\n    /**\r\n     * Gets the unique id of the compute shader\r\n     */\r\n    public readonly uniqueId: number;\r\n\r\n    /**\r\n     * The name of the shader\r\n     */\r\n    @serialize()\r\n    public name: string;\r\n\r\n    /**\r\n     * The options used to create the shader\r\n     */\r\n    public get options() {\r\n        return this._options;\r\n    }\r\n\r\n    /**\r\n     * The shaderPath used to create the shader\r\n     */\r\n    public get shaderPath() {\r\n        return this._shaderPath;\r\n    }\r\n\r\n    /**\r\n     * When set to true, dispatch won't call isReady anymore and won't check if the underlying GPU resources should be (re)created because of a change in the inputs (texture, uniform buffer, etc.)\r\n     * If you know that your inputs did not change since last time dispatch was called and that isReady() returns true, set this flag to true to improve performance\r\n     */\r\n    @serialize()\r\n    public fastMode = false;\r\n\r\n    /**\r\n     * Callback triggered when the shader is compiled\r\n     */\r\n    public onCompiled: Nullable<(effect: ComputeEffect) => void> = null;\r\n\r\n    /**\r\n     * Callback triggered when an error occurs\r\n     */\r\n    public onError: Nullable<(effect: ComputeEffect, errors: string) => void> = null;\r\n\r\n    /**\r\n     * Gets the GPU time spent running the compute shader for the last frame rendered (in nanoseconds).\r\n     * You have to enable the \"timestamp-query\" extension in the engine constructor options and set engine.enableGPUTimingMeasurements = true.\r\n     */\r\n    public readonly gpuTimeInFrame?: WebGPUPerfCounter;\r\n\r\n    /**\r\n     * Instantiates a new compute shader.\r\n     * @param name Defines the name of the compute shader in the scene\r\n     * @param engine Defines the engine the compute shader belongs to\r\n     * @param shaderPath Defines the route to the shader code in one of three ways:\r\n     *  * object: \\{ compute: \"custom\" \\}, used with ShaderStore.ShadersStoreWGSL[\"customComputeShader\"]\r\n     *  * object: \\{ computeElement: \"HTMLElementId\" \\}, used with shader code in script tags\r\n     *  * object: \\{ computeSource: \"compute shader code string\" \\}, where the string contains the shader code\r\n     *  * string: try first to find the code in ShaderStore.ShadersStoreWGSL[shaderPath + \"ComputeShader\"]. If not, assumes it is a file with name shaderPath.compute.fx in index.html folder.\r\n     * @param options Define the options used to create the shader\r\n     */\r\n    constructor(name: string, engine: AbstractEngine, shaderPath: IComputeShaderPath | string, options: Partial<IComputeShaderOptions> = {}) {\r\n        this.name = name;\r\n        this._engine = engine;\r\n        this.uniqueId = UniqueIdGenerator.UniqueId;\r\n        if ((engine as WebGPUEngine).enableGPUTimingMeasurements) {\r\n            this.gpuTimeInFrame = new WebGPUPerfCounter();\r\n        }\r\n\r\n        if (!this._engine.getCaps().supportComputeShaders) {\r\n            Logger.Error(\"This engine does not support compute shaders!\");\r\n            return;\r\n        }\r\n        if (!options.bindingsMapping) {\r\n            Logger.Error(\"You must provide the binding mappings as browsers don't support reflection for wgsl shaders yet!\");\r\n            return;\r\n        }\r\n\r\n        this._context = engine.createComputeContext()!;\r\n        this._shaderPath = shaderPath;\r\n        this._options = {\r\n            bindingsMapping: {},\r\n            defines: [],\r\n            ...options,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name of the material e.g. \"ComputeShader\"\r\n     * Mainly use in serialization.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"ComputeShader\";\r\n    }\r\n\r\n    /**\r\n     * Binds a texture to the shader\r\n     * @param name Binding name of the texture\r\n     * @param texture Texture to bind\r\n     * @param bindSampler Bind the sampler corresponding to the texture (default: true). The sampler will be bound just before the binding index of the texture\r\n     */\r\n    public setTexture(name: string, texture: BaseTexture, bindSampler = true): void {\r\n        const current = this._bindings[name];\r\n\r\n        this._bindings[name] = {\r\n            type: bindSampler ? ComputeBindingType.Texture : ComputeBindingType.TextureWithoutSampler,\r\n            object: texture,\r\n            indexInGroupEntries: current?.indexInGroupEntries,\r\n        };\r\n\r\n        this._contextIsDirty ||= !current || current.object !== texture || current.type !== this._bindings[name].type;\r\n    }\r\n\r\n    /**\r\n     * Binds a storage texture to the shader\r\n     * @param name Binding name of the texture\r\n     * @param texture Texture to bind\r\n     */\r\n    public setStorageTexture(name: string, texture: BaseTexture): void {\r\n        const current = this._bindings[name];\r\n\r\n        this._contextIsDirty ||= !current || current.object !== texture;\r\n\r\n        this._bindings[name] = {\r\n            type: ComputeBindingType.StorageTexture,\r\n            object: texture,\r\n            indexInGroupEntries: current?.indexInGroupEntries,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Binds an external texture to the shader\r\n     * @param name Binding name of the texture\r\n     * @param texture Texture to bind\r\n     */\r\n    public setExternalTexture(name: string, texture: ExternalTexture): void {\r\n        const current = this._bindings[name];\r\n\r\n        this._contextIsDirty ||= !current || current.object !== texture;\r\n\r\n        this._bindings[name] = {\r\n            type: ComputeBindingType.ExternalTexture,\r\n            object: texture,\r\n            indexInGroupEntries: current?.indexInGroupEntries,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Binds a video texture to the shader (by binding the external texture attached to this video)\r\n     * @param name Binding name of the texture\r\n     * @param texture Texture to bind\r\n     * @returns true if the video texture was successfully bound, else false. false will be returned if the current engine does not support external textures\r\n     */\r\n    public setVideoTexture(name: string, texture: VideoTexture) {\r\n        if (texture.externalTexture) {\r\n            this.setExternalTexture(name, texture.externalTexture);\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Binds a uniform buffer to the shader\r\n     * @param name Binding name of the buffer\r\n     * @param buffer Buffer to bind\r\n     */\r\n    public setUniformBuffer(name: string, buffer: UniformBuffer | DataBuffer): void {\r\n        const current = this._bindings[name];\r\n\r\n        this._contextIsDirty ||= !current || current.object !== buffer;\r\n\r\n        this._bindings[name] = {\r\n            type: ComputeShader._BufferIsDataBuffer(buffer) ? ComputeBindingType.DataBuffer : ComputeBindingType.UniformBuffer,\r\n            object: buffer,\r\n            indexInGroupEntries: current?.indexInGroupEntries,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Binds a storage buffer to the shader\r\n     * @param name Binding name of the buffer\r\n     * @param buffer Buffer to bind\r\n     */\r\n    public setStorageBuffer(name: string, buffer: StorageBuffer | DataBuffer): void {\r\n        const current = this._bindings[name];\r\n\r\n        this._contextIsDirty ||= !current || current.object !== buffer;\r\n\r\n        this._bindings[name] = {\r\n            type: ComputeShader._BufferIsDataBuffer(buffer) ? ComputeBindingType.DataBuffer : ComputeBindingType.StorageBuffer,\r\n            object: buffer,\r\n            indexInGroupEntries: current?.indexInGroupEntries,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Binds a texture sampler to the shader\r\n     * @param name Binding name of the sampler\r\n     * @param sampler Sampler to bind\r\n     */\r\n    public setTextureSampler(name: string, sampler: TextureSampler): void {\r\n        const current = this._bindings[name];\r\n\r\n        this._contextIsDirty ||= !current || !sampler.compareSampler(current.object);\r\n\r\n        this._bindings[name] = {\r\n            type: ComputeBindingType.Sampler,\r\n            object: sampler,\r\n            indexInGroupEntries: current?.indexInGroupEntries,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Specifies that the compute shader is ready to be executed (the compute effect and all the resources are ready)\r\n     * @returns true if the compute shader is ready to be executed\r\n     */\r\n    public isReady(): boolean {\r\n        let effect = this._effect;\r\n\r\n        for (const key in this._bindings) {\r\n            const binding = this._bindings[key],\r\n                type = binding.type,\r\n                object = binding.object;\r\n\r\n            switch (type) {\r\n                case ComputeBindingType.Texture:\r\n                case ComputeBindingType.TextureWithoutSampler:\r\n                case ComputeBindingType.StorageTexture: {\r\n                    const texture = object as BaseTexture;\r\n                    if (!texture.isReady()) {\r\n                        return false;\r\n                    }\r\n                    break;\r\n                }\r\n                case ComputeBindingType.ExternalTexture: {\r\n                    const texture = object as ExternalTexture;\r\n                    if (!texture.isReady()) {\r\n                        return false;\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        const defines = [];\r\n\r\n        const shaderName = this._shaderPath;\r\n\r\n        if (this._options.defines) {\r\n            for (let index = 0; index < this._options.defines.length; index++) {\r\n                defines.push(this._options.defines[index]);\r\n            }\r\n        }\r\n\r\n        const join = defines.join(\"\\n\");\r\n\r\n        if (this._cachedDefines !== join) {\r\n            this._cachedDefines = join;\r\n\r\n            effect = this._engine.createComputeEffect(shaderName, <IComputeEffectCreationOptions>{\r\n                defines: join,\r\n                entryPoint: this._options.entryPoint,\r\n                onCompiled: this.onCompiled,\r\n                onError: this.onError,\r\n            });\r\n\r\n            this._effect = effect;\r\n        }\r\n\r\n        if (!effect.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Dispatches (executes) the compute shader\r\n     * @param x Number of workgroups to execute on the X dimension\r\n     * @param y Number of workgroups to execute on the Y dimension (default: 1)\r\n     * @param z Number of workgroups to execute on the Z dimension (default: 1)\r\n     * @returns True if the dispatch could be done, else false (meaning either the compute effect or at least one of the bound resources was not ready)\r\n     */\r\n    public dispatch(x: number, y?: number, z?: number): boolean {\r\n        if (!this.fastMode && !this._checkContext()) {\r\n            return false;\r\n        }\r\n        this._engine.computeDispatch(this._effect, this._context, this._bindings, x, y, z, this._options.bindingsMapping, this.gpuTimeInFrame);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Dispatches (executes) the compute shader.\r\n     * @param buffer Buffer containing the number of workgroups to execute on the X, Y and Z dimensions\r\n     * @param offset Offset in the buffer where the workgroup counts are stored (default: 0)\r\n     * @returns True if the dispatch could be done, else false (meaning either the compute effect or at least one of the bound resources was not ready)\r\n     */\r\n    public dispatchIndirect(buffer: StorageBuffer | DataBuffer, offset: number = 0): boolean {\r\n        if (!this.fastMode && !this._checkContext()) {\r\n            return false;\r\n        }\r\n        const dataBuffer = ComputeShader._BufferIsDataBuffer(buffer) ? buffer : buffer.getBuffer();\r\n        this._engine.computeDispatchIndirect(this._effect, this._context, this._bindings, dataBuffer, offset, this._options.bindingsMapping, this.gpuTimeInFrame);\r\n        return true;\r\n    }\r\n\r\n    private _checkContext(): boolean {\r\n        if (!this.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        // If the sampling parameters of a texture bound to the shader have changed, we must clear the compute context so that it is recreated with the updated values\r\n        // Also, if the actual (gpu) buffer used by a uniform buffer has changed, we must clear the compute context so that it is recreated with the updated value\r\n        for (const key in this._bindings) {\r\n            const binding = this._bindings[key];\r\n\r\n            if (!this._options.bindingsMapping[key]) {\r\n                throw new Error(\"ComputeShader ('\" + this.name + \"'): No binding mapping has been provided for the property '\" + key + \"'\");\r\n            }\r\n\r\n            switch (binding.type) {\r\n                case ComputeBindingType.Texture: {\r\n                    const sampler = this._samplers[key];\r\n                    const texture = binding.object as BaseTexture;\r\n\r\n                    if (!sampler || !texture._texture || !sampler.compareSampler(texture._texture)) {\r\n                        this._samplers[key] = new TextureSampler().setParameters(\r\n                            texture.wrapU,\r\n                            texture.wrapV,\r\n                            texture.wrapR,\r\n                            texture.anisotropicFilteringLevel,\r\n                            texture._texture!.samplingMode,\r\n                            texture._texture?._comparisonFunction\r\n                        );\r\n                        this._contextIsDirty = true;\r\n                    }\r\n                    break;\r\n                }\r\n                case ComputeBindingType.ExternalTexture: {\r\n                    // we must recreate the bind groups each time if there's an external texture, because device.importExternalTexture must be called each frame\r\n                    this._contextIsDirty = true;\r\n                    break;\r\n                }\r\n                case ComputeBindingType.UniformBuffer: {\r\n                    const ubo = binding.object as UniformBuffer;\r\n                    if (ubo.getBuffer() !== binding.buffer) {\r\n                        binding.buffer = ubo.getBuffer();\r\n                        this._contextIsDirty = true;\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (this._contextIsDirty) {\r\n            this._contextIsDirty = false;\r\n            this._context.clear();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Waits for the compute shader to be ready and executes it\r\n     * @param x Number of workgroups to execute on the X dimension\r\n     * @param y Number of workgroups to execute on the Y dimension (default: 1)\r\n     * @param z Number of workgroups to execute on the Z dimension (default: 1)\r\n     * @param delay Delay between the retries while the shader is not ready (in milliseconds - 10 by default)\r\n     * @returns A promise that is resolved once the shader has been sent to the GPU. Note that it does not mean that the shader execution itself is finished!\r\n     */\r\n    public dispatchWhenReady(x: number, y?: number, z?: number, delay = 10): Promise<void> {\r\n        return new Promise((resolve) => {\r\n            _retryWithInterval(() => this.dispatch(x, y, z), resolve, undefined, delay);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Serializes this compute shader in a JSON representation\r\n     * @returns the serialized compute shader object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = SerializationHelper.Serialize(this);\r\n\r\n        serializationObject.options = this._options;\r\n        serializationObject.shaderPath = this._shaderPath;\r\n        serializationObject.bindings = {};\r\n        serializationObject.textures = {};\r\n\r\n        for (const key in this._bindings) {\r\n            const binding = this._bindings[key];\r\n            const object = binding.object;\r\n\r\n            switch (binding.type) {\r\n                case ComputeBindingType.Texture:\r\n                case ComputeBindingType.TextureWithoutSampler:\r\n                case ComputeBindingType.StorageTexture: {\r\n                    const serializedData = (object as BaseTexture).serialize();\r\n                    if (serializedData) {\r\n                        serializationObject.textures[key] = serializedData;\r\n                        serializationObject.bindings[key] = {\r\n                            type: binding.type,\r\n                        };\r\n                    }\r\n                    break;\r\n                }\r\n\r\n                case ComputeBindingType.UniformBuffer: {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Creates a compute shader from parsed compute shader data\r\n     * @param source defines the JSON representation of the compute shader\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @returns a new compute shader\r\n     */\r\n    public static Parse(source: any, scene: Scene, rootUrl: string): ComputeShader {\r\n        const compute = SerializationHelper.Parse(\r\n            () => new ComputeShader(source.name, scene.getEngine() as WebGPUEngine, source.shaderPath, source.options),\r\n            source,\r\n            scene,\r\n            rootUrl\r\n        );\r\n\r\n        for (const key in source.textures) {\r\n            const binding = source.bindings[key];\r\n            const texture = <Texture>Texture.Parse(source.textures[key], scene, rootUrl);\r\n\r\n            if (binding.type === ComputeBindingType.Texture) {\r\n                compute.setTexture(key, texture);\r\n            } else if (binding.type === ComputeBindingType.TextureWithoutSampler) {\r\n                compute.setTexture(key, texture, false);\r\n            } else {\r\n                compute.setStorageTexture(key, texture);\r\n            }\r\n        }\r\n\r\n        return compute;\r\n    }\r\n\r\n    protected static _BufferIsDataBuffer(buffer: UniformBuffer | StorageBuffer | DataBuffer): buffer is DataBuffer {\r\n        return (buffer as DataBuffer).underlyingResource !== undefined;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.ComputeShader\", ComputeShader);\r\n", "import type { DataBuffer } from \"../Buffers/dataBuffer\";\r\nimport type { DataArray } from \"../types\";\r\nimport type { WebGPUEngine } from \"core/Engines/webgpuEngine\";\r\nimport { Constants } from \"../Engines/constants\";\r\n\r\n/**\r\n * This class is a small wrapper around a native buffer that can be read and/or written\r\n */\r\nexport class StorageBuffer {\r\n    private _engine: WebGPUEngine;\r\n    private _buffer: DataBuffer;\r\n    private _bufferSize: number;\r\n    private _creationFlags: number;\r\n    private _label?: string;\r\n\r\n    /**\r\n     * Creates a new storage buffer instance\r\n     * @param engine The engine the buffer will be created inside\r\n     * @param size The size of the buffer in bytes\r\n     * @param creationFlags flags to use when creating the buffer (see Constants.BUFFER_CREATIONFLAG_XXX). The BUFFER_CREATIONFLAG_STORAGE flag will be automatically added.\r\n     * @param label defines the label of the buffer (for debug purpose)\r\n     */\r\n    constructor(engine: WebGPUEngine, size: number, creationFlags = Constants.BUFFER_CREATIONFLAG_READWRITE, label?: string) {\r\n        this._engine = engine;\r\n        this._label = label;\r\n        this._engine._storageBuffers.push(this);\r\n        this._create(size, creationFlags);\r\n    }\r\n\r\n    private _create(size: number, creationFlags: number): void {\r\n        this._bufferSize = size;\r\n        this._creationFlags = creationFlags;\r\n        this._buffer = this._engine.createStorageBuffer(size, creationFlags, this._label);\r\n    }\r\n\r\n    /** @internal */\r\n    public _rebuild(): void {\r\n        this._create(this._bufferSize, this._creationFlags);\r\n    }\r\n\r\n    /**\r\n     * Gets underlying native buffer\r\n     * @returns underlying native buffer\r\n     */\r\n    public getBuffer(): DataBuffer {\r\n        return this._buffer;\r\n    }\r\n\r\n    /**\r\n     * Updates the storage buffer\r\n     * @param data the data used to update the storage buffer\r\n     * @param byteOffset the byte offset of the data (optional)\r\n     * @param byteLength the byte length of the data (optional)\r\n     */\r\n    public update(data: DataArray, byteOffset?: number, byteLength?: number): void {\r\n        if (!this._buffer) {\r\n            return;\r\n        }\r\n\r\n        this._engine.updateStorageBuffer(this._buffer, data, byteOffset, byteLength);\r\n    }\r\n\r\n    /**\r\n     * Reads data from the storage buffer\r\n     * @param offset The offset in the storage buffer to start reading from (default: 0)\r\n     * @param size  The number of bytes to read from the storage buffer (default: capacity of the buffer)\r\n     * @param buffer The buffer to write the data we have read from the storage buffer to (optional)\r\n     * @param noDelay If true, a call to flushFramebuffer will be issued so that the data can be read back immediately. This can speed up data retrieval, at the cost of a small perf penalty (default: false).\r\n     * @returns If not undefined, returns the (promise) buffer (as provided by the 4th parameter) filled with the data, else it returns a (promise) Uint8Array with the data read from the storage buffer\r\n     */\r\n    public read(offset?: number, size?: number, buffer?: ArrayBufferView, noDelay?: boolean): Promise<ArrayBufferView> {\r\n        return this._engine.readFromStorageBuffer(this._buffer, offset, size, buffer, noDelay);\r\n    }\r\n\r\n    /**\r\n     * Disposes the storage buffer\r\n     */\r\n    public dispose(): void {\r\n        const storageBuffers = this._engine._storageBuffers;\r\n        const index = storageBuffers.indexOf(this);\r\n\r\n        if (index !== -1) {\r\n            storageBuffers[index] = storageBuffers[storageBuffers.length - 1];\r\n            storageBuffers.pop();\r\n        }\r\n\r\n        this._engine._releaseBuffer(this._buffer);\r\n        this._buffer = null as any;\r\n    }\r\n}\r\n", "// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"boundingInfoComputeShader\";\nconst shader = `struct Results {minX : atomic<i32>,\nminY : atomic<i32>,\nminZ : atomic<i32>,\nmaxX : atomic<i32>,\nmaxY : atomic<i32>,\nmaxZ : atomic<i32>,\ndummy1 : i32,\ndummy2 : i32,};fn floatToBits(value: f32)->i32 {return bitcast<i32>(value);}\nfn bitsToFloat(value: i32)->f32 {return bitcast<f32>(value);}\nfn atomicMinFloat(atomicVar: ptr<storage,atomic<i32>,read_write>,value: f32) {let intValue=floatToBits(value);loop {let oldIntValue=atomicLoad(atomicVar);let oldValue=bitsToFloat(oldIntValue);if (value>=oldValue) {break;}\nif (atomicCompareExchangeWeak(atomicVar,oldIntValue,intValue).old_value==oldIntValue) {break;}}}\nfn atomicMaxFloat(atomicVar: ptr<storage,atomic<i32>,read_write>,value: f32) {let intValue=floatToBits(value);loop {let oldIntValue=atomicLoad(atomicVar);let oldValue=bitsToFloat(oldIntValue);if (value<=oldValue) {break;}\nif (atomicCompareExchangeWeak(atomicVar,oldIntValue,intValue).old_value==oldIntValue) {break;}}}\nfn readMatrixFromRawSampler(smp : texture_2d<f32>,index : f32)->mat4x4<f32>\n{let offset=i32(index) *4; \nlet m0=textureLoad(smp,vec2<i32>(offset+0,0),0);let m1=textureLoad(smp,vec2<i32>(offset+1,0),0);let m2=textureLoad(smp,vec2<i32>(offset+2,0),0);let m3=textureLoad(smp,vec2<i32>(offset+3,0),0);return mat4x4<f32>(m0,m1,m2,m3);}\nconst identity=mat4x4f(\nvec4f(1.0,0.0,0.0,0.0),\nvec4f(0.0,1.0,0.0,0.0),\nvec4f(0.0,0.0,1.0,0.0),\nvec4f(0.0,0.0,0.0,1.0)\n);struct Settings {morphTargetTextureInfo: vec3f,\nmorphTargetCount: i32,\nindexResult : u32,};@group(0) @binding(0) var<storage,read> positionBuffer : array<f32>;@group(0) @binding(1) var<storage,read_write> resultBuffer : array<Results>;@group(0) @binding(7) var<uniform> settings : Settings;\n#if NUM_BONE_INFLUENCERS>0\n@group(0) @binding(2) var boneSampler : texture_2d<f32>;@group(0) @binding(3) var<storage,read> indexBuffer : array<vec4f>;@group(0) @binding(4) var<storage,read> weightBuffer : array<vec4f>;\n#if NUM_BONE_INFLUENCERS>4\n@group(0) @binding(5) var<storage,read> indexExtraBuffer : array<vec4f>;@group(0) @binding(6) var<storage,read> weightExtraBuffer : array<vec4f>;\n#endif\n#endif\n#ifdef MORPHTARGETS\n@group(0) @binding(8) var morphTargets : texture_2d_array<f32>;@group(0) @binding(9) var<storage,read> morphTargetInfluences : array<f32>;@group(0) @binding(10) var<storage,read> morphTargetTextureIndices : array<f32>;\n#endif\n#ifdef MORPHTARGETS\nfn readVector3FromRawSampler(targetIndex : i32,vertexIndex : u32)->vec3f\n{ \nlet vertexID=f32(vertexIndex)*settings.morphTargetTextureInfo.x;let y=floor(vertexID/settings.morphTargetTextureInfo.y);let x=vertexID-y*settings.morphTargetTextureInfo.y;let textureUV=vec2<i32>(i32(x),i32(y));return textureLoad(morphTargets,textureUV,i32(morphTargetTextureIndices[targetIndex]),0).xyz;}\nfn readVector4FromRawSampler(targetIndex : i32,vertexIndex : u32)->vec4f\n{ \nlet vertexID=f32(vertexIndex)*settings.morphTargetTextureInfo.x;let y=floor(vertexID/settings.morphTargetTextureInfo.y);let x=vertexID-y*settings.morphTargetTextureInfo.y;let textureUV=vec2<i32>(i32(x),i32(y));return textureLoad(morphTargets,textureUV,i32(morphTargetTextureIndices[targetIndex]),0);}\n#endif\n@compute @workgroup_size(256,1,1)\nfn main(@builtin(global_invocation_id) global_id : vec3<u32>) {let index=global_id.x;if (index>=arrayLength(&positionBuffer)/3) {return;}\nlet position=vec3f(positionBuffer[index*3],positionBuffer[index*3+1],positionBuffer[index*3+2]);var finalWorld=identity;var positionUpdated=position;\n#if NUM_BONE_INFLUENCERS>0\nvar influence : mat4x4<f32>;let matricesIndices=indexBuffer[index];let matricesWeights=weightBuffer[index];influence=readMatrixFromRawSampler(boneSampler,matricesIndices[0])*matricesWeights[0];\n#if NUM_BONE_INFLUENCERS>1\ninfluence=influence+readMatrixFromRawSampler(boneSampler,matricesIndices[1])*matricesWeights[1];\n#endif \n#if NUM_BONE_INFLUENCERS>2\ninfluence=influence+readMatrixFromRawSampler(boneSampler,matricesIndices[2])*matricesWeights[2];\n#endif \n#if NUM_BONE_INFLUENCERS>3\ninfluence=influence+readMatrixFromRawSampler(boneSampler,matricesIndices[3])*matricesWeights[3];\n#endif \n#if NUM_BONE_INFLUENCERS>4\nlet matricesIndicesExtra=indexExtraBuffer[index];let matricesWeightsExtra=weightExtraBuffer[index];influence=influence+readMatrixFromRawSampler(boneSampler,matricesIndicesExtra.x)*matricesWeightsExtra.x;\n#if NUM_BONE_INFLUENCERS>5\ninfluence=influence+readMatrixFromRawSampler(boneSampler,matricesIndicesExtra.y)*matricesWeightsExtra.y;\n#endif \n#if NUM_BONE_INFLUENCERS>6\ninfluence=influence+readMatrixFromRawSampler(boneSampler,matricesIndicesExtra.z)*matricesWeightsExtra.z;\n#endif \n#if NUM_BONE_INFLUENCERS>7\ninfluence=influence+readMatrixFromRawSampler(boneSampler,matricesIndicesExtra.w)*matricesWeightsExtra.w;\n#endif \n#endif \nfinalWorld=finalWorld*influence;\n#endif\n#ifdef MORPHTARGETS\nfor (var i=0; i<NUM_MORPH_INFLUENCERS; i=i+1) {if (i>=settings.morphTargetCount) {break;}\npositionUpdated=positionUpdated+(readVector3FromRawSampler(i,index)-position)*morphTargetInfluences[i];}\n#endif\nvar worldPos=finalWorld*vec4f(positionUpdated.x,positionUpdated.y,positionUpdated.z,1.0);atomicMinFloat(&resultBuffer[settings.indexResult].minX,worldPos.x);atomicMinFloat(&resultBuffer[settings.indexResult].minY,worldPos.y);atomicMinFloat(&resultBuffer[settings.indexResult].minZ,worldPos.z);atomicMaxFloat(&resultBuffer[settings.indexResult].maxX,worldPos.x);atomicMaxFloat(&resultBuffer[settings.indexResult].maxY,worldPos.y);atomicMaxFloat(&resultBuffer[settings.indexResult].maxZ,worldPos.z);}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const boundingInfoComputeShaderWGSL = { name, shader };\n", "import type { IBoundingInfoHelperPlatform } from \"./IBoundingInfoHelperPlatform\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport { ComputeShader } from \"core/Compute/computeShader\";\r\nimport { StorageBuffer } from \"core/Buffers/storageBuffer\";\r\nimport type { WebGPUEngine } from \"core/Engines/webgpuEngine\";\r\nimport type { AbstractEngine } from \"core/Engines/abstractEngine\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport { Vector3 } from \"core/Maths/math.vector\";\r\nimport { UniformBuffer } from \"core/Materials/uniformBuffer\";\r\nimport type { DataBuffer } from \"core/Buffers/dataBuffer\";\r\nimport type { ComputeBindingMapping } from \"core/Engines/Extensions/engine.computeShader\";\r\n\r\nimport \"../../ShadersWGSL/boundingInfo.compute\";\r\nimport { _retryWithInterval } from \"core/Misc/timingTools\";\r\n\r\n/** @internal */\r\nexport class ComputeShaderBoundingHelper implements IBoundingInfoHelperPlatform {\r\n    private _engine: AbstractEngine;\r\n    private _computeShadersCache: { [key: string]: ComputeShader } = {};\r\n    private _positionBuffers: { [key: number]: StorageBuffer } = {};\r\n    private _indexBuffers: { [key: number]: StorageBuffer } = {};\r\n    private _weightBuffers: { [key: number]: StorageBuffer } = {};\r\n    private _indexExtraBuffers: { [key: number]: StorageBuffer } = {};\r\n    private _weightExtraBuffers: { [key: number]: StorageBuffer } = {};\r\n    private _morphTargetInfluenceBuffers: { [key: number]: StorageBuffer } = {};\r\n    private _morphTargetTextureIndexBuffers: { [key: number]: StorageBuffer } = {};\r\n    private _ubos: UniformBuffer[] = [];\r\n    private _uboIndex: number = 0;\r\n    private _processedMeshes: AbstractMesh[] = [];\r\n    private _computeShaders: ComputeShader[][] = [];\r\n    private _uniqueComputeShaders: Set<ComputeShader> = new Set();\r\n    private _resultBuffers: StorageBuffer[] = [];\r\n\r\n    /**\r\n     * Creates a new ComputeShaderBoundingHelper\r\n     * @param engine defines the engine to use\r\n     */\r\n    constructor(engine: AbstractEngine) {\r\n        this._engine = engine;\r\n    }\r\n\r\n    private _getComputeShader(defines: string[], hasBones: boolean, hasMorphs: boolean) {\r\n        let computeShader: ComputeShader;\r\n        const join = defines.join(\"\\n\");\r\n\r\n        if (!this._computeShadersCache[join]) {\r\n            const bindingsMapping: ComputeBindingMapping = {\r\n                positionBuffer: { group: 0, binding: 0 },\r\n                resultBuffer: { group: 0, binding: 1 },\r\n                settings: { group: 0, binding: 7 },\r\n            };\r\n\r\n            if (hasBones) {\r\n                bindingsMapping.boneSampler = { group: 0, binding: 2 };\r\n                bindingsMapping.indexBuffer = { group: 0, binding: 3 };\r\n                bindingsMapping.weightBuffer = { group: 0, binding: 4 };\r\n                bindingsMapping.indexExtraBuffer = { group: 0, binding: 5 };\r\n                bindingsMapping.weightExtraBuffer = { group: 0, binding: 6 };\r\n            }\r\n            if (hasMorphs) {\r\n                bindingsMapping.morphTargets = { group: 0, binding: 8 };\r\n                bindingsMapping.morphTargetInfluences = { group: 0, binding: 9 };\r\n                bindingsMapping.morphTargetTextureIndices = { group: 0, binding: 10 };\r\n            }\r\n\r\n            computeShader = new ComputeShader(`boundingInfoCompute${hasBones ? \"_bones\" : \"\"}${hasMorphs ? \"_morphs\" : \"\"}`, this._engine, \"boundingInfo\", {\r\n                bindingsMapping,\r\n                defines: defines,\r\n            });\r\n            this._computeShadersCache[join] = computeShader;\r\n        } else {\r\n            computeShader = this._computeShadersCache[join];\r\n        }\r\n\r\n        return computeShader;\r\n    }\r\n\r\n    private _getUBO() {\r\n        if (this._uboIndex >= this._ubos.length) {\r\n            const ubo = new UniformBuffer(this._engine);\r\n            ubo.addFloat3(\"morphTargetTextureInfo\", 0, 0, 0);\r\n            ubo.addUniform(\"morphTargetCount\", 1);\r\n            ubo.addUniform(\"indexResult\", 1);\r\n            this._ubos.push(ubo);\r\n        }\r\n\r\n        return this._ubos[this._uboIndex++];\r\n    }\r\n\r\n    private _extractDataAndLink(computeShader: ComputeShader, mesh: Mesh, kind: string, stride: number, name: string, storageUnit: { [key: number]: StorageBuffer }) {\r\n        let buffer: StorageBuffer;\r\n        const vertexCount = mesh.getTotalVertices();\r\n        if (!storageUnit[mesh.uniqueId]) {\r\n            const dataArray = mesh.getVertexBuffer(kind)?.getFloatData(vertexCount);\r\n            buffer = new StorageBuffer(this._engine as WebGPUEngine, Float32Array.BYTES_PER_ELEMENT * vertexCount * stride);\r\n            buffer.update(dataArray!);\r\n\r\n            storageUnit[mesh.uniqueId] = buffer;\r\n        } else {\r\n            buffer = storageUnit[mesh.uniqueId];\r\n        }\r\n\r\n        computeShader.setStorageBuffer(name, buffer);\r\n    }\r\n\r\n    private _prepareStorage(computeShader: ComputeShader, name: string, id: number, storageUnit: { [key: number]: StorageBuffer }, numInfluencers: number, data: Float32Array) {\r\n        let buffer: StorageBuffer;\r\n        if (!storageUnit[id]) {\r\n            buffer = new StorageBuffer(this._engine as WebGPUEngine, Float32Array.BYTES_PER_ELEMENT * numInfluencers);\r\n\r\n            storageUnit[id] = buffer;\r\n        } else {\r\n            buffer = storageUnit[id];\r\n        }\r\n        buffer.update(data);\r\n\r\n        computeShader.setStorageBuffer(name, buffer);\r\n    }\r\n\r\n    /** @internal */\r\n    public async processAsync(meshes: AbstractMesh | AbstractMesh[]): Promise<void> {\r\n        await this.registerMeshListAsync(meshes);\r\n        this.processMeshList();\r\n        await this.fetchResultsForMeshListAsync();\r\n    }\r\n\r\n    /** @internal */\r\n    public registerMeshListAsync(meshes: AbstractMesh | AbstractMesh[]): Promise<void> {\r\n        this._disposeForMeshList();\r\n\r\n        if (!Array.isArray(meshes)) {\r\n            meshes = [meshes];\r\n        }\r\n\r\n        let maxNumInfluencers = 0;\r\n        for (let i = 0; i < meshes.length; i++) {\r\n            const mesh = meshes[i];\r\n            const vertexCount = mesh.getTotalVertices();\r\n\r\n            if (vertexCount === 0 || !(mesh as Mesh).getVertexBuffer || !(mesh as Mesh).getVertexBuffer(VertexBuffer.PositionKind)) {\r\n                continue;\r\n            }\r\n\r\n            this._processedMeshes.push(mesh);\r\n\r\n            const manager = (<Mesh>mesh).morphTargetManager;\r\n            if (manager && manager.supportsPositions) {\r\n                maxNumInfluencers = Math.max(maxNumInfluencers, manager.numTargets);\r\n            }\r\n        }\r\n\r\n        for (let i = 0; i < this._processedMeshes.length; i++) {\r\n            const mesh = this._processedMeshes[i];\r\n            let defines = [\"\"];\r\n\r\n            let hasBones = false;\r\n            if (mesh && mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {\r\n                defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\r\n                hasBones = true;\r\n            }\r\n\r\n            const computeShaderWithoutMorph = this._getComputeShader(defines, hasBones, false);\r\n\r\n            this._uniqueComputeShaders.add(computeShaderWithoutMorph);\r\n\r\n            const manager = (<Mesh>mesh).morphTargetManager;\r\n            if (manager && manager.supportsPositions) {\r\n                defines = defines.slice();\r\n                defines.push(\"#define MORPHTARGETS\");\r\n                defines.push(\"#define NUM_MORPH_INFLUENCERS \" + maxNumInfluencers);\r\n\r\n                const computeShaderWithMorph = this._getComputeShader(defines, hasBones, true);\r\n\r\n                this._uniqueComputeShaders.add(computeShaderWithMorph);\r\n                this._computeShaders.push([computeShaderWithoutMorph, computeShaderWithMorph]);\r\n            } else {\r\n                this._computeShaders.push([computeShaderWithoutMorph, computeShaderWithoutMorph]);\r\n            }\r\n\r\n            // Pre-build the ubos, as they won't change if there's no morph targets\r\n            const ubo = this._getUBO();\r\n            ubo.updateUInt(\"indexResult\", i);\r\n\r\n            ubo.update();\r\n        }\r\n\r\n        return new Promise((resolve) => {\r\n            _retryWithInterval(() => {\r\n                const iterator = this._uniqueComputeShaders.keys();\r\n                for (let key = iterator.next(); key.done !== true; key = iterator.next()) {\r\n                    const computeShader = key.value;\r\n                    if (!computeShader.isReady()) {\r\n                        return false;\r\n                    }\r\n                }\r\n                return true;\r\n            }, resolve);\r\n        });\r\n    }\r\n\r\n    /** @internal */\r\n    public processMeshList(): void {\r\n        if (this._processedMeshes.length === 0) {\r\n            return;\r\n        }\r\n\r\n        this._uboIndex = 0;\r\n\r\n        const resultDataSize = 8 * this._processedMeshes.length;\r\n        const resultData = new Float32Array(resultDataSize);\r\n\r\n        const resultBuffer = new StorageBuffer(this._engine as WebGPUEngine, Float32Array.BYTES_PER_ELEMENT * resultDataSize);\r\n        this._resultBuffers.push(resultBuffer);\r\n\r\n        for (let i = 0; i < this._processedMeshes.length; i++) {\r\n            resultData[i * 8 + 0] = Number.POSITIVE_INFINITY;\r\n            resultData[i * 8 + 1] = Number.POSITIVE_INFINITY;\r\n            resultData[i * 8 + 2] = Number.POSITIVE_INFINITY;\r\n\r\n            resultData[i * 8 + 3] = Number.NEGATIVE_INFINITY;\r\n            resultData[i * 8 + 4] = Number.NEGATIVE_INFINITY;\r\n            resultData[i * 8 + 5] = Number.NEGATIVE_INFINITY;\r\n        }\r\n\r\n        resultBuffer.update(resultData);\r\n\r\n        for (let i = 0; i < this._processedMeshes.length; i++) {\r\n            const mesh = this._processedMeshes[i];\r\n            const vertexCount = mesh.getTotalVertices();\r\n\r\n            const [computeShaderWithoutMorph, computeShaderWithMorph] = this._computeShaders[i];\r\n\r\n            const manager = (<Mesh>mesh).morphTargetManager;\r\n            const hasMorphs = manager && manager.numInfluencers > 0 && manager.supportsPositions;\r\n            const computeShader = hasMorphs ? computeShaderWithMorph : computeShaderWithoutMorph;\r\n\r\n            this._extractDataAndLink(computeShader, mesh as Mesh, VertexBuffer.PositionKind, 3, \"positionBuffer\", this._positionBuffers);\r\n\r\n            // Bones\r\n            if (mesh && mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton && mesh.skeleton.useTextureToStoreBoneMatrices) {\r\n                this._extractDataAndLink(computeShader, mesh as Mesh, VertexBuffer.MatricesIndicesKind, 4, \"indexBuffer\", this._indexBuffers);\r\n                this._extractDataAndLink(computeShader, mesh as Mesh, VertexBuffer.MatricesWeightsKind, 4, \"weightBuffer\", this._weightBuffers);\r\n                const boneSampler = mesh.skeleton.getTransformMatrixTexture(mesh);\r\n                computeShader.setTexture(\"boneSampler\", boneSampler!, false);\r\n                if (mesh.numBoneInfluencers > 4) {\r\n                    this._extractDataAndLink(computeShader, mesh as Mesh, VertexBuffer.MatricesIndicesExtraKind, 4, \"indexExtraBuffer\", this._indexExtraBuffers);\r\n                    this._extractDataAndLink(computeShader, mesh as Mesh, VertexBuffer.MatricesWeightsExtraKind, 4, \"weightExtraBuffer\", this._weightExtraBuffers);\r\n                }\r\n            }\r\n\r\n            const ubo = this._getUBO();\r\n\r\n            // Morphs\r\n            if (hasMorphs) {\r\n                const morphTargets = manager._targetStoreTexture;\r\n                computeShader.setTexture(\"morphTargets\", morphTargets!, false);\r\n\r\n                this._prepareStorage(computeShader, \"morphTargetInfluences\", mesh.uniqueId, this._morphTargetInfluenceBuffers, manager.numInfluencers, manager.influences);\r\n                this._prepareStorage(\r\n                    computeShader,\r\n                    \"morphTargetTextureIndices\",\r\n                    mesh.uniqueId,\r\n                    this._morphTargetTextureIndexBuffers,\r\n                    manager.numInfluencers,\r\n                    manager._morphTargetTextureIndices\r\n                );\r\n\r\n                ubo.updateFloat3(\"morphTargetTextureInfo\", manager._textureVertexStride, manager._textureWidth, manager._textureHeight);\r\n                ubo.updateInt(\"morphTargetCount\", manager.numInfluencers);\r\n                ubo.update();\r\n            }\r\n\r\n            computeShader.setStorageBuffer(\"resultBuffer\", resultBuffer);\r\n\r\n            computeShader.setUniformBuffer(\"settings\", ubo);\r\n\r\n            // Dispatch\r\n            computeShader.dispatch(Math.ceil(vertexCount / 256));\r\n\r\n            this._engine.flushFramebuffer();\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public fetchResultsForMeshListAsync(): Promise<void> {\r\n        return new Promise((resolve) => {\r\n            const buffers: DataBuffer[] = [];\r\n            let size = 0;\r\n            for (let i = 0; i < this._resultBuffers.length; i++) {\r\n                const buffer = this._resultBuffers[i].getBuffer();\r\n                buffers.push(buffer);\r\n                size += buffer.capacity;\r\n            }\r\n\r\n            const resultData = new Float32Array(size / Float32Array.BYTES_PER_ELEMENT);\r\n\r\n            const minimum = Vector3.Zero();\r\n            const maximum = Vector3.Zero();\r\n\r\n            const minmax = { minimum, maximum };\r\n\r\n            (this._engine as WebGPUEngine).readFromMultipleStorageBuffers(buffers, 0, undefined, resultData, true).then(() => {\r\n                let resultDataOffset = 0;\r\n                for (let j = 0; j < this._resultBuffers.length; j++) {\r\n                    for (let i = 0; i < this._processedMeshes.length; i++) {\r\n                        const mesh = this._processedMeshes[i];\r\n\r\n                        Vector3.FromArrayToRef(resultData, resultDataOffset + i * 8, minimum);\r\n                        Vector3.FromArrayToRef(resultData, resultDataOffset + i * 8 + 3, maximum);\r\n\r\n                        if (j > 0) {\r\n                            minimum.minimizeInPlace(mesh.getBoundingInfo().minimum);\r\n                            maximum.maximizeInPlace(mesh.getBoundingInfo().maximum);\r\n                        }\r\n\r\n                        mesh._refreshBoundingInfoDirect(minmax);\r\n                    }\r\n\r\n                    resultDataOffset += 8 * this._processedMeshes.length;\r\n                }\r\n\r\n                for (const resultBuffer of this._resultBuffers) {\r\n                    resultBuffer.dispose();\r\n                }\r\n\r\n                this._resultBuffers = [];\r\n                this._uboIndex = 0;\r\n\r\n                resolve();\r\n            });\r\n        });\r\n    }\r\n\r\n    private _disposeCache(storageUnit: { [key: number]: StorageBuffer }) {\r\n        for (const key in storageUnit) {\r\n            storageUnit[key].dispose();\r\n        }\r\n    }\r\n\r\n    private _disposeForMeshList() {\r\n        for (const resultBuffer of this._resultBuffers) {\r\n            resultBuffer.dispose();\r\n        }\r\n        this._resultBuffers = [];\r\n        this._processedMeshes = [];\r\n        this._computeShaders = [];\r\n        this._uniqueComputeShaders = new Set();\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose(): void {\r\n        this._disposeCache(this._positionBuffers);\r\n        this._positionBuffers = {};\r\n        this._disposeCache(this._indexBuffers);\r\n        this._indexBuffers = {};\r\n        this._disposeCache(this._weightBuffers);\r\n        this._weightBuffers = {};\r\n        this._disposeCache(this._morphTargetInfluenceBuffers);\r\n        this._morphTargetInfluenceBuffers = {};\r\n        this._disposeCache(this._morphTargetTextureIndexBuffers);\r\n        this._morphTargetTextureIndexBuffers = {};\r\n        for (const ubo of this._ubos) {\r\n            ubo.dispose();\r\n        }\r\n        this._ubos = [];\r\n        this._computeShadersCache = {};\r\n        this._engine = undefined!;\r\n        this._disposeForMeshList();\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": ["name", "name"]
}
