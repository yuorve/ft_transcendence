import {
  AbstractSound,
  _AbstractSoundInstance,
  _CleanUrl
} from "./chunk-HHEWCVWA.js";
import {
  _HasSpatialAudioOptions,
  _SpatialWebAudio,
  _StereoAudio,
  _WebAudioBusAndSoundSubGraph
} from "./chunk-JVS6DDUT.js";
import {
  Tools
} from "./chunk-CDRMOKEX.js";
import {
  Logger
} from "./chunk-OJJXGLTO.js";
import {
  Observable
} from "./chunk-GWFZRJMO.js";

// node_modules/@babylonjs/core/AudioV2/abstractAudio/streamingSound.js
var StreamingSound = class extends AbstractSound {
  constructor(name, engine) {
    super(name, engine);
    this._preloadedInstances = new Array();
  }
  /**
   * The number of instances to preload. Defaults to `1`.
   */
  get preloadCount() {
    return this._options.preloadCount ?? 1;
  }
  /**
   * Returns the number of instances that have been preloaded.
   */
  get preloadCompletedCount() {
    return this._preloadedInstances.length;
  }
  /**
   * Preloads an instance of the sound.
   * @returns A promise that resolves when the instance is preloaded.
   */
  preloadInstance() {
    const instance = this._createInstance();
    this._addPreloadedInstance(instance);
    return instance.preloadedPromise;
  }
  /**
   * Preloads the given number of instances of the sound.
   * @param count - The number of instances to preload.
   * @returns A promise that resolves when all instances are preloaded.
   */
  async preloadInstances(count) {
    for (let i = 0; i < count; i++) {
      this.preloadInstance();
    }
    await Promise.all(this._preloadedInstances.map((instance) => instance.preloadedPromise));
  }
  /**
   * Plays the sound.
   * - Triggers `onEndedObservable` if played for the full duration and the `loop` option is not set.
   * @param options The options to use when playing the sound. Options set here override the sound's options.
   */
  play(options = {}) {
    if (this.state === 5) {
      this.resume();
      return;
    }
    let instance;
    if (this.preloadCompletedCount > 0) {
      instance = this._preloadedInstances[0];
      instance.startOffset = this.startOffset;
      this._removePreloadedInstance(instance);
    } else {
      instance = this._createInstance();
    }
    const onInstanceStateChanged = () => {
      if (instance.state === 3) {
        this._stopExcessInstances();
        instance.onStateChangedObservable.removeCallback(onInstanceStateChanged);
      }
    };
    instance.onStateChangedObservable.add(onInstanceStateChanged);
    options.startOffset ?? (options.startOffset = this.startOffset);
    options.loop ?? (options.loop = this.loop);
    options.volume ?? (options.volume = 1);
    this._beforePlay(instance);
    instance.play(options);
    this._afterPlay(instance);
  }
  /**
   * Stops the sound.
   */
  stop() {
    this._setState(
      1
      /* SoundState.Stopped */
    );
    if (!this._instances) {
      return;
    }
    for (const instance of Array.from(this._instances)) {
      instance.stop();
    }
  }
  _addPreloadedInstance(instance) {
    if (!this._preloadedInstances.includes(instance)) {
      this._preloadedInstances.push(instance);
    }
  }
  _removePreloadedInstance(instance) {
    const index = this._preloadedInstances.indexOf(instance);
    if (index !== -1) {
      this._preloadedInstances.splice(index, 1);
    }
  }
};

// node_modules/@babylonjs/core/AudioV2/abstractAudio/streamingSoundInstance.js
var _StreamingSoundInstance = class extends _AbstractSoundInstance {
  constructor(sound) {
    super(sound);
    this.onReadyObservable = new Observable();
    this.preloadedPromise = new Promise((resolve, reject) => {
      this._rejectPreloadedProimse = reject;
      this._resolvePreloadedPromise = resolve;
    });
    this.onErrorObservable.add(this._rejectPreloadedProimse);
    this.onReadyObservable.add(this._resolvePreloadedPromise);
  }
  /** @internal */
  set startOffset(value) {
    this._options.startOffset = value;
  }
  /** @internal */
  dispose() {
    super.dispose();
    this.onErrorObservable.clear();
    this.onReadyObservable.clear();
    this._resolvePreloadedPromise();
  }
};

// node_modules/@babylonjs/core/AudioV2/webAudio/webAudioStreamingSound.js
var _WebAudioStreamingSound = class __WebAudioStreamingSound extends StreamingSound {
  /** @internal */
  constructor(name, engine, options) {
    super(name, engine);
    this._spatial = null;
    this._spatialAutoUpdate = true;
    this._spatialMinUpdateTime = 0;
    this._stereo = null;
    if (typeof options.spatialAutoUpdate === "boolean") {
      this._spatialAutoUpdate = options.spatialAutoUpdate;
    }
    if (typeof options.spatialMinUpdateTime === "number") {
      this._spatialMinUpdateTime = options.spatialMinUpdateTime;
    }
    this._options = {
      autoplay: options.autoplay ?? false,
      loop: options.loop ?? false,
      maxInstances: options.maxInstances ?? Infinity,
      preloadCount: options.preloadCount ?? 1,
      startOffset: options.startOffset ?? 0
    };
    this._subGraph = new __WebAudioStreamingSound._SubGraph(this);
  }
  /** @internal */
  async init(source, options) {
    const audioContext = this.engine.audioContext;
    if (!(audioContext instanceof AudioContext)) {
      throw new Error("Unsupported audio context type.");
    }
    this.audioContext = audioContext;
    this.source = source;
    if (options.outBus) {
      this.outBus = options.outBus;
    } else {
      await this.engine.isReadyPromise;
      this.outBus = this.engine.defaultMainBus;
    }
    await this._subGraph.init(options);
    if (_HasSpatialAudioOptions(options)) {
      this._initSpatialProperty();
    }
    if (this.preloadCount) {
      await this.preloadInstances(this.preloadCount);
    }
    if (options.autoplay) {
      this.play(options);
    }
    this.engine.addNode(this);
  }
  /** @internal */
  get inNode() {
    return this._subGraph.inNode;
  }
  /** @internal */
  get outNode() {
    return this._subGraph.outNode;
  }
  /** @internal */
  get spatial() {
    if (this._spatial) {
      return this._spatial;
    }
    return this._initSpatialProperty();
  }
  /** @internal */
  get stereo() {
    return this._stereo ?? (this._stereo = new _StereoAudio(this._subGraph));
  }
  /** @internal */
  dispose() {
    super.dispose();
    this._spatial = null;
    this._stereo = null;
    this._subGraph.dispose();
    this.engine.removeNode(this);
  }
  /** @internal */
  getClassName() {
    return "_WebAudioStreamingSound";
  }
  _createInstance() {
    return new _WebAudioStreamingSoundInstance(this, this._options);
  }
  _connect(node) {
    var _a;
    const connected = super._connect(node);
    if (!connected) {
      return false;
    }
    if (node.inNode) {
      (_a = this.outNode) == null ? void 0 : _a.connect(node.inNode);
    }
    return true;
  }
  _disconnect(node) {
    var _a;
    const disconnected = super._disconnect(node);
    if (!disconnected) {
      return false;
    }
    if (node.inNode) {
      (_a = this.outNode) == null ? void 0 : _a.disconnect(node.inNode);
    }
    return true;
  }
  _initSpatialProperty() {
    if (!this._spatial) {
      this._spatial = new _SpatialWebAudio(this._subGraph, this._spatialAutoUpdate, this._spatialMinUpdateTime);
    }
    return this._spatial;
  }
};
_WebAudioStreamingSound._SubGraph = class extends _WebAudioBusAndSoundSubGraph {
  get _downstreamNodes() {
    return this._owner._downstreamNodes ?? null;
  }
  get _upstreamNodes() {
    return this._owner._upstreamNodes ?? null;
  }
};
var _WebAudioStreamingSoundInstance = class extends _StreamingSoundInstance {
  constructor(sound, options) {
    super(sound);
    this._currentTimeChangedWhilePaused = false;
    this._enginePlayTime = Infinity;
    this._enginePauseTime = 0;
    this._isReady = false;
    this._isReadyPromise = new Promise((resolve, reject) => {
      this._resolveIsReadyPromise = resolve;
      this._rejectIsReadyPromise = reject;
    });
    this._onCanPlayThrough = () => {
      this._isReady = true;
      this._resolveIsReadyPromise(this._mediaElement);
      this.onReadyObservable.notifyObservers(this);
    };
    this._onEnded = () => {
      this.onEndedObservable.notifyObservers(this);
      this.dispose();
    };
    this._onError = (reason) => {
      this._setState(
        4
        /* SoundState.FailedToStart */
      );
      this.onErrorObservable.notifyObservers(reason);
      this._rejectIsReadyPromise(reason);
      this.dispose();
    };
    this._onEngineStateChanged = () => {
      if (this.engine.state !== "running") {
        return;
      }
      if (this._options.loop && this.state === 2) {
        this.play();
      }
      this.engine.stateChangedObservable.removeCallback(this._onEngineStateChanged);
    };
    this._onUserGesture = () => {
      this.play();
    };
    this._options = options;
    this._volumeNode = new GainNode(sound.audioContext);
    if (typeof sound.source === "string") {
      this._initFromUrl(sound.source);
    } else if (Array.isArray(sound.source)) {
      this._initFromUrls(sound.source);
    } else if (sound.source instanceof HTMLMediaElement) {
      this._initFromMediaElement(sound.source);
    }
  }
  /** @internal */
  get currentTime() {
    if (this._state === 1) {
      return 0;
    }
    const timeSinceLastStart = this._state === 5 ? 0 : this.engine.currentTime - this._enginePlayTime;
    return this._enginePauseTime + timeSinceLastStart + this._options.startOffset;
  }
  set currentTime(value) {
    const restart = this._state === 2 || this._state === 3;
    if (restart) {
      this._mediaElement.pause();
      this._setState(
        1
        /* SoundState.Stopped */
      );
    }
    this._options.startOffset = value;
    if (restart) {
      this.play({ startOffset: value });
    } else if (this._state === 5) {
      this._currentTimeChangedWhilePaused = true;
    }
  }
  get outNode() {
    return this._volumeNode;
  }
  /** @internal */
  get startTime() {
    if (this._state === 1) {
      return 0;
    }
    return this._enginePlayTime;
  }
  /** @internal */
  dispose() {
    var _a;
    super.dispose();
    this.stop();
    (_a = this._sourceNode) == null ? void 0 : _a.disconnect(this._volumeNode);
    this._sourceNode = null;
    this._mediaElement.removeEventListener("error", this._onError);
    this._mediaElement.removeEventListener("ended", this._onEnded);
    this._mediaElement.removeEventListener("canplaythrough", this._onCanPlayThrough);
    for (const source of Array.from(this._mediaElement.children)) {
      this._mediaElement.removeChild(source);
    }
    this.engine.stateChangedObservable.removeCallback(this._onEngineStateChanged);
    this.engine.userGestureObservable.removeCallback(this._onUserGesture);
  }
  /** @internal */
  play(options = {}) {
    if (this._state === 3) {
      return;
    }
    if (options.loop !== void 0) {
      this._options.loop = options.loop;
    }
    this._mediaElement.loop = this._options.loop;
    let startOffset = options.startOffset;
    if (this._currentTimeChangedWhilePaused) {
      startOffset = this._options.startOffset;
      this._currentTimeChangedWhilePaused = false;
    } else if (this._state === 5) {
      startOffset = this.currentTime + this._options.startOffset;
    }
    if (startOffset && startOffset > 0) {
      this._mediaElement.currentTime = startOffset;
    }
    this._volumeNode.gain.value = options.volume ?? 1;
    this._play();
  }
  /** @internal */
  pause() {
    if (this._state !== 2 && this._state !== 3) {
      return;
    }
    this._setState(
      5
      /* SoundState.Paused */
    );
    this._enginePauseTime += this.engine.currentTime - this._enginePlayTime;
    this._mediaElement.pause();
  }
  /** @internal */
  resume() {
    if (this._state === 5) {
      this.play();
    } else if (this._currentTimeChangedWhilePaused) {
      this.play();
    }
  }
  /** @internal */
  stop() {
    if (this._state === 1) {
      return;
    }
    this._stop();
  }
  /** @internal */
  getClassName() {
    return "_WebAudioStreamingSoundInstance";
  }
  _connect(node) {
    var _a;
    const connected = super._connect(node);
    if (!connected) {
      return false;
    }
    if (node instanceof _WebAudioStreamingSound && node.inNode) {
      (_a = this.outNode) == null ? void 0 : _a.connect(node.inNode);
    }
    return true;
  }
  _disconnect(node) {
    var _a;
    const disconnected = super._disconnect(node);
    if (!disconnected) {
      return false;
    }
    if (node instanceof _WebAudioStreamingSound && node.inNode) {
      (_a = this.outNode) == null ? void 0 : _a.disconnect(node.inNode);
    }
    return true;
  }
  _initFromMediaElement(mediaElement) {
    Tools.SetCorsBehavior(mediaElement.currentSrc, mediaElement);
    mediaElement.controls = false;
    mediaElement.loop = this._options.loop;
    mediaElement.preload = "auto";
    mediaElement.addEventListener("canplaythrough", this._onCanPlayThrough, { once: true });
    mediaElement.addEventListener("ended", this._onEnded, { once: true });
    mediaElement.addEventListener("error", this._onError, { once: true });
    mediaElement.load();
    this._sourceNode = new MediaElementAudioSourceNode(this._sound.audioContext, { mediaElement });
    this._sourceNode.connect(this._volumeNode);
    if (!this._connect(this._sound)) {
      throw new Error("Connect failed");
    }
    this._mediaElement = mediaElement;
  }
  _initFromUrl(url) {
    const audio = new Audio(_CleanUrl(url));
    this._initFromMediaElement(audio);
  }
  _initFromUrls(urls) {
    const audio = new Audio();
    for (const url of urls) {
      const source = document.createElement("source");
      source.src = _CleanUrl(url);
      audio.appendChild(source);
    }
    this._initFromMediaElement(audio);
  }
  _play() {
    this._setState(
      2
      /* SoundState.Starting */
    );
    if (!this._isReady) {
      this._playWhenReady();
      return;
    }
    if (this._state !== 2) {
      return;
    }
    if (this.engine.state === "running") {
      const result = this._mediaElement.play();
      this._enginePlayTime = this.engine.currentTime;
      this._setState(
        3
        /* SoundState.Started */
      );
      result.catch(() => {
        this._setState(
          4
          /* SoundState.FailedToStart */
        );
        if (this._options.loop) {
          this.engine.userGestureObservable.addOnce(this._onUserGesture);
        }
      });
    } else if (this._options.loop) {
      this.engine.stateChangedObservable.add(this._onEngineStateChanged);
    } else {
      this.stop();
      this._setState(
        4
        /* SoundState.FailedToStart */
      );
    }
  }
  _playWhenReady() {
    this._isReadyPromise.then(() => {
      this._play();
    }).catch(() => {
      Logger.Error("Streaming sound instance failed to play");
      this._setState(
        4
        /* SoundState.FailedToStart */
      );
    });
  }
  _stop() {
    this._mediaElement.pause();
    this._setState(
      1
      /* SoundState.Stopped */
    );
    this._onEnded();
    this.engine.stateChangedObservable.removeCallback(this._onEngineStateChanged);
  }
};

export {
  StreamingSound,
  _WebAudioStreamingSound
};
//# sourceMappingURL=chunk-DP7GZ4BU.js.map
