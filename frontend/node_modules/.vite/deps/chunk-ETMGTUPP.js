import {
  SerializationHelper,
  Size
} from "./chunk-GY7MF23I.js";
import {
  __decorate,
  serialize
} from "./chunk-3FJRTHLS.js";
import {
  Color3,
  Color4
} from "./chunk-YZQDNKZM.js";
import {
  Matrix,
  Quaternion,
  TmpVectors,
  Vector2,
  Vector3
} from "./chunk-NSQZ6PEP.js";
import {
  WebRequest
} from "./chunk-2ZEUD233.js";
import {
  RegisterClass
} from "./chunk-LMH7SWDS.js";
import {
  Hermite,
  Lerp
} from "./chunk-X4PSP3XC.js";
import {
  _WarnImport
} from "./chunk-4GUORC2E.js";
import {
  EngineStore
} from "./chunk-AYMFJBP3.js";
import {
  Observable
} from "./chunk-GWFZRJMO.js";

// node_modules/@babylonjs/core/Animations/animationRange.js
var AnimationRange = class _AnimationRange {
  /**
   * Initializes the range of an animation
   * @param name The name of the animation range
   * @param from The starting frame of the animation
   * @param to The ending frame of the animation
   */
  constructor(name, from, to) {
    this.name = name;
    this.from = from;
    this.to = to;
  }
  /**
   * Makes a copy of the animation range
   * @returns A copy of the animation range
   */
  clone() {
    return new _AnimationRange(this.name, this.from, this.to);
  }
};

// node_modules/@babylonjs/core/node.js
var _InternalNodeDataInfo = class {
  constructor() {
    this._doNotSerialize = false;
    this._isDisposed = false;
    this._sceneRootNodesIndex = -1;
    this._isEnabled = true;
    this._isParentEnabled = true;
    this._isReady = true;
    this._onEnabledStateChangedObservable = new Observable();
    this._onClonedObservable = new Observable();
  }
};
var Node = class _Node {
  /**
   * Add a new node constructor
   * @param type defines the type name of the node to construct
   * @param constructorFunc defines the constructor function
   */
  static AddNodeConstructor(type, constructorFunc) {
    this._NodeConstructors[type] = constructorFunc;
  }
  /**
   * Returns a node constructor based on type name
   * @param type defines the type name
   * @param name defines the new node name
   * @param scene defines the hosting scene
   * @param options defines optional options to transmit to constructors
   * @returns the new constructor or null
   */
  static Construct(type, name, scene, options) {
    const constructorFunc = this._NodeConstructors[type];
    if (!constructorFunc) {
      return null;
    }
    return constructorFunc(name, scene, options);
  }
  /**
   * Gets or sets the accessibility tag to describe the node for accessibility purpose.
   */
  set accessibilityTag(value) {
    this._accessibilityTag = value;
    this.onAccessibilityTagChangedObservable.notifyObservers(value);
  }
  get accessibilityTag() {
    return this._accessibilityTag;
  }
  /**
   * Gets or sets a boolean used to define if the node must be serialized
   */
  get doNotSerialize() {
    if (this._nodeDataStorage._doNotSerialize) {
      return true;
    }
    if (this._parentNode) {
      return this._parentNode.doNotSerialize;
    }
    return false;
  }
  set doNotSerialize(value) {
    this._nodeDataStorage._doNotSerialize = value;
  }
  /**
   * Gets a boolean indicating if the node has been disposed
   * @returns true if the node was disposed
   */
  isDisposed() {
    return this._nodeDataStorage._isDisposed;
  }
  /**
   * Gets or sets the parent of the node (without keeping the current position in the scene)
   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/transforms/parent_pivot/parent
   */
  set parent(parent) {
    if (this._parentNode === parent) {
      return;
    }
    const previousParentNode = this._parentNode;
    if (this._parentNode && this._parentNode._children !== void 0 && this._parentNode._children !== null) {
      const index = this._parentNode._children.indexOf(this);
      if (index !== -1) {
        this._parentNode._children.splice(index, 1);
      }
      if (!parent && !this._nodeDataStorage._isDisposed) {
        this._addToSceneRootNodes();
      }
    }
    this._parentNode = parent;
    this._isDirty = true;
    if (this._parentNode) {
      if (this._parentNode._children === void 0 || this._parentNode._children === null) {
        this._parentNode._children = new Array();
      }
      this._parentNode._children.push(this);
      if (!previousParentNode) {
        this._removeFromSceneRootNodes();
      }
    }
    this._syncParentEnabledState();
  }
  get parent() {
    return this._parentNode;
  }
  /**
   * @internal
   */
  _serializeAsParent(serializationObject) {
    serializationObject.parentId = this.uniqueId;
  }
  /** @internal */
  _addToSceneRootNodes() {
    if (this._nodeDataStorage._sceneRootNodesIndex === -1) {
      this._nodeDataStorage._sceneRootNodesIndex = this._scene.rootNodes.length;
      this._scene.rootNodes.push(this);
    }
  }
  /** @internal */
  _removeFromSceneRootNodes() {
    if (this._nodeDataStorage._sceneRootNodesIndex !== -1) {
      const rootNodes = this._scene.rootNodes;
      const lastIdx = rootNodes.length - 1;
      rootNodes[this._nodeDataStorage._sceneRootNodesIndex] = rootNodes[lastIdx];
      rootNodes[this._nodeDataStorage._sceneRootNodesIndex]._nodeDataStorage._sceneRootNodesIndex = this._nodeDataStorage._sceneRootNodesIndex;
      this._scene.rootNodes.pop();
      this._nodeDataStorage._sceneRootNodesIndex = -1;
    }
  }
  /**
   * Gets or sets the animation properties override
   */
  get animationPropertiesOverride() {
    if (!this._animationPropertiesOverride) {
      return this._scene.animationPropertiesOverride;
    }
    return this._animationPropertiesOverride;
  }
  set animationPropertiesOverride(value) {
    this._animationPropertiesOverride = value;
  }
  /**
   * Gets a string identifying the name of the class
   * @returns "Node" string
   */
  getClassName() {
    return "Node";
  }
  /**
   * Sets a callback that will be raised when the node will be disposed
   */
  set onDispose(callback) {
    if (this._onDisposeObserver) {
      this.onDisposeObservable.remove(this._onDisposeObserver);
    }
    this._onDisposeObserver = this.onDisposeObservable.add(callback);
  }
  /**
   * An event triggered when the enabled state of the node changes
   */
  get onEnabledStateChangedObservable() {
    return this._nodeDataStorage._onEnabledStateChangedObservable;
  }
  /**
   * An event triggered when the node is cloned
   */
  get onClonedObservable() {
    return this._nodeDataStorage._onClonedObservable;
  }
  /**
   * Creates a new Node
   * @param name the name and id to be given to this node
   * @param scene the scene this node will be added to
   * @param isPure indicates this Node is just a Node, and not a derived class like Mesh or Camera
   */
  constructor(name, scene = null, isPure = true) {
    this._isDirty = false;
    this._nodeDataStorage = new _InternalNodeDataInfo();
    this.state = "";
    this.metadata = null;
    this.reservedDataStore = null;
    this._accessibilityTag = null;
    this.onAccessibilityTagChangedObservable = new Observable();
    this._parentContainer = null;
    this.animations = [];
    this._ranges = {};
    this.onReady = null;
    this._currentRenderId = -1;
    this._parentUpdateId = -1;
    this._childUpdateId = -1;
    this._waitingParentId = null;
    this._waitingParentInstanceIndex = null;
    this._waitingParsedUniqueId = null;
    this._cache = {};
    this._parentNode = null;
    this._children = null;
    this._worldMatrix = Matrix.Identity();
    this._worldMatrixDeterminant = 0;
    this._worldMatrixDeterminantIsDirty = true;
    this._animationPropertiesOverride = null;
    this._isNode = true;
    this.onDisposeObservable = new Observable();
    this._onDisposeObserver = null;
    this._behaviors = new Array();
    this.name = name;
    this.id = name;
    this._scene = scene || EngineStore.LastCreatedScene;
    this.uniqueId = this._scene.getUniqueId();
    this._initCache();
    if (isPure) {
      this._addToSceneRootNodes();
    }
  }
  /**
   * Gets the scene of the node
   * @returns a scene
   */
  getScene() {
    return this._scene;
  }
  /**
   * Gets the engine of the node
   * @returns a Engine
   */
  getEngine() {
    return this._scene.getEngine();
  }
  /**
   * Attach a behavior to the node
   * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors
   * @param behavior defines the behavior to attach
   * @param attachImmediately defines that the behavior must be attached even if the scene is still loading
   * @returns the current Node
   */
  addBehavior(behavior, attachImmediately = false) {
    const index = this._behaviors.indexOf(behavior);
    if (index !== -1) {
      return this;
    }
    behavior.init();
    if (this._scene.isLoading && !attachImmediately) {
      this._scene.onDataLoadedObservable.addOnce(() => {
        behavior.attach(this);
      });
    } else {
      behavior.attach(this);
    }
    this._behaviors.push(behavior);
    return this;
  }
  /**
   * Remove an attached behavior
   * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors
   * @param behavior defines the behavior to attach
   * @returns the current Node
   */
  removeBehavior(behavior) {
    const index = this._behaviors.indexOf(behavior);
    if (index === -1) {
      return this;
    }
    this._behaviors[index].detach();
    this._behaviors.splice(index, 1);
    return this;
  }
  /**
   * Gets the list of attached behaviors
   * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors
   */
  get behaviors() {
    return this._behaviors;
  }
  /**
   * Gets an attached behavior by name
   * @param name defines the name of the behavior to look for
   * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors
   * @returns null if behavior was not found else the requested behavior
   */
  getBehaviorByName(name) {
    for (const behavior of this._behaviors) {
      if (behavior.name === name) {
        return behavior;
      }
    }
    return null;
  }
  /**
   * Returns the latest update of the World matrix
   * @returns a Matrix
   */
  getWorldMatrix() {
    if (this._currentRenderId !== this._scene.getRenderId()) {
      this.computeWorldMatrix();
    }
    return this._worldMatrix;
  }
  /** @internal */
  _getWorldMatrixDeterminant() {
    if (this._worldMatrixDeterminantIsDirty) {
      this._worldMatrixDeterminantIsDirty = false;
      this._worldMatrixDeterminant = this._worldMatrix.determinant();
    }
    return this._worldMatrixDeterminant;
  }
  /**
   * Returns directly the latest state of the mesh World matrix.
   * A Matrix is returned.
   */
  get worldMatrixFromCache() {
    return this._worldMatrix;
  }
  // override it in derived class if you add new variables to the cache
  // and call the parent class method
  /** @internal */
  _initCache() {
    this._cache = {};
  }
  /**
   * @internal
   */
  updateCache(force) {
    if (!force && this.isSynchronized()) {
      return;
    }
    this._updateCache();
  }
  /**
   * @internal
   */
  _getActionManagerForTrigger(trigger, _initialCall = true) {
    if (!this.parent) {
      return null;
    }
    return this.parent._getActionManagerForTrigger(trigger, false);
  }
  // override it in derived class if you add new variables to the cache
  // and call the parent class method if !ignoreParentClass
  /**
   * @internal
   */
  _updateCache(_ignoreParentClass) {
  }
  // override it in derived class if you add new variables to the cache
  /** @internal */
  _isSynchronized() {
    return true;
  }
  /** @internal */
  _markSyncedWithParent() {
    if (this._parentNode) {
      this._parentUpdateId = this._parentNode._childUpdateId;
    }
  }
  /** @internal */
  isSynchronizedWithParent() {
    if (!this._parentNode) {
      return true;
    }
    if (this._parentNode._isDirty || this._parentUpdateId !== this._parentNode._childUpdateId) {
      return false;
    }
    return this._parentNode.isSynchronized();
  }
  /** @internal */
  isSynchronized() {
    if (this._parentNode && !this.isSynchronizedWithParent()) {
      return false;
    }
    return this._isSynchronized();
  }
  /**
   * Is this node ready to be used/rendered
   * @param _completeCheck defines if a complete check (including materials and lights) has to be done (false by default)
   * @returns true if the node is ready
   */
  isReady(_completeCheck = false) {
    return this._nodeDataStorage._isReady;
  }
  /**
   * Flag the  node as dirty (Forcing it to update everything)
   * @param _property helps children apply precise "dirtyfication"
   * @returns this node
   */
  markAsDirty(_property) {
    this._currentRenderId = Number.MAX_VALUE;
    this._isDirty = true;
    return this;
  }
  /**
   * Is this node enabled?
   * If the node has a parent, all ancestors will be checked and false will be returned if any are false (not enabled), otherwise will return true
   * @param checkAncestors indicates if this method should check the ancestors. The default is to check the ancestors. If set to false, the method will return the value of this node without checking ancestors
   * @returns whether this node (and its parent) is enabled
   */
  isEnabled(checkAncestors = true) {
    if (checkAncestors === false) {
      return this._nodeDataStorage._isEnabled;
    }
    if (!this._nodeDataStorage._isEnabled) {
      return false;
    }
    return this._nodeDataStorage._isParentEnabled;
  }
  /** @internal */
  _syncParentEnabledState() {
    this._nodeDataStorage._isParentEnabled = this._parentNode ? this._parentNode.isEnabled() : true;
    if (this._children) {
      this._children.forEach((c) => {
        c._syncParentEnabledState();
      });
    }
  }
  /**
   * Set the enabled state of this node
   * @param value defines the new enabled state
   */
  setEnabled(value) {
    if (this._nodeDataStorage._isEnabled === value) {
      return;
    }
    this._nodeDataStorage._isEnabled = value;
    this._syncParentEnabledState();
    this._nodeDataStorage._onEnabledStateChangedObservable.notifyObservers(value);
  }
  /**
   * Is this node a descendant of the given node?
   * The function will iterate up the hierarchy until the ancestor was found or no more parents defined
   * @param ancestor defines the parent node to inspect
   * @returns a boolean indicating if this node is a descendant of the given node
   */
  isDescendantOf(ancestor) {
    if (this.parent) {
      if (this.parent === ancestor) {
        return true;
      }
      return this.parent.isDescendantOf(ancestor);
    }
    return false;
  }
  /**
   * @internal
   */
  _getDescendants(results, directDescendantsOnly = false, predicate) {
    if (!this._children) {
      return;
    }
    for (let index = 0; index < this._children.length; index++) {
      const item = this._children[index];
      if (!predicate || predicate(item)) {
        results.push(item);
      }
      if (!directDescendantsOnly) {
        item._getDescendants(results, false, predicate);
      }
    }
  }
  /**
   * Will return all nodes that have this node as ascendant
   * @param directDescendantsOnly defines if true only direct descendants of 'this' will be considered, if false direct and also indirect (children of children, an so on in a recursive manner) descendants of 'this' will be considered
   * @param predicate defines an optional predicate that will be called on every evaluated child, the predicate must return true for a given child to be part of the result, otherwise it will be ignored
   * @returns all children nodes of all types
   */
  getDescendants(directDescendantsOnly, predicate) {
    const results = [];
    this._getDescendants(results, directDescendantsOnly, predicate);
    return results;
  }
  /**
   * Get all child-meshes of this node
   * @param directDescendantsOnly defines if true only direct descendants of 'this' will be considered, if false direct and also indirect (children of children, an so on in a recursive manner) descendants of 'this' will be considered (Default: false)
   * @param predicate defines an optional predicate that will be called on every evaluated child, the predicate must return true for a given child to be part of the result, otherwise it will be ignored
   * @returns an array of AbstractMesh
   */
  getChildMeshes(directDescendantsOnly, predicate) {
    const results = [];
    this._getDescendants(results, directDescendantsOnly, (node) => {
      return (!predicate || predicate(node)) && node.cullingStrategy !== void 0;
    });
    return results;
  }
  /**
   * Get all direct children of this node
   * @param predicate defines an optional predicate that will be called on every evaluated child, the predicate must return true for a given child to be part of the result, otherwise it will be ignored
   * @param directDescendantsOnly defines if true only direct descendants of 'this' will be considered, if false direct and also indirect (children of children, an so on in a recursive manner) descendants of 'this' will be considered (Default: true)
   * @returns an array of Node
   */
  getChildren(predicate, directDescendantsOnly = true) {
    return this.getDescendants(directDescendantsOnly, predicate);
  }
  /**
   * @internal
   */
  _setReady(state) {
    if (state === this._nodeDataStorage._isReady) {
      return;
    }
    if (!state) {
      this._nodeDataStorage._isReady = false;
      return;
    }
    if (this.onReady) {
      this.onReady(this);
    }
    this._nodeDataStorage._isReady = true;
  }
  /**
   * Get an animation by name
   * @param name defines the name of the animation to look for
   * @returns null if not found else the requested animation
   */
  getAnimationByName(name) {
    for (let i = 0; i < this.animations.length; i++) {
      const animation = this.animations[i];
      if (animation.name === name) {
        return animation;
      }
    }
    return null;
  }
  /**
   * Creates an animation range for this node
   * @param name defines the name of the range
   * @param from defines the starting key
   * @param to defines the end key
   */
  createAnimationRange(name, from, to) {
    if (!this._ranges[name]) {
      this._ranges[name] = _Node._AnimationRangeFactory(name, from, to);
      for (let i = 0, nAnimations = this.animations.length; i < nAnimations; i++) {
        if (this.animations[i]) {
          this.animations[i].createRange(name, from, to);
        }
      }
    }
  }
  /**
   * Delete a specific animation range
   * @param name defines the name of the range to delete
   * @param deleteFrames defines if animation frames from the range must be deleted as well
   */
  deleteAnimationRange(name, deleteFrames = true) {
    for (let i = 0, nAnimations = this.animations.length; i < nAnimations; i++) {
      if (this.animations[i]) {
        this.animations[i].deleteRange(name, deleteFrames);
      }
    }
    this._ranges[name] = null;
  }
  /**
   * Get an animation range by name
   * @param name defines the name of the animation range to look for
   * @returns null if not found else the requested animation range
   */
  getAnimationRange(name) {
    return this._ranges[name] || null;
  }
  /**
   * Clone the current node
   * @param name Name of the new clone
   * @param newParent New parent for the clone
   * @param doNotCloneChildren Do not clone children hierarchy
   * @returns the new transform node
   */
  clone(name, newParent, doNotCloneChildren) {
    const result = SerializationHelper.Clone(() => new _Node(name, this.getScene()), this);
    if (newParent) {
      result.parent = newParent;
    }
    if (!doNotCloneChildren) {
      const directDescendants = this.getDescendants(true);
      for (let index = 0; index < directDescendants.length; index++) {
        const child = directDescendants[index];
        child.clone(name + "." + child.name, result);
      }
    }
    return result;
  }
  /**
   * Gets the list of all animation ranges defined on this node
   * @returns an array
   */
  getAnimationRanges() {
    const animationRanges = [];
    let name;
    for (name in this._ranges) {
      animationRanges.push(this._ranges[name]);
    }
    return animationRanges;
  }
  /**
   * Will start the animation sequence
   * @param name defines the range frames for animation sequence
   * @param loop defines if the animation should loop (false by default)
   * @param speedRatio defines the speed factor in which to run the animation (1 by default)
   * @param onAnimationEnd defines a function to be executed when the animation ended (undefined by default)
   * @returns the object created for this animation. If range does not exist, it will return null
   */
  beginAnimation(name, loop, speedRatio, onAnimationEnd) {
    const range = this.getAnimationRange(name);
    if (!range) {
      return null;
    }
    return this._scene.beginAnimation(this, range.from, range.to, loop, speedRatio, onAnimationEnd);
  }
  /**
   * Serialize animation ranges into a JSON compatible object
   * @returns serialization object
   */
  serializeAnimationRanges() {
    const serializationRanges = [];
    for (const name in this._ranges) {
      const localRange = this._ranges[name];
      if (!localRange) {
        continue;
      }
      const range = {};
      range.name = name;
      range.from = localRange.from;
      range.to = localRange.to;
      serializationRanges.push(range);
    }
    return serializationRanges;
  }
  /**
   * Computes the world matrix of the node
   * @param _force defines if the cache version should be invalidated forcing the world matrix to be created from scratch
   * @returns the world matrix
   */
  computeWorldMatrix(_force) {
    if (!this._worldMatrix) {
      this._worldMatrix = Matrix.Identity();
    }
    return this._worldMatrix;
  }
  /**
   * Releases resources associated with this node.
   * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)
   * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)
   */
  dispose(doNotRecurse, disposeMaterialAndTextures = false) {
    this._nodeDataStorage._isDisposed = true;
    if (!doNotRecurse) {
      const nodes = this.getDescendants(true);
      for (const node of nodes) {
        node.dispose(doNotRecurse, disposeMaterialAndTextures);
      }
    }
    if (!this.parent) {
      this._removeFromSceneRootNodes();
    } else {
      this.parent = null;
    }
    this.onDisposeObservable.notifyObservers(this);
    this.onDisposeObservable.clear();
    this.onEnabledStateChangedObservable.clear();
    this.onClonedObservable.clear();
    for (const behavior of this._behaviors) {
      behavior.detach();
    }
    this._behaviors.length = 0;
    this.metadata = null;
  }
  /**
   * Parse animation range data from a serialization object and store them into a given node
   * @param node defines where to store the animation ranges
   * @param parsedNode defines the serialization object to read data from
   * @param _scene defines the hosting scene
   */
  static ParseAnimationRanges(node, parsedNode, _scene) {
    if (parsedNode.ranges) {
      for (let index = 0; index < parsedNode.ranges.length; index++) {
        const data = parsedNode.ranges[index];
        node.createAnimationRange(data.name, data.from, data.to);
      }
    }
  }
  /**
   * Return the minimum and maximum world vectors of the entire hierarchy under current node
   * @param includeDescendants Include bounding info from descendants as well (true by default)
   * @param predicate defines a callback function that can be customize to filter what meshes should be included in the list used to compute the bounding vectors
   * @returns the new bounding vectors
   */
  getHierarchyBoundingVectors(includeDescendants = true, predicate = null) {
    this.getScene().incrementRenderId();
    this.computeWorldMatrix(true);
    let min;
    let max;
    const thisAbstractMesh = this;
    if (thisAbstractMesh.getBoundingInfo && thisAbstractMesh.subMeshes) {
      const boundingInfo = thisAbstractMesh.getBoundingInfo();
      min = boundingInfo.boundingBox.minimumWorld.clone();
      max = boundingInfo.boundingBox.maximumWorld.clone();
    } else {
      min = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
      max = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
    }
    if (includeDescendants) {
      const descendants = this.getDescendants(false);
      for (const descendant of descendants) {
        const childMesh = descendant;
        childMesh.computeWorldMatrix(true);
        if (predicate && !predicate(childMesh)) {
          continue;
        }
        if (!childMesh.getBoundingInfo || childMesh.getTotalVertices() === 0) {
          continue;
        }
        const childBoundingInfo = childMesh.getBoundingInfo();
        const boundingBox = childBoundingInfo.boundingBox;
        const minBox = boundingBox.minimumWorld;
        const maxBox = boundingBox.maximumWorld;
        Vector3.CheckExtends(minBox, min, max);
        Vector3.CheckExtends(maxBox, min, max);
      }
    }
    return {
      min,
      max
    };
  }
};
Node._AnimationRangeFactory = (_name, _from, _to) => {
  throw _WarnImport("AnimationRange");
};
Node._NodeConstructors = {};
__decorate([
  serialize()
], Node.prototype, "name", void 0);
__decorate([
  serialize()
], Node.prototype, "id", void 0);
__decorate([
  serialize()
], Node.prototype, "uniqueId", void 0);
__decorate([
  serialize()
], Node.prototype, "state", void 0);
__decorate([
  serialize()
], Node.prototype, "metadata", void 0);

// node_modules/@babylonjs/core/Animations/animation.js
var _staticOffsetValueQuaternion = Object.freeze(new Quaternion(0, 0, 0, 0));
var _staticOffsetValueVector3 = Object.freeze(Vector3.Zero());
var _staticOffsetValueVector2 = Object.freeze(Vector2.Zero());
var _staticOffsetValueSize = Object.freeze(Size.Zero());
var _staticOffsetValueColor3 = Object.freeze(Color3.Black());
var _staticOffsetValueColor4 = Object.freeze(new Color4(0, 0, 0, 0));
var evaluateAnimationState = {
  key: 0,
  repeatCount: 0,
  loopMode: 2
};
var Animation = class _Animation {
  /**
   * @internal Internal use
   */
  static _PrepareAnimation(name, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction) {
    let dataType = void 0;
    if (!isNaN(parseFloat(from)) && isFinite(from)) {
      dataType = _Animation.ANIMATIONTYPE_FLOAT;
    } else if (from instanceof Quaternion) {
      dataType = _Animation.ANIMATIONTYPE_QUATERNION;
    } else if (from instanceof Vector3) {
      dataType = _Animation.ANIMATIONTYPE_VECTOR3;
    } else if (from instanceof Vector2) {
      dataType = _Animation.ANIMATIONTYPE_VECTOR2;
    } else if (from instanceof Color3) {
      dataType = _Animation.ANIMATIONTYPE_COLOR3;
    } else if (from instanceof Color4) {
      dataType = _Animation.ANIMATIONTYPE_COLOR4;
    } else if (from instanceof Size) {
      dataType = _Animation.ANIMATIONTYPE_SIZE;
    }
    if (dataType == void 0) {
      return null;
    }
    const animation = new _Animation(name, targetProperty, framePerSecond, dataType, loopMode);
    const keys = [
      { frame: 0, value: from },
      { frame: totalFrame, value: to }
    ];
    animation.setKeys(keys);
    if (easingFunction !== void 0) {
      animation.setEasingFunction(easingFunction);
    }
    return animation;
  }
  /**
   * Sets up an animation
   * @param property The property to animate
   * @param animationType The animation type to apply
   * @param framePerSecond The frames per second of the animation
   * @param easingFunction The easing function used in the animation
   * @returns The created animation
   */
  static CreateAnimation(property, animationType, framePerSecond, easingFunction) {
    const animation = new _Animation(property + "Animation", property, framePerSecond, animationType, _Animation.ANIMATIONLOOPMODE_CONSTANT);
    animation.setEasingFunction(easingFunction);
    return animation;
  }
  /**
   * Create and start an animation on a node
   * @param name defines the name of the global animation that will be run on all nodes
   * @param target defines the target where the animation will take place
   * @param targetProperty defines property to animate
   * @param framePerSecond defines the number of frame per second yo use
   * @param totalFrame defines the number of frames in total
   * @param from defines the initial value
   * @param to defines the final value
   * @param loopMode defines which loop mode you want to use (off by default)
   * @param easingFunction defines the easing function to use (linear by default)
   * @param onAnimationEnd defines the callback to call when animation end
   * @param scene defines the hosting scene
   * @returns the animatable created for this animation
   */
  static CreateAndStartAnimation(name, target, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction, onAnimationEnd, scene) {
    const animation = _Animation._PrepareAnimation(name, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction);
    if (!animation) {
      return null;
    }
    if (target.getScene) {
      scene = target.getScene();
    }
    if (!scene) {
      return null;
    }
    return scene.beginDirectAnimation(target, [animation], 0, totalFrame, animation.loopMode !== _Animation.ANIMATIONLOOPMODE_CONSTANT, 1, onAnimationEnd);
  }
  /**
   * Create and start an animation on a node and its descendants
   * @param name defines the name of the global animation that will be run on all nodes
   * @param node defines the root node where the animation will take place
   * @param directDescendantsOnly if true only direct descendants will be used, if false direct and also indirect (children of children, an so on in a recursive manner) descendants will be used
   * @param targetProperty defines property to animate
   * @param framePerSecond defines the number of frame per second to use
   * @param totalFrame defines the number of frames in total
   * @param from defines the initial value
   * @param to defines the final value
   * @param loopMode defines which loop mode you want to use (off by default)
   * @param easingFunction defines the easing function to use (linear by default)
   * @param onAnimationEnd defines the callback to call when an animation ends (will be called once per node)
   * @returns the list of animatables created for all nodes
   * @example https://www.babylonjs-playground.com/#MH0VLI
   */
  static CreateAndStartHierarchyAnimation(name, node, directDescendantsOnly, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction, onAnimationEnd) {
    const animation = _Animation._PrepareAnimation(name, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction);
    if (!animation) {
      return null;
    }
    const scene = node.getScene();
    return scene.beginDirectHierarchyAnimation(node, directDescendantsOnly, [animation], 0, totalFrame, animation.loopMode === 1, 1, onAnimationEnd);
  }
  /**
   * Creates a new animation, merges it with the existing animations and starts it
   * @param name Name of the animation
   * @param node Node which contains the scene that begins the animations
   * @param targetProperty Specifies which property to animate
   * @param framePerSecond The frames per second of the animation
   * @param totalFrame The total number of frames
   * @param from The frame at the beginning of the animation
   * @param to The frame at the end of the animation
   * @param loopMode Specifies the loop mode of the animation
   * @param easingFunction (Optional) The easing function of the animation, which allow custom mathematical formulas for animations
   * @param onAnimationEnd Callback to run once the animation is complete
   * @returns Nullable animation
   */
  static CreateMergeAndStartAnimation(name, node, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction, onAnimationEnd) {
    const animation = _Animation._PrepareAnimation(name, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction);
    if (!animation) {
      return null;
    }
    node.animations.push(animation);
    return node.getScene().beginAnimation(node, 0, totalFrame, animation.loopMode === 1, 1, onAnimationEnd);
  }
  /** @internal */
  static MakeAnimationAdditive(sourceAnimation, referenceFrameOrOptions, range, cloneOriginal = false, clonedName) {
    let options;
    if (typeof referenceFrameOrOptions === "object") {
      options = referenceFrameOrOptions;
    } else {
      options = {
        referenceFrame: referenceFrameOrOptions ?? 0,
        range,
        cloneOriginalAnimation: cloneOriginal,
        clonedAnimationName: clonedName
      };
    }
    let animation = sourceAnimation;
    if (options.cloneOriginalAnimation) {
      animation = sourceAnimation.clone();
      animation.name = options.clonedAnimationName || animation.name;
    }
    if (!animation._keys.length) {
      return animation;
    }
    const referenceFrame = options.referenceFrame && options.referenceFrame >= 0 ? options.referenceFrame : 0;
    let startIndex = 0;
    const firstKey = animation._keys[0];
    let endIndex = animation._keys.length - 1;
    const lastKey = animation._keys[endIndex];
    const valueStore = {
      referenceValue: firstKey.value,
      referencePosition: TmpVectors.Vector3[0],
      referenceQuaternion: TmpVectors.Quaternion[0],
      referenceScaling: TmpVectors.Vector3[1],
      keyPosition: TmpVectors.Vector3[2],
      keyQuaternion: TmpVectors.Quaternion[1],
      keyScaling: TmpVectors.Vector3[3]
    };
    let from = firstKey.frame;
    let to = lastKey.frame;
    if (options.range) {
      const rangeValue = animation.getRange(options.range);
      if (rangeValue) {
        from = rangeValue.from;
        to = rangeValue.to;
      }
    } else {
      from = options.fromFrame ?? from;
      to = options.toFrame ?? to;
    }
    if (from !== firstKey.frame) {
      startIndex = animation.createKeyForFrame(from);
    }
    if (to !== lastKey.frame) {
      endIndex = animation.createKeyForFrame(to);
    }
    if (animation._keys.length === 1) {
      const value = animation._getKeyValue(animation._keys[0]);
      valueStore.referenceValue = value.clone ? value.clone() : value;
    } else if (referenceFrame <= firstKey.frame) {
      const value = animation._getKeyValue(firstKey.value);
      valueStore.referenceValue = value.clone ? value.clone() : value;
    } else if (referenceFrame >= lastKey.frame) {
      const value = animation._getKeyValue(lastKey.value);
      valueStore.referenceValue = value.clone ? value.clone() : value;
    } else {
      evaluateAnimationState.key = 0;
      const value = animation._interpolate(referenceFrame, evaluateAnimationState);
      valueStore.referenceValue = value.clone ? value.clone() : value;
    }
    if (animation.dataType === _Animation.ANIMATIONTYPE_QUATERNION) {
      valueStore.referenceValue.normalize().conjugateInPlace();
    } else if (animation.dataType === _Animation.ANIMATIONTYPE_MATRIX) {
      valueStore.referenceValue.decompose(valueStore.referenceScaling, valueStore.referenceQuaternion, valueStore.referencePosition);
      valueStore.referenceQuaternion.normalize().conjugateInPlace();
    }
    let startFrame = Number.MAX_VALUE;
    const clippedKeys = options.clipKeys ? [] : null;
    for (let index = startIndex; index <= endIndex; index++) {
      let key = animation._keys[index];
      if (clippedKeys || options.cloneOriginalAnimation) {
        key = {
          frame: key.frame,
          value: key.value.clone ? key.value.clone() : key.value,
          inTangent: key.inTangent,
          outTangent: key.outTangent,
          interpolation: key.interpolation,
          lockedTangent: key.lockedTangent
        };
        if (clippedKeys) {
          if (startFrame === Number.MAX_VALUE) {
            startFrame = key.frame;
          }
          key.frame -= startFrame;
          clippedKeys.push(key);
        }
      }
      if (index && animation.dataType !== _Animation.ANIMATIONTYPE_FLOAT && key.value === firstKey.value) {
        continue;
      }
      switch (animation.dataType) {
        case _Animation.ANIMATIONTYPE_MATRIX:
          key.value.decompose(valueStore.keyScaling, valueStore.keyQuaternion, valueStore.keyPosition);
          valueStore.keyPosition.subtractInPlace(valueStore.referencePosition);
          valueStore.keyScaling.divideInPlace(valueStore.referenceScaling);
          valueStore.referenceQuaternion.multiplyToRef(valueStore.keyQuaternion, valueStore.keyQuaternion);
          Matrix.ComposeToRef(valueStore.keyScaling, valueStore.keyQuaternion, valueStore.keyPosition, key.value);
          break;
        case _Animation.ANIMATIONTYPE_QUATERNION:
          valueStore.referenceValue.multiplyToRef(key.value, key.value);
          break;
        case _Animation.ANIMATIONTYPE_VECTOR2:
        case _Animation.ANIMATIONTYPE_VECTOR3:
        case _Animation.ANIMATIONTYPE_COLOR3:
        case _Animation.ANIMATIONTYPE_COLOR4:
          key.value.subtractToRef(valueStore.referenceValue, key.value);
          break;
        case _Animation.ANIMATIONTYPE_SIZE:
          key.value.width -= valueStore.referenceValue.width;
          key.value.height -= valueStore.referenceValue.height;
          break;
        default:
          key.value -= valueStore.referenceValue;
      }
    }
    if (clippedKeys) {
      animation.setKeys(clippedKeys, true);
    }
    return animation;
  }
  /**
   * Transition property of an host to the target Value
   * @param property The property to transition
   * @param targetValue The target Value of the property
   * @param host The object where the property to animate belongs
   * @param scene Scene used to run the animation
   * @param frameRate Framerate (in frame/s) to use
   * @param transition The transition type we want to use
   * @param duration The duration of the animation, in milliseconds
   * @param onAnimationEnd Callback trigger at the end of the animation
   * @returns Nullable animation
   */
  static TransitionTo(property, targetValue, host, scene, frameRate, transition, duration, onAnimationEnd = null) {
    if (duration <= 0) {
      host[property] = targetValue;
      if (onAnimationEnd) {
        onAnimationEnd();
      }
      return null;
    }
    const endFrame = frameRate * (duration / 1e3);
    transition.setKeys([
      {
        frame: 0,
        value: host[property].clone ? host[property].clone() : host[property]
      },
      {
        frame: endFrame,
        value: targetValue
      }
    ]);
    if (!host.animations) {
      host.animations = [];
    }
    host.animations.push(transition);
    const animation = scene.beginAnimation(host, 0, endFrame, false);
    animation.onAnimationEnd = onAnimationEnd;
    return animation;
  }
  /**
   * Return the array of runtime animations currently using this animation
   */
  get runtimeAnimations() {
    return this._runtimeAnimations;
  }
  /**
   * Specifies if any of the runtime animations are currently running
   */
  get hasRunningRuntimeAnimations() {
    for (const runtimeAnimation of this._runtimeAnimations) {
      if (!runtimeAnimation.isStopped()) {
        return true;
      }
    }
    return false;
  }
  /**
   * Initializes the animation
   * @param name Name of the animation
   * @param targetProperty Property to animate
   * @param framePerSecond The frames per second of the animation
   * @param dataType The data type of the animation
   * @param loopMode The loop mode of the animation
   * @param enableBlending Specifies if blending should be enabled
   */
  constructor(name, targetProperty, framePerSecond, dataType, loopMode, enableBlending) {
    this.name = name;
    this.targetProperty = targetProperty;
    this.framePerSecond = framePerSecond;
    this.dataType = dataType;
    this.loopMode = loopMode;
    this.enableBlending = enableBlending;
    this._easingFunction = null;
    this._runtimeAnimations = new Array();
    this._events = new Array();
    this.blendingSpeed = 0.01;
    this._ranges = {};
    this.targetPropertyPath = targetProperty.split(".");
    this.dataType = dataType;
    this.loopMode = loopMode === void 0 ? _Animation.ANIMATIONLOOPMODE_CYCLE : loopMode;
    this.uniqueId = _Animation._UniqueIdGenerator++;
  }
  // Methods
  /**
   * Converts the animation to a string
   * @param fullDetails support for multiple levels of logging within scene loading
   * @returns String form of the animation
   */
  toString(fullDetails) {
    let ret = "Name: " + this.name + ", property: " + this.targetProperty;
    ret += ", datatype: " + ["Float", "Vector3", "Quaternion", "Matrix", "Color3", "Vector2"][this.dataType];
    ret += ", nKeys: " + (this._keys ? this._keys.length : "none");
    ret += ", nRanges: " + (this._ranges ? Object.keys(this._ranges).length : "none");
    if (fullDetails) {
      ret += ", Ranges: {";
      let first = true;
      for (const name in this._ranges) {
        if (first) {
          ret += ", ";
          first = false;
        }
        ret += name;
      }
      ret += "}";
    }
    return ret;
  }
  /**
   * Add an event to this animation
   * @param event Event to add
   */
  addEvent(event) {
    this._events.push(event);
    this._events.sort((a, b) => a.frame - b.frame);
  }
  /**
   * Remove all events found at the given frame
   * @param frame The frame to remove events from
   */
  removeEvents(frame) {
    for (let index = 0; index < this._events.length; index++) {
      if (this._events[index].frame === frame) {
        this._events.splice(index, 1);
        index--;
      }
    }
  }
  /**
   * Retrieves all the events from the animation
   * @returns Events from the animation
   */
  getEvents() {
    return this._events;
  }
  /**
   * Creates an animation range
   * @param name Name of the animation range
   * @param from Starting frame of the animation range
   * @param to Ending frame of the animation
   */
  createRange(name, from, to) {
    if (!this._ranges[name]) {
      this._ranges[name] = new AnimationRange(name, from, to);
    }
  }
  /**
   * Deletes an animation range by name
   * @param name Name of the animation range to delete
   * @param deleteFrames Specifies if the key frames for the range should also be deleted (true) or not (false)
   */
  deleteRange(name, deleteFrames = true) {
    const range = this._ranges[name];
    if (!range) {
      return;
    }
    if (deleteFrames) {
      const from = range.from;
      const to = range.to;
      for (let key = this._keys.length - 1; key >= 0; key--) {
        if (this._keys[key].frame >= from && this._keys[key].frame <= to) {
          this._keys.splice(key, 1);
        }
      }
    }
    this._ranges[name] = null;
  }
  /**
   * Gets the animation range by name, or null if not defined
   * @param name Name of the animation range
   * @returns Nullable animation range
   */
  getRange(name) {
    return this._ranges[name];
  }
  /**
   * Gets the key frames from the animation
   * @returns The key frames of the animation
   */
  getKeys() {
    return this._keys;
  }
  /**
   * Gets the highest frame of the animation
   * @returns Highest frame of the animation
   */
  getHighestFrame() {
    let ret = 0;
    for (let key = 0, nKeys = this._keys.length; key < nKeys; key++) {
      if (ret < this._keys[key].frame) {
        ret = this._keys[key].frame;
      }
    }
    return ret;
  }
  /**
   * Gets the easing function of the animation
   * @returns Easing function of the animation
   */
  getEasingFunction() {
    return this._easingFunction;
  }
  /**
   * Sets the easing function of the animation
   * @param easingFunction A custom mathematical formula for animation
   */
  setEasingFunction(easingFunction) {
    this._easingFunction = easingFunction;
  }
  /**
   * Interpolates a scalar linearly
   * @param startValue Start value of the animation curve
   * @param endValue End value of the animation curve
   * @param gradient Scalar amount to interpolate
   * @returns Interpolated scalar value
   */
  floatInterpolateFunction(startValue, endValue, gradient) {
    return Lerp(startValue, endValue, gradient);
  }
  /**
   * Interpolates a scalar cubically
   * @param startValue Start value of the animation curve
   * @param outTangent End tangent of the animation
   * @param endValue End value of the animation curve
   * @param inTangent Start tangent of the animation curve
   * @param gradient Scalar amount to interpolate
   * @returns Interpolated scalar value
   */
  floatInterpolateFunctionWithTangents(startValue, outTangent, endValue, inTangent, gradient) {
    return Hermite(startValue, outTangent, endValue, inTangent, gradient);
  }
  /**
   * Interpolates a quaternion using a spherical linear interpolation
   * @param startValue Start value of the animation curve
   * @param endValue End value of the animation curve
   * @param gradient Scalar amount to interpolate
   * @returns Interpolated quaternion value
   */
  quaternionInterpolateFunction(startValue, endValue, gradient) {
    return Quaternion.Slerp(startValue, endValue, gradient);
  }
  /**
   * Interpolates a quaternion cubically
   * @param startValue Start value of the animation curve
   * @param outTangent End tangent of the animation curve
   * @param endValue End value of the animation curve
   * @param inTangent Start tangent of the animation curve
   * @param gradient Scalar amount to interpolate
   * @returns Interpolated quaternion value
   */
  quaternionInterpolateFunctionWithTangents(startValue, outTangent, endValue, inTangent, gradient) {
    return Quaternion.Hermite(startValue, outTangent, endValue, inTangent, gradient).normalize();
  }
  /**
   * Interpolates a Vector3 linearly
   * @param startValue Start value of the animation curve
   * @param endValue End value of the animation curve
   * @param gradient Scalar amount to interpolate (value between 0 and 1)
   * @returns Interpolated scalar value
   */
  vector3InterpolateFunction(startValue, endValue, gradient) {
    return Vector3.Lerp(startValue, endValue, gradient);
  }
  /**
   * Interpolates a Vector3 cubically
   * @param startValue Start value of the animation curve
   * @param outTangent End tangent of the animation
   * @param endValue End value of the animation curve
   * @param inTangent Start tangent of the animation curve
   * @param gradient Scalar amount to interpolate (value between 0 and 1)
   * @returns InterpolatedVector3 value
   */
  vector3InterpolateFunctionWithTangents(startValue, outTangent, endValue, inTangent, gradient) {
    return Vector3.Hermite(startValue, outTangent, endValue, inTangent, gradient);
  }
  /**
   * Interpolates a Vector2 linearly
   * @param startValue Start value of the animation curve
   * @param endValue End value of the animation curve
   * @param gradient Scalar amount to interpolate (value between 0 and 1)
   * @returns Interpolated Vector2 value
   */
  vector2InterpolateFunction(startValue, endValue, gradient) {
    return Vector2.Lerp(startValue, endValue, gradient);
  }
  /**
   * Interpolates a Vector2 cubically
   * @param startValue Start value of the animation curve
   * @param outTangent End tangent of the animation
   * @param endValue End value of the animation curve
   * @param inTangent Start tangent of the animation curve
   * @param gradient Scalar amount to interpolate (value between 0 and 1)
   * @returns Interpolated Vector2 value
   */
  vector2InterpolateFunctionWithTangents(startValue, outTangent, endValue, inTangent, gradient) {
    return Vector2.Hermite(startValue, outTangent, endValue, inTangent, gradient);
  }
  /**
   * Interpolates a size linearly
   * @param startValue Start value of the animation curve
   * @param endValue End value of the animation curve
   * @param gradient Scalar amount to interpolate
   * @returns Interpolated Size value
   */
  sizeInterpolateFunction(startValue, endValue, gradient) {
    return Size.Lerp(startValue, endValue, gradient);
  }
  /**
   * Interpolates a Color3 linearly
   * @param startValue Start value of the animation curve
   * @param endValue End value of the animation curve
   * @param gradient Scalar amount to interpolate
   * @returns Interpolated Color3 value
   */
  color3InterpolateFunction(startValue, endValue, gradient) {
    return Color3.Lerp(startValue, endValue, gradient);
  }
  /**
   * Interpolates a Color3 cubically
   * @param startValue Start value of the animation curve
   * @param outTangent End tangent of the animation
   * @param endValue End value of the animation curve
   * @param inTangent Start tangent of the animation curve
   * @param gradient Scalar amount to interpolate
   * @returns interpolated value
   */
  color3InterpolateFunctionWithTangents(startValue, outTangent, endValue, inTangent, gradient) {
    return Color3.Hermite(startValue, outTangent, endValue, inTangent, gradient);
  }
  /**
   * Interpolates a Color4 linearly
   * @param startValue Start value of the animation curve
   * @param endValue End value of the animation curve
   * @param gradient Scalar amount to interpolate
   * @returns Interpolated Color3 value
   */
  color4InterpolateFunction(startValue, endValue, gradient) {
    return Color4.Lerp(startValue, endValue, gradient);
  }
  /**
   * Interpolates a Color4 cubically
   * @param startValue Start value of the animation curve
   * @param outTangent End tangent of the animation
   * @param endValue End value of the animation curve
   * @param inTangent Start tangent of the animation curve
   * @param gradient Scalar amount to interpolate
   * @returns interpolated value
   */
  color4InterpolateFunctionWithTangents(startValue, outTangent, endValue, inTangent, gradient) {
    return Color4.Hermite(startValue, outTangent, endValue, inTangent, gradient);
  }
  /**
   * @internal Internal use only
   */
  _getKeyValue(value) {
    if (typeof value === "function") {
      return value();
    }
    return value;
  }
  /**
   * Evaluate the animation value at a given frame
   * @param currentFrame defines the frame where we want to evaluate the animation
   * @returns the animation value
   */
  evaluate(currentFrame) {
    evaluateAnimationState.key = 0;
    return this._interpolate(currentFrame, evaluateAnimationState);
  }
  /**
   * @internal Internal use only
   */
  _interpolate(currentFrame, state, searchClosestKeyOnly = false) {
    if (state.loopMode === _Animation.ANIMATIONLOOPMODE_CONSTANT && state.repeatCount > 0) {
      return state.highLimitValue.clone ? state.highLimitValue.clone() : state.highLimitValue;
    }
    const keys = this._keys;
    const keysLength = keys.length;
    let key = state.key;
    while (key >= 0 && currentFrame < keys[key].frame) {
      --key;
    }
    while (key + 1 <= keysLength - 1 && currentFrame >= keys[key + 1].frame) {
      ++key;
    }
    state.key = key;
    if (key < 0) {
      return searchClosestKeyOnly ? void 0 : this._getKeyValue(keys[0].value);
    } else if (key + 1 > keysLength - 1) {
      return searchClosestKeyOnly ? void 0 : this._getKeyValue(keys[keysLength - 1].value);
    }
    const startKey = keys[key];
    const endKey = keys[key + 1];
    if (searchClosestKeyOnly && (currentFrame === startKey.frame || currentFrame === endKey.frame)) {
      return void 0;
    }
    const startValue = this._getKeyValue(startKey.value);
    const endValue = this._getKeyValue(endKey.value);
    if (startKey.interpolation === 1) {
      if (endKey.frame > currentFrame) {
        return startValue;
      } else {
        return endValue;
      }
    }
    const useTangent = startKey.outTangent !== void 0 && endKey.inTangent !== void 0;
    const frameDelta = endKey.frame - startKey.frame;
    let gradient = (currentFrame - startKey.frame) / frameDelta;
    const easingFunction = startKey.easingFunction || this.getEasingFunction();
    if (easingFunction) {
      gradient = easingFunction.ease(gradient);
    }
    switch (this.dataType) {
      // Float
      case _Animation.ANIMATIONTYPE_FLOAT: {
        const floatValue = useTangent ? this.floatInterpolateFunctionWithTangents(startValue, startKey.outTangent * frameDelta, endValue, endKey.inTangent * frameDelta, gradient) : this.floatInterpolateFunction(startValue, endValue, gradient);
        switch (state.loopMode) {
          case _Animation.ANIMATIONLOOPMODE_CYCLE:
          case _Animation.ANIMATIONLOOPMODE_CONSTANT:
          case _Animation.ANIMATIONLOOPMODE_YOYO:
            return floatValue;
          case _Animation.ANIMATIONLOOPMODE_RELATIVE:
          case _Animation.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:
            return (state.offsetValue ?? 0) * state.repeatCount + floatValue;
        }
        break;
      }
      // Quaternion
      case _Animation.ANIMATIONTYPE_QUATERNION: {
        const quatValue = useTangent ? this.quaternionInterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient) : this.quaternionInterpolateFunction(startValue, endValue, gradient);
        switch (state.loopMode) {
          case _Animation.ANIMATIONLOOPMODE_CYCLE:
          case _Animation.ANIMATIONLOOPMODE_CONSTANT:
          case _Animation.ANIMATIONLOOPMODE_YOYO:
            return quatValue;
          case _Animation.ANIMATIONLOOPMODE_RELATIVE:
          case _Animation.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:
            return quatValue.addInPlace((state.offsetValue || _staticOffsetValueQuaternion).scale(state.repeatCount));
        }
        return quatValue;
      }
      // Vector3
      case _Animation.ANIMATIONTYPE_VECTOR3: {
        const vec3Value = useTangent ? this.vector3InterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient) : this.vector3InterpolateFunction(startValue, endValue, gradient);
        switch (state.loopMode) {
          case _Animation.ANIMATIONLOOPMODE_CYCLE:
          case _Animation.ANIMATIONLOOPMODE_CONSTANT:
          case _Animation.ANIMATIONLOOPMODE_YOYO:
            return vec3Value;
          case _Animation.ANIMATIONLOOPMODE_RELATIVE:
          case _Animation.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:
            return vec3Value.add((state.offsetValue || _staticOffsetValueVector3).scale(state.repeatCount));
        }
        break;
      }
      // Vector2
      case _Animation.ANIMATIONTYPE_VECTOR2: {
        const vec2Value = useTangent ? this.vector2InterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient) : this.vector2InterpolateFunction(startValue, endValue, gradient);
        switch (state.loopMode) {
          case _Animation.ANIMATIONLOOPMODE_CYCLE:
          case _Animation.ANIMATIONLOOPMODE_CONSTANT:
          case _Animation.ANIMATIONLOOPMODE_YOYO:
            return vec2Value;
          case _Animation.ANIMATIONLOOPMODE_RELATIVE:
          case _Animation.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:
            return vec2Value.add((state.offsetValue || _staticOffsetValueVector2).scale(state.repeatCount));
        }
        break;
      }
      // Size
      case _Animation.ANIMATIONTYPE_SIZE: {
        switch (state.loopMode) {
          case _Animation.ANIMATIONLOOPMODE_CYCLE:
          case _Animation.ANIMATIONLOOPMODE_CONSTANT:
          case _Animation.ANIMATIONLOOPMODE_YOYO:
            return this.sizeInterpolateFunction(startValue, endValue, gradient);
          case _Animation.ANIMATIONLOOPMODE_RELATIVE:
          case _Animation.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:
            return this.sizeInterpolateFunction(startValue, endValue, gradient).add((state.offsetValue || _staticOffsetValueSize).scale(state.repeatCount));
        }
        break;
      }
      // Color3
      case _Animation.ANIMATIONTYPE_COLOR3: {
        const color3Value = useTangent ? this.color3InterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient) : this.color3InterpolateFunction(startValue, endValue, gradient);
        switch (state.loopMode) {
          case _Animation.ANIMATIONLOOPMODE_CYCLE:
          case _Animation.ANIMATIONLOOPMODE_CONSTANT:
          case _Animation.ANIMATIONLOOPMODE_YOYO:
            return color3Value;
          case _Animation.ANIMATIONLOOPMODE_RELATIVE:
          case _Animation.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:
            return color3Value.add((state.offsetValue || _staticOffsetValueColor3).scale(state.repeatCount));
        }
        break;
      }
      // Color4
      case _Animation.ANIMATIONTYPE_COLOR4: {
        const color4Value = useTangent ? this.color4InterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient) : this.color4InterpolateFunction(startValue, endValue, gradient);
        switch (state.loopMode) {
          case _Animation.ANIMATIONLOOPMODE_CYCLE:
          case _Animation.ANIMATIONLOOPMODE_CONSTANT:
          case _Animation.ANIMATIONLOOPMODE_YOYO:
            return color4Value;
          case _Animation.ANIMATIONLOOPMODE_RELATIVE:
          case _Animation.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:
            return color4Value.add((state.offsetValue || _staticOffsetValueColor4).scale(state.repeatCount));
        }
        break;
      }
      // Matrix
      case _Animation.ANIMATIONTYPE_MATRIX: {
        switch (state.loopMode) {
          case _Animation.ANIMATIONLOOPMODE_CYCLE:
          case _Animation.ANIMATIONLOOPMODE_CONSTANT:
          case _Animation.ANIMATIONLOOPMODE_YOYO: {
            if (_Animation.AllowMatricesInterpolation) {
              return this.matrixInterpolateFunction(startValue, endValue, gradient, state.workValue);
            }
            return startValue;
          }
          case _Animation.ANIMATIONLOOPMODE_RELATIVE:
          case _Animation.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT: {
            return startValue;
          }
        }
        break;
      }
    }
    return 0;
  }
  /**
   * Defines the function to use to interpolate matrices
   * @param startValue defines the start matrix
   * @param endValue defines the end matrix
   * @param gradient defines the gradient between both matrices
   * @param result defines an optional target matrix where to store the interpolation
   * @returns the interpolated matrix
   */
  matrixInterpolateFunction(startValue, endValue, gradient, result) {
    if (_Animation.AllowMatrixDecomposeForInterpolation) {
      if (result) {
        Matrix.DecomposeLerpToRef(startValue, endValue, gradient, result);
        return result;
      }
      return Matrix.DecomposeLerp(startValue, endValue, gradient);
    }
    if (result) {
      Matrix.LerpToRef(startValue, endValue, gradient, result);
      return result;
    }
    return Matrix.Lerp(startValue, endValue, gradient);
  }
  /**
   * Makes a copy of the animation
   * @returns Cloned animation
   */
  clone() {
    const clone = new _Animation(this.name, this.targetPropertyPath.join("."), this.framePerSecond, this.dataType, this.loopMode);
    clone.enableBlending = this.enableBlending;
    clone.blendingSpeed = this.blendingSpeed;
    if (this._keys) {
      clone.setKeys(this._keys);
    }
    if (this._ranges) {
      clone._ranges = {};
      for (const name in this._ranges) {
        const range = this._ranges[name];
        if (!range) {
          continue;
        }
        clone._ranges[name] = range.clone();
      }
    }
    return clone;
  }
  /**
   * Sets the key frames of the animation
   * @param values The animation key frames to set
   * @param dontClone Whether to clone the keys or not (default is false, so the array of keys is cloned)
   */
  setKeys(values, dontClone = false) {
    this._keys = !dontClone ? values.slice(0) : values;
  }
  /**
   * Creates a key for the frame passed as a parameter and adds it to the animation IF a key doesn't already exist for that frame
   * @param frame Frame number
   * @returns The key index if the key was added or the index of the pre existing key if the frame passed as parameter already has a corresponding key
   */
  createKeyForFrame(frame) {
    evaluateAnimationState.key = 0;
    const value = this._interpolate(frame, evaluateAnimationState, true);
    if (!value) {
      return this._keys[evaluateAnimationState.key].frame === frame ? evaluateAnimationState.key : evaluateAnimationState.key + 1;
    }
    const newKey = {
      frame,
      value: value.clone ? value.clone() : value
    };
    this._keys.splice(evaluateAnimationState.key + 1, 0, newKey);
    return evaluateAnimationState.key + 1;
  }
  /**
   * Serializes the animation to an object
   * @returns Serialized object
   */
  serialize() {
    const serializationObject = {};
    serializationObject.name = this.name;
    serializationObject.property = this.targetProperty;
    serializationObject.framePerSecond = this.framePerSecond;
    serializationObject.dataType = this.dataType;
    serializationObject.loopBehavior = this.loopMode;
    serializationObject.enableBlending = this.enableBlending;
    serializationObject.blendingSpeed = this.blendingSpeed;
    const dataType = this.dataType;
    serializationObject.keys = [];
    const keys = this.getKeys();
    for (let index = 0; index < keys.length; index++) {
      const animationKey = keys[index];
      const key = {};
      key.frame = animationKey.frame;
      switch (dataType) {
        case _Animation.ANIMATIONTYPE_FLOAT:
          key.values = [animationKey.value];
          if (animationKey.inTangent !== void 0) {
            key.values.push(animationKey.inTangent);
          }
          if (animationKey.outTangent !== void 0) {
            if (animationKey.inTangent === void 0) {
              key.values.push(void 0);
            }
            key.values.push(animationKey.outTangent);
          }
          if (animationKey.interpolation !== void 0) {
            if (animationKey.inTangent === void 0) {
              key.values.push(void 0);
            }
            if (animationKey.outTangent === void 0) {
              key.values.push(void 0);
            }
            key.values.push(animationKey.interpolation);
          }
          break;
        case _Animation.ANIMATIONTYPE_QUATERNION:
        case _Animation.ANIMATIONTYPE_MATRIX:
        case _Animation.ANIMATIONTYPE_VECTOR3:
        case _Animation.ANIMATIONTYPE_COLOR3:
        case _Animation.ANIMATIONTYPE_COLOR4:
          key.values = animationKey.value.asArray();
          if (animationKey.inTangent != void 0) {
            key.values.push(animationKey.inTangent.asArray());
          }
          if (animationKey.outTangent != void 0) {
            if (animationKey.inTangent === void 0) {
              key.values.push(void 0);
            }
            key.values.push(animationKey.outTangent.asArray());
          }
          if (animationKey.interpolation !== void 0) {
            if (animationKey.inTangent === void 0) {
              key.values.push(void 0);
            }
            if (animationKey.outTangent === void 0) {
              key.values.push(void 0);
            }
            key.values.push(animationKey.interpolation);
          }
          break;
      }
      serializationObject.keys.push(key);
    }
    serializationObject.ranges = [];
    for (const name in this._ranges) {
      const source = this._ranges[name];
      if (!source) {
        continue;
      }
      const range = {};
      range.name = name;
      range.from = source.from;
      range.to = source.to;
      serializationObject.ranges.push(range);
    }
    return serializationObject;
  }
  /**
   * @internal
   */
  static _UniversalLerp(left, right, amount) {
    const constructor = left.constructor;
    if (constructor.Lerp) {
      return constructor.Lerp(left, right, amount);
    } else if (constructor.Slerp) {
      return constructor.Slerp(left, right, amount);
    } else if (left.toFixed) {
      return left * (1 - amount) + amount * right;
    } else {
      return right;
    }
  }
  /**
   * Parses an animation object and creates an animation
   * @param parsedAnimation Parsed animation object
   * @returns Animation object
   */
  static Parse(parsedAnimation) {
    const animation = new _Animation(parsedAnimation.name, parsedAnimation.property, parsedAnimation.framePerSecond, parsedAnimation.dataType, parsedAnimation.loopBehavior);
    const dataType = parsedAnimation.dataType;
    const keys = [];
    let data;
    let index;
    if (parsedAnimation.enableBlending) {
      animation.enableBlending = parsedAnimation.enableBlending;
    }
    if (parsedAnimation.blendingSpeed) {
      animation.blendingSpeed = parsedAnimation.blendingSpeed;
    }
    for (index = 0; index < parsedAnimation.keys.length; index++) {
      const key = parsedAnimation.keys[index];
      let inTangent = void 0;
      let outTangent = void 0;
      let interpolation = void 0;
      switch (dataType) {
        case _Animation.ANIMATIONTYPE_FLOAT:
          data = key.values[0];
          if (key.values.length >= 2) {
            inTangent = key.values[1];
          }
          if (key.values.length >= 3) {
            outTangent = key.values[2];
          }
          if (key.values.length >= 4) {
            interpolation = key.values[3];
          }
          break;
        case _Animation.ANIMATIONTYPE_QUATERNION:
          data = Quaternion.FromArray(key.values);
          if (key.values.length >= 8) {
            const _inTangent = Quaternion.FromArray(key.values.slice(4, 8));
            if (!_inTangent.equals(Quaternion.Zero())) {
              inTangent = _inTangent;
            }
          }
          if (key.values.length >= 12) {
            const _outTangent = Quaternion.FromArray(key.values.slice(8, 12));
            if (!_outTangent.equals(Quaternion.Zero())) {
              outTangent = _outTangent;
            }
          }
          if (key.values.length >= 13) {
            interpolation = key.values[12];
          }
          break;
        case _Animation.ANIMATIONTYPE_MATRIX:
          data = Matrix.FromArray(key.values);
          if (key.values.length >= 17) {
            interpolation = key.values[16];
          }
          break;
        case _Animation.ANIMATIONTYPE_COLOR3:
          data = Color3.FromArray(key.values);
          if (key.values[3]) {
            inTangent = Color3.FromArray(key.values[3]);
          }
          if (key.values[4]) {
            outTangent = Color3.FromArray(key.values[4]);
          }
          if (key.values[5]) {
            interpolation = key.values[5];
          }
          break;
        case _Animation.ANIMATIONTYPE_COLOR4:
          data = Color4.FromArray(key.values);
          if (key.values[4]) {
            inTangent = Color4.FromArray(key.values[4]);
          }
          if (key.values[5]) {
            outTangent = Color4.FromArray(key.values[5]);
          }
          if (key.values[6]) {
            interpolation = Color4.FromArray(key.values[6]);
          }
          break;
        case _Animation.ANIMATIONTYPE_VECTOR3:
        default:
          data = Vector3.FromArray(key.values);
          if (key.values[3]) {
            inTangent = Vector3.FromArray(key.values[3]);
          }
          if (key.values[4]) {
            outTangent = Vector3.FromArray(key.values[4]);
          }
          if (key.values[5]) {
            interpolation = key.values[5];
          }
          break;
      }
      const keyData = {};
      keyData.frame = key.frame;
      keyData.value = data;
      if (inTangent != void 0) {
        keyData.inTangent = inTangent;
      }
      if (outTangent != void 0) {
        keyData.outTangent = outTangent;
      }
      if (interpolation != void 0) {
        keyData.interpolation = interpolation;
      }
      keys.push(keyData);
    }
    animation.setKeys(keys);
    if (parsedAnimation.ranges) {
      for (index = 0; index < parsedAnimation.ranges.length; index++) {
        data = parsedAnimation.ranges[index];
        animation.createRange(data.name, data.from, data.to);
      }
    }
    return animation;
  }
  /**
   * Appends the serialized animations from the source animations
   * @param source Source containing the animations
   * @param destination Target to store the animations
   */
  static AppendSerializedAnimations(source, destination) {
    SerializationHelper.AppendSerializedAnimations(source, destination);
  }
  /**
   * Creates a new animation or an array of animations from a snippet saved in a remote file
   * @param name defines the name of the animation to create (can be null or empty to use the one from the json data)
   * @param url defines the url to load from
   * @returns a promise that will resolve to the new animation or an array of animations
   */
  static ParseFromFileAsync(name, url) {
    return new Promise((resolve, reject) => {
      const request = new WebRequest();
      request.addEventListener("readystatechange", () => {
        if (request.readyState == 4) {
          if (request.status == 200) {
            let serializationObject = JSON.parse(request.responseText);
            if (serializationObject.animations) {
              serializationObject = serializationObject.animations;
            }
            if (serializationObject.length) {
              const output = [];
              for (const serializedAnimation of serializationObject) {
                output.push(this.Parse(serializedAnimation));
              }
              resolve(output);
            } else {
              const output = this.Parse(serializationObject);
              if (name) {
                output.name = name;
              }
              resolve(output);
            }
          } else {
            reject("Unable to load the animation");
          }
        }
      });
      request.open("GET", url);
      request.send();
    });
  }
  /**
   * Creates an animation or an array of animations from a snippet saved by the Inspector
   * @param snippetId defines the snippet to load
   * @returns a promise that will resolve to the new animation or a new array of animations
   */
  static ParseFromSnippetAsync(snippetId) {
    return new Promise((resolve, reject) => {
      const request = new WebRequest();
      request.addEventListener("readystatechange", () => {
        if (request.readyState == 4) {
          if (request.status == 200) {
            const snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);
            if (snippet.animations) {
              const serializationObject = JSON.parse(snippet.animations);
              const outputs = [];
              for (const serializedAnimation of serializationObject.animations) {
                const output = this.Parse(serializedAnimation);
                output.snippetId = snippetId;
                outputs.push(output);
              }
              resolve(outputs);
            } else {
              const serializationObject = JSON.parse(snippet.animation);
              const output = this.Parse(serializationObject);
              output.snippetId = snippetId;
              resolve(output);
            }
          } else {
            reject("Unable to load the snippet " + snippetId);
          }
        }
      });
      request.open("GET", this.SnippetUrl + "/" + snippetId.replace(/#/g, "/"));
      request.send();
    });
  }
};
Animation._UniqueIdGenerator = 0;
Animation.AllowMatricesInterpolation = false;
Animation.AllowMatrixDecomposeForInterpolation = true;
Animation.SnippetUrl = `https://snippet.babylonjs.com`;
Animation.ANIMATIONTYPE_FLOAT = 0;
Animation.ANIMATIONTYPE_VECTOR3 = 1;
Animation.ANIMATIONTYPE_QUATERNION = 2;
Animation.ANIMATIONTYPE_MATRIX = 3;
Animation.ANIMATIONTYPE_COLOR3 = 4;
Animation.ANIMATIONTYPE_COLOR4 = 7;
Animation.ANIMATIONTYPE_VECTOR2 = 5;
Animation.ANIMATIONTYPE_SIZE = 6;
Animation.ANIMATIONLOOPMODE_RELATIVE = 0;
Animation.ANIMATIONLOOPMODE_CYCLE = 1;
Animation.ANIMATIONLOOPMODE_CONSTANT = 2;
Animation.ANIMATIONLOOPMODE_YOYO = 4;
Animation.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT = 5;
Animation.CreateFromSnippetAsync = Animation.ParseFromSnippetAsync;
RegisterClass("BABYLON.Animation", Animation);
Node._AnimationRangeFactory = (name, from, to) => new AnimationRange(name, from, to);

export {
  AnimationRange,
  Node,
  _staticOffsetValueQuaternion,
  _staticOffsetValueVector3,
  _staticOffsetValueVector2,
  _staticOffsetValueSize,
  _staticOffsetValueColor3,
  _staticOffsetValueColor4,
  Animation
};
//# sourceMappingURL=chunk-ETMGTUPP.js.map
