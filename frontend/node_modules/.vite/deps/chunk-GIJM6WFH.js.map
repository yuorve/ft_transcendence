{
  "version": 3,
  "sources": ["../../../dev/core/src/Misc/andOrNotEvaluator.ts", "../../../dev/core/src/Misc/tags.ts", "../../../dev/core/src/Misc/decorators.serialization.ts", "../../../dev/core/src/Maths/math.size.ts", "../../../dev/core/src/Maths/math.plane.ts", "../../../dev/core/src/Materials/Textures/thinTexture.ts", "../../../dev/core/src/Materials/Textures/baseTexture.ts", "../../../dev/core/src/Misc/copyTools.ts", "../../../dev/core/src/Compat/compatibilityOptions.ts", "../../../dev/core/src/Materials/Textures/texture.ts"],
  "sourcesContent": ["/**\r\n * Class used to evaluate queries containing `and` and `or` operators\r\n */\r\nexport class AndOrNotEvaluator {\r\n    /**\r\n     * Evaluate a query\r\n     * @param query defines the query to evaluate\r\n     * @param evaluateCallback defines the callback used to filter result\r\n     * @returns true if the query matches\r\n     */\r\n    public static Eval(query: string, evaluateCallback: (val: any) => boolean): boolean {\r\n        if (!query.match(/\\([^()]*\\)/g)) {\r\n            query = AndOrNotEvaluator._HandleParenthesisContent(query, evaluateCallback);\r\n        } else {\r\n            query = query.replace(/\\([^()]*\\)/g, (r) => {\r\n                // remove parenthesis\r\n                r = r.slice(1, r.length - 1);\r\n                return AndOrNotEvaluator._HandleParenthesisContent(r, evaluateCallback);\r\n            });\r\n        }\r\n\r\n        if (query === \"true\") {\r\n            return true;\r\n        }\r\n\r\n        if (query === \"false\") {\r\n            return false;\r\n        }\r\n\r\n        return AndOrNotEvaluator.Eval(query, evaluateCallback);\r\n    }\r\n\r\n    private static _HandleParenthesisContent(parenthesisContent: string, evaluateCallback: (val: string) => boolean): string {\r\n        evaluateCallback =\r\n            evaluateCallback ||\r\n            ((r) => {\r\n                return r === \"true\" ? true : false;\r\n            });\r\n\r\n        let result;\r\n        const or = parenthesisContent.split(\"||\");\r\n\r\n        for (const i in or) {\r\n            if (Object.prototype.hasOwnProperty.call(or, i)) {\r\n                let ori = AndOrNotEvaluator._SimplifyNegation(or[i].trim());\r\n                const and = ori.split(\"&&\");\r\n\r\n                if (and.length > 1) {\r\n                    for (let j = 0; j < and.length; ++j) {\r\n                        const andj = AndOrNotEvaluator._SimplifyNegation(and[j].trim());\r\n                        if (andj !== \"true\" && andj !== \"false\") {\r\n                            if (andj[0] === \"!\") {\r\n                                result = !evaluateCallback(andj.substring(1));\r\n                            } else {\r\n                                result = evaluateCallback(andj);\r\n                            }\r\n                        } else {\r\n                            result = andj === \"true\" ? true : false;\r\n                        }\r\n                        if (!result) {\r\n                            // no need to continue since 'false && ... && ...' will always return false\r\n                            ori = \"false\";\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (result || ori === \"true\") {\r\n                    // no need to continue since 'true || ... || ...' will always return true\r\n                    result = true;\r\n                    break;\r\n                }\r\n\r\n                // result equals false (or undefined)\r\n\r\n                if (ori !== \"true\" && ori !== \"false\") {\r\n                    if (ori[0] === \"!\") {\r\n                        result = !evaluateCallback(ori.substring(1));\r\n                    } else {\r\n                        result = evaluateCallback(ori);\r\n                    }\r\n                } else {\r\n                    result = ori === \"true\" ? true : false;\r\n                }\r\n            }\r\n        }\r\n\r\n        // the whole parenthesis scope is replaced by 'true' or 'false'\r\n        return result ? \"true\" : \"false\";\r\n    }\r\n\r\n    private static _SimplifyNegation(booleanString: string): string {\r\n        booleanString = booleanString.replace(/^[\\s!]+/, (r) => {\r\n            // remove whitespaces\r\n            r = r.replace(/[\\s]/g, () => \"\");\r\n            return r.length % 2 ? \"!\" : \"\";\r\n        });\r\n\r\n        booleanString = booleanString.trim();\r\n\r\n        if (booleanString === \"!true\") {\r\n            booleanString = \"false\";\r\n        } else if (booleanString === \"!false\") {\r\n            booleanString = \"true\";\r\n        }\r\n\r\n        return booleanString;\r\n    }\r\n}\r\n", "import { AndOrNotEvaluator } from \"./andOrNotEvaluator\";\r\n\r\n/**\r\n * Class used to store custom tags\r\n */\r\nexport class Tags {\r\n    /**\r\n     * Adds support for tags on the given object\r\n     * @param obj defines the object to use\r\n     */\r\n    public static EnableFor(obj: any): void {\r\n        obj._tags = obj._tags || {};\r\n\r\n        obj.hasTags = () => {\r\n            return Tags.HasTags(obj);\r\n        };\r\n\r\n        obj.addTags = (tagsString: string) => {\r\n            return Tags.AddTagsTo(obj, tagsString);\r\n        };\r\n\r\n        obj.removeTags = (tagsString: string) => {\r\n            return Tags.RemoveTagsFrom(obj, tagsString);\r\n        };\r\n\r\n        obj.matchesTagsQuery = (tagsQuery: string) => {\r\n            return Tags.MatchesQuery(obj, tagsQuery);\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Removes tags support\r\n     * @param obj defines the object to use\r\n     */\r\n    public static DisableFor(obj: any): void {\r\n        delete obj._tags;\r\n        delete obj.hasTags;\r\n        delete obj.addTags;\r\n        delete obj.removeTags;\r\n        delete obj.matchesTagsQuery;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if the given object has tags\r\n     * @param obj defines the object to use\r\n     * @returns a boolean\r\n     */\r\n    public static HasTags(obj: any): boolean {\r\n        if (!obj._tags) {\r\n            return false;\r\n        }\r\n\r\n        const tags = obj._tags;\r\n        for (const i in tags) {\r\n            if (Object.prototype.hasOwnProperty.call(tags, i)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Gets the tags available on a given object\r\n     * @param obj defines the object to use\r\n     * @param asString defines if the tags must be returned as a string instead of an array of strings\r\n     * @returns the tags\r\n     */\r\n    public static GetTags(obj: any, asString: boolean = true): any {\r\n        if (!obj._tags) {\r\n            return null;\r\n        }\r\n        if (asString) {\r\n            const tagsArray = [];\r\n            for (const tag in obj._tags) {\r\n                if (Object.prototype.hasOwnProperty.call(obj._tags, tag) && obj._tags[tag] === true) {\r\n                    tagsArray.push(tag);\r\n                }\r\n            }\r\n            return tagsArray.join(\" \");\r\n        } else {\r\n            return obj._tags;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds tags to an object\r\n     * @param obj defines the object to use\r\n     * @param tagsString defines the tag string. The tags 'true' and 'false' are reserved and cannot be used as tags.\r\n     * A tag cannot start with '||', '&&', and '!'. It cannot contain whitespaces\r\n     */\r\n    public static AddTagsTo(obj: any, tagsString: string): void {\r\n        if (!tagsString) {\r\n            return;\r\n        }\r\n\r\n        if (typeof tagsString !== \"string\") {\r\n            return;\r\n        }\r\n\r\n        const tags = tagsString.split(\" \");\r\n        tags.forEach(function (tag) {\r\n            Tags._AddTagTo(obj, tag);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _AddTagTo(obj: any, tag: string): void {\r\n        tag = tag.trim();\r\n\r\n        if (tag === \"\" || tag === \"true\" || tag === \"false\") {\r\n            return;\r\n        }\r\n\r\n        if (tag.match(/[\\s]/) || tag.match(/^([!]|([|]|[&]){2})/)) {\r\n            return;\r\n        }\r\n\r\n        Tags.EnableFor(obj);\r\n        obj._tags[tag] = true;\r\n    }\r\n\r\n    /**\r\n     * Removes specific tags from a specific object\r\n     * @param obj defines the object to use\r\n     * @param tagsString defines the tags to remove\r\n     */\r\n    public static RemoveTagsFrom(obj: any, tagsString: string) {\r\n        if (!Tags.HasTags(obj)) {\r\n            return;\r\n        }\r\n        const tags = tagsString.split(\" \");\r\n        for (const t in tags) {\r\n            Tags._RemoveTagFrom(obj, tags[t]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _RemoveTagFrom(obj: any, tag: string): void {\r\n        delete obj._tags[tag];\r\n    }\r\n\r\n    /**\r\n     * Defines if tags hosted on an object match a given query\r\n     * @param obj defines the object to use\r\n     * @param tagsQuery defines the tag query\r\n     * @returns a boolean\r\n     */\r\n    public static MatchesQuery(obj: any, tagsQuery: string): boolean {\r\n        if (tagsQuery === undefined) {\r\n            return true;\r\n        }\r\n\r\n        if (tagsQuery === \"\") {\r\n            return Tags.HasTags(obj);\r\n        }\r\n\r\n        return AndOrNotEvaluator.Eval(tagsQuery, (r) => Tags.HasTags(obj) && obj._tags[r]);\r\n    }\r\n}\r\n", "import type { FresnelParameters } from \"../Materials/fresnelParameters\";\r\nimport type { ImageProcessingConfiguration } from \"../Materials/imageProcessingConfiguration\";\r\nimport { _WarnImport } from \"./devTools\";\r\nimport type { ColorCurves } from \"../Materials/colorCurves\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport type { IAnimatable } from \"../Animations/animatable.interface\";\r\nimport { Tags } from \"./tags\";\r\nimport { Color3, Color4 } from \"../Maths/math.color\";\r\nimport { Matrix, Quaternion, Vector2, Vector3 } from \"../Maths/math.vector\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport { GetMergedStore } from \"./decorators.functions\";\r\n\r\n/** @internal */\r\nexport interface CopySourceOptions {\r\n    /*\r\n     * if a texture is used in more than one channel (e.g diffuse and opacity),\r\n     * only clone it once and reuse it on the other channels. Default false\r\n     */\r\n    cloneTexturesOnlyOnce?: boolean;\r\n}\r\n\r\nconst _copySource = function <T>(creationFunction: () => T, source: T, instanciate: boolean, options: CopySourceOptions = {}): T {\r\n    const destination = creationFunction();\r\n\r\n    // Tags\r\n    if (Tags && Tags.HasTags(source)) {\r\n        Tags.AddTagsTo(destination, Tags.GetTags(source, true));\r\n    }\r\n\r\n    const classStore = GetMergedStore(destination);\r\n\r\n    // Map from source texture uniqueId to destination texture\r\n    const textureMap: Record<number, any> = {};\r\n\r\n    // Properties\r\n    for (const property in classStore) {\r\n        const propertyDescriptor = classStore[property];\r\n        const sourceProperty = (<any>source)[property];\r\n        const propertyType = propertyDescriptor.type;\r\n\r\n        if (sourceProperty !== undefined && sourceProperty !== null && (property !== \"uniqueId\" || SerializationHelper.AllowLoadingUniqueId)) {\r\n            switch (propertyType) {\r\n                case 0: // Value\r\n                case 6: // Mesh reference\r\n                case 9: // Image processing configuration reference\r\n                case 11: // Camera reference\r\n                    (<any>destination)[property] = sourceProperty;\r\n                    break;\r\n                case 1: // Texture\r\n                    if (options.cloneTexturesOnlyOnce && textureMap[sourceProperty.uniqueId]) {\r\n                        (<any>destination)[property] = textureMap[sourceProperty.uniqueId];\r\n                    } else {\r\n                        (<any>destination)[property] = instanciate || sourceProperty.isRenderTarget ? sourceProperty : sourceProperty.clone();\r\n                        textureMap[sourceProperty.uniqueId] = (<any>destination)[property];\r\n                    }\r\n                    break;\r\n                case 2: // Color3\r\n                case 3: // FresnelParameters\r\n                case 4: // Vector2\r\n                case 5: // Vector3\r\n                case 7: // Color Curves\r\n                case 8: // Color 4\r\n                case 10: // Quaternion\r\n                case 12: // Matrix\r\n                    (<any>destination)[property] = instanciate ? sourceProperty : sourceProperty.clone();\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n\r\n    return destination;\r\n};\r\n\r\n/**\r\n * Class used to help serialization objects\r\n */\r\nexport class SerializationHelper {\r\n    /**\r\n     * Gets or sets a boolean to indicate if the UniqueId property should be serialized\r\n     */\r\n    public static AllowLoadingUniqueId = false;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _ImageProcessingConfigurationParser = (sourceProperty: any): ImageProcessingConfiguration => {\r\n        throw _WarnImport(\"ImageProcessingConfiguration\");\r\n    };\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _FresnelParametersParser = (sourceProperty: any): FresnelParameters => {\r\n        throw _WarnImport(\"FresnelParameters\");\r\n    };\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _ColorCurvesParser = (sourceProperty: any): ColorCurves => {\r\n        throw _WarnImport(\"ColorCurves\");\r\n    };\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _TextureParser = (sourceProperty: any, scene: Scene, rootUrl: string): Nullable<BaseTexture> => {\r\n        throw _WarnImport(\"Texture\");\r\n    };\r\n\r\n    /**\r\n     * Appends the serialized animations from the source animations\r\n     * @param source Source containing the animations\r\n     * @param destination Target to store the animations\r\n     */\r\n    public static AppendSerializedAnimations(source: IAnimatable, destination: any): void {\r\n        if (source.animations) {\r\n            destination.animations = [];\r\n            for (let animationIndex = 0; animationIndex < source.animations.length; animationIndex++) {\r\n                const animation = source.animations[animationIndex];\r\n\r\n                destination.animations.push(animation.serialize());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Static function used to serialized a specific entity\r\n     * @param entity defines the entity to serialize\r\n     * @param serializationObject defines the optional target object where serialization data will be stored\r\n     * @returns a JSON compatible object representing the serialization of the entity\r\n     */\r\n    public static Serialize<T>(entity: T, serializationObject?: any): any {\r\n        if (!serializationObject) {\r\n            serializationObject = {};\r\n        }\r\n\r\n        // Tags\r\n        if (Tags) {\r\n            serializationObject.tags = Tags.GetTags(entity);\r\n        }\r\n\r\n        const serializedProperties = GetMergedStore(entity);\r\n\r\n        // Properties\r\n        for (const property in serializedProperties) {\r\n            const propertyDescriptor = serializedProperties[property];\r\n            const targetPropertyName = propertyDescriptor.sourceName || property;\r\n            const propertyType = propertyDescriptor.type;\r\n            const sourceProperty = (<any>entity)[property];\r\n\r\n            if (sourceProperty !== undefined && sourceProperty !== null && (property !== \"uniqueId\" || SerializationHelper.AllowLoadingUniqueId)) {\r\n                switch (propertyType) {\r\n                    case 0: // Value\r\n                        serializationObject[targetPropertyName] = sourceProperty;\r\n                        break;\r\n                    case 1: // Texture\r\n                        serializationObject[targetPropertyName] = sourceProperty.serialize();\r\n                        break;\r\n                    case 2: // Color3\r\n                        serializationObject[targetPropertyName] = sourceProperty.asArray();\r\n                        break;\r\n                    case 3: // FresnelParameters\r\n                        serializationObject[targetPropertyName] = sourceProperty.serialize();\r\n                        break;\r\n                    case 4: // Vector2\r\n                        serializationObject[targetPropertyName] = sourceProperty.asArray();\r\n                        break;\r\n                    case 5: // Vector3\r\n                        serializationObject[targetPropertyName] = sourceProperty.asArray();\r\n                        break;\r\n                    case 6: // Mesh reference\r\n                        serializationObject[targetPropertyName] = sourceProperty.id;\r\n                        break;\r\n                    case 7: // Color Curves\r\n                        serializationObject[targetPropertyName] = sourceProperty.serialize();\r\n                        break;\r\n                    case 8: // Color 4\r\n                        serializationObject[targetPropertyName] = (<Color4>sourceProperty).asArray();\r\n                        break;\r\n                    case 9: // Image Processing\r\n                        serializationObject[targetPropertyName] = (<ImageProcessingConfiguration>sourceProperty).serialize();\r\n                        break;\r\n                    case 10: // Quaternion\r\n                        serializationObject[targetPropertyName] = (<Quaternion>sourceProperty).asArray();\r\n                        break;\r\n                    case 11: // Camera reference\r\n                        serializationObject[targetPropertyName] = (<Camera>sourceProperty).id;\r\n                        break;\r\n                    case 12: // Matrix\r\n                        serializationObject[targetPropertyName] = (<Matrix>sourceProperty).asArray();\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Given a source json and a destination object in a scene, this function will parse the source and will try to apply its content to the destination object\r\n     * @param source the source json data\r\n     * @param destination the destination object\r\n     * @param scene the scene where the object is\r\n     * @param rootUrl root url to use to load assets\r\n     */\r\n    public static ParseProperties(source: any, destination: any, scene: Nullable<Scene>, rootUrl: Nullable<string>) {\r\n        if (!rootUrl) {\r\n            rootUrl = \"\";\r\n        }\r\n\r\n        const classStore = GetMergedStore(destination);\r\n\r\n        // Properties\r\n        for (const property in classStore) {\r\n            const propertyDescriptor = classStore[property];\r\n            const sourceProperty = source[propertyDescriptor.sourceName || property];\r\n            const propertyType = propertyDescriptor.type;\r\n\r\n            if (sourceProperty !== undefined && sourceProperty !== null && (property !== \"uniqueId\" || SerializationHelper.AllowLoadingUniqueId)) {\r\n                const dest = <any>destination;\r\n                switch (propertyType) {\r\n                    case 0: // Value\r\n                        dest[property] = sourceProperty;\r\n                        break;\r\n                    case 1: // Texture\r\n                        if (scene) {\r\n                            dest[property] = SerializationHelper._TextureParser(sourceProperty, scene, rootUrl);\r\n                        }\r\n                        break;\r\n                    case 2: // Color3\r\n                        dest[property] = Color3.FromArray(sourceProperty);\r\n                        break;\r\n                    case 3: // FresnelParameters\r\n                        dest[property] = SerializationHelper._FresnelParametersParser(sourceProperty);\r\n                        break;\r\n                    case 4: // Vector2\r\n                        dest[property] = Vector2.FromArray(sourceProperty);\r\n                        break;\r\n                    case 5: // Vector3\r\n                        dest[property] = Vector3.FromArray(sourceProperty);\r\n                        break;\r\n                    case 6: // Mesh reference\r\n                        if (scene) {\r\n                            dest[property] = scene.getLastMeshById(sourceProperty);\r\n                        }\r\n                        break;\r\n                    case 7: // Color Curves\r\n                        dest[property] = SerializationHelper._ColorCurvesParser(sourceProperty);\r\n                        break;\r\n                    case 8: // Color 4\r\n                        dest[property] = Color4.FromArray(sourceProperty);\r\n                        break;\r\n                    case 9: // Image Processing\r\n                        dest[property] = SerializationHelper._ImageProcessingConfigurationParser(sourceProperty);\r\n                        break;\r\n                    case 10: // Quaternion\r\n                        dest[property] = Quaternion.FromArray(sourceProperty);\r\n                        break;\r\n                    case 11: // Camera reference\r\n                        if (scene) {\r\n                            dest[property] = scene.getCameraById(sourceProperty);\r\n                        }\r\n                        break;\r\n                    case 12: // Matrix\r\n                        dest[property] = Matrix.FromArray(sourceProperty);\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a new entity from a serialization data object\r\n     * @param creationFunction defines a function used to instanciated the new entity\r\n     * @param source defines the source serialization data\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root url for resources\r\n     * @returns a new entity\r\n     */\r\n    public static Parse<T>(creationFunction: () => T, source: any, scene: Nullable<Scene>, rootUrl: Nullable<string> = null): T {\r\n        const destination = creationFunction();\r\n\r\n        // Tags\r\n        if (Tags) {\r\n            Tags.AddTagsTo(destination, source.tags);\r\n        }\r\n\r\n        SerializationHelper.ParseProperties(source, destination, scene, rootUrl);\r\n\r\n        return destination;\r\n    }\r\n\r\n    /**\r\n     * Clones an object\r\n     * @param creationFunction defines the function used to instanciate the new object\r\n     * @param source defines the source object\r\n     * @param options defines the options to use\r\n     * @returns the cloned object\r\n     */\r\n    public static Clone<T>(creationFunction: () => T, source: T, options: CopySourceOptions = {}): T {\r\n        return _copySource(creationFunction, source, false, options);\r\n    }\r\n\r\n    /**\r\n     * Instanciates a new object based on a source one (some data will be shared between both object)\r\n     * @param creationFunction defines the function used to instanciate the new object\r\n     * @param source defines the source object\r\n     * @returns the new object\r\n     */\r\n    public static Instanciate<T>(creationFunction: () => T, source: T): T {\r\n        return _copySource(creationFunction, source, true);\r\n    }\r\n}\r\n", "/**\r\n * Interface for the size containing width and height\r\n */\r\nexport interface ISize {\r\n    /**\r\n     * Width\r\n     */\r\n    width: number;\r\n    /**\r\n     * Height\r\n     */\r\n    height: number;\r\n}\r\n\r\n/**\r\n * Size containing width and height\r\n */\r\nexport class Size implements ISize {\r\n    /**\r\n     * Width\r\n     */\r\n    public width: number;\r\n    /**\r\n     * Height\r\n     */\r\n    public height: number;\r\n\r\n    /**\r\n     * Creates a Size object from the given width and height (floats).\r\n     * @param width width of the new size\r\n     * @param height height of the new size\r\n     */\r\n    public constructor(width: number, height: number) {\r\n        this.width = width;\r\n        this.height = height;\r\n    }\r\n\r\n    /**\r\n     * Returns a string with the Size width and height\r\n     * @returns a string with the Size width and height\r\n     */\r\n    public toString(): string {\r\n        return `{W: ${this.width}, H: ${this.height}}`;\r\n    }\r\n    /**\r\n     * \"Size\"\r\n     * @returns the string \"Size\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"Size\";\r\n    }\r\n    /**\r\n     * Returns the Size hash code.\r\n     * @returns a hash code for a unique width and height\r\n     */\r\n    public getHashCode(): number {\r\n        let hash = this.width | 0;\r\n        hash = (hash * 397) ^ (this.height | 0);\r\n        return hash;\r\n    }\r\n    /**\r\n     * Updates the current size from the given one.\r\n     * @param src the given size\r\n     */\r\n    public copyFrom(src: Size) {\r\n        this.width = src.width;\r\n        this.height = src.height;\r\n    }\r\n    /**\r\n     * Updates in place the current Size from the given floats.\r\n     * @param width width of the new size\r\n     * @param height height of the new size\r\n     * @returns the updated Size.\r\n     */\r\n    public copyFromFloats(width: number, height: number): Size {\r\n        this.width = width;\r\n        this.height = height;\r\n        return this;\r\n    }\r\n    /**\r\n     * Updates in place the current Size from the given floats.\r\n     * @param width width to set\r\n     * @param height height to set\r\n     * @returns the updated Size.\r\n     */\r\n    public set(width: number, height: number): Size {\r\n        return this.copyFromFloats(width, height);\r\n    }\r\n    /**\r\n     * Multiplies the width and height by numbers\r\n     * @param w factor to multiple the width by\r\n     * @param h factor to multiple the height by\r\n     * @returns a new Size set with the multiplication result of the current Size and the given floats.\r\n     */\r\n    public multiplyByFloats(w: number, h: number): Size {\r\n        return new Size(this.width * w, this.height * h);\r\n    }\r\n    /**\r\n     * Clones the size\r\n     * @returns a new Size copied from the given one.\r\n     */\r\n    public clone(): Size {\r\n        return new Size(this.width, this.height);\r\n    }\r\n    /**\r\n     * True if the current Size and the given one width and height are strictly equal.\r\n     * @param other the other size to compare against\r\n     * @returns True if the current Size and the given one width and height are strictly equal.\r\n     */\r\n    public equals(other: Size): boolean {\r\n        if (!other) {\r\n            return false;\r\n        }\r\n        return this.width === other.width && this.height === other.height;\r\n    }\r\n    /**\r\n     * The surface of the Size : width * height (float).\r\n     */\r\n    public get surface(): number {\r\n        return this.width * this.height;\r\n    }\r\n    /**\r\n     * Create a new size of zero\r\n     * @returns a new Size set to (0.0, 0.0)\r\n     */\r\n    public static Zero(): Size {\r\n        return new Size(0.0, 0.0);\r\n    }\r\n    /**\r\n     * Sums the width and height of two sizes\r\n     * @param otherSize size to add to this size\r\n     * @returns a new Size set as the addition result of the current Size and the given one.\r\n     */\r\n    public add(otherSize: Size): Size {\r\n        const r = new Size(this.width + otherSize.width, this.height + otherSize.height);\r\n        return r;\r\n    }\r\n    /**\r\n     * Subtracts the width and height of two\r\n     * @param otherSize size to subtract to this size\r\n     * @returns a new Size set as the subtraction result of  the given one from the current Size.\r\n     */\r\n    public subtract(otherSize: Size): Size {\r\n        const r = new Size(this.width - otherSize.width, this.height - otherSize.height);\r\n        return r;\r\n    }\r\n    /**\r\n     * Scales the width and height\r\n     * @param scale the scale to multiply the width and height by\r\n     * @returns a new Size set with the multiplication result of the current Size and the given floats.\r\n     */\r\n    public scale(scale: number): Size {\r\n        return new Size(this.width * scale, this.height * scale);\r\n    }\r\n    /**\r\n     * Creates a new Size set at the linear interpolation \"amount\" between \"start\" and \"end\"\r\n     * @param start starting size to lerp between\r\n     * @param end end size to lerp between\r\n     * @param amount amount to lerp between the start and end values\r\n     * @returns a new Size set at the linear interpolation \"amount\" between \"start\" and \"end\"\r\n     */\r\n    public static Lerp(start: Size, end: Size, amount: number): Size {\r\n        const w = start.width + (end.width - start.width) * amount;\r\n        const h = start.height + (end.height - start.height) * amount;\r\n\r\n        return new Size(w, h);\r\n    }\r\n}\r\n", "import type { DeepImmutable } from \"../types\";\r\nimport { Vector3, Matrix } from \"./math.vector\";\r\nimport type { IPlaneLike } from \"./math.like\";\r\n\r\n/**\r\n * Represents a plane by the equation ax + by + cz + d = 0\r\n */\r\nexport class Plane implements IPlaneLike {\r\n    private static _TmpMatrix = Matrix.Identity();\r\n\r\n    /**\r\n     * Normal of the plane (a,b,c)\r\n     */\r\n    public normal: Vector3;\r\n    /**\r\n     * d component of the plane\r\n     */\r\n    public d: number;\r\n    /**\r\n     * Creates a Plane object according to the given floats a, b, c, d and the plane equation : ax + by + cz + d = 0\r\n     * @param a a component of the plane\r\n     * @param b b component of the plane\r\n     * @param c c component of the plane\r\n     * @param d d component of the plane\r\n     */\r\n    constructor(a: number, b: number, c: number, d: number) {\r\n        this.normal = new Vector3(a, b, c);\r\n        this.d = d;\r\n    }\r\n\r\n    /**\r\n     * @returns the plane coordinates as a new array of 4 elements [a, b, c, d].\r\n     */\r\n    public asArray(): number[] {\r\n        return [this.normal.x, this.normal.y, this.normal.z, this.d];\r\n    }\r\n\r\n    // Methods\r\n    /**\r\n     * @returns a new plane copied from the current Plane.\r\n     */\r\n    public clone(): Plane {\r\n        return new Plane(this.normal.x, this.normal.y, this.normal.z, this.d);\r\n    }\r\n    /**\r\n     * @returns the string \"Plane\".\r\n     */\r\n    public getClassName(): string {\r\n        return \"Plane\";\r\n    }\r\n    /**\r\n     * @returns the Plane hash code.\r\n     */\r\n    public getHashCode(): number {\r\n        let hash = this.normal.getHashCode();\r\n        hash = (hash * 397) ^ (this.d | 0);\r\n        return hash;\r\n    }\r\n    /**\r\n     * Normalize the current Plane in place.\r\n     * @returns the updated Plane.\r\n     */\r\n    public normalize(): Plane {\r\n        const norm = Math.sqrt(this.normal.x * this.normal.x + this.normal.y * this.normal.y + this.normal.z * this.normal.z);\r\n        let magnitude = 0.0;\r\n\r\n        if (norm !== 0) {\r\n            magnitude = 1.0 / norm;\r\n        }\r\n        this.normal.x *= magnitude;\r\n        this.normal.y *= magnitude;\r\n        this.normal.z *= magnitude;\r\n        this.d *= magnitude;\r\n        return this;\r\n    }\r\n    /**\r\n     * Applies a transformation the plane and returns the result\r\n     * @param transformation the transformation matrix to be applied to the plane\r\n     * @returns a new Plane as the result of the transformation of the current Plane by the given matrix.\r\n     */\r\n    public transform(transformation: DeepImmutable<Matrix>): Plane {\r\n        const invertedMatrix = Plane._TmpMatrix;\r\n        transformation.invertToRef(invertedMatrix);\r\n        const m = invertedMatrix.m;\r\n        const x = this.normal.x;\r\n        const y = this.normal.y;\r\n        const z = this.normal.z;\r\n        const d = this.d;\r\n\r\n        const normalX = x * m[0] + y * m[1] + z * m[2] + d * m[3];\r\n        const normalY = x * m[4] + y * m[5] + z * m[6] + d * m[7];\r\n        const normalZ = x * m[8] + y * m[9] + z * m[10] + d * m[11];\r\n        const finalD = x * m[12] + y * m[13] + z * m[14] + d * m[15];\r\n\r\n        return new Plane(normalX, normalY, normalZ, finalD);\r\n    }\r\n\r\n    /**\r\n     * Compute the dot product between the point and the plane normal\r\n     * @param point point to calculate the dot product with\r\n     * @returns the dot product (float) of the point coordinates and the plane normal.\r\n     */\r\n    public dotCoordinate(point: DeepImmutable<Vector3>): number {\r\n        return this.normal.x * point.x + this.normal.y * point.y + this.normal.z * point.z + this.d;\r\n    }\r\n\r\n    /**\r\n     * Updates the current Plane from the plane defined by the three given points.\r\n     * @param point1 one of the points used to construct the plane\r\n     * @param point2 one of the points used to construct the plane\r\n     * @param point3 one of the points used to construct the plane\r\n     * @returns the updated Plane.\r\n     */\r\n    public copyFromPoints(point1: DeepImmutable<Vector3>, point2: DeepImmutable<Vector3>, point3: DeepImmutable<Vector3>): Plane {\r\n        const x1 = point2.x - point1.x;\r\n        const y1 = point2.y - point1.y;\r\n        const z1 = point2.z - point1.z;\r\n        const x2 = point3.x - point1.x;\r\n        const y2 = point3.y - point1.y;\r\n        const z2 = point3.z - point1.z;\r\n        const yz = y1 * z2 - z1 * y2;\r\n        const xz = z1 * x2 - x1 * z2;\r\n        const xy = x1 * y2 - y1 * x2;\r\n        const pyth = Math.sqrt(yz * yz + xz * xz + xy * xy);\r\n        let invPyth;\r\n\r\n        if (pyth !== 0) {\r\n            invPyth = 1.0 / pyth;\r\n        } else {\r\n            invPyth = 0.0;\r\n        }\r\n\r\n        this.normal.x = yz * invPyth;\r\n        this.normal.y = xz * invPyth;\r\n        this.normal.z = xy * invPyth;\r\n        this.d = -(this.normal.x * point1.x + this.normal.y * point1.y + this.normal.z * point1.z);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Checks if the plane is facing a given direction (meaning if the plane's normal is pointing in the opposite direction of the given vector).\r\n     * Note that for this function to work as expected you should make sure that:\r\n     *   - direction and the plane normal are normalized\r\n     *   - epsilon is a number just bigger than -1, something like -0.99 for eg\r\n     * @param direction the direction to check if the plane is facing\r\n     * @param epsilon value the dot product is compared against (returns true if dot <= epsilon)\r\n     * @returns True if the plane is facing the given direction\r\n     */\r\n    public isFrontFacingTo(direction: DeepImmutable<Vector3>, epsilon: number): boolean {\r\n        const dot = Vector3.Dot(this.normal, direction);\r\n        return dot <= epsilon;\r\n    }\r\n\r\n    /**\r\n     * Calculates the distance to a point\r\n     * @param point point to calculate distance to\r\n     * @returns the signed distance (float) from the given point to the Plane.\r\n     */\r\n    public signedDistanceTo(point: DeepImmutable<Vector3>): number {\r\n        return Vector3.Dot(point, this.normal) + this.d;\r\n    }\r\n\r\n    // Statics\r\n    /**\r\n     * Creates a plane from an  array\r\n     * @param array the array to create a plane from\r\n     * @returns a new Plane from the given array.\r\n     */\r\n    static FromArray(array: DeepImmutable<ArrayLike<number>>): Plane {\r\n        return new Plane(array[0], array[1], array[2], array[3]);\r\n    }\r\n    /**\r\n     * Creates a plane from three points\r\n     * @param point1 point used to create the plane\r\n     * @param point2 point used to create the plane\r\n     * @param point3 point used to create the plane\r\n     * @returns a new Plane defined by the three given points.\r\n     */\r\n    static FromPoints(point1: DeepImmutable<Vector3>, point2: DeepImmutable<Vector3>, point3: DeepImmutable<Vector3>): Plane {\r\n        const result = new Plane(0.0, 0.0, 0.0, 0.0);\r\n        result.copyFromPoints(point1, point2, point3);\r\n        return result;\r\n    }\r\n    /**\r\n     * Creates a plane from an origin point and a normal\r\n     * @param origin origin of the plane to be constructed\r\n     * @param normal normal of the plane to be constructed\r\n     * @returns a new Plane the normal vector to this plane at the given origin point.\r\n     */\r\n    static FromPositionAndNormal(origin: DeepImmutable<Vector3>, normal: Vector3): Plane {\r\n        const plane = new Plane(0.0, 0.0, 0.0, 0.0);\r\n        return this.FromPositionAndNormalToRef(origin, normal, plane);\r\n    }\r\n\r\n    /**\r\n     * Updates the given Plane \"result\" from an origin point and a normal.\r\n     * @param origin origin of the plane to be constructed\r\n     * @param normal the normalized normals of the plane to be constructed\r\n     * @param result defines the Plane where to store the result\r\n     * @returns result input\r\n     */\r\n    static FromPositionAndNormalToRef<T extends Plane>(origin: DeepImmutable<Vector3>, normal: DeepImmutable<Vector3>, result: T): T {\r\n        result.normal.copyFrom(normal);\r\n        result.normal.normalize();\r\n        result.d = -origin.dot(result.normal);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Calculates the distance from a plane and a point\r\n     * @param origin origin of the plane to be constructed\r\n     * @param normal normal of the plane to be constructed\r\n     * @param point point to calculate distance to\r\n     * @returns the signed distance between the plane defined by the normal vector at the \"origin\"\" point and the given other point.\r\n     */\r\n    static SignedDistanceToPlaneFromPositionAndNormal(origin: DeepImmutable<Vector3>, normal: DeepImmutable<Vector3>, point: DeepImmutable<Vector3>): number {\r\n        const d = -(normal.x * origin.x + normal.y * origin.y + normal.z * origin.z);\r\n        return Vector3.Dot(point, normal) + d;\r\n    }\r\n}\r\n", "import type { Nullable } from \"../../types\";\r\nimport type { InternalTexture } from \"../../Materials/Textures/internalTexture\";\r\nimport { Constants } from \"../../Engines/constants\";\r\n\r\nimport type { ISize } from \"../../Maths/math.size\";\r\nimport { Size } from \"../../Maths/math.size\";\r\n\r\nimport type { AbstractEngine } from \"../../Engines/abstractEngine\";\r\nimport type { RenderTargetWrapper } from \"core/Engines/renderTargetWrapper\";\r\n\r\n/**\r\n * Base class of all the textures in babylon.\r\n * It groups all the common properties required to work with Thin Engine.\r\n */\r\nexport class ThinTexture {\r\n    protected _wrapU = Constants.TEXTURE_WRAP_ADDRESSMODE;\r\n    /**\r\n     * | Value | Type               | Description |\r\n     * | ----- | ------------------ | ----------- |\r\n     * | 0     | CLAMP_ADDRESSMODE  |             |\r\n     * | 1     | WRAP_ADDRESSMODE   |             |\r\n     * | 2     | MIRROR_ADDRESSMODE |             |\r\n     */\r\n    public get wrapU() {\r\n        return this._wrapU;\r\n    }\r\n\r\n    public set wrapU(value: number) {\r\n        this._wrapU = value;\r\n    }\r\n\r\n    protected _wrapV = Constants.TEXTURE_WRAP_ADDRESSMODE;\r\n    /**\r\n     * | Value | Type               | Description |\r\n     * | ----- | ------------------ | ----------- |\r\n     * | 0     | CLAMP_ADDRESSMODE  |             |\r\n     * | 1     | WRAP_ADDRESSMODE   |             |\r\n     * | 2     | MIRROR_ADDRESSMODE |             |\r\n     */\r\n    public get wrapV() {\r\n        return this._wrapV;\r\n    }\r\n\r\n    public set wrapV(value: number) {\r\n        this._wrapV = value;\r\n    }\r\n\r\n    /**\r\n     * | Value | Type               | Description |\r\n     * | ----- | ------------------ | ----------- |\r\n     * | 0     | CLAMP_ADDRESSMODE  |             |\r\n     * | 1     | WRAP_ADDRESSMODE   |             |\r\n     * | 2     | MIRROR_ADDRESSMODE |             |\r\n     */\r\n    public wrapR = Constants.TEXTURE_WRAP_ADDRESSMODE;\r\n\r\n    /**\r\n     * With compliant hardware and browser (supporting anisotropic filtering)\r\n     * this defines the level of anisotropic filtering in the texture.\r\n     * The higher the better but the slower. This defaults to 4 as it seems to be the best tradeoff.\r\n     */\r\n    public anisotropicFilteringLevel = 4;\r\n\r\n    /**\r\n     * Define the current state of the loading sequence when in delayed load mode.\r\n     */\r\n    public delayLoadState = Constants.DELAYLOADSTATE_NONE;\r\n\r\n    /**\r\n     * How a texture is mapped.\r\n     * Unused in thin texture mode.\r\n     */\r\n    public get coordinatesMode(): number {\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Define if the texture is a cube texture or if false a 2d texture.\r\n     */\r\n    public get isCube(): boolean {\r\n        if (!this._texture) {\r\n            return false;\r\n        }\r\n\r\n        return this._texture.isCube;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    protected set isCube(value: boolean) {\r\n        if (!this._texture) {\r\n            return;\r\n        }\r\n\r\n        this._texture.isCube = value;\r\n    }\r\n\r\n    /**\r\n     * Define if the texture is a 3d texture (webgl 2) or if false a 2d texture.\r\n     */\r\n    public get is3D(): boolean {\r\n        if (!this._texture) {\r\n            return false;\r\n        }\r\n\r\n        return this._texture.is3D;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    protected set is3D(value: boolean) {\r\n        if (!this._texture) {\r\n            return;\r\n        }\r\n\r\n        this._texture.is3D = value;\r\n    }\r\n\r\n    /**\r\n     * Define if the texture is a 2d array texture (webgl 2) or if false a 2d texture.\r\n     */\r\n    public get is2DArray(): boolean {\r\n        if (!this._texture) {\r\n            return false;\r\n        }\r\n\r\n        return this._texture.is2DArray;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    protected set is2DArray(value: boolean) {\r\n        if (!this._texture) {\r\n            return;\r\n        }\r\n\r\n        this._texture.is2DArray = value;\r\n    }\r\n\r\n    /**\r\n     * Get the class name of the texture.\r\n     * @returns \"ThinTexture\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"ThinTexture\";\r\n    }\r\n\r\n    /** @internal */\r\n    public _texture: Nullable<InternalTexture> = null;\r\n\r\n    protected _engine: Nullable<AbstractEngine> = null;\r\n\r\n    private _cachedSize: ISize = Size.Zero();\r\n    private _cachedBaseSize: ISize = Size.Zero();\r\n\r\n    private static _IsRenderTargetWrapper(texture: Nullable<InternalTexture> | Nullable<RenderTargetWrapper>): texture is RenderTargetWrapper {\r\n        return (texture as RenderTargetWrapper)?.shareDepth !== undefined;\r\n    }\r\n\r\n    /**\r\n     * Instantiates a new ThinTexture.\r\n     * Base class of all the textures in babylon.\r\n     * This can be used as an internal texture wrapper in AbstractEngine to benefit from the cache\r\n     * @param internalTexture Define the internalTexture to wrap. You can also pass a RenderTargetWrapper, in which case the texture will be the render target's texture\r\n     */\r\n    constructor(internalTexture: Nullable<InternalTexture | RenderTargetWrapper>) {\r\n        this._texture = ThinTexture._IsRenderTargetWrapper(internalTexture) ? internalTexture.texture : internalTexture;\r\n        if (this._texture) {\r\n            this._engine = this._texture.getEngine();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get if the texture is ready to be used (downloaded, converted, mip mapped...).\r\n     * @returns true if fully ready\r\n     */\r\n    public isReady(): boolean {\r\n        if (this.delayLoadState === Constants.DELAYLOADSTATE_NOTLOADED) {\r\n            this.delayLoad();\r\n            return false;\r\n        }\r\n\r\n        if (this._texture) {\r\n            return this._texture.isReady;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Triggers the load sequence in delayed load mode.\r\n     */\r\n    public delayLoad(): void {}\r\n\r\n    /**\r\n     * Get the underlying lower level texture from Babylon.\r\n     * @returns the internal texture\r\n     */\r\n    public getInternalTexture(): Nullable<InternalTexture> {\r\n        return this._texture;\r\n    }\r\n\r\n    /**\r\n     * Get the size of the texture.\r\n     * @returns the texture size.\r\n     */\r\n    public getSize(): ISize {\r\n        if (this._texture) {\r\n            if (this._texture.width) {\r\n                this._cachedSize.width = this._texture.width;\r\n                this._cachedSize.height = this._texture.height;\r\n                return this._cachedSize;\r\n            }\r\n\r\n            if (this._texture._size) {\r\n                this._cachedSize.width = this._texture._size;\r\n                this._cachedSize.height = this._texture._size;\r\n                return this._cachedSize;\r\n            }\r\n        }\r\n\r\n        return this._cachedSize;\r\n    }\r\n\r\n    /**\r\n     * Get the base size of the texture.\r\n     * It can be different from the size if the texture has been resized for POT for instance\r\n     * @returns the base size\r\n     */\r\n    public getBaseSize(): ISize {\r\n        if (!this.isReady() || !this._texture) {\r\n            this._cachedBaseSize.width = 0;\r\n            this._cachedBaseSize.height = 0;\r\n            return this._cachedBaseSize;\r\n        }\r\n\r\n        if (this._texture._size) {\r\n            this._cachedBaseSize.width = this._texture._size;\r\n            this._cachedBaseSize.height = this._texture._size;\r\n            return this._cachedBaseSize;\r\n        }\r\n\r\n        this._cachedBaseSize.width = this._texture.baseWidth;\r\n        this._cachedBaseSize.height = this._texture.baseHeight;\r\n        return this._cachedBaseSize;\r\n    }\r\n\r\n    /** @internal */\r\n    protected _initialSamplingMode = Constants.TEXTURE_BILINEAR_SAMPLINGMODE;\r\n\r\n    /**\r\n     * Get the current sampling mode associated with the texture.\r\n     */\r\n    public get samplingMode(): number {\r\n        if (!this._texture) {\r\n            return this._initialSamplingMode;\r\n        }\r\n\r\n        return this._texture.samplingMode;\r\n    }\r\n\r\n    /**\r\n     * Update the sampling mode of the texture.\r\n     * Default is Trilinear mode.\r\n     *\r\n     * | Value | Type               | Description |\r\n     * | ----- | ------------------ | ----------- |\r\n     * | 1     | NEAREST_SAMPLINGMODE or NEAREST_NEAREST_MIPLINEAR  | Nearest is: mag = nearest, min = nearest, mip = linear |\r\n     * | 2     | BILINEAR_SAMPLINGMODE or LINEAR_LINEAR_MIPNEAREST | Bilinear is: mag = linear, min = linear, mip = nearest |\r\n     * | 3     | TRILINEAR_SAMPLINGMODE or LINEAR_LINEAR_MIPLINEAR | Trilinear is: mag = linear, min = linear, mip = linear |\r\n     * | 4     | NEAREST_NEAREST_MIPNEAREST |             |\r\n     * | 5    | NEAREST_LINEAR_MIPNEAREST |             |\r\n     * | 6    | NEAREST_LINEAR_MIPLINEAR |             |\r\n     * | 7    | NEAREST_LINEAR |             |\r\n     * | 8    | NEAREST_NEAREST |             |\r\n     * | 9   | LINEAR_NEAREST_MIPNEAREST |             |\r\n     * | 10   | LINEAR_NEAREST_MIPLINEAR |             |\r\n     * | 11   | LINEAR_LINEAR |             |\r\n     * | 12   | LINEAR_NEAREST |             |\r\n     *\r\n     *    > _mag_: magnification filter (close to the viewer)\r\n     *    > _min_: minification filter (far from the viewer)\r\n     *    > _mip_: filter used between mip map levels\r\n     *@param samplingMode Define the new sampling mode of the texture\r\n     */\r\n    public updateSamplingMode(samplingMode: number): void {\r\n        if (this._texture && this._engine) {\r\n            this._engine.updateTextureSamplingMode(samplingMode, this._texture);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Release and destroy the underlying lower level texture aka internalTexture.\r\n     */\r\n    public releaseInternalTexture(): void {\r\n        if (this._texture) {\r\n            this._texture.dispose();\r\n            this._texture = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Dispose the texture and release its associated resources.\r\n     */\r\n    public dispose(): void {\r\n        if (this._texture) {\r\n            this.releaseInternalTexture();\r\n            this._engine = null;\r\n        }\r\n    }\r\n}\r\n", "import { serialize, serializeAsTexture } from \"../../Misc/decorators\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Matrix } from \"../../Maths/math.vector\";\r\nimport { EngineStore } from \"../../Engines/engineStore\";\r\nimport type { InternalTexture } from \"../../Materials/Textures/internalTexture\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport type { IAnimatable } from \"../../Animations/animatable.interface\";\r\nimport { RandomGUID } from \"../../Misc/guid\";\r\n\r\nimport \"../../Misc/fileTools\";\r\nimport type { AbstractEngine } from \"../../Engines/abstractEngine\";\r\nimport { ThinTexture } from \"./thinTexture\";\r\n\r\nimport type { Animation } from \"../../Animations/animation\";\r\nimport { SerializationHelper } from \"../../Misc/decorators.serialization\";\r\nimport type { IAssetContainer } from \"core/IAssetContainer\";\r\n\r\n/**\r\n * Base class of all the textures in babylon.\r\n * It groups all the common properties the materials, post process, lights... might need\r\n * in order to make a correct use of the texture.\r\n */\r\nexport class BaseTexture extends ThinTexture implements IAnimatable {\r\n    /**\r\n     * Default anisotropic filtering level for the application.\r\n     * It is set to 4 as a good tradeoff between perf and quality.\r\n     */\r\n    public static DEFAULT_ANISOTROPIC_FILTERING_LEVEL = 4;\r\n\r\n    /**\r\n     * Gets or sets the unique id of the texture\r\n     */\r\n    @serialize()\r\n    public uniqueId: number;\r\n\r\n    /**\r\n     * Define the name of the texture.\r\n     */\r\n    @serialize()\r\n    public name: string;\r\n\r\n    /**\r\n     * Define the display name of the texture, which is used as tree item name of the dedicated node in the inspector\r\n     */\r\n    @serialize()\r\n    public displayName: string;\r\n\r\n    /**\r\n     * Gets or sets an object used to store user defined information.\r\n     */\r\n    @serialize()\r\n    public metadata: any = null;\r\n\r\n    /** @internal */\r\n    public _internalMetadata: any;\r\n\r\n    /**\r\n     * For internal use only. Please do not use.\r\n     */\r\n    public reservedDataStore: any = null;\r\n\r\n    @serialize(\"hasAlpha\")\r\n    private _hasAlpha = false;\r\n    /**\r\n     * Define if the texture is having a usable alpha value (can be use for transparency or glossiness for instance).\r\n     */\r\n    public set hasAlpha(value: boolean) {\r\n        if (this._hasAlpha === value) {\r\n            return;\r\n        }\r\n        this._hasAlpha = value;\r\n        if (this._scene) {\r\n            this._scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(this);\r\n            });\r\n        }\r\n    }\r\n    public get hasAlpha(): boolean {\r\n        return this._hasAlpha;\r\n    }\r\n\r\n    @serialize(\"getAlphaFromRGB\")\r\n    private _getAlphaFromRGB = false;\r\n    /**\r\n     * Defines if the alpha value should be determined via the rgb values.\r\n     * If true the luminance of the pixel might be used to find the corresponding alpha value.\r\n     */\r\n    public set getAlphaFromRGB(value: boolean) {\r\n        if (this._getAlphaFromRGB === value) {\r\n            return;\r\n        }\r\n        this._getAlphaFromRGB = value;\r\n        if (this._scene) {\r\n            this._scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(this);\r\n            });\r\n        }\r\n    }\r\n    public get getAlphaFromRGB(): boolean {\r\n        return this._getAlphaFromRGB;\r\n    }\r\n\r\n    /**\r\n     * Intensity or strength of the texture.\r\n     * It is commonly used by materials to fine tune the intensity of the texture\r\n     */\r\n    @serialize()\r\n    public level = 1;\r\n\r\n    @serialize(\"coordinatesIndex\")\r\n    protected _coordinatesIndex = 0;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that the texture should try to reduce shader code if there is no UV manipulation.\r\n     * (ie. when texture.getTextureMatrix().isIdentityAs3x2() returns true)\r\n     */\r\n    @serialize()\r\n    public optimizeUVAllocation = true;\r\n\r\n    /**\r\n     * Define the UV channel to use starting from 0 and defaulting to 0.\r\n     * This is part of the texture as textures usually maps to one uv set.\r\n     */\r\n    public set coordinatesIndex(value: number) {\r\n        if (this._coordinatesIndex === value) {\r\n            return;\r\n        }\r\n        this._coordinatesIndex = value;\r\n        if (this._scene) {\r\n            this._scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(this);\r\n            });\r\n        }\r\n    }\r\n    public get coordinatesIndex(): number {\r\n        return this._coordinatesIndex;\r\n    }\r\n\r\n    @serialize(\"coordinatesMode\")\r\n    protected _coordinatesMode = Constants.TEXTURE_EXPLICIT_MODE;\r\n\r\n    /**\r\n     * How a texture is mapped.\r\n     *\r\n     * | Value | Type                                | Description |\r\n     * | ----- | ----------------------------------- | ----------- |\r\n     * | 0     | EXPLICIT_MODE                       |             |\r\n     * | 1     | SPHERICAL_MODE                      |             |\r\n     * | 2     | PLANAR_MODE                         |             |\r\n     * | 3     | CUBIC_MODE                          |             |\r\n     * | 4     | PROJECTION_MODE                     |             |\r\n     * | 5     | SKYBOX_MODE                         |             |\r\n     * | 6     | INVCUBIC_MODE                       |             |\r\n     * | 7     | EQUIRECTANGULAR_MODE                |             |\r\n     * | 8     | FIXED_EQUIRECTANGULAR_MODE          |             |\r\n     * | 9     | FIXED_EQUIRECTANGULAR_MIRRORED_MODE |             |\r\n     */\r\n    public override set coordinatesMode(value: number) {\r\n        if (this._coordinatesMode === value) {\r\n            return;\r\n        }\r\n        this._coordinatesMode = value;\r\n        if (this._scene) {\r\n            this._scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(this);\r\n            });\r\n        }\r\n    }\r\n    public override get coordinatesMode(): number {\r\n        return this._coordinatesMode;\r\n    }\r\n\r\n    /**\r\n     * | Value | Type               | Description |\r\n     * | ----- | ------------------ | ----------- |\r\n     * | 0     | CLAMP_ADDRESSMODE  |             |\r\n     * | 1     | WRAP_ADDRESSMODE   |             |\r\n     * | 2     | MIRROR_ADDRESSMODE |             |\r\n     */\r\n    @serialize()\r\n    public override get wrapU() {\r\n        return this._wrapU;\r\n    }\r\n    public override set wrapU(value: number) {\r\n        this._wrapU = value;\r\n    }\r\n\r\n    /**\r\n     * | Value | Type               | Description |\r\n     * | ----- | ------------------ | ----------- |\r\n     * | 0     | CLAMP_ADDRESSMODE  |             |\r\n     * | 1     | WRAP_ADDRESSMODE   |             |\r\n     * | 2     | MIRROR_ADDRESSMODE |             |\r\n     */\r\n    @serialize()\r\n    public override get wrapV() {\r\n        return this._wrapV;\r\n    }\r\n    public override set wrapV(value: number) {\r\n        this._wrapV = value;\r\n    }\r\n\r\n    /**\r\n     * | Value | Type               | Description |\r\n     * | ----- | ------------------ | ----------- |\r\n     * | 0     | CLAMP_ADDRESSMODE  |             |\r\n     * | 1     | WRAP_ADDRESSMODE   |             |\r\n     * | 2     | MIRROR_ADDRESSMODE |             |\r\n     */\r\n    @serialize()\r\n    public override wrapR = Constants.TEXTURE_WRAP_ADDRESSMODE;\r\n\r\n    /**\r\n     * With compliant hardware and browser (supporting anisotropic filtering)\r\n     * this defines the level of anisotropic filtering in the texture.\r\n     * The higher the better but the slower. This defaults to 4 as it seems to be the best tradeoff.\r\n     */\r\n    @serialize()\r\n    public override anisotropicFilteringLevel = BaseTexture.DEFAULT_ANISOTROPIC_FILTERING_LEVEL;\r\n\r\n    /** @internal */\r\n    public _isCube = false;\r\n    /**\r\n     * Define if the texture is a cube texture or if false a 2d texture.\r\n     */\r\n    @serialize()\r\n    public override get isCube(): boolean {\r\n        if (!this._texture) {\r\n            return this._isCube;\r\n        }\r\n\r\n        return this._texture.isCube;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    protected override set isCube(value: boolean) {\r\n        if (!this._texture) {\r\n            this._isCube = value;\r\n        } else {\r\n            this._texture.isCube = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Define if the texture is a 3d texture (webgl 2) or if false a 2d texture.\r\n     */\r\n    @serialize()\r\n    public override get is3D(): boolean {\r\n        if (!this._texture) {\r\n            return false;\r\n        }\r\n\r\n        return this._texture.is3D;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    protected override set is3D(value: boolean) {\r\n        if (!this._texture) {\r\n            return;\r\n        }\r\n\r\n        this._texture.is3D = value;\r\n    }\r\n\r\n    /**\r\n     * Define if the texture is a 2d array texture (webgl 2) or if false a 2d texture.\r\n     */\r\n    @serialize()\r\n    public override get is2DArray(): boolean {\r\n        if (!this._texture) {\r\n            return false;\r\n        }\r\n\r\n        return this._texture.is2DArray;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    protected override set is2DArray(value: boolean) {\r\n        if (!this._texture) {\r\n            return;\r\n        }\r\n\r\n        this._texture.is2DArray = value;\r\n    }\r\n\r\n    /** @internal */\r\n    protected _gammaSpace = true;\r\n    /**\r\n     * Define if the texture contains data in gamma space (most of the png/jpg aside bump).\r\n     * HDR texture are usually stored in linear space.\r\n     * This only impacts the PBR and Background materials\r\n     */\r\n    @serialize()\r\n    public get gammaSpace(): boolean {\r\n        if (!this._texture) {\r\n            return this._gammaSpace;\r\n        } else {\r\n            if (this._texture._gammaSpace === null) {\r\n                this._texture._gammaSpace = this._gammaSpace;\r\n            }\r\n        }\r\n\r\n        return this._texture._gammaSpace && !this._texture._useSRGBBuffer;\r\n    }\r\n\r\n    public set gammaSpace(gamma: boolean) {\r\n        if (!this._texture) {\r\n            if (this._gammaSpace === gamma) {\r\n                return;\r\n            }\r\n\r\n            this._gammaSpace = gamma;\r\n        } else {\r\n            if (this._texture._gammaSpace === gamma) {\r\n                return;\r\n            }\r\n            this._texture._gammaSpace = gamma;\r\n        }\r\n\r\n        this.getScene()?.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n            return mat.hasTexture(this);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Gets or sets whether or not the texture contains RGBD data.\r\n     */\r\n    public get isRGBD(): boolean {\r\n        return this._texture != null && this._texture._isRGBD;\r\n    }\r\n    public set isRGBD(value: boolean) {\r\n        if (value === this.isRGBD) {\r\n            return;\r\n        }\r\n\r\n        if (this._texture) {\r\n            this._texture._isRGBD = value;\r\n        }\r\n\r\n        this.getScene()?.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n            return mat.hasTexture(this);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Is Z inverted in the texture (useful in a cube texture).\r\n     */\r\n    @serialize()\r\n    public invertZ = false;\r\n\r\n    /**\r\n     * Are mip maps generated for this texture or not.\r\n     */\r\n    public get noMipmap(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    @serialize()\r\n    public lodLevelInAlpha = false;\r\n\r\n    /**\r\n     * With prefiltered texture, defined the offset used during the prefiltering steps.\r\n     */\r\n    @serialize()\r\n    public get lodGenerationOffset(): number {\r\n        if (this._texture) {\r\n            return this._texture._lodGenerationOffset;\r\n        }\r\n\r\n        return 0.0;\r\n    }\r\n    public set lodGenerationOffset(value: number) {\r\n        if (this._texture) {\r\n            this._texture._lodGenerationOffset = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * With prefiltered texture, defined the scale used during the prefiltering steps.\r\n     */\r\n    @serialize()\r\n    public get lodGenerationScale(): number {\r\n        if (this._texture) {\r\n            return this._texture._lodGenerationScale;\r\n        }\r\n\r\n        return 0.0;\r\n    }\r\n    public set lodGenerationScale(value: number) {\r\n        if (this._texture) {\r\n            this._texture._lodGenerationScale = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * With prefiltered texture, defined if the specular generation is based on a linear ramp.\r\n     * By default we are using a log2 of the linear roughness helping to keep a better resolution for\r\n     * average roughness values.\r\n     */\r\n    @serialize()\r\n    public get linearSpecularLOD(): boolean {\r\n        if (this._texture) {\r\n            return this._texture._linearSpecularLOD;\r\n        }\r\n\r\n        return false;\r\n    }\r\n    public set linearSpecularLOD(value: boolean) {\r\n        if (this._texture) {\r\n            this._texture._linearSpecularLOD = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * In case a better definition than spherical harmonics is required for the diffuse part of the environment.\r\n     * You can set the irradiance texture to rely on a texture instead of the spherical approach.\r\n     * This texture need to have the same characteristics than its parent (Cube vs 2d, coordinates mode, Gamma/Linear, RGBD).\r\n     */\r\n    @serializeAsTexture()\r\n    public get irradianceTexture(): Nullable<BaseTexture> {\r\n        if (this._texture) {\r\n            return this._texture._irradianceTexture;\r\n        }\r\n\r\n        return null;\r\n    }\r\n    public set irradianceTexture(value: Nullable<BaseTexture>) {\r\n        if (this._texture) {\r\n            this._texture._irradianceTexture = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Define if the texture is a render target.\r\n     */\r\n    @serialize()\r\n    public isRenderTarget = false;\r\n\r\n    /**\r\n     * Define the unique id of the texture in the scene.\r\n     */\r\n    public get uid(): string {\r\n        if (!this._uid) {\r\n            this._uid = RandomGUID();\r\n        }\r\n        return this._uid;\r\n    }\r\n\r\n    /** @internal */\r\n    public _prefiltered: boolean = false;\r\n    /** @internal */\r\n    public _forceSerialize: boolean = false;\r\n\r\n    /**\r\n     * Return a string representation of the texture.\r\n     * @returns the texture as a string\r\n     */\r\n    public override toString(): string {\r\n        return this.name;\r\n    }\r\n\r\n    /**\r\n     * Get the class name of the texture.\r\n     * @returns \"BaseTexture\"\r\n     */\r\n    public override getClassName(): string {\r\n        return \"BaseTexture\";\r\n    }\r\n\r\n    /**\r\n     * Define the list of animation attached to the texture.\r\n     */\r\n    public animations: Animation[] = [];\r\n\r\n    /**\r\n     * An event triggered when the texture is disposed.\r\n     */\r\n    public onDisposeObservable = new Observable<BaseTexture>();\r\n\r\n    private _onDisposeObserver: Nullable<Observer<BaseTexture>> = null;\r\n    /**\r\n     * Callback triggered when the texture has been disposed.\r\n     * Kept for back compatibility, you can use the onDisposeObservable instead.\r\n     */\r\n    public set onDispose(callback: () => void) {\r\n        if (this._onDisposeObserver) {\r\n            this.onDisposeObservable.remove(this._onDisposeObserver);\r\n        }\r\n        this._onDisposeObserver = this.onDisposeObservable.add(callback);\r\n    }\r\n\r\n    protected _scene: Nullable<Scene> = null;\r\n\r\n    /** @internal */\r\n    private _uid: Nullable<string> = null;\r\n\r\n    /**\r\n     * Define if the texture is preventing a material to render or not.\r\n     * If not and the texture is not ready, the engine will use a default black texture instead.\r\n     */\r\n    public get isBlocking(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /** @internal */\r\n    public _parentContainer: Nullable<IAssetContainer> = null;\r\n\r\n    protected _loadingError: boolean = false;\r\n    protected _errorObject?: {\r\n        message?: string;\r\n        exception?: any;\r\n    };\r\n\r\n    /**\r\n     * Was there any loading error?\r\n     */\r\n    public get loadingError(): boolean {\r\n        return this._loadingError;\r\n    }\r\n\r\n    /**\r\n     * If a loading error occurred this object will be populated with information about the error.\r\n     */\r\n    public get errorObject():\r\n        | {\r\n              message?: string;\r\n              exception?: any;\r\n          }\r\n        | undefined {\r\n        return this._errorObject;\r\n    }\r\n\r\n    /**\r\n     * Instantiates a new BaseTexture.\r\n     * Base class of all the textures in babylon.\r\n     * It groups all the common properties the materials, post process, lights... might need\r\n     * in order to make a correct use of the texture.\r\n     * @param sceneOrEngine Define the scene or engine the texture belongs to\r\n     * @param internalTexture Define the internal texture associated with the texture\r\n     */\r\n    constructor(sceneOrEngine?: Nullable<Scene | AbstractEngine>, internalTexture: Nullable<InternalTexture> = null) {\r\n        super(null);\r\n\r\n        if (sceneOrEngine) {\r\n            if (BaseTexture._IsScene(sceneOrEngine)) {\r\n                this._scene = sceneOrEngine;\r\n            } else {\r\n                this._engine = sceneOrEngine;\r\n            }\r\n        } else {\r\n            this._scene = EngineStore.LastCreatedScene;\r\n        }\r\n\r\n        if (this._scene) {\r\n            this.uniqueId = this._scene.getUniqueId();\r\n            this._scene.addTexture(this);\r\n            this._engine = this._scene.getEngine();\r\n        }\r\n\r\n        this._texture = internalTexture;\r\n\r\n        this._uid = null;\r\n    }\r\n\r\n    /**\r\n     * Get the scene the texture belongs to.\r\n     * @returns the scene or null if undefined\r\n     */\r\n    public getScene(): Nullable<Scene> {\r\n        return this._scene;\r\n    }\r\n\r\n    /** @internal */\r\n    protected _getEngine(): Nullable<AbstractEngine> {\r\n        return this._engine;\r\n    }\r\n\r\n    /**\r\n     * Get the texture transform matrix used to offset tile the texture for instance.\r\n     * @returns the transformation matrix\r\n     */\r\n    public getTextureMatrix(): Matrix {\r\n        return <Matrix>Matrix.IdentityReadOnly;\r\n    }\r\n\r\n    /**\r\n     * Get the texture reflection matrix used to rotate/transform the reflection.\r\n     * @returns the reflection matrix\r\n     */\r\n    public getReflectionTextureMatrix(): Matrix {\r\n        return <Matrix>Matrix.IdentityReadOnly;\r\n    }\r\n\r\n    /**\r\n     * Gets a suitable rotate/transform matrix when the texture is used for refraction.\r\n     * There's a separate function from getReflectionTextureMatrix because refraction requires a special configuration of the matrix in right-handed mode.\r\n     * @returns The refraction matrix\r\n     */\r\n    public getRefractionTextureMatrix(): Matrix {\r\n        return this.getReflectionTextureMatrix();\r\n    }\r\n\r\n    /**\r\n     * Get if the texture is ready to be consumed (either it is ready or it is not blocking)\r\n     * @returns true if ready, not blocking or if there was an error loading the texture\r\n     */\r\n    public isReadyOrNotBlocking(): boolean {\r\n        return !this.isBlocking || this.isReady() || this.loadingError;\r\n    }\r\n\r\n    /**\r\n     * Scales the texture if is `canRescale()`\r\n     * @param ratio the resize factor we want to use to rescale\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public scale(ratio: number): void {}\r\n\r\n    /**\r\n     * Get if the texture can rescale.\r\n     */\r\n    public get canRescale(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getFromCache(url: Nullable<string>, noMipmap: boolean, sampling?: number, invertY?: boolean, useSRGBBuffer?: boolean, isCube?: boolean): Nullable<InternalTexture> {\r\n        const engine = this._getEngine();\r\n        if (!engine) {\r\n            return null;\r\n        }\r\n\r\n        const correctedUseSRGBBuffer = engine._getUseSRGBBuffer(!!useSRGBBuffer, noMipmap);\r\n\r\n        const texturesCache = engine.getLoadedTexturesCache();\r\n        for (let index = 0; index < texturesCache.length; index++) {\r\n            const texturesCacheEntry = texturesCache[index];\r\n\r\n            if (useSRGBBuffer === undefined || correctedUseSRGBBuffer === texturesCacheEntry._useSRGBBuffer) {\r\n                if (invertY === undefined || invertY === texturesCacheEntry.invertY) {\r\n                    if (texturesCacheEntry.url === url && texturesCacheEntry.generateMipMaps === !noMipmap) {\r\n                        if (!sampling || sampling === texturesCacheEntry.samplingMode) {\r\n                            if (isCube === undefined || isCube === texturesCacheEntry.isCube) {\r\n                                texturesCacheEntry.incrementReferences();\r\n                                return texturesCacheEntry;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /** @internal */\r\n    public _rebuild(_fromContextLost = false): void {}\r\n\r\n    /**\r\n     * Clones the texture.\r\n     * @returns the cloned texture\r\n     */\r\n    public clone(): Nullable<BaseTexture> {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Get the texture underlying type (INT, FLOAT...)\r\n     */\r\n    public get textureType(): number {\r\n        if (!this._texture) {\r\n            return Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n        }\r\n\r\n        return this._texture.type !== undefined ? this._texture.type : Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n    }\r\n\r\n    /**\r\n     * Get the texture underlying format (RGB, RGBA...)\r\n     */\r\n    public get textureFormat(): number {\r\n        if (!this._texture) {\r\n            return Constants.TEXTUREFORMAT_RGBA;\r\n        }\r\n\r\n        return this._texture.format !== undefined ? this._texture.format : Constants.TEXTUREFORMAT_RGBA;\r\n    }\r\n\r\n    /**\r\n     * Indicates that textures need to be re-calculated for all materials\r\n     */\r\n    protected _markAllSubMeshesAsTexturesDirty() {\r\n        const scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n    }\r\n\r\n    /**\r\n     * Reads the pixels stored in the webgl texture and returns them as an ArrayBuffer.\r\n     * This will returns an RGBA array buffer containing either in values (0-255) or\r\n     * float values (0-1) depending of the underlying buffer type.\r\n     * @param faceIndex defines the face of the texture to read (in case of cube texture)\r\n     * @param level defines the LOD level of the texture to read (in case of Mip Maps)\r\n     * @param buffer defines a user defined buffer to fill with data (can be null)\r\n     * @param flushRenderer true to flush the renderer from the pending commands before reading the pixels\r\n     * @param noDataConversion false to convert the data to Uint8Array (if texture type is UNSIGNED_BYTE) or to Float32Array (if texture type is anything but UNSIGNED_BYTE). If true, the type of the generated buffer (if buffer==null) will depend on the type of the texture\r\n     * @param x defines the region x coordinates to start reading from (default to 0)\r\n     * @param y defines the region y coordinates to start reading from (default to 0)\r\n     * @param width defines the region width to read from (default to the texture size at level)\r\n     * @param height defines the region width to read from (default to the texture size at level)\r\n     * @returns The Array buffer promise containing the pixels data.\r\n     */\r\n    public readPixels(\r\n        faceIndex = 0,\r\n        level = 0,\r\n        buffer: Nullable<ArrayBufferView> = null,\r\n        flushRenderer = true,\r\n        noDataConversion = false,\r\n        x = 0,\r\n        y = 0,\r\n        width = Number.MAX_VALUE,\r\n        height = Number.MAX_VALUE\r\n    ): Nullable<Promise<ArrayBufferView>> {\r\n        if (!this._texture) {\r\n            return null;\r\n        }\r\n\r\n        const engine = this._getEngine();\r\n        if (!engine) {\r\n            return null;\r\n        }\r\n\r\n        const size = this.getSize();\r\n        let maxWidth = size.width;\r\n        let maxHeight = size.height;\r\n        if (level !== 0) {\r\n            maxWidth = maxWidth / Math.pow(2, level);\r\n            maxHeight = maxHeight / Math.pow(2, level);\r\n            maxWidth = Math.round(maxWidth);\r\n            maxHeight = Math.round(maxHeight);\r\n        }\r\n\r\n        width = Math.min(maxWidth, width);\r\n        height = Math.min(maxHeight, height);\r\n\r\n        try {\r\n            if (this._texture.isCube) {\r\n                return engine._readTexturePixels(this._texture, width, height, faceIndex, level, buffer, flushRenderer, noDataConversion, x, y);\r\n            }\r\n\r\n            return engine._readTexturePixels(this._texture, width, height, -1, level, buffer, flushRenderer, noDataConversion, x, y);\r\n        } catch (e) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _readPixelsSync(faceIndex = 0, level = 0, buffer: Nullable<ArrayBufferView> = null, flushRenderer = true, noDataConversion = false): Nullable<ArrayBufferView> {\r\n        if (!this._texture) {\r\n            return null;\r\n        }\r\n\r\n        const size = this.getSize();\r\n        let width = size.width;\r\n        let height = size.height;\r\n\r\n        const engine = this._getEngine();\r\n        if (!engine) {\r\n            return null;\r\n        }\r\n\r\n        if (level != 0) {\r\n            width = width / Math.pow(2, level);\r\n            height = height / Math.pow(2, level);\r\n\r\n            width = Math.round(width);\r\n            height = Math.round(height);\r\n        }\r\n\r\n        try {\r\n            if (this._texture.isCube) {\r\n                return engine._readTexturePixelsSync(this._texture, width, height, faceIndex, level, buffer, flushRenderer, noDataConversion);\r\n            }\r\n\r\n            return engine._readTexturePixelsSync(this._texture, width, height, -1, level, buffer, flushRenderer, noDataConversion);\r\n        } catch (e) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public get _lodTextureHigh(): Nullable<BaseTexture> {\r\n        if (this._texture) {\r\n            return this._texture._lodTextureHigh;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /** @internal */\r\n    public get _lodTextureMid(): Nullable<BaseTexture> {\r\n        if (this._texture) {\r\n            return this._texture._lodTextureMid;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /** @internal */\r\n    public get _lodTextureLow(): Nullable<BaseTexture> {\r\n        if (this._texture) {\r\n            return this._texture._lodTextureLow;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Dispose the texture and release its associated resources.\r\n     */\r\n    public override dispose(): void {\r\n        if (this._scene) {\r\n            // Animations\r\n            if (this._scene.stopAnimation) {\r\n                this._scene.stopAnimation(this);\r\n            }\r\n\r\n            // Remove from scene\r\n            this._scene.removePendingData(this);\r\n            const index = this._scene.textures.indexOf(this);\r\n\r\n            if (index >= 0) {\r\n                this._scene.textures.splice(index, 1);\r\n            }\r\n            this._scene.onTextureRemovedObservable.notifyObservers(this);\r\n            this._scene = null;\r\n\r\n            if (this._parentContainer) {\r\n                const index = this._parentContainer.textures.indexOf(this);\r\n                if (index > -1) {\r\n                    this._parentContainer.textures.splice(index, 1);\r\n                }\r\n                this._parentContainer = null;\r\n            }\r\n        }\r\n\r\n        // Callback\r\n        this.onDisposeObservable.notifyObservers(this);\r\n        this.onDisposeObservable.clear();\r\n\r\n        this.metadata = null;\r\n\r\n        super.dispose();\r\n    }\r\n\r\n    /**\r\n     * Serialize the texture into a JSON representation that can be parsed later on.\r\n     * @param allowEmptyName True to force serialization even if name is empty. Default: false\r\n     * @returns the JSON representation of the texture\r\n     */\r\n    public serialize(allowEmptyName = false): any {\r\n        if (!this.name && !allowEmptyName) {\r\n            return null;\r\n        }\r\n\r\n        const serializationObject = SerializationHelper.Serialize(this);\r\n\r\n        // Animations\r\n        SerializationHelper.AppendSerializedAnimations(this, serializationObject);\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Helper function to be called back once a list of texture contains only ready textures.\r\n     * @param textures Define the list of textures to wait for\r\n     * @param callback Define the callback triggered once the entire list will be ready\r\n     */\r\n    public static WhenAllReady(textures: BaseTexture[], callback: () => void): void {\r\n        let numRemaining = textures.length;\r\n        if (numRemaining === 0) {\r\n            callback();\r\n            return;\r\n        }\r\n\r\n        for (let i = 0; i < textures.length; i++) {\r\n            const texture = textures[i];\r\n\r\n            if (texture.isReady()) {\r\n                if (--numRemaining === 0) {\r\n                    callback();\r\n                }\r\n            } else {\r\n                const onLoadObservable = (texture as any).onLoadObservable as Observable<BaseTexture>;\r\n\r\n                if (onLoadObservable) {\r\n                    onLoadObservable.addOnce(() => {\r\n                        if (--numRemaining === 0) {\r\n                            callback();\r\n                        }\r\n                    });\r\n                } else {\r\n                    if (--numRemaining === 0) {\r\n                        callback();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private static _IsScene(sceneOrEngine: Scene | AbstractEngine): sceneOrEngine is Scene {\r\n        return sceneOrEngine.getClassName() === \"Scene\";\r\n    }\r\n}\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { ISize } from \"../Maths/math.size\";\r\nimport type { Nullable } from \"../types\";\r\n\r\nimport type { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\n\r\n/**\r\n * Transform some pixel data to a base64 string\r\n * @param pixels defines the pixel data to transform to base64\r\n * @param size defines the width and height of the (texture) data\r\n * @param invertY true if the data must be inverted for the Y coordinate during the conversion\r\n * @returns The base64 encoded string or null\r\n */\r\nexport function GenerateBase64StringFromPixelData(pixels: ArrayBufferView, size: ISize, invertY = false): Nullable<string> {\r\n    const width = size.width;\r\n    const height = size.height;\r\n\r\n    if (pixels instanceof Float32Array) {\r\n        let len = pixels.byteLength / pixels.BYTES_PER_ELEMENT;\r\n        const npixels = new Uint8Array(len);\r\n\r\n        while (--len >= 0) {\r\n            let val = pixels[len];\r\n            if (val < 0) {\r\n                val = 0;\r\n            } else if (val > 1) {\r\n                val = 1;\r\n            }\r\n            npixels[len] = val * 255;\r\n        }\r\n\r\n        pixels = npixels;\r\n    }\r\n\r\n    const canvas = document.createElement(\"canvas\");\r\n    canvas.width = width;\r\n    canvas.height = height;\r\n\r\n    const ctx = canvas.getContext(\"2d\");\r\n    if (!ctx) {\r\n        return null;\r\n    }\r\n\r\n    const imageData = ctx.createImageData(width, height);\r\n    const castData = <any>imageData.data;\r\n    castData.set(pixels);\r\n    ctx.putImageData(imageData, 0, 0);\r\n\r\n    if (invertY) {\r\n        const canvas2 = document.createElement(\"canvas\");\r\n        canvas2.width = width;\r\n        canvas2.height = height;\r\n\r\n        const ctx2 = canvas2.getContext(\"2d\");\r\n        if (!ctx2) {\r\n            return null;\r\n        }\r\n\r\n        ctx2.translate(0, height);\r\n        ctx2.scale(1, -1);\r\n        ctx2.drawImage(canvas, 0, 0);\r\n\r\n        return canvas2.toDataURL(\"image/png\");\r\n    }\r\n\r\n    return canvas.toDataURL(\"image/png\");\r\n}\r\n\r\n/**\r\n * Reads the pixels stored in the webgl texture and returns them as a base64 string\r\n * @param texture defines the texture to read pixels from\r\n * @param faceIndex defines the face of the texture to read (in case of cube texture)\r\n * @param level defines the LOD level of the texture to read (in case of Mip Maps)\r\n * @returns The base64 encoded string or null\r\n */\r\nexport function GenerateBase64StringFromTexture(texture: BaseTexture, faceIndex = 0, level = 0): Nullable<string> {\r\n    const internalTexture = texture.getInternalTexture();\r\n    if (!internalTexture) {\r\n        return null;\r\n    }\r\n\r\n    const pixels = texture._readPixelsSync(faceIndex, level);\r\n    if (!pixels) {\r\n        return null;\r\n    }\r\n\r\n    return GenerateBase64StringFromPixelData(pixels, texture.getSize(), internalTexture.invertY);\r\n}\r\n\r\n/**\r\n * Reads the pixels stored in the webgl texture and returns them as a base64 string\r\n * @param texture defines the texture to read pixels from\r\n * @param faceIndex defines the face of the texture to read (in case of cube texture)\r\n * @param level defines the LOD level of the texture to read (in case of Mip Maps)\r\n * @returns The base64 encoded string or null wrapped in a promise\r\n */\r\nexport async function GenerateBase64StringFromTextureAsync(texture: BaseTexture, faceIndex = 0, level = 0): Promise<Nullable<string>> {\r\n    const internalTexture = texture.getInternalTexture();\r\n    if (!internalTexture) {\r\n        return null;\r\n    }\r\n\r\n    const pixels = await texture.readPixels(faceIndex, level);\r\n    if (!pixels) {\r\n        return null;\r\n    }\r\n\r\n    return GenerateBase64StringFromPixelData(pixels, texture.getSize(), internalTexture.invertY);\r\n}\r\n\r\n/**\r\n * Class used to host copy specific utilities\r\n * (Back-compat)\r\n */\r\nexport const CopyTools = {\r\n    /**\r\n     * Transform some pixel data to a base64 string\r\n     * @param pixels defines the pixel data to transform to base64\r\n     * @param size defines the width and height of the (texture) data\r\n     * @param invertY true if the data must be inverted for the Y coordinate during the conversion\r\n     * @returns The base64 encoded string or null\r\n     */\r\n    GenerateBase64StringFromPixelData,\r\n\r\n    /**\r\n     * Reads the pixels stored in the webgl texture and returns them as a base64 string\r\n     * @param texture defines the texture to read pixels from\r\n     * @param faceIndex defines the face of the texture to read (in case of cube texture)\r\n     * @param level defines the LOD level of the texture to read (in case of Mip Maps)\r\n     * @returns The base64 encoded string or null\r\n     */\r\n    GenerateBase64StringFromTexture,\r\n\r\n    /**\r\n     * Reads the pixels stored in the webgl texture and returns them as a base64 string\r\n     * @param texture defines the texture to read pixels from\r\n     * @param faceIndex defines the face of the texture to read (in case of cube texture)\r\n     * @param level defines the LOD level of the texture to read (in case of Mip Maps)\r\n     * @returns The base64 encoded string or null wrapped in a promise\r\n     */\r\n    GenerateBase64StringFromTextureAsync,\r\n};\r\n", "/**\r\n * Defines if the system should use OpenGL convention for UVs when creating geometry or loading .babylon files (false by default)\r\n */\r\nexport let useOpenGLOrientationForUV = false;\r\n\r\n/**\r\n * Sets whether to use OpenGL convention for UVs\r\n * @param value the new value\r\n */\r\nexport function setOpenGLOrientationForUV(value: boolean) {\r\n    useOpenGLOrientationForUV = value;\r\n}\r\n\r\n/**\r\n * Options used to control default behaviors regarding compatibility support\r\n * @deprecated please use named exports\r\n */\r\nexport const CompatibilityOptions = {\r\n    /* eslint-disable @typescript-eslint/naming-convention */\r\n    get UseOpenGLOrientationForUV() {\r\n        return useOpenGLOrientationForUV;\r\n    },\r\n    set UseOpenGLOrientationForUV(value) {\r\n        useOpenGLOrientationForUV = value;\r\n    },\r\n    /* eslint-enable @typescript-eslint/naming-convention */\r\n};\r\n", "import { serialize } from \"../../Misc/decorators\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Matrix, TmpVectors, Vector3 } from \"../../Maths/math.vector\";\r\nimport { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport { GetClass, RegisterClass } from \"../../Misc/typeStore\";\r\nimport { _WarnImport } from \"../../Misc/devTools\";\r\nimport type { IInspectable } from \"../../Misc/iInspectable\";\r\nimport type { AbstractEngine } from \"../../Engines/abstractEngine\";\r\nimport { TimingTools } from \"../../Misc/timingTools\";\r\nimport { InstantiationTools } from \"../../Misc/instantiationTools\";\r\nimport { Plane } from \"../../Maths/math.plane\";\r\nimport { EncodeArrayBufferToBase64 } from \"../../Misc/stringTools\";\r\nimport { GenerateBase64StringFromTexture, GenerateBase64StringFromTextureAsync } from \"../../Misc/copyTools\";\r\nimport { useOpenGLOrientationForUV } from \"../../Compat/compatibilityOptions\";\r\nimport type { InternalTexture } from \"./internalTexture\";\r\n\r\nimport type { CubeTexture } from \"../../Materials/Textures/cubeTexture\";\r\nimport type { MirrorTexture } from \"../../Materials/Textures/mirrorTexture\";\r\nimport type { RenderTargetTexture } from \"../../Materials/Textures/renderTargetTexture\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { VideoTexture, VideoTextureSettings } from \"./videoTexture\";\r\n\r\nimport { SerializationHelper } from \"../../Misc/decorators.serialization\";\r\n\r\n/**\r\n * Defines the available options when creating a texture\r\n */\r\nexport interface ITextureCreationOptions {\r\n    /** Defines if the texture will require mip maps or not (default: false) */\r\n    noMipmap?: boolean;\r\n\r\n    /** Defines if the texture needs to be inverted on the y axis during loading (default: true) */\r\n    invertY?: boolean;\r\n\r\n    /** Defines the sampling mode we want for the texture while fetching from it (Texture.NEAREST_SAMPLINGMODE...) (default: Texture.TRILINEAR_SAMPLINGMODE) */\r\n    samplingMode?: number;\r\n\r\n    /** Defines a callback triggered when the texture has been loaded (default: null) */\r\n    onLoad?: Nullable<() => void>;\r\n\r\n    /** Defines a callback triggered when an error occurred during the loading session (default: null) */\r\n    onError?: Nullable<(message?: string, exception?: any) => void>;\r\n\r\n    /** Defines the buffer to load the texture from in case the texture is loaded from a buffer representation (default: null) */\r\n    buffer?: Nullable<string | ArrayBuffer | ArrayBufferView | HTMLImageElement | Blob | ImageBitmap>;\r\n\r\n    /** Defines if the buffer we are loading the texture from should be deleted after load (default: false) */\r\n    deleteBuffer?: boolean;\r\n\r\n    /** Defines the format of the texture we are trying to load (Engine.TEXTUREFORMAT_RGBA...) (default: ) */\r\n    format?: number;\r\n\r\n    /** Defines an optional mime type information (default: undefined) */\r\n    mimeType?: string;\r\n\r\n    /** Options to be passed to the loader (default: undefined) */\r\n    loaderOptions?: any;\r\n\r\n    /** Specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg) (default: undefined) */\r\n    creationFlags?: number;\r\n\r\n    /** Defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU) (default: false) */\r\n    useSRGBBuffer?: boolean;\r\n\r\n    /** Defines the underlying texture from an already existing one */\r\n    internalTexture?: InternalTexture;\r\n\r\n    /** Defines the underlying texture texture space */\r\n    gammaSpace?: boolean;\r\n\r\n    /** Defines the extension to use to pick the right loader */\r\n    forcedExtension?: string;\r\n}\r\n\r\n/**\r\n * This represents a texture in babylon. It can be easily loaded from a network, base64 or html input.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/materials_introduction#texture\r\n */\r\nexport class Texture extends BaseTexture {\r\n    /**\r\n     * Gets or sets a general boolean used to indicate that textures containing direct data (buffers) must be saved as part of the serialization process\r\n     */\r\n    public static SerializeBuffers = true;\r\n\r\n    /**\r\n     * Gets or sets a general boolean used to indicate that texture buffers must be saved as part of the serialization process.\r\n     * If no buffer exists, one will be created as base64 string from the internal webgl data.\r\n     */\r\n    public static ForceSerializeBuffers = false;\r\n\r\n    /**\r\n     * This observable will notify when any texture had a loading error\r\n     */\r\n    public static OnTextureLoadErrorObservable = new Observable<BaseTexture>();\r\n\r\n    /** @internal */\r\n    public static _SerializeInternalTextureUniqueId = false;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public static _CubeTextureParser = (jsonTexture: any, scene: Scene, rootUrl: string): CubeTexture => {\r\n        throw _WarnImport(\"CubeTexture\");\r\n    };\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public static _CreateMirror = (name: string, renderTargetSize: number, scene: Scene, generateMipMaps: boolean): MirrorTexture => {\r\n        throw _WarnImport(\"MirrorTexture\");\r\n    };\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public static _CreateRenderTargetTexture = (name: string, renderTargetSize: number, scene: Scene, generateMipMaps: boolean, creationFlags?: number): RenderTargetTexture => {\r\n        throw _WarnImport(\"RenderTargetTexture\");\r\n    };\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _CreateVideoTexture(\r\n        name: Nullable<string>,\r\n        src: string | string[] | HTMLVideoElement,\r\n        scene: Nullable<Scene>,\r\n        generateMipMaps = false,\r\n        invertY = false,\r\n        samplingMode: number = Texture.TRILINEAR_SAMPLINGMODE,\r\n        settings: Partial<VideoTextureSettings> = {},\r\n        onError?: Nullable<(message?: string, exception?: any) => void>,\r\n        format: number = Constants.TEXTUREFORMAT_RGBA\r\n    ): VideoTexture {\r\n        throw _WarnImport(\"VideoTexture\");\r\n    }\r\n\r\n    /** nearest is mag = nearest and min = nearest and no mip */\r\n    public static readonly NEAREST_SAMPLINGMODE = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n    /** nearest is mag = nearest and min = nearest and mip = linear */\r\n    public static readonly NEAREST_NEAREST_MIPLINEAR = Constants.TEXTURE_NEAREST_NEAREST_MIPLINEAR; // nearest is mag = nearest and min = nearest and mip = linear\r\n\r\n    /** Bilinear is mag = linear and min = linear and no mip */\r\n    public static readonly BILINEAR_SAMPLINGMODE = Constants.TEXTURE_BILINEAR_SAMPLINGMODE;\r\n    /** Bilinear is mag = linear and min = linear and mip = nearest */\r\n    public static readonly LINEAR_LINEAR_MIPNEAREST = Constants.TEXTURE_LINEAR_LINEAR_MIPNEAREST; // Bilinear is mag = linear and min = linear and mip = nearest\r\n\r\n    /** Trilinear is mag = linear and min = linear and mip = linear */\r\n    public static readonly TRILINEAR_SAMPLINGMODE = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE;\r\n    /** Trilinear is mag = linear and min = linear and mip = linear */\r\n    public static readonly LINEAR_LINEAR_MIPLINEAR = Constants.TEXTURE_LINEAR_LINEAR_MIPLINEAR; // Trilinear is mag = linear and min = linear and mip = linear\r\n\r\n    /** mag = nearest and min = nearest and mip = nearest */\r\n    public static readonly NEAREST_NEAREST_MIPNEAREST = Constants.TEXTURE_NEAREST_NEAREST_MIPNEAREST;\r\n    /** mag = nearest and min = linear and mip = nearest */\r\n    public static readonly NEAREST_LINEAR_MIPNEAREST = Constants.TEXTURE_NEAREST_LINEAR_MIPNEAREST;\r\n    /** mag = nearest and min = linear and mip = linear */\r\n    public static readonly NEAREST_LINEAR_MIPLINEAR = Constants.TEXTURE_NEAREST_LINEAR_MIPLINEAR;\r\n    /** mag = nearest and min = linear and mip = none */\r\n    public static readonly NEAREST_LINEAR = Constants.TEXTURE_NEAREST_LINEAR;\r\n    /** mag = nearest and min = nearest and mip = none */\r\n    public static readonly NEAREST_NEAREST = Constants.TEXTURE_NEAREST_NEAREST;\r\n    /** mag = linear and min = nearest and mip = nearest */\r\n    public static readonly LINEAR_NEAREST_MIPNEAREST = Constants.TEXTURE_LINEAR_NEAREST_MIPNEAREST;\r\n    /** mag = linear and min = nearest and mip = linear */\r\n    public static readonly LINEAR_NEAREST_MIPLINEAR = Constants.TEXTURE_LINEAR_NEAREST_MIPLINEAR;\r\n    /** mag = linear and min = linear and mip = none */\r\n    public static readonly LINEAR_LINEAR = Constants.TEXTURE_LINEAR_LINEAR;\r\n    /** mag = linear and min = nearest and mip = none */\r\n    public static readonly LINEAR_NEAREST = Constants.TEXTURE_LINEAR_NEAREST;\r\n\r\n    /** Explicit coordinates mode */\r\n    public static readonly EXPLICIT_MODE = Constants.TEXTURE_EXPLICIT_MODE;\r\n    /** Spherical coordinates mode */\r\n    public static readonly SPHERICAL_MODE = Constants.TEXTURE_SPHERICAL_MODE;\r\n    /** Planar coordinates mode */\r\n    public static readonly PLANAR_MODE = Constants.TEXTURE_PLANAR_MODE;\r\n    /** Cubic coordinates mode */\r\n    public static readonly CUBIC_MODE = Constants.TEXTURE_CUBIC_MODE;\r\n    /** Projection coordinates mode */\r\n    public static readonly PROJECTION_MODE = Constants.TEXTURE_PROJECTION_MODE;\r\n    /** Inverse Cubic coordinates mode */\r\n    public static readonly SKYBOX_MODE = Constants.TEXTURE_SKYBOX_MODE;\r\n    /** Inverse Cubic coordinates mode */\r\n    public static readonly INVCUBIC_MODE = Constants.TEXTURE_INVCUBIC_MODE;\r\n    /** Equirectangular coordinates mode */\r\n    public static readonly EQUIRECTANGULAR_MODE = Constants.TEXTURE_EQUIRECTANGULAR_MODE;\r\n    /** Equirectangular Fixed coordinates mode */\r\n    public static readonly FIXED_EQUIRECTANGULAR_MODE = Constants.TEXTURE_FIXED_EQUIRECTANGULAR_MODE;\r\n    /** Equirectangular Fixed Mirrored coordinates mode */\r\n    public static readonly FIXED_EQUIRECTANGULAR_MIRRORED_MODE = Constants.TEXTURE_FIXED_EQUIRECTANGULAR_MIRRORED_MODE;\r\n\r\n    /** Texture is not repeating outside of 0..1 UVs */\r\n    public static readonly CLAMP_ADDRESSMODE = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n    /** Texture is repeating outside of 0..1 UVs */\r\n    public static readonly WRAP_ADDRESSMODE = Constants.TEXTURE_WRAP_ADDRESSMODE;\r\n    /** Texture is repeating and mirrored */\r\n    public static readonly MIRROR_ADDRESSMODE = Constants.TEXTURE_MIRROR_ADDRESSMODE;\r\n\r\n    /**\r\n     * Gets or sets a boolean which defines if the texture url must be build from the serialized URL instead of just using the name and loading them side by side with the scene file\r\n     */\r\n    public static UseSerializedUrlIfAny = false;\r\n\r\n    /**\r\n     * Define the url of the texture.\r\n     */\r\n    @serialize()\r\n    public url: Nullable<string> = null;\r\n\r\n    /**\r\n     * Define an offset on the texture to offset the u coordinates of the UVs\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/moreMaterials#offsetting\r\n     */\r\n    @serialize()\r\n    public uOffset = 0;\r\n\r\n    /**\r\n     * Define an offset on the texture to offset the v coordinates of the UVs\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/moreMaterials#offsetting\r\n     */\r\n    @serialize()\r\n    public vOffset = 0;\r\n\r\n    /**\r\n     * Define an offset on the texture to scale the u coordinates of the UVs\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/moreMaterials#tiling\r\n     */\r\n    @serialize()\r\n    public uScale = 1.0;\r\n\r\n    /**\r\n     * Define an offset on the texture to scale the v coordinates of the UVs\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/moreMaterials#tiling\r\n     */\r\n    @serialize()\r\n    public vScale = 1.0;\r\n\r\n    /**\r\n     * Define an offset on the texture to rotate around the u coordinates of the UVs\r\n     * The angle is defined in radians.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/moreMaterials\r\n     */\r\n    @serialize()\r\n    public uAng = 0;\r\n\r\n    /**\r\n     * Define an offset on the texture to rotate around the v coordinates of the UVs\r\n     * The angle is defined in radians.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/moreMaterials\r\n     */\r\n    @serialize()\r\n    public vAng = 0;\r\n\r\n    /**\r\n     * Define an offset on the texture to rotate around the w coordinates of the UVs (in case of 3d texture)\r\n     * The angle is defined in radians.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/moreMaterials\r\n     */\r\n    @serialize()\r\n    public wAng = 0;\r\n\r\n    /**\r\n     * Defines the center of rotation (U)\r\n     */\r\n    @serialize()\r\n    public uRotationCenter = 0.5;\r\n\r\n    /**\r\n     * Defines the center of rotation (V)\r\n     */\r\n    @serialize()\r\n    public vRotationCenter = 0.5;\r\n\r\n    /**\r\n     * Defines the center of rotation (W)\r\n     */\r\n    @serialize()\r\n    public wRotationCenter = 0.5;\r\n\r\n    /**\r\n     * Sets this property to true to avoid deformations when rotating the texture with non-uniform scaling\r\n     */\r\n    @serialize()\r\n    public homogeneousRotationInUVTransform = false;\r\n\r\n    /**\r\n     * Are mip maps generated for this texture or not.\r\n     */\r\n    override get noMipmap(): boolean {\r\n        return this._noMipmap;\r\n    }\r\n\r\n    /**\r\n     * List of inspectable custom properties (used by the Inspector)\r\n     * @see https://doc.babylonjs.com/toolsAndResources/inspector#extensibility\r\n     */\r\n    public inspectableCustomProperties: Nullable<IInspectable[]> = null;\r\n\r\n    /** @internal */\r\n    public _noMipmap: boolean = false;\r\n    /** @internal */\r\n    public _invertY: boolean = false;\r\n    private _rowGenerationMatrix: Nullable<Matrix> = null;\r\n    private _cachedTextureMatrix: Nullable<Matrix> = null;\r\n    private _projectionModeMatrix: Nullable<Matrix> = null;\r\n    private _t0: Nullable<Vector3> = null;\r\n    private _t1: Nullable<Vector3> = null;\r\n    private _t2: Nullable<Vector3> = null;\r\n\r\n    private _cachedUOffset: number = -1;\r\n    private _cachedVOffset: number = -1;\r\n    private _cachedUScale: number = 0;\r\n    private _cachedVScale: number = 0;\r\n    private _cachedUAng: number = -1;\r\n    private _cachedVAng: number = -1;\r\n    private _cachedWAng: number = -1;\r\n    private _cachedReflectionProjectionMatrixId: number = -1;\r\n    private _cachedURotationCenter: number = -1;\r\n    private _cachedVRotationCenter: number = -1;\r\n    private _cachedWRotationCenter: number = -1;\r\n    private _cachedHomogeneousRotationInUVTransform: boolean = false;\r\n    private _cachedIdentity3x2: boolean = true;\r\n\r\n    private _cachedReflectionTextureMatrix: Nullable<Matrix> = null;\r\n    private _cachedReflectionUOffset = -1;\r\n    private _cachedReflectionVOffset = -1;\r\n    private _cachedReflectionUScale = 0;\r\n    private _cachedReflectionVScale = 0;\r\n    private _cachedReflectionCoordinatesMode = -1;\r\n\r\n    /** @internal */\r\n    public _buffer: Nullable<string | ArrayBuffer | ArrayBufferView | HTMLImageElement | Blob | ImageBitmap> = null;\r\n    private _deleteBuffer: boolean = false;\r\n    protected _format: Nullable<number> = null;\r\n    private _delayedOnLoad: Nullable<() => void> = null;\r\n    private _delayedOnError: Nullable<() => void> = null;\r\n    private _mimeType?: string;\r\n    private _loaderOptions?: any;\r\n    private _creationFlags?: number;\r\n    /** @internal */\r\n    public _useSRGBBuffer?: boolean;\r\n    private _forcedExtension?: string;\r\n\r\n    /** Returns the texture mime type if it was defined by a loader (undefined else) */\r\n    public get mimeType() {\r\n        return this._mimeType;\r\n    }\r\n\r\n    /**\r\n     * Observable triggered once the texture has been loaded.\r\n     */\r\n    public onLoadObservable: Observable<Texture> = new Observable<Texture>();\r\n\r\n    protected _isBlocking: boolean = true;\r\n    /**\r\n     * Is the texture preventing material to render while loading.\r\n     * If false, a default texture will be used instead of the loading one during the preparation step.\r\n     */\r\n    public override set isBlocking(value: boolean) {\r\n        this._isBlocking = value;\r\n    }\r\n    @serialize()\r\n    public override get isBlocking(): boolean {\r\n        return this._isBlocking;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if the texture needs to be inverted on the y axis during loading\r\n     */\r\n    public get invertY(): boolean {\r\n        return this._invertY;\r\n    }\r\n\r\n    /**\r\n     * Instantiates a new texture.\r\n     * This represents a texture in babylon. It can be easily loaded from a network, base64 or html input.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/materials_introduction#texture\r\n     * @param url defines the url of the picture to load as a texture\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param noMipmapOrOptions defines if the texture will require mip maps or not or set of all options to create the texture\r\n     * @param invertY defines if the texture needs to be inverted on the y axis during loading\r\n     * @param samplingMode defines the sampling mode we want for the texture while fetching from it (Texture.NEAREST_SAMPLINGMODE...)\r\n     * @param onLoad defines a callback triggered when the texture has been loaded\r\n     * @param onError defines a callback triggered when an error occurred during the loading session\r\n     * @param buffer defines the buffer to load the texture from in case the texture is loaded from a buffer representation\r\n     * @param deleteBuffer defines if the buffer we are loading the texture from should be deleted after load\r\n     * @param format defines the format of the texture we are trying to load (Engine.TEXTUREFORMAT_RGBA...)\r\n     * @param mimeType defines an optional mime type information\r\n     * @param loaderOptions options to be passed to the loader\r\n     * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\r\n     * @param forcedExtension defines the extension to use to pick the right loader\r\n     */\r\n    constructor(\r\n        url: Nullable<string>,\r\n        sceneOrEngine?: Nullable<Scene | AbstractEngine>,\r\n        noMipmapOrOptions?: boolean | ITextureCreationOptions,\r\n        invertY?: boolean,\r\n        samplingMode: number = Texture.TRILINEAR_SAMPLINGMODE,\r\n        onLoad: Nullable<() => void> = null,\r\n        onError: Nullable<(message?: string, exception?: any) => void> = null,\r\n        buffer: Nullable<string | ArrayBuffer | ArrayBufferView | HTMLImageElement | Blob | ImageBitmap> = null,\r\n        deleteBuffer: boolean = false,\r\n        format?: number,\r\n        mimeType?: string,\r\n        loaderOptions?: any,\r\n        creationFlags?: number,\r\n        forcedExtension?: string\r\n    ) {\r\n        super(sceneOrEngine);\r\n\r\n        this.name = url || \"\";\r\n        this.url = url;\r\n\r\n        let noMipmap: boolean;\r\n        let useSRGBBuffer: boolean = false;\r\n        let internalTexture: Nullable<InternalTexture> = null;\r\n        let gammaSpace = true;\r\n\r\n        if (typeof noMipmapOrOptions === \"object\" && noMipmapOrOptions !== null) {\r\n            noMipmap = noMipmapOrOptions.noMipmap ?? false;\r\n            invertY = noMipmapOrOptions.invertY ?? !useOpenGLOrientationForUV;\r\n            samplingMode = noMipmapOrOptions.samplingMode ?? Texture.TRILINEAR_SAMPLINGMODE;\r\n            onLoad = noMipmapOrOptions.onLoad ?? null;\r\n            onError = noMipmapOrOptions.onError ?? null;\r\n            buffer = noMipmapOrOptions.buffer ?? null;\r\n            deleteBuffer = noMipmapOrOptions.deleteBuffer ?? false;\r\n            format = noMipmapOrOptions.format;\r\n            mimeType = noMipmapOrOptions.mimeType;\r\n            loaderOptions = noMipmapOrOptions.loaderOptions;\r\n            creationFlags = noMipmapOrOptions.creationFlags;\r\n            useSRGBBuffer = noMipmapOrOptions.useSRGBBuffer ?? false;\r\n            internalTexture = noMipmapOrOptions.internalTexture ?? null;\r\n            gammaSpace = noMipmapOrOptions.gammaSpace ?? gammaSpace;\r\n            forcedExtension = noMipmapOrOptions.forcedExtension ?? forcedExtension;\r\n        } else {\r\n            noMipmap = !!noMipmapOrOptions;\r\n        }\r\n\r\n        this._gammaSpace = gammaSpace;\r\n        this._noMipmap = noMipmap;\r\n        this._invertY = invertY === undefined ? !useOpenGLOrientationForUV : invertY;\r\n        this._initialSamplingMode = samplingMode;\r\n        this._buffer = buffer;\r\n        this._deleteBuffer = deleteBuffer;\r\n        this._mimeType = mimeType;\r\n        this._loaderOptions = loaderOptions;\r\n        this._creationFlags = creationFlags;\r\n        this._useSRGBBuffer = useSRGBBuffer;\r\n        this._forcedExtension = forcedExtension;\r\n        if (format) {\r\n            this._format = format;\r\n        }\r\n\r\n        const scene = this.getScene();\r\n        const engine = this._getEngine();\r\n        if (!engine) {\r\n            return;\r\n        }\r\n\r\n        engine.onBeforeTextureInitObservable.notifyObservers(this);\r\n\r\n        const load = () => {\r\n            if (this._texture) {\r\n                if (this._texture._invertVScale) {\r\n                    this.vScale *= -1;\r\n                    this.vOffset += 1;\r\n                }\r\n\r\n                // Update texture to match internal texture's wrapping\r\n                if (this._texture._cachedWrapU !== null) {\r\n                    this.wrapU = this._texture._cachedWrapU;\r\n                    this._texture._cachedWrapU = null;\r\n                }\r\n                if (this._texture._cachedWrapV !== null) {\r\n                    this.wrapV = this._texture._cachedWrapV;\r\n                    this._texture._cachedWrapV = null;\r\n                }\r\n                if (this._texture._cachedWrapR !== null) {\r\n                    this.wrapR = this._texture._cachedWrapR;\r\n                    this._texture._cachedWrapR = null;\r\n                }\r\n            }\r\n\r\n            if (this.onLoadObservable.hasObservers()) {\r\n                this.onLoadObservable.notifyObservers(this);\r\n            }\r\n            if (onLoad) {\r\n                onLoad();\r\n            }\r\n\r\n            if (!this.isBlocking && scene) {\r\n                scene.resetCachedMaterial();\r\n            }\r\n        };\r\n\r\n        const errorHandler = (message?: string, exception?: any) => {\r\n            this._loadingError = true;\r\n            this._errorObject = { message, exception };\r\n            if (onError) {\r\n                onError(message, exception);\r\n            }\r\n            Texture.OnTextureLoadErrorObservable.notifyObservers(this);\r\n        };\r\n\r\n        if (!this.url && !internalTexture) {\r\n            this._delayedOnLoad = load;\r\n            this._delayedOnError = errorHandler;\r\n            return;\r\n        }\r\n\r\n        this._texture = internalTexture ?? this._getFromCache(this.url, noMipmap, samplingMode, this._invertY, useSRGBBuffer, this.isCube);\r\n\r\n        if (!this._texture) {\r\n            if (!scene || !scene.useDelayedTextureLoading) {\r\n                try {\r\n                    this._texture = engine.createTexture(\r\n                        this.url,\r\n                        noMipmap,\r\n                        this._invertY,\r\n                        scene,\r\n                        samplingMode,\r\n                        load,\r\n                        errorHandler,\r\n                        this._buffer,\r\n                        undefined,\r\n                        this._format,\r\n                        this._forcedExtension,\r\n                        mimeType,\r\n                        loaderOptions,\r\n                        creationFlags,\r\n                        useSRGBBuffer\r\n                    );\r\n                } catch (e) {\r\n                    errorHandler(\"error loading\", e);\r\n                    throw e;\r\n                }\r\n                if (deleteBuffer) {\r\n                    this._buffer = null;\r\n                }\r\n            } else {\r\n                this.delayLoadState = Constants.DELAYLOADSTATE_NOTLOADED;\r\n\r\n                this._delayedOnLoad = load;\r\n                this._delayedOnError = errorHandler;\r\n            }\r\n        } else {\r\n            if (this._texture.isReady) {\r\n                TimingTools.SetImmediate(() => load());\r\n            } else {\r\n                const loadObserver = this._texture.onLoadedObservable.add(load);\r\n                this._texture.onErrorObservable.add((e) => {\r\n                    errorHandler(e.message, e.exception);\r\n                    this._texture?.onLoadedObservable.remove(loadObserver);\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update the url (and optional buffer) of this texture if url was null during construction.\r\n     * @param url the url of the texture\r\n     * @param buffer the buffer of the texture (defaults to null)\r\n     * @param onLoad callback called when the texture is loaded  (defaults to null)\r\n     * @param forcedExtension defines the extension to use to pick the right loader\r\n     */\r\n    public updateURL(\r\n        url: string,\r\n        buffer: Nullable<string | ArrayBuffer | ArrayBufferView | HTMLImageElement | Blob | ImageBitmap> = null,\r\n        onLoad?: () => void,\r\n        forcedExtension?: string\r\n    ): void {\r\n        if (this.url) {\r\n            this.releaseInternalTexture();\r\n            this.getScene()!.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(this);\r\n            });\r\n        }\r\n\r\n        if (!this.name || this.name.startsWith(\"data:\")) {\r\n            this.name = url;\r\n        }\r\n        this.url = url;\r\n        this._buffer = buffer;\r\n        this._forcedExtension = forcedExtension;\r\n        this.delayLoadState = Constants.DELAYLOADSTATE_NOTLOADED;\r\n\r\n        if (onLoad) {\r\n            this._delayedOnLoad = onLoad;\r\n        }\r\n        this.delayLoad();\r\n    }\r\n\r\n    /**\r\n     * Finish the loading sequence of a texture flagged as delayed load.\r\n     * @internal\r\n     */\r\n    public override delayLoad(): void {\r\n        if (this.delayLoadState !== Constants.DELAYLOADSTATE_NOTLOADED) {\r\n            return;\r\n        }\r\n\r\n        const scene = this.getScene();\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        this.delayLoadState = Constants.DELAYLOADSTATE_LOADED;\r\n        this._texture = this._getFromCache(this.url, this._noMipmap, this.samplingMode, this._invertY, this._useSRGBBuffer, this.isCube);\r\n\r\n        if (!this._texture) {\r\n            this._texture = scene\r\n                .getEngine()\r\n                .createTexture(\r\n                    this.url,\r\n                    this._noMipmap,\r\n                    this._invertY,\r\n                    scene,\r\n                    this.samplingMode,\r\n                    this._delayedOnLoad,\r\n                    this._delayedOnError,\r\n                    this._buffer,\r\n                    null,\r\n                    this._format,\r\n                    this._forcedExtension,\r\n                    this._mimeType,\r\n                    this._loaderOptions,\r\n                    this._creationFlags,\r\n                    this._useSRGBBuffer\r\n                );\r\n            if (this._deleteBuffer) {\r\n                this._buffer = null;\r\n            }\r\n        } else {\r\n            if (this._delayedOnLoad) {\r\n                if (this._texture.isReady) {\r\n                    TimingTools.SetImmediate(this._delayedOnLoad);\r\n                } else {\r\n                    this._texture.onLoadedObservable.add(this._delayedOnLoad);\r\n                }\r\n            }\r\n        }\r\n\r\n        this._delayedOnLoad = null;\r\n        this._delayedOnError = null;\r\n    }\r\n\r\n    private _prepareRowForTextureGeneration(x: number, y: number, z: number, t: Vector3): void {\r\n        x *= this._cachedUScale;\r\n        y *= this._cachedVScale;\r\n\r\n        x -= this.uRotationCenter * this._cachedUScale;\r\n        y -= this.vRotationCenter * this._cachedVScale;\r\n        z -= this.wRotationCenter;\r\n\r\n        Vector3.TransformCoordinatesFromFloatsToRef(x, y, z, this._rowGenerationMatrix!, t);\r\n\r\n        t.x += this.uRotationCenter * this._cachedUScale + this._cachedUOffset;\r\n        t.y += this.vRotationCenter * this._cachedVScale + this._cachedVOffset;\r\n        t.z += this.wRotationCenter;\r\n    }\r\n\r\n    /**\r\n     * Get the current texture matrix which includes the requested offsetting, tiling and rotation components.\r\n     * @param uBase The horizontal base offset multiplier (1 by default)\r\n     * @returns the transform matrix of the texture.\r\n     */\r\n    public override getTextureMatrix(uBase = 1): Matrix {\r\n        if (\r\n            this.uOffset === this._cachedUOffset &&\r\n            this.vOffset === this._cachedVOffset &&\r\n            this.uScale * uBase === this._cachedUScale &&\r\n            this.vScale === this._cachedVScale &&\r\n            this.uAng === this._cachedUAng &&\r\n            this.vAng === this._cachedVAng &&\r\n            this.wAng === this._cachedWAng &&\r\n            this.uRotationCenter === this._cachedURotationCenter &&\r\n            this.vRotationCenter === this._cachedVRotationCenter &&\r\n            this.wRotationCenter === this._cachedWRotationCenter &&\r\n            this.homogeneousRotationInUVTransform === this._cachedHomogeneousRotationInUVTransform\r\n        ) {\r\n            return this._cachedTextureMatrix!;\r\n        }\r\n\r\n        this._cachedUOffset = this.uOffset;\r\n        this._cachedVOffset = this.vOffset;\r\n        this._cachedUScale = this.uScale * uBase;\r\n        this._cachedVScale = this.vScale;\r\n        this._cachedUAng = this.uAng;\r\n        this._cachedVAng = this.vAng;\r\n        this._cachedWAng = this.wAng;\r\n        this._cachedURotationCenter = this.uRotationCenter;\r\n        this._cachedVRotationCenter = this.vRotationCenter;\r\n        this._cachedWRotationCenter = this.wRotationCenter;\r\n        this._cachedHomogeneousRotationInUVTransform = this.homogeneousRotationInUVTransform;\r\n\r\n        if (!this._cachedTextureMatrix || !this._rowGenerationMatrix) {\r\n            this._cachedTextureMatrix = Matrix.Zero();\r\n            this._rowGenerationMatrix = new Matrix();\r\n            this._t0 = Vector3.Zero();\r\n            this._t1 = Vector3.Zero();\r\n            this._t2 = Vector3.Zero();\r\n        }\r\n\r\n        Matrix.RotationYawPitchRollToRef(this.vAng, this.uAng, this.wAng, this._rowGenerationMatrix!);\r\n\r\n        if (this.homogeneousRotationInUVTransform) {\r\n            Matrix.TranslationToRef(-this._cachedURotationCenter, -this._cachedVRotationCenter, -this._cachedWRotationCenter, TmpVectors.Matrix[0]);\r\n            Matrix.TranslationToRef(this._cachedURotationCenter, this._cachedVRotationCenter, this._cachedWRotationCenter, TmpVectors.Matrix[1]);\r\n            Matrix.ScalingToRef(this._cachedUScale, this._cachedVScale, 0, TmpVectors.Matrix[2]);\r\n            Matrix.TranslationToRef(this._cachedUOffset, this._cachedVOffset, 0, TmpVectors.Matrix[3]);\r\n\r\n            TmpVectors.Matrix[0].multiplyToRef(this._rowGenerationMatrix!, this._cachedTextureMatrix);\r\n            this._cachedTextureMatrix.multiplyToRef(TmpVectors.Matrix[1], this._cachedTextureMatrix);\r\n            this._cachedTextureMatrix.multiplyToRef(TmpVectors.Matrix[2], this._cachedTextureMatrix);\r\n            this._cachedTextureMatrix.multiplyToRef(TmpVectors.Matrix[3], this._cachedTextureMatrix);\r\n\r\n            // copy the translation row to the 3rd row of the matrix so that we don't need to update the shaders (which expects the translation to be on the 3rd row)\r\n            this._cachedTextureMatrix.setRowFromFloats(2, this._cachedTextureMatrix.m[12], this._cachedTextureMatrix.m[13], this._cachedTextureMatrix.m[14], 1);\r\n        } else {\r\n            this._prepareRowForTextureGeneration(0, 0, 0, this._t0!);\r\n            this._prepareRowForTextureGeneration(1.0, 0, 0, this._t1!);\r\n            this._prepareRowForTextureGeneration(0, 1.0, 0, this._t2!);\r\n\r\n            this._t1!.subtractInPlace(this._t0!);\r\n            this._t2!.subtractInPlace(this._t0!);\r\n\r\n            Matrix.FromValuesToRef(\r\n                this._t1!.x,\r\n                this._t1!.y,\r\n                this._t1!.z,\r\n                0.0,\r\n                this._t2!.x,\r\n                this._t2!.y,\r\n                this._t2!.z,\r\n                0.0,\r\n                this._t0!.x,\r\n                this._t0!.y,\r\n                this._t0!.z,\r\n                0.0,\r\n                0.0,\r\n                0.0,\r\n                0.0,\r\n                1.0,\r\n                this._cachedTextureMatrix\r\n            );\r\n        }\r\n\r\n        const scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return this._cachedTextureMatrix;\r\n        }\r\n\r\n        const previousIdentity3x2 = this._cachedIdentity3x2;\r\n        this._cachedIdentity3x2 = this._cachedTextureMatrix.isIdentityAs3x2();\r\n\r\n        if (this.optimizeUVAllocation && previousIdentity3x2 !== this._cachedIdentity3x2) {\r\n            // We flag the materials that are using this texture as \"texture dirty\" because depending on the fact that the matrix is the identity or not, some defines\r\n            // will get different values (see PrepareDefinesForMergedUV), meaning we should regenerate the effect accordingly\r\n            scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(this);\r\n            });\r\n        }\r\n\r\n        return this._cachedTextureMatrix;\r\n    }\r\n\r\n    /**\r\n     * Get the current matrix used to apply reflection. This is useful to rotate an environment texture for instance.\r\n     * @returns The reflection texture transform\r\n     */\r\n    public override getReflectionTextureMatrix(): Matrix {\r\n        const scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return this._cachedReflectionTextureMatrix!;\r\n        }\r\n\r\n        if (\r\n            this.uOffset === this._cachedReflectionUOffset &&\r\n            this.vOffset === this._cachedReflectionVOffset &&\r\n            this.uScale === this._cachedReflectionUScale &&\r\n            this.vScale === this._cachedReflectionVScale &&\r\n            this.coordinatesMode === this._cachedReflectionCoordinatesMode\r\n        ) {\r\n            if (this.coordinatesMode === Texture.PROJECTION_MODE) {\r\n                if (this._cachedReflectionProjectionMatrixId === scene.getProjectionMatrix().updateFlag) {\r\n                    return this._cachedReflectionTextureMatrix!;\r\n                }\r\n            } else {\r\n                return this._cachedReflectionTextureMatrix!;\r\n            }\r\n        }\r\n\r\n        if (!this._cachedReflectionTextureMatrix) {\r\n            this._cachedReflectionTextureMatrix = Matrix.Zero();\r\n        }\r\n\r\n        if (!this._projectionModeMatrix) {\r\n            this._projectionModeMatrix = Matrix.Zero();\r\n        }\r\n\r\n        const flagMaterialsAsTextureDirty = this._cachedReflectionCoordinatesMode !== this.coordinatesMode;\r\n\r\n        this._cachedReflectionUOffset = this.uOffset;\r\n        this._cachedReflectionVOffset = this.vOffset;\r\n        this._cachedReflectionUScale = this.uScale;\r\n        this._cachedReflectionVScale = this.vScale;\r\n        this._cachedReflectionCoordinatesMode = this.coordinatesMode;\r\n\r\n        switch (this.coordinatesMode) {\r\n            case Texture.PLANAR_MODE: {\r\n                Matrix.IdentityToRef(this._cachedReflectionTextureMatrix);\r\n                (<any>this._cachedReflectionTextureMatrix)[0] = this.uScale;\r\n                (<any>this._cachedReflectionTextureMatrix)[5] = this.vScale;\r\n                (<any>this._cachedReflectionTextureMatrix)[12] = this.uOffset;\r\n                (<any>this._cachedReflectionTextureMatrix)[13] = this.vOffset;\r\n                break;\r\n            }\r\n            case Texture.PROJECTION_MODE: {\r\n                Matrix.FromValuesToRef(0.5, 0.0, 0.0, 0.0, 0.0, -0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.5, 0.5, 1.0, 1.0, this._projectionModeMatrix);\r\n\r\n                const projectionMatrix = scene.getProjectionMatrix();\r\n                this._cachedReflectionProjectionMatrixId = projectionMatrix.updateFlag;\r\n                projectionMatrix.multiplyToRef(this._projectionModeMatrix, this._cachedReflectionTextureMatrix);\r\n                break;\r\n            }\r\n            default:\r\n                Matrix.IdentityToRef(this._cachedReflectionTextureMatrix);\r\n                break;\r\n        }\r\n\r\n        if (flagMaterialsAsTextureDirty) {\r\n            // We flag the materials that are using this texture as \"texture dirty\" if the coordinatesMode has changed.\r\n            // Indeed, this property is used to set the value of some defines used to generate the effect (in material.isReadyForSubMesh), so we must make sure this code will be re-executed and the effect recreated if necessary\r\n            scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(this);\r\n            });\r\n        }\r\n\r\n        return this._cachedReflectionTextureMatrix;\r\n    }\r\n\r\n    /**\r\n     * Clones the texture.\r\n     * @returns the cloned texture\r\n     */\r\n    public override clone(): Texture {\r\n        const options: ITextureCreationOptions = {\r\n            noMipmap: this._noMipmap,\r\n            invertY: this._invertY,\r\n            samplingMode: this.samplingMode,\r\n            onLoad: undefined,\r\n            onError: undefined,\r\n            buffer: this._texture ? this._texture._buffer : undefined,\r\n            deleteBuffer: this._deleteBuffer,\r\n            format: this.textureFormat,\r\n            mimeType: this.mimeType,\r\n            loaderOptions: this._loaderOptions,\r\n            creationFlags: this._creationFlags,\r\n            useSRGBBuffer: this._useSRGBBuffer,\r\n        };\r\n\r\n        return SerializationHelper.Clone(() => {\r\n            return new Texture(this._texture ? this._texture.url : null, this.getScene(), options);\r\n        }, this);\r\n    }\r\n\r\n    /**\r\n     * Serialize the texture to a JSON representation we can easily use in the respective Parse function.\r\n     * @returns The JSON representation of the texture\r\n     */\r\n    public override serialize(): any {\r\n        const savedName = this.name;\r\n\r\n        if (!Texture.SerializeBuffers) {\r\n            if (this.name.startsWith(\"data:\")) {\r\n                this.name = \"\";\r\n            }\r\n        }\r\n\r\n        if (this.name.startsWith(\"data:\") && this.url === this.name) {\r\n            this.url = \"\";\r\n        }\r\n\r\n        const serializationObject = super.serialize(Texture._SerializeInternalTextureUniqueId);\r\n\r\n        if (!serializationObject) {\r\n            return null;\r\n        }\r\n\r\n        if (Texture.SerializeBuffers || Texture.ForceSerializeBuffers) {\r\n            if (typeof this._buffer === \"string\" && (this._buffer as string).substring(0, 5) === \"data:\") {\r\n                serializationObject.base64String = this._buffer;\r\n                serializationObject.name = serializationObject.name.replace(\"data:\", \"\");\r\n            } else if (this.url && this.url.startsWith(\"data:\") && this._buffer instanceof Uint8Array) {\r\n                serializationObject.base64String = \"data:image/png;base64,\" + EncodeArrayBufferToBase64(this._buffer);\r\n            } else if (Texture.ForceSerializeBuffers || (this.url && this.url.startsWith(\"blob:\")) || this._forceSerialize) {\r\n                serializationObject.base64String =\r\n                    !this._engine || this._engine._features.supportSyncTextureRead ? GenerateBase64StringFromTexture(this) : GenerateBase64StringFromTextureAsync(this);\r\n            }\r\n        }\r\n\r\n        serializationObject.invertY = this._invertY;\r\n        serializationObject.samplingMode = this.samplingMode;\r\n        serializationObject._creationFlags = this._creationFlags;\r\n        serializationObject._useSRGBBuffer = this._useSRGBBuffer;\r\n        if (Texture._SerializeInternalTextureUniqueId) {\r\n            serializationObject.internalTextureUniqueId = this._texture?.uniqueId;\r\n        }\r\n        serializationObject.internalTextureLabel = this._texture?.label;\r\n        serializationObject.noMipmap = this._noMipmap;\r\n\r\n        this.name = savedName;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Get the current class name of the texture useful for serialization or dynamic coding.\r\n     * @returns \"Texture\"\r\n     */\r\n    public override getClassName(): string {\r\n        return \"Texture\";\r\n    }\r\n\r\n    /**\r\n     * Dispose the texture and release its associated resources.\r\n     */\r\n    public override dispose(): void {\r\n        super.dispose();\r\n\r\n        this.onLoadObservable.clear();\r\n\r\n        this._delayedOnLoad = null;\r\n        this._delayedOnError = null;\r\n        this._buffer = null;\r\n    }\r\n\r\n    /**\r\n     * Parse the JSON representation of a texture in order to recreate the texture in the given scene.\r\n     * @param parsedTexture Define the JSON representation of the texture\r\n     * @param scene Define the scene the parsed texture should be instantiated in\r\n     * @param rootUrl Define the root url of the parsing sequence in the case of relative dependencies\r\n     * @returns The parsed texture if successful\r\n     */\r\n    public static Parse(parsedTexture: any, scene: Scene, rootUrl: string): Nullable<BaseTexture> {\r\n        if (parsedTexture.customType) {\r\n            const customTexture = InstantiationTools.Instantiate(parsedTexture.customType);\r\n            // Update Sampling Mode\r\n            const parsedCustomTexture: any = customTexture.Parse(parsedTexture, scene, rootUrl);\r\n            if (parsedTexture.samplingMode && parsedCustomTexture.updateSamplingMode && parsedCustomTexture._samplingMode) {\r\n                if (parsedCustomTexture._samplingMode !== parsedTexture.samplingMode) {\r\n                    parsedCustomTexture.updateSamplingMode(parsedTexture.samplingMode);\r\n                }\r\n            }\r\n            return parsedCustomTexture;\r\n        }\r\n\r\n        if (parsedTexture.isCube && !parsedTexture.isRenderTarget) {\r\n            return Texture._CubeTextureParser(parsedTexture, scene, rootUrl);\r\n        }\r\n\r\n        const hasInternalTextureUniqueId = parsedTexture.internalTextureUniqueId !== undefined;\r\n\r\n        if (!parsedTexture.name && !parsedTexture.isRenderTarget && !hasInternalTextureUniqueId) {\r\n            return null;\r\n        }\r\n\r\n        let internalTexture: InternalTexture | undefined;\r\n\r\n        if (hasInternalTextureUniqueId) {\r\n            const cache = scene.getEngine().getLoadedTexturesCache();\r\n            for (const texture of cache) {\r\n                if (texture.uniqueId === parsedTexture.internalTextureUniqueId) {\r\n                    internalTexture = texture;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        const onLoaded = (texture: Texture | null) => {\r\n            // Clear cache\r\n            if (texture && texture._texture) {\r\n                texture._texture._cachedWrapU = null;\r\n                texture._texture._cachedWrapV = null;\r\n                texture._texture._cachedWrapR = null;\r\n            }\r\n\r\n            // Update Sampling Mode\r\n            if (parsedTexture.samplingMode) {\r\n                const sampling: number = parsedTexture.samplingMode;\r\n                if (texture && texture.samplingMode !== sampling) {\r\n                    texture.updateSamplingMode(sampling);\r\n                }\r\n            }\r\n            // Animations\r\n            if (texture && parsedTexture.animations) {\r\n                for (let animationIndex = 0; animationIndex < parsedTexture.animations.length; animationIndex++) {\r\n                    const parsedAnimation = parsedTexture.animations[animationIndex];\r\n                    const internalClass = GetClass(\"BABYLON.Animation\");\r\n                    if (internalClass) {\r\n                        texture.animations.push(internalClass.Parse(parsedAnimation));\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (texture && texture._texture) {\r\n                if (hasInternalTextureUniqueId && !internalTexture) {\r\n                    texture._texture._setUniqueId(parsedTexture.internalTextureUniqueId);\r\n                }\r\n\r\n                texture._texture.label = parsedTexture.internalTextureLabel;\r\n            }\r\n        };\r\n\r\n        const texture = SerializationHelper.Parse(\r\n            () => {\r\n                let generateMipMaps: boolean = true;\r\n                if (parsedTexture.noMipmap) {\r\n                    generateMipMaps = false;\r\n                }\r\n                if (parsedTexture.mirrorPlane) {\r\n                    const mirrorTexture = Texture._CreateMirror(parsedTexture.name, parsedTexture.renderTargetSize, scene, generateMipMaps);\r\n                    mirrorTexture._waitingRenderList = parsedTexture.renderList;\r\n                    mirrorTexture.mirrorPlane = Plane.FromArray(parsedTexture.mirrorPlane);\r\n                    onLoaded(mirrorTexture);\r\n                    return mirrorTexture;\r\n                } else if (parsedTexture.isRenderTarget) {\r\n                    let renderTargetTexture: Nullable<RenderTargetTexture> = null;\r\n                    if (parsedTexture.isCube) {\r\n                        // Search for an existing reflection probe (which contains a cube render target texture)\r\n                        if (scene.reflectionProbes) {\r\n                            for (let index = 0; index < scene.reflectionProbes.length; index++) {\r\n                                const probe = scene.reflectionProbes[index];\r\n                                if (probe.name === parsedTexture.name) {\r\n                                    return probe.cubeTexture;\r\n                                }\r\n                            }\r\n                        }\r\n                    } else {\r\n                        renderTargetTexture = Texture._CreateRenderTargetTexture(\r\n                            parsedTexture.name,\r\n                            parsedTexture.renderTargetSize,\r\n                            scene,\r\n                            generateMipMaps,\r\n                            parsedTexture._creationFlags ?? 0\r\n                        );\r\n                        renderTargetTexture._waitingRenderList = parsedTexture.renderList;\r\n                    }\r\n                    onLoaded(renderTargetTexture);\r\n                    return renderTargetTexture;\r\n                } else if (parsedTexture.isVideo) {\r\n                    const texture = Texture._CreateVideoTexture(\r\n                        rootUrl + (parsedTexture.url || parsedTexture.name),\r\n                        rootUrl + (parsedTexture.src || parsedTexture.url),\r\n                        scene,\r\n                        generateMipMaps,\r\n                        parsedTexture.invertY,\r\n                        parsedTexture.samplingMode,\r\n                        parsedTexture.settings || {}\r\n                    );\r\n                    onLoaded(texture);\r\n                    return texture;\r\n                } else {\r\n                    let texture: Texture;\r\n\r\n                    if (parsedTexture.base64String && !internalTexture) {\r\n                        // name and url are the same to ensure caching happens from the actual base64 string\r\n                        texture = Texture.CreateFromBase64String(\r\n                            parsedTexture.base64String,\r\n                            parsedTexture.base64String,\r\n                            scene,\r\n                            !generateMipMaps,\r\n                            parsedTexture.invertY,\r\n                            parsedTexture.samplingMode,\r\n                            () => {\r\n                                onLoaded(texture);\r\n                            },\r\n                            parsedTexture._creationFlags ?? 0,\r\n                            parsedTexture._useSRGBBuffer ?? false\r\n                        );\r\n\r\n                        // prettier name to fit with the loaded data\r\n                        texture.name = parsedTexture.name;\r\n                    } else {\r\n                        let url: string;\r\n                        if (parsedTexture.name && (parsedTexture.name.indexOf(\"://\") > 0 || parsedTexture.name.startsWith(\"data:\"))) {\r\n                            url = parsedTexture.name;\r\n                        } else {\r\n                            url = rootUrl + parsedTexture.name;\r\n                        }\r\n\r\n                        if (parsedTexture.url && (parsedTexture.url.startsWith(\"data:\") || Texture.UseSerializedUrlIfAny)) {\r\n                            url = parsedTexture.url;\r\n                        }\r\n\r\n                        const options: ITextureCreationOptions = {\r\n                            noMipmap: !generateMipMaps,\r\n                            invertY: parsedTexture.invertY,\r\n                            samplingMode: parsedTexture.samplingMode,\r\n                            onLoad: () => {\r\n                                onLoaded(texture);\r\n                            },\r\n                            internalTexture,\r\n                        };\r\n\r\n                        texture = new Texture(url, scene, options);\r\n                    }\r\n\r\n                    return texture;\r\n                }\r\n            },\r\n            parsedTexture,\r\n            scene\r\n        );\r\n\r\n        return texture;\r\n    }\r\n\r\n    /**\r\n     * Creates a texture from its base 64 representation.\r\n     * @param data Define the base64 payload without the data: prefix\r\n     * @param name Define the name of the texture in the scene useful fo caching purpose for instance\r\n     * @param scene Define the scene the texture should belong to\r\n     * @param noMipmapOrOptions defines if the texture will require mip maps or not or set of all options to create the texture\r\n     * @param invertY define if the texture needs to be inverted on the y axis during loading\r\n     * @param samplingMode define the sampling mode we want for the texture while fetching from it (Texture.NEAREST_SAMPLINGMODE...)\r\n     * @param onLoad define a callback triggered when the texture has been loaded\r\n     * @param onError define a callback triggered when an error occurred during the loading session\r\n     * @param format define the format of the texture we are trying to load (Engine.TEXTUREFORMAT_RGBA...)\r\n     * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\r\n     * @param forcedExtension defines the extension to use to pick the right loader\r\n     * @returns the created texture\r\n     */\r\n    public static CreateFromBase64String(\r\n        data: string,\r\n        name: string,\r\n        scene: Scene,\r\n        noMipmapOrOptions?: boolean | ITextureCreationOptions,\r\n        invertY?: boolean,\r\n        samplingMode: number = Texture.TRILINEAR_SAMPLINGMODE,\r\n        onLoad: Nullable<() => void> = null,\r\n        onError: Nullable<() => void> = null,\r\n        format: number = Constants.TEXTUREFORMAT_RGBA,\r\n        creationFlags?: number,\r\n        forcedExtension?: string\r\n    ): Texture {\r\n        return new Texture(\r\n            \"data:\" + name,\r\n            scene,\r\n            noMipmapOrOptions,\r\n            invertY,\r\n            samplingMode,\r\n            onLoad,\r\n            onError,\r\n            data,\r\n            false,\r\n            format,\r\n            undefined,\r\n            undefined,\r\n            creationFlags,\r\n            forcedExtension\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Creates a texture from its data: representation. (data: will be added in case only the payload has been passed in)\r\n     * @param name Define the name of the texture in the scene useful fo caching purpose for instance\r\n     * @param buffer define the buffer to load the texture from in case the texture is loaded from a buffer representation\r\n     * @param scene Define the scene the texture should belong to\r\n     * @param deleteBuffer define if the buffer we are loading the texture from should be deleted after load\r\n     * @param noMipmapOrOptions defines if the texture will require mip maps or not or set of all options to create the texture\r\n     * @param invertY define if the texture needs to be inverted on the y axis during loading\r\n     * @param samplingMode define the sampling mode we want for the texture while fetching from it (Texture.NEAREST_SAMPLINGMODE...)\r\n     * @param onLoad define a callback triggered when the texture has been loaded\r\n     * @param onError define a callback triggered when an error occurred during the loading session\r\n     * @param format define the format of the texture we are trying to load (Engine.TEXTUREFORMAT_RGBA...)\r\n     * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\r\n     * @param forcedExtension defines the extension to use to pick the right loader\r\n     * @returns the created texture\r\n     */\r\n    public static LoadFromDataString(\r\n        name: string,\r\n        buffer: any,\r\n        scene: Scene,\r\n        deleteBuffer: boolean = false,\r\n        noMipmapOrOptions?: boolean | ITextureCreationOptions,\r\n        invertY: boolean = true,\r\n        samplingMode: number = Texture.TRILINEAR_SAMPLINGMODE,\r\n        onLoad: Nullable<() => void> = null,\r\n        onError: Nullable<(message?: string, exception?: any) => void> = null,\r\n        format: number = Constants.TEXTUREFORMAT_RGBA,\r\n        creationFlags?: number,\r\n        forcedExtension?: string\r\n    ): Texture {\r\n        if (name.substring(0, 5) !== \"data:\") {\r\n            name = \"data:\" + name;\r\n        }\r\n\r\n        return new Texture(\r\n            name,\r\n            scene,\r\n            noMipmapOrOptions,\r\n            invertY,\r\n            samplingMode,\r\n            onLoad,\r\n            onError,\r\n            buffer,\r\n            deleteBuffer,\r\n            format,\r\n            undefined,\r\n            undefined,\r\n            creationFlags,\r\n            forcedExtension\r\n        );\r\n    }\r\n}\r\n\r\n// References the dependencies.\r\nRegisterClass(\"BABYLON.Texture\", Texture);\r\nSerializationHelper._TextureParser = Texture.Parse;\r\n"],
  "mappings": "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",
  "names": ["index", "texture"]
}
