import {
  ApplyPostProcess,
  CubeMapToSphericalPolynomialTools,
  PostProcess,
  SphericalPolynomial
} from "./chunk-YFFCUWOF.js";
import {
  DumpDataAsync
} from "./chunk-JNHAHXNL.js";
import {
  Scene
} from "./chunk-R2AMZKOU.js";
import {
  BaseTexture
} from "./chunk-KTDED253.js";
import {
  Vector3
} from "./chunk-NSQZ6PEP.js";
import {
  Tools
} from "./chunk-5JUVH2TK.js";
import {
  ILog2
} from "./chunk-X4PSP3XC.js";
import {
  InternalTexture
} from "./chunk-M4GEDTPQ.js";
import {
  Logger
} from "./chunk-OJJXGLTO.js";

// node_modules/@babylonjs/core/Misc/rgbdTextureTools.js
var RGBDTextureTools = class {
  /**
   * Expand the RGBD Texture from RGBD to Half Float if possible.
   * @param texture the texture to expand.
   */
  static ExpandRGBDTexture(texture) {
    const internalTexture = texture._texture;
    if (!internalTexture || !texture.isRGBD) {
      return;
    }
    const engine = internalTexture.getEngine();
    const caps = engine.getCaps();
    const isReady = internalTexture.isReady;
    let expandTexture = false;
    if (caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering) {
      expandTexture = true;
      internalTexture.type = 2;
    } else if (caps.textureFloatRender && caps.textureFloatLinearFiltering) {
      expandTexture = true;
      internalTexture.type = 1;
    }
    if (expandTexture) {
      internalTexture.isReady = false;
      internalTexture._isRGBD = false;
      internalTexture.invertY = false;
    }
    const expandRGBDTexture = async () => {
      const isWebGPU = engine.isWebGPU;
      const shaderLanguage = isWebGPU ? 1 : 0;
      internalTexture.isReady = false;
      if (isWebGPU) {
        await import("./rgbdDecode.fragment-YNB3EJMU.js");
      } else {
        await import("./rgbdDecode.fragment-K7E2DG2K.js");
      }
      const rgbdPostProcess = new PostProcess("rgbdDecode", "rgbdDecode", null, null, 1, null, 3, engine, false, void 0, internalTexture.type, void 0, null, false, void 0, shaderLanguage);
      rgbdPostProcess.externalTextureSamplerBinding = true;
      const expandedTexture = engine.createRenderTargetTexture(internalTexture.width, {
        generateDepthBuffer: false,
        generateMipMaps: false,
        generateStencilBuffer: false,
        samplingMode: internalTexture.samplingMode,
        type: internalTexture.type,
        format: 5
      });
      rgbdPostProcess.onEffectCreatedObservable.addOnce((e) => {
        e.executeWhenCompiled(() => {
          rgbdPostProcess.onApply = (effect) => {
            effect._bindTexture("textureSampler", internalTexture);
            effect.setFloat2("scale", 1, 1);
          };
          texture.getScene().postProcessManager.directRender([rgbdPostProcess], expandedTexture, true);
          engine.restoreDefaultFramebuffer();
          engine._releaseTexture(internalTexture);
          if (rgbdPostProcess) {
            rgbdPostProcess.dispose();
          }
          expandedTexture._swapAndDie(internalTexture);
          internalTexture.isReady = true;
        });
      });
    };
    if (expandTexture) {
      if (isReady) {
        expandRGBDTexture();
      } else {
        texture.onLoadObservable.addOnce(expandRGBDTexture);
      }
    }
  }
  /**
   * Encode the texture to RGBD if possible.
   * @param internalTexture the texture to encode
   * @param scene the scene hosting the texture
   * @param outputTextureType type of the texture in which the encoding is performed
   * @returns a promise with the internalTexture having its texture replaced by the result of the processing
   */
  static async EncodeTextureToRGBD(internalTexture, scene, outputTextureType = 0) {
    if (!scene.getEngine().isWebGPU) {
      await import("./rgbdEncode.fragment-K2D2DYO4.js");
    } else {
      await import("./rgbdEncode.fragment-XQ6EU2YS.js");
    }
    return ApplyPostProcess("rgbdEncode", internalTexture, scene, outputTextureType, 1, 5);
  }
};

// node_modules/@babylonjs/core/Materials/Textures/baseTexture.polynomial.js
BaseTexture.prototype.forceSphericalPolynomialsRecompute = function() {
  if (this._texture) {
    this._texture._sphericalPolynomial = null;
    this._texture._sphericalPolynomialPromise = null;
    this._texture._sphericalPolynomialComputed = false;
  }
};
Object.defineProperty(BaseTexture.prototype, "sphericalPolynomial", {
  get: function() {
    if (this._texture) {
      if (this._texture._sphericalPolynomial || this._texture._sphericalPolynomialComputed) {
        return this._texture._sphericalPolynomial;
      }
      if (this._texture.isReady) {
        if (!this._texture._sphericalPolynomialPromise) {
          this._texture._sphericalPolynomialPromise = CubeMapToSphericalPolynomialTools.ConvertCubeMapTextureToSphericalPolynomial(this);
          if (this._texture._sphericalPolynomialPromise === null) {
            this._texture._sphericalPolynomialComputed = true;
          } else {
            this._texture._sphericalPolynomialPromise.then((sphericalPolynomial) => {
              this._texture._sphericalPolynomial = sphericalPolynomial;
              this._texture._sphericalPolynomialComputed = true;
            });
          }
        }
        return null;
      }
    }
    return null;
  },
  set: function(value) {
    if (this._texture) {
      this._texture._sphericalPolynomial = value;
    }
  },
  enumerable: true,
  configurable: true
});

// node_modules/@babylonjs/core/Misc/environmentTextureTools.js
var DefaultEnvironmentTextureImageType = "image/png";
var CurrentVersion = 2;
var MagicBytes = [134, 22, 135, 150, 246, 214, 150, 54];
function GetEnvInfo(data) {
  const dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);
  let pos = 0;
  for (let i = 0; i < MagicBytes.length; i++) {
    if (dataView.getUint8(pos++) !== MagicBytes[i]) {
      Logger.Error("Not a babylon environment map");
      return null;
    }
  }
  let manifestString = "";
  let charCode = 0;
  while (charCode = dataView.getUint8(pos++)) {
    manifestString += String.fromCharCode(charCode);
  }
  let manifest = JSON.parse(manifestString);
  manifest = normalizeEnvInfo(manifest);
  manifest.binaryDataPosition = pos;
  if (manifest.specular) {
    manifest.specular.lodGenerationScale = manifest.specular.lodGenerationScale || 0.8;
  }
  return manifest;
}
function normalizeEnvInfo(info) {
  if (info.version > CurrentVersion) {
    throw new Error(`Unsupported babylon environment map version "${info.version}". Latest supported version is "${CurrentVersion}".`);
  }
  if (info.version === 2) {
    return info;
  }
  info = { ...info, version: 2, imageType: DefaultEnvironmentTextureImageType };
  return info;
}
async function CreateEnvTextureAsync(texture, options = {}) {
  var _a;
  const internalTexture = texture.getInternalTexture();
  if (!internalTexture) {
    return Promise.reject("The cube texture is invalid.");
  }
  const engine = internalTexture.getEngine();
  if (texture.textureType !== 2 && texture.textureType !== 1 && texture.textureType !== 0 && texture.textureType !== 0 && texture.textureType !== 7 && texture.textureType !== -1) {
    return Promise.reject("The cube texture should allow HDR (Full Float or Half Float).");
  }
  let textureType = 1;
  if (!engine.getCaps().textureFloatRender) {
    textureType = 2;
    if (!engine.getCaps().textureHalfFloatRender) {
      return Promise.reject("Env texture can only be created when the browser supports half float or full float rendering.");
    }
  }
  texture.sphericalPolynomial;
  const sphericalPolynomialPromise = (_a = texture.getInternalTexture()) == null ? void 0 : _a._sphericalPolynomialPromise;
  const cubeWidth = internalTexture.width;
  const hostingScene = new Scene(engine);
  const specularTextures = {};
  const diffuseTextures = {};
  engine.flushFramebuffer();
  const imageType = options.imageType ?? DefaultEnvironmentTextureImageType;
  const mipmapsCount = ILog2(internalTexture.width);
  for (let i = 0; i <= mipmapsCount; i++) {
    const faceWidth = Math.pow(2, mipmapsCount - i);
    for (let face = 0; face < 6; face++) {
      specularTextures[i * 6 + face] = await _getTextureEncodedData(hostingScene, texture, textureType, face, i, faceWidth, imageType, options.imageQuality);
    }
  }
  const irradianceTexture = options.disableIrradianceTexture ? null : texture.irradianceTexture;
  if (irradianceTexture) {
    const faceWidth = irradianceTexture.getSize().width;
    for (let face = 0; face < 6; face++) {
      diffuseTextures[face] = await _getTextureEncodedData(hostingScene, irradianceTexture, textureType, face, 0, faceWidth, imageType, options.imageQuality);
    }
  }
  hostingScene.dispose();
  if (sphericalPolynomialPromise) {
    await sphericalPolynomialPromise;
  }
  const info = {
    version: CurrentVersion,
    width: cubeWidth,
    imageType,
    irradiance: _CreateEnvTextureIrradiance(texture),
    specular: {
      mipmaps: [],
      lodGenerationScale: texture.lodGenerationScale
    }
  };
  let position = 0;
  for (let i = 0; i <= mipmapsCount; i++) {
    for (let face = 0; face < 6; face++) {
      const byteLength = specularTextures[i * 6 + face].byteLength;
      info.specular.mipmaps.push({
        length: byteLength,
        position
      });
      position += byteLength;
    }
  }
  if (irradianceTexture) {
    info.irradiance = info.irradiance || {
      x: [0, 0, 0],
      xx: [0, 0, 0],
      y: [0, 0, 0],
      yy: [0, 0, 0],
      z: [0, 0, 0],
      zz: [0, 0, 0],
      yz: [0, 0, 0],
      zx: [0, 0, 0],
      xy: [0, 0, 0]
    };
    info.irradiance.irradianceTexture = {
      size: irradianceTexture.getSize().width,
      faces: []
    };
    for (let face = 0; face < 6; face++) {
      const byteLength = diffuseTextures[face].byteLength;
      info.irradiance.irradianceTexture.faces.push({
        length: byteLength,
        position
      });
      position += byteLength;
    }
  }
  const infoString = JSON.stringify(info);
  const infoBuffer = new ArrayBuffer(infoString.length + 1);
  const infoView = new Uint8Array(infoBuffer);
  for (let i = 0, strLen = infoString.length; i < strLen; i++) {
    infoView[i] = infoString.charCodeAt(i);
  }
  infoView[infoString.length] = 0;
  const totalSize = MagicBytes.length + position + infoBuffer.byteLength;
  const finalBuffer = new ArrayBuffer(totalSize);
  const finalBufferView = new Uint8Array(finalBuffer);
  const dataView = new DataView(finalBuffer);
  let pos = 0;
  for (let i = 0; i < MagicBytes.length; i++) {
    dataView.setUint8(pos++, MagicBytes[i]);
  }
  finalBufferView.set(new Uint8Array(infoBuffer), pos);
  pos += infoBuffer.byteLength;
  for (let i = 0; i <= mipmapsCount; i++) {
    for (let face = 0; face < 6; face++) {
      const dataBuffer = specularTextures[i * 6 + face];
      finalBufferView.set(new Uint8Array(dataBuffer), pos);
      pos += dataBuffer.byteLength;
    }
  }
  if (irradianceTexture) {
    for (let face = 0; face < 6; face++) {
      const dataBuffer = diffuseTextures[face];
      finalBufferView.set(new Uint8Array(dataBuffer), pos);
      pos += dataBuffer.byteLength;
    }
  }
  return finalBuffer;
}
async function _getTextureEncodedData(hostingScene, texture, textureType, face, i, size, imageType, imageQuality) {
  let faceData = await texture.readPixels(face, i, void 0, false);
  if (faceData && faceData.byteLength === faceData.length) {
    const faceDataFloat = new Float32Array(faceData.byteLength * 4);
    for (let i2 = 0; i2 < faceData.byteLength; i2++) {
      faceDataFloat[i2] = faceData[i2] / 255;
      faceDataFloat[i2] = Math.pow(faceDataFloat[i2], 2.2);
    }
    faceData = faceDataFloat;
  } else if (faceData && texture.gammaSpace) {
    const floatData = faceData;
    for (let i2 = 0; i2 < floatData.length; i2++) {
      floatData[i2] = Math.pow(floatData[i2], 2.2);
    }
  }
  const engine = hostingScene.getEngine();
  const tempTexture = engine.createRawTexture(faceData, size, size, 5, false, true, 1, null, textureType);
  await RGBDTextureTools.EncodeTextureToRGBD(tempTexture, hostingScene, textureType);
  const rgbdEncodedData = await engine._readTexturePixels(tempTexture, size, size);
  const imageEncodedData = await DumpDataAsync(size, size, rgbdEncodedData, imageType, void 0, false, true, imageQuality);
  tempTexture.dispose();
  return imageEncodedData;
}
function _CreateEnvTextureIrradiance(texture) {
  const polynmials = texture.sphericalPolynomial;
  if (polynmials == null) {
    return null;
  }
  return {
    x: [polynmials.x.x, polynmials.x.y, polynmials.x.z],
    y: [polynmials.y.x, polynmials.y.y, polynmials.y.z],
    z: [polynmials.z.x, polynmials.z.y, polynmials.z.z],
    xx: [polynmials.xx.x, polynmials.xx.y, polynmials.xx.z],
    yy: [polynmials.yy.x, polynmials.yy.y, polynmials.yy.z],
    zz: [polynmials.zz.x, polynmials.zz.y, polynmials.zz.z],
    yz: [polynmials.yz.x, polynmials.yz.y, polynmials.yz.z],
    zx: [polynmials.zx.x, polynmials.zx.y, polynmials.zx.z],
    xy: [polynmials.xy.x, polynmials.xy.y, polynmials.xy.z]
  };
}
function CreateRadianceImageDataArrayBufferViews(data, info) {
  info = normalizeEnvInfo(info);
  const specularInfo = info.specular;
  let mipmapsCount = Math.log2(info.width);
  mipmapsCount = Math.round(mipmapsCount) + 1;
  if (specularInfo.mipmaps.length !== 6 * mipmapsCount) {
    throw new Error(`Unsupported specular mipmaps number "${specularInfo.mipmaps.length}"`);
  }
  const imageData = new Array(mipmapsCount);
  for (let i = 0; i < mipmapsCount; i++) {
    imageData[i] = new Array(6);
    for (let face = 0; face < 6; face++) {
      const imageInfo = specularInfo.mipmaps[i * 6 + face];
      imageData[i][face] = new Uint8Array(data.buffer, data.byteOffset + info.binaryDataPosition + imageInfo.position, imageInfo.length);
    }
  }
  return imageData;
}
function CreateIrradianceImageDataArrayBufferViews(data, info) {
  var _a;
  info = normalizeEnvInfo(info);
  const imageData = new Array(6);
  const irradianceTexture = (_a = info.irradiance) == null ? void 0 : _a.irradianceTexture;
  if (irradianceTexture) {
    if (irradianceTexture.faces.length !== 6) {
      throw new Error(`Incorrect irradiance texture faces number "${irradianceTexture.faces.length}"`);
    }
    for (let face = 0; face < 6; face++) {
      const imageInfo = irradianceTexture.faces[face];
      imageData[face] = new Uint8Array(data.buffer, data.byteOffset + info.binaryDataPosition + imageInfo.position, imageInfo.length);
    }
  }
  return imageData;
}
function UploadEnvLevelsAsync(texture, data, info) {
  var _a;
  info = normalizeEnvInfo(info);
  const specularInfo = info.specular;
  if (!specularInfo) {
    return Promise.resolve([]);
  }
  texture._lodGenerationScale = specularInfo.lodGenerationScale;
  const promises = [];
  const radianceImageData = CreateRadianceImageDataArrayBufferViews(data, info);
  promises.push(UploadRadianceLevelsAsync(texture, radianceImageData, info.imageType));
  const irradianceTexture = (_a = info.irradiance) == null ? void 0 : _a.irradianceTexture;
  if (irradianceTexture) {
    const irradianceImageData = CreateIrradianceImageDataArrayBufferViews(data, info);
    promises.push(UploadIrradianceLevelsAsync(texture, irradianceImageData, irradianceTexture.size, info.imageType));
  }
  return Promise.all(promises);
}
function _OnImageReadyAsync(image, engine, expandTexture, rgbdPostProcess, url, face, i, generateNonLODTextures, lodTextures, cubeRtt, texture) {
  return new Promise((resolve, reject) => {
    if (expandTexture) {
      const tempTexture = engine.createTexture(null, true, true, null, 1, null, (message) => {
        reject(message);
      }, image);
      rgbdPostProcess == null ? void 0 : rgbdPostProcess.onEffectCreatedObservable.addOnce((effect) => {
        effect.executeWhenCompiled(() => {
          rgbdPostProcess.externalTextureSamplerBinding = true;
          rgbdPostProcess.onApply = (effect2) => {
            effect2._bindTexture("textureSampler", tempTexture);
            effect2.setFloat2("scale", 1, engine._features.needsInvertingBitmap && image instanceof ImageBitmap ? -1 : 1);
          };
          if (!engine.scenes.length) {
            return;
          }
          engine.scenes[0].postProcessManager.directRender([rgbdPostProcess], cubeRtt, true, face, i);
          engine.restoreDefaultFramebuffer();
          tempTexture.dispose();
          URL.revokeObjectURL(url);
          resolve();
        });
      });
    } else {
      engine._uploadImageToTexture(texture, image, face, i);
      if (generateNonLODTextures) {
        const lodTexture = lodTextures[i];
        if (lodTexture) {
          engine._uploadImageToTexture(lodTexture._texture, image, face, 0);
        }
      }
      resolve();
    }
  });
}
async function UploadRadianceLevelsAsync(texture, imageData, imageType = DefaultEnvironmentTextureImageType) {
  const engine = texture.getEngine();
  texture.format = 5;
  texture.type = 0;
  texture.generateMipMaps = true;
  texture._cachedAnisotropicFilteringLevel = null;
  engine.updateTextureSamplingMode(3, texture);
  await _UploadLevelsAsync(texture, imageData, true, imageType);
  texture.isReady = true;
}
async function UploadIrradianceLevelsAsync(mainTexture, imageData, size, imageType = DefaultEnvironmentTextureImageType) {
  const engine = mainTexture.getEngine();
  const texture = new InternalTexture(
    engine,
    5
    /* InternalTextureSource.RenderTarget */
  );
  const baseTexture = new BaseTexture(engine, texture);
  mainTexture._irradianceTexture = baseTexture;
  texture.isCube = true;
  texture.format = 5;
  texture.type = 0;
  texture.generateMipMaps = true;
  texture._cachedAnisotropicFilteringLevel = null;
  texture.generateMipMaps = true;
  texture.width = size;
  texture.height = size;
  engine.updateTextureSamplingMode(3, texture);
  await _UploadLevelsAsync(texture, [imageData], false, imageType);
  engine.generateMipMapsForCubemap(texture);
  texture.isReady = true;
}
async function _UploadLevelsAsync(texture, imageData, canGenerateNonLODTextures, imageType = DefaultEnvironmentTextureImageType) {
  if (!Tools.IsExponentOfTwo(texture.width)) {
    throw new Error("Texture size must be a power of two");
  }
  const mipmapsCount = ILog2(texture.width) + 1;
  const engine = texture.getEngine();
  let expandTexture = false;
  let generateNonLODTextures = false;
  let rgbdPostProcess = null;
  let cubeRtt = null;
  let lodTextures = null;
  const caps = engine.getCaps();
  if (!caps.textureLOD) {
    expandTexture = false;
    generateNonLODTextures = canGenerateNonLODTextures;
  } else if (!engine._features.supportRenderAndCopyToLodForFloatTextures) {
    expandTexture = false;
  } else if (caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering) {
    expandTexture = true;
    texture.type = 2;
  } else if (caps.textureFloatRender && caps.textureFloatLinearFiltering) {
    expandTexture = true;
    texture.type = 1;
  }
  let shaderLanguage = 0;
  if (expandTexture) {
    if (engine.isWebGPU) {
      shaderLanguage = 1;
      await import("./rgbdDecode.fragment-YNB3EJMU.js");
    } else {
      await import("./rgbdDecode.fragment-K7E2DG2K.js");
    }
    rgbdPostProcess = new PostProcess("rgbdDecode", "rgbdDecode", null, null, 1, null, 3, engine, false, void 0, texture.type, void 0, null, false, void 0, shaderLanguage);
    texture._isRGBD = false;
    texture.invertY = false;
    cubeRtt = engine.createRenderTargetCubeTexture(texture.width, {
      generateDepthBuffer: false,
      generateMipMaps: true,
      generateStencilBuffer: false,
      samplingMode: 3,
      type: texture.type,
      format: 5
    });
  } else {
    texture._isRGBD = true;
    texture.invertY = true;
    if (generateNonLODTextures) {
      const mipSlices = 3;
      lodTextures = {};
      const scale = texture._lodGenerationScale;
      const offset = texture._lodGenerationOffset;
      for (let i = 0; i < mipSlices; i++) {
        const smoothness = i / (mipSlices - 1);
        const roughness = 1 - smoothness;
        const minLODIndex = offset;
        const maxLODIndex = (mipmapsCount - 1) * scale + offset;
        const lodIndex = minLODIndex + (maxLODIndex - minLODIndex) * roughness;
        const mipmapIndex = Math.round(Math.min(Math.max(lodIndex, 0), maxLODIndex));
        const glTextureFromLod = new InternalTexture(
          engine,
          2
          /* InternalTextureSource.Temp */
        );
        glTextureFromLod.isCube = true;
        glTextureFromLod.invertY = true;
        glTextureFromLod.generateMipMaps = false;
        engine.updateTextureSamplingMode(2, glTextureFromLod);
        const lodTexture = new BaseTexture(null);
        lodTexture._isCube = true;
        lodTexture._texture = glTextureFromLod;
        lodTextures[mipmapIndex] = lodTexture;
        switch (i) {
          case 0:
            texture._lodTextureLow = lodTexture;
            break;
          case 1:
            texture._lodTextureMid = lodTexture;
            break;
          case 2:
            texture._lodTextureHigh = lodTexture;
            break;
        }
      }
    }
  }
  const promises = [];
  for (let i = 0; i < imageData.length; i++) {
    for (let face = 0; face < 6; face++) {
      const bytes = imageData[i][face];
      const blob = new Blob([bytes], { type: imageType });
      const url = URL.createObjectURL(blob);
      let promise;
      if (engine._features.forceBitmapOverHTMLImageElement) {
        promise = engine.createImageBitmap(blob, { premultiplyAlpha: "none" }).then((img) => {
          return _OnImageReadyAsync(img, engine, expandTexture, rgbdPostProcess, url, face, i, generateNonLODTextures, lodTextures, cubeRtt, texture);
        });
      } else {
        const image = new Image();
        image.src = url;
        promise = new Promise((resolve, reject) => {
          image.onload = () => {
            _OnImageReadyAsync(image, engine, expandTexture, rgbdPostProcess, url, face, i, generateNonLODTextures, lodTextures, cubeRtt, texture).then(() => resolve()).catch((reason) => {
              reject(reason);
            });
          };
          image.onerror = (error) => {
            reject(error);
          };
        });
      }
      promises.push(promise);
    }
  }
  await Promise.all(promises);
  if (imageData.length < mipmapsCount) {
    let data;
    const size = Math.pow(2, mipmapsCount - 1 - imageData.length);
    const dataLength = size * size * 4;
    switch (texture.type) {
      case 0: {
        data = new Uint8Array(dataLength);
        break;
      }
      case 2: {
        data = new Uint16Array(dataLength);
        break;
      }
      case 1: {
        data = new Float32Array(dataLength);
        break;
      }
    }
    for (let i = imageData.length; i < mipmapsCount; i++) {
      for (let face = 0; face < 6; face++) {
        engine._uploadArrayBufferViewToTexture((cubeRtt == null ? void 0 : cubeRtt.texture) || texture, data, face, i);
      }
    }
  }
  if (cubeRtt) {
    const irradiance = texture._irradianceTexture;
    texture._irradianceTexture = null;
    engine._releaseTexture(texture);
    cubeRtt._swapAndDie(texture);
    texture._irradianceTexture = irradiance;
  }
  if (rgbdPostProcess) {
    rgbdPostProcess.dispose();
  }
  if (generateNonLODTextures) {
    if (texture._lodTextureHigh && texture._lodTextureHigh._texture) {
      texture._lodTextureHigh._texture.isReady = true;
    }
    if (texture._lodTextureMid && texture._lodTextureMid._texture) {
      texture._lodTextureMid._texture.isReady = true;
    }
    if (texture._lodTextureLow && texture._lodTextureLow._texture) {
      texture._lodTextureLow._texture.isReady = true;
    }
  }
}
function UploadEnvSpherical(texture, info) {
  info = normalizeEnvInfo(info);
  const irradianceInfo = info.irradiance;
  if (!irradianceInfo) {
    return;
  }
  const sp = new SphericalPolynomial();
  Vector3.FromArrayToRef(irradianceInfo.x, 0, sp.x);
  Vector3.FromArrayToRef(irradianceInfo.y, 0, sp.y);
  Vector3.FromArrayToRef(irradianceInfo.z, 0, sp.z);
  Vector3.FromArrayToRef(irradianceInfo.xx, 0, sp.xx);
  Vector3.FromArrayToRef(irradianceInfo.yy, 0, sp.yy);
  Vector3.FromArrayToRef(irradianceInfo.zz, 0, sp.zz);
  Vector3.FromArrayToRef(irradianceInfo.yz, 0, sp.yz);
  Vector3.FromArrayToRef(irradianceInfo.zx, 0, sp.zx);
  Vector3.FromArrayToRef(irradianceInfo.xy, 0, sp.xy);
  texture._sphericalPolynomial = sp;
}
function _UpdateRGBDAsync(internalTexture, data, sphericalPolynomial, lodScale, lodOffset) {
  const proxy = internalTexture.getEngine().createRawCubeTexture(null, internalTexture.width, internalTexture.format, internalTexture.type, internalTexture.generateMipMaps, internalTexture.invertY, internalTexture.samplingMode, internalTexture._compression);
  const proxyPromise = UploadRadianceLevelsAsync(proxy, data).then(() => internalTexture);
  internalTexture.onRebuildCallback = (_internalTexture) => {
    return {
      proxy: proxyPromise,
      isReady: true,
      isAsync: true
    };
  };
  internalTexture._source = 13;
  internalTexture._bufferViewArrayArray = data;
  internalTexture._lodGenerationScale = lodScale;
  internalTexture._lodGenerationOffset = lodOffset;
  internalTexture._sphericalPolynomial = sphericalPolynomial;
  return UploadRadianceLevelsAsync(internalTexture, data).then(() => {
    internalTexture.isReady = true;
    return internalTexture;
  });
}
var EnvironmentTextureTools = {
  /**
   * Gets the environment info from an env file.
   * @param data The array buffer containing the .env bytes.
   * @returns the environment file info (the json header) if successfully parsed, normalized to the latest supported version.
   */
  GetEnvInfo,
  /**
   * Creates an environment texture from a loaded cube texture.
   * @param texture defines the cube texture to convert in env file
   * @param options options for the conversion process
   * @param options.imageType the mime type for the encoded images, with support for "image/png" (default) and "image/webp"
   * @param options.imageQuality the image quality of encoded WebP images.
   * @returns a promise containing the environment data if successful.
   */
  CreateEnvTextureAsync,
  /**
   * Creates the ArrayBufferViews used for initializing environment texture image data.
   * @param data the image data
   * @param info parameters that determine what views will be created for accessing the underlying buffer
   * @returns the views described by info providing access to the underlying buffer
   */
  CreateRadianceImageDataArrayBufferViews,
  /**
   * Creates the ArrayBufferViews used for initializing environment texture image data.
   * @param data the image data
   * @param info parameters that determine what views will be created for accessing the underlying buffer
   * @returns the views described by info providing access to the underlying buffer
   */
  CreateIrradianceImageDataArrayBufferViews,
  /**
   * Uploads the texture info contained in the env file to the GPU.
   * @param texture defines the internal texture to upload to
   * @param data defines the data to load
   * @param info defines the texture info retrieved through the GetEnvInfo method
   * @returns a promise
   */
  UploadEnvLevelsAsync,
  /**
   * Uploads the levels of image data to the GPU.
   * @param texture defines the internal texture to upload to
   * @param imageData defines the array buffer views of image data [mipmap][face]
   * @param imageType the mime type of the image data
   * @returns a promise
   */
  UploadRadianceLevelsAsync,
  /**
   * Uploads the levels of image data to the GPU.
   * @param texture defines the internal texture to upload to
   * @param imageData defines the array buffer views of image data [mipmap][face]
   * @param imageType the mime type of the image data
   * @returns a promise
   */
  UploadIrradianceLevelsAsync,
  /**
   * Uploads spherical polynomials information to the texture.
   * @param texture defines the texture we are trying to upload the information to
   * @param info defines the environment texture info retrieved through the GetEnvInfo method
   */
  UploadEnvSpherical
};

// node_modules/@babylonjs/core/Materials/Textures/Loaders/envTextureLoader.js
var _ENVTextureLoader = class {
  constructor() {
    this.supportCascades = false;
  }
  /**
   * Uploads the cube texture data to the WebGL texture. It has already been bound.
   * @param data contains the texture data
   * @param texture defines the BabylonJS internal texture
   * @param createPolynomials will be true if polynomials have been requested
   * @param onLoad defines the callback to trigger once the texture is ready
   * @param onError defines the callback to trigger in case of error
   */
  loadCubeData(data, texture, createPolynomials, onLoad, onError) {
    if (Array.isArray(data)) {
      return;
    }
    const info = GetEnvInfo(data);
    if (info) {
      texture.width = info.width;
      texture.height = info.width;
      try {
        UploadEnvSpherical(texture, info);
        UploadEnvLevelsAsync(texture, data, info).then(() => {
          texture.isReady = true;
          texture.onLoadedObservable.notifyObservers(texture);
          texture.onLoadedObservable.clear();
          if (onLoad) {
            onLoad();
          }
        }, (reason) => {
          onError == null ? void 0 : onError("Can not upload environment levels", reason);
        });
      } catch (e) {
        onError == null ? void 0 : onError("Can not upload environment file", e);
      }
    } else if (onError) {
      onError("Can not parse the environment file", null);
    }
  }
  /**
   * Uploads the 2D texture data to the WebGL texture. It has already been bound once in the callback.
   */
  loadData() {
    throw ".env not supported in 2d.";
  }
};

export {
  RGBDTextureTools,
  GetEnvInfo,
  normalizeEnvInfo,
  CreateEnvTextureAsync,
  CreateRadianceImageDataArrayBufferViews,
  CreateIrradianceImageDataArrayBufferViews,
  UploadEnvLevelsAsync,
  UploadRadianceLevelsAsync,
  UploadIrradianceLevelsAsync,
  UploadEnvSpherical,
  _UpdateRGBDAsync,
  EnvironmentTextureTools,
  _ENVTextureLoader
};
//# sourceMappingURL=chunk-GOMYW7OA.js.map
