{
  "version": 3,
  "sources": ["../../../dev/core/src/AudioV2/abstractAudio/abstractSound.ts", "../../../dev/core/src/AudioV2/audioUtils.ts", "../../../dev/core/src/AudioV2/abstractAudio/abstractSoundInstance.ts"],
  "sourcesContent": ["import { Observable } from \"../../Misc/observable\";\nimport type { Nullable } from \"../../types\";\nimport { SoundState } from \"../soundState\";\nimport { AbstractNamedAudioNode, AudioNodeType } from \"./abstractAudioNode\";\nimport type { _AbstractSoundInstance } from \"./abstractSoundInstance\";\nimport type { PrimaryAudioBus } from \"./audioBus\";\nimport type { AudioEngineV2 } from \"./audioEngineV2\";\nimport type { _AbstractAudioSubGraph } from \"./subNodes/abstractAudioSubGraph\";\nimport type { IVolumeAudioOptions } from \"./subNodes/volumeAudioSubNode\";\nimport { _GetVolumeAudioProperty, _GetVolumeAudioSubNode } from \"./subNodes/volumeAudioSubNode\";\nimport type { AbstractAudioAnalyzer, IAudioAnalyzerOptions } from \"./subProperties/abstractAudioAnalyzer\";\nimport type { AbstractSpatialAudio, ISpatialAudioOptions } from \"./subProperties/abstractSpatialAudio\";\nimport type { AbstractStereoAudio, IStereoAudioOptions } from \"./subProperties/abstractStereoAudio\";\nimport { _AudioAnalyzer } from \"./subProperties/audioAnalyzer\";\n\n/** @internal */\nexport interface IAbstractSoundOptionsBase {\n    /**\n     * Whether the sound should start playing automatically. Defaults to `false`.\n     */\n    autoplay: boolean;\n    /**\n     * The maximum number of instances that can play at the same time. Defaults to `Infinity`.\n     */\n    maxInstances: number;\n}\n\n/** @internal */\nexport interface IAbstractSoundPlayOptionsBase {\n    /**\n     * Whether the sound should loop. Defaults to `false`.\n     */\n    loop: boolean;\n    /**\n     * The time within the sound buffer to start playing at, in seconds. Defaults to `0`.\n     */\n    startOffset: number;\n}\n\n/**\n * Options for creating a sound.\n */\nexport interface IAbstractSoundOptions extends IAbstractSoundOptionsBase, IAbstractSoundPlayOptions, IAudioAnalyzerOptions, ISpatialAudioOptions, IStereoAudioOptions {\n    /**\n     * The output bus for the sound. Defaults to `null`.\n     * - If not set or `null`, the sound is automatically connected to the audio engine's default main bus.\n     * @see {@link AudioEngineV2.defaultMainBus}\n     */\n    outBus: Nullable<PrimaryAudioBus>;\n}\n\n/**\n * Options for playing a sound.\n */\nexport interface IAbstractSoundPlayOptions extends IAbstractSoundPlayOptionsBase, IVolumeAudioOptions {}\n\n/**\n * Options stored in a sound.\n * @internal\n */\nexport interface IAbstractSoundStoredOptions extends IAbstractSoundOptionsBase, IAbstractSoundPlayOptionsBase {}\n\n/**\n * Abstract class representing a sound in the audio engine.\n */\nexport abstract class AbstractSound extends AbstractNamedAudioNode {\n    private _analyzer: Nullable<AbstractAudioAnalyzer> = null;\n    private _newestInstance: Nullable<_AbstractSoundInstance> = null;\n    private _outBus: Nullable<PrimaryAudioBus> = null;\n    private _privateInstances = new Set<_AbstractSoundInstance>();\n    private _state: SoundState = SoundState.Stopped;\n\n    protected _instances: ReadonlySet<_AbstractSoundInstance> = this._privateInstances;\n    protected abstract readonly _options: IAbstractSoundStoredOptions;\n    protected abstract _subGraph: _AbstractAudioSubGraph;\n\n    /**\n     * Observable for when the sound stops playing.\n     */\n    public readonly onEndedObservable = new Observable<AbstractSound>();\n\n    protected constructor(name: string, engine: AudioEngineV2) {\n        super(name, engine, AudioNodeType.HAS_INPUTS_AND_OUTPUTS); // Inputs are for instances.\n    }\n\n    /**\n     * The analyzer features of the sound.\n     */\n    public get analyzer(): AbstractAudioAnalyzer {\n        return this._analyzer ?? (this._analyzer = new _AudioAnalyzer(this._subGraph));\n    }\n\n    /**\n     * Whether the sound should start playing automatically. Defaults to `false`.\n     */\n    public get autoplay(): boolean {\n        return this._options.autoplay;\n    }\n\n    /**\n     * The current playback time of the sound, in seconds.\n     */\n    public get currentTime(): number {\n        const instance = this._getNewestInstance();\n        return instance ? instance.currentTime : 0;\n    }\n\n    public set currentTime(value: number) {\n        this.startOffset = value;\n\n        const instance = this._getNewestInstance();\n        if (instance) {\n            instance.currentTime = value;\n        }\n    }\n\n    /**\n     * Whether the sound should loop. Defaults to `false`.\n     */\n    public get loop(): boolean {\n        return this._options.loop;\n    }\n\n    public set loop(value: boolean) {\n        this._options.loop = value;\n    }\n\n    /**\n     * The maximum number of instances that can play at the same time. Defaults to `Infinity`.\n     */\n    public get maxInstances(): number {\n        return this._options.maxInstances;\n    }\n\n    public set maxInstances(value: number) {\n        this._options.maxInstances = value;\n    }\n\n    /**\n     * The output bus for the sound. Defaults to `null`.\n     * - If not set or `null`, the sound is automatically connected to the audio engine's default main bus.\n     * @see {@link AudioEngineV2.defaultMainBus}\n     */\n    public get outBus(): Nullable<PrimaryAudioBus> {\n        return this._outBus;\n    }\n\n    public set outBus(outBus: Nullable<PrimaryAudioBus>) {\n        if (this._outBus === outBus) {\n            return;\n        }\n\n        if (this._outBus) {\n            this._outBus.onDisposeObservable.removeCallback(this._onOutBusDisposed);\n            if (!this._disconnect(this._outBus)) {\n                throw new Error(\"Disconnect failed\");\n            }\n        }\n\n        this._outBus = outBus;\n\n        if (this._outBus) {\n            this._outBus.onDisposeObservable.add(this._onOutBusDisposed);\n            if (!this._connect(this._outBus)) {\n                throw new Error(\"Connect failed\");\n            }\n        }\n    }\n\n    /**\n     * The spatial features of the sound.\n     */\n    public abstract spatial: AbstractSpatialAudio;\n\n    /**\n     * The time within the sound buffer to start playing at, in seconds. Defaults to `0`.\n     */\n    public get startOffset(): number {\n        return this._options.startOffset;\n    }\n\n    public set startOffset(value: number) {\n        this._options.startOffset = value;\n    }\n\n    /**\n     * The state of the sound.\n     */\n    public get state(): SoundState {\n        return this._state;\n    }\n\n    /**\n     * The stereo features of the sound.\n     */\n    public abstract stereo: AbstractStereoAudio;\n\n    /**\n     * The output volume of the sound.\n     */\n    public get volume(): number {\n        return _GetVolumeAudioProperty(this._subGraph, \"volume\");\n    }\n\n    public set volume(value: number) {\n        // The volume subnode is created on initialization and should always exist.\n        const node = _GetVolumeAudioSubNode(this._subGraph);\n        if (!node) {\n            throw new Error(\"No volume subnode\");\n        }\n\n        node.volume = value;\n    }\n\n    /**\n     * Releases associated resources.\n     */\n    public override dispose(): void {\n        super.dispose();\n\n        this.stop();\n\n        this._analyzer?.dispose();\n        this._analyzer = null;\n\n        this._newestInstance = null;\n        this._outBus = null;\n\n        this._privateInstances.clear();\n        this.onEndedObservable.clear();\n    }\n\n    /**\n     * Plays the sound.\n     * - Triggers `onEndedObservable` if played for the full duration and the `loop` option is not set.\n     * @param options The options to use when playing the sound. Options set here override the sound's options.\n     */\n    public abstract play(options?: Partial<IAbstractSoundPlayOptions>): void;\n\n    /**\n     * Pauses the sound.\n     */\n    public pause(): void {\n        const it = this._instances.values();\n        for (let next = it.next(); !next.done; next = it.next()) {\n            next.value.pause();\n        }\n\n        this._state = SoundState.Paused;\n    }\n\n    /**\n     * Resumes the sound.\n     */\n    public resume(): void {\n        if (this._state !== SoundState.Paused) {\n            return;\n        }\n\n        const it = this._instances.values();\n        for (let next = it.next(); !next.done; next = it.next()) {\n            next.value.resume();\n        }\n\n        this._state = SoundState.Started;\n    }\n\n    /**\n     * Stops the sound.\n     * - Triggers `onEndedObservable` if the sound is playing.\n     */\n    public abstract stop(): void;\n\n    protected _beforePlay(instance: _AbstractSoundInstance): void {\n        if (this.state === SoundState.Paused && this._instances.size > 0) {\n            this.resume();\n            return;\n        }\n\n        instance.onEndedObservable.addOnce(this._onInstanceEnded);\n        this._privateInstances.add(instance);\n        this._newestInstance = instance;\n    }\n\n    protected _afterPlay(instance: _AbstractSoundInstance): void {\n        this._state = instance.state;\n    }\n\n    protected _getNewestInstance(): Nullable<_AbstractSoundInstance> {\n        if (this._instances.size === 0) {\n            return null;\n        }\n\n        if (!this._newestInstance) {\n            const it = this._instances.values();\n            for (let next = it.next(); !next.done; next = it.next()) {\n                this._newestInstance = next.value;\n            }\n        }\n\n        return this._newestInstance;\n    }\n\n    protected _setState(state: SoundState): void {\n        this._state = state;\n    }\n\n    protected abstract _createInstance(): _AbstractSoundInstance;\n\n    protected _stopExcessInstances(): void {\n        if (this.maxInstances < Infinity) {\n            const numberOfInstancesToStop = Array.from(this._instances).filter((instance) => instance.state === SoundState.Started).length - this.maxInstances;\n            const it = this._instances.values();\n\n            for (let i = 0; i < numberOfInstancesToStop; i++) {\n                const instance = it.next().value;\n                instance.stop();\n            }\n        }\n    }\n\n    private _onInstanceEnded: (instance: _AbstractSoundInstance) => void = (instance) => {\n        if (this._newestInstance === instance) {\n            this._newestInstance = null;\n        }\n\n        this._privateInstances.delete(instance);\n\n        if (this._instances.size === 0) {\n            this._state = SoundState.Stopped;\n            this.onEndedObservable.notifyObservers(this);\n        }\n    };\n\n    private _onOutBusDisposed = () => {\n        this.outBus = null;\n    };\n}\n", "export const _FileExtensionRegex = new RegExp(\"\\\\.(\\\\w{3,4})($|\\\\?)\");\n\n/** @internal */\nexport function _CleanUrl(url: string) {\n    return url.replace(/#/gm, \"%23\");\n}\n", "import { Observable } from \"../../Misc/observable\";\nimport { SoundState } from \"../soundState\";\nimport { AbstractAudioNode, AudioNodeType } from \"./abstractAudioNode\";\nimport type { AbstractSound, IAbstractSoundPlayOptions, IAbstractSoundPlayOptionsBase } from \"./abstractSound\";\n\n/**\n * Options for creating a sound instance.\n * @internal\n * */\nexport interface IAbstractSoundInstanceOptions extends IAbstractSoundPlayOptionsBase {}\n\n/** @internal */\nexport abstract class _AbstractSoundInstance extends AbstractAudioNode {\n    protected _sound: AbstractSound;\n    protected _state: SoundState = SoundState.Stopped;\n\n    /** Observable triggered when the sound instance's playback ends */\n    public readonly onEndedObservable = new Observable<_AbstractSoundInstance>();\n\n    /** Observable triggered if the sound instance encounters an error and can not be played */\n    public readonly onErrorObservable = new Observable<any>();\n\n    /** Observable triggered when the sound instance's state changes */\n    public readonly onStateChangedObservable = new Observable<_AbstractSoundInstance>();\n\n    protected abstract readonly _options: IAbstractSoundInstanceOptions;\n\n    protected constructor(sound: AbstractSound) {\n        super(sound.engine, AudioNodeType.HAS_OUTPUTS);\n\n        this._sound = sound;\n    }\n\n    public abstract currentTime: number;\n\n    public abstract readonly startTime: number;\n\n    /** The playback state of the sound instance */\n    public get state(): SoundState {\n        return this._state;\n    }\n\n    /** @internal */\n    public override dispose(): void {\n        super.dispose();\n        this.stop();\n        this.onEndedObservable.clear();\n        this.onStateChangedObservable.clear();\n    }\n\n    public abstract play(options: Partial<IAbstractSoundPlayOptions>): void;\n    public abstract pause(): void;\n    public abstract resume(): void;\n    public abstract stop(): void;\n\n    protected _setState(value: SoundState) {\n        if (this._state === value) {\n            return;\n        }\n\n        this._state = value;\n        this.onStateChangedObservable.notifyObservers(this);\n    }\n}\n"],
  "mappings": "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",
  "names": []
}
