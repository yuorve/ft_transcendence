import {
  AbstractSound,
  _AbstractSoundInstance,
  _CleanUrl,
  _FileExtensionRegex
} from "./chunk-2KA4QZFS.js";
import {
  _HasSpatialAudioOptions,
  _SpatialWebAudio,
  _StereoAudio,
  _WebAudioBusAndSoundSubGraph
} from "./chunk-6HCS7QKZ.js";

// node_modules/@babylonjs/core/AudioV2/abstractAudio/staticSound.js
var StaticSound = class extends AbstractSound {
  constructor(name, engine) {
    super(name, engine);
  }
  /**
   * The amount of time to play the sound for, in seconds. Defaults to `0`.
   * - If less than or equal to `0`, the sound plays for its full duration.
   */
  get duration() {
    return this._options.duration;
  }
  set duration(value) {
    this._options.duration = value;
  }
  /**
   * The start of the loop range, in seconds. Defaults to `0`.
   * - If less than or equal to `0`, the loop starts at the beginning of the sound.
   */
  get loopStart() {
    return this._options.loopStart;
  }
  set loopStart(value) {
    this._options.loopStart = value;
  }
  /**
   * The end of the loop range, in seconds. Defaults to `0`.
   * - If less than or equal to `0`, the loop plays for the sound's full duration.
   */
  get loopEnd() {
    return this._options.loopEnd;
  }
  set loopEnd(value) {
    this._options.loopEnd = value;
  }
  /**
   * The pitch of the sound, in cents. Defaults to `0`.
   * - Gets combined with {@link playbackRate} to determine the final pitch.
   */
  get pitch() {
    return this._options.pitch;
  }
  set pitch(value) {
    this._options.pitch = value;
    const instance = this._getNewestInstance();
    if (instance) {
      instance.pitch = value;
    }
  }
  /**
   * The playback rate of the sound. Defaults to `1`.
   * - Gets combined with {@link pitch} to determine the final playback rate.
   */
  get playbackRate() {
    return this._options.playbackRate;
  }
  set playbackRate(value) {
    this._options.playbackRate = value;
    const instance = this._getNewestInstance();
    if (instance) {
      instance.playbackRate = value;
    }
  }
  /**
   * Plays the sound.
   * - Triggers `onEndedObservable` if played for the full duration and the `loop` option is not set.
   * @param options The options to use when playing the sound. Options set here override the sound's options.
   */
  play(options = {}) {
    if (this.state === 5) {
      this.resume();
      return;
    }
    options.duration ?? (options.duration = this.duration);
    options.loop ?? (options.loop = this.loop);
    options.loopStart ?? (options.loopStart = this.loopStart);
    options.loopEnd ?? (options.loopEnd = this.loopEnd);
    options.pitch ?? (options.pitch = this.pitch);
    options.playbackRate ?? (options.playbackRate = this.playbackRate);
    options.startOffset ?? (options.startOffset = this.startOffset);
    options.volume ?? (options.volume = 1);
    options.waitTime ?? (options.waitTime = 0);
    const instance = this._createInstance();
    this._beforePlay(instance);
    instance.play(options);
    this._afterPlay(instance);
    this._stopExcessInstances();
  }
  /**
   * Stops the sound.
   * - Triggers `onEndedObservable` if the sound is playing.
   * @param options - The options to use when stopping the sound.
   */
  stop(options = {}) {
    if (options.waitTime && 0 < options.waitTime) {
      this._setState(
        0
        /* SoundState.Stopping */
      );
    } else {
      this._setState(
        1
        /* SoundState.Stopped */
      );
    }
    if (!this._instances) {
      return;
    }
    for (const instance of Array.from(this._instances)) {
      instance.stop(options);
    }
  }
};

// node_modules/@babylonjs/core/AudioV2/abstractAudio/staticSoundBuffer.js
var StaticSoundBuffer = class {
  constructor(engine) {
    this.engine = engine;
  }
};

// node_modules/@babylonjs/core/AudioV2/abstractAudio/staticSoundInstance.js
var _StaticSoundInstance = class extends _AbstractSoundInstance {
};

// node_modules/@babylonjs/core/AudioV2/webAudio/webAudioStaticSound.js
var _WebAudioStaticSound = class __WebAudioStaticSound extends StaticSound {
  /** @internal */
  constructor(name, engine, options) {
    super(name, engine);
    this._spatial = null;
    this._spatialAutoUpdate = true;
    this._spatialMinUpdateTime = 0;
    this._stereo = null;
    if (typeof options.spatialAutoUpdate === "boolean") {
      this._spatialAutoUpdate = options.spatialAutoUpdate;
    }
    if (typeof options.spatialMinUpdateTime === "number") {
      this._spatialMinUpdateTime = options.spatialMinUpdateTime;
    }
    this._options = {
      autoplay: options.autoplay ?? false,
      duration: options.duration ?? 0,
      loop: options.loop ?? false,
      loopEnd: options.loopEnd ?? 0,
      loopStart: options.loopStart ?? 0,
      maxInstances: options.maxInstances ?? Infinity,
      pitch: options.pitch ?? 0,
      playbackRate: options.playbackRate ?? 1,
      startOffset: options.startOffset ?? 0
    };
    this._subGraph = new __WebAudioStaticSound._SubGraph(this);
  }
  /** @internal */
  async init(source, options) {
    this.audioContext = this.engine.audioContext;
    if (source instanceof _WebAudioStaticSoundBuffer) {
      this._buffer = source;
    } else if (typeof source === "string" || Array.isArray(source) || source instanceof ArrayBuffer || source instanceof AudioBuffer) {
      this._buffer = await this.engine.createSoundBufferAsync(source, options);
    }
    if (options.outBus) {
      this.outBus = options.outBus;
    } else {
      await this.engine.isReadyPromise;
      this.outBus = this.engine.defaultMainBus;
    }
    await this._subGraph.init(options);
    if (_HasSpatialAudioOptions(options)) {
      this._initSpatialProperty();
    }
    if (options.autoplay) {
      this.play();
    }
    this.engine.addNode(this);
  }
  /** @internal */
  get buffer() {
    return this._buffer;
  }
  /** @internal */
  get inNode() {
    return this._subGraph.inNode;
  }
  /** @internal */
  get outNode() {
    return this._subGraph.outNode;
  }
  /** @internal */
  get spatial() {
    if (this._spatial) {
      return this._spatial;
    }
    return this._initSpatialProperty();
  }
  /** @internal */
  get stereo() {
    return this._stereo ?? (this._stereo = new _StereoAudio(this._subGraph));
  }
  /** @internal */
  dispose() {
    var _a;
    super.dispose();
    (_a = this._spatial) == null ? void 0 : _a.dispose();
    this._spatial = null;
    this._stereo = null;
    this._subGraph.dispose();
    this.engine.removeNode(this);
  }
  /** @internal */
  getClassName() {
    return "_WebAudioStaticSound";
  }
  _createInstance() {
    return new _WebAudioStaticSoundInstance(this, this._options);
  }
  _connect(node) {
    var _a;
    const connected = super._connect(node);
    if (!connected) {
      return false;
    }
    if (node.inNode) {
      (_a = this.outNode) == null ? void 0 : _a.connect(node.inNode);
    }
    return true;
  }
  _disconnect(node) {
    var _a;
    const disconnected = super._disconnect(node);
    if (!disconnected) {
      return false;
    }
    if (node.inNode) {
      (_a = this.outNode) == null ? void 0 : _a.disconnect(node.inNode);
    }
    return true;
  }
  _initSpatialProperty() {
    if (!this._spatial) {
      this._spatial = new _SpatialWebAudio(this._subGraph, this._spatialAutoUpdate, this._spatialMinUpdateTime);
    }
    return this._spatial;
  }
};
_WebAudioStaticSound._SubGraph = class extends _WebAudioBusAndSoundSubGraph {
  get _downstreamNodes() {
    return this._owner._downstreamNodes ?? null;
  }
  get _upstreamNodes() {
    return this._owner._upstreamNodes ?? null;
  }
};
var _WebAudioStaticSoundBuffer = class extends StaticSoundBuffer {
  /** @internal */
  constructor(engine) {
    super(engine);
  }
  async init(source, options) {
    if (source instanceof AudioBuffer) {
      this.audioBuffer = source;
    } else if (typeof source === "string") {
      await this._initFromUrl(source);
    } else if (Array.isArray(source)) {
      await this._initFromUrls(source, options.skipCodecCheck ?? false);
    } else if (source instanceof ArrayBuffer) {
      await this._initFromArrayBuffer(source);
    }
  }
  /** @internal */
  get channelCount() {
    return this.audioBuffer.numberOfChannels;
  }
  /** @internal */
  get duration() {
    return this.audioBuffer.duration;
  }
  /** @internal */
  get length() {
    return this.audioBuffer.length;
  }
  /** @internal */
  get sampleRate() {
    return this.audioBuffer.sampleRate;
  }
  async _initFromArrayBuffer(arrayBuffer) {
    this.audioBuffer = await this.engine.audioContext.decodeAudioData(arrayBuffer);
  }
  async _initFromUrl(url) {
    url = _CleanUrl(url);
    await this._initFromArrayBuffer(await (await fetch(url)).arrayBuffer());
  }
  async _initFromUrls(urls, skipCodecCheck) {
    for (const url of urls) {
      if (skipCodecCheck) {
        await this._initFromUrl(url);
      } else {
        const matches = url.match(_FileExtensionRegex);
        const format = matches == null ? void 0 : matches.at(1);
        if (format && this.engine.isFormatValid(format)) {
          try {
            await this._initFromUrl(url);
          } catch (e) {
            if (format && 0 < format.length) {
              this.engine.flagInvalidFormat(format);
            }
          }
        }
      }
      if (this.audioBuffer) {
        break;
      }
    }
  }
};
var _WebAudioStaticSoundInstance = class extends _StaticSoundInstance {
  constructor(sound, options) {
    super(sound);
    this._enginePlayTime = 0;
    this._enginePauseTime = 0;
    this._sourceNode = null;
    this._onEnded = () => {
      this._enginePlayTime = 0;
      this.onEndedObservable.notifyObservers(this);
      this._deinitSourceNode();
    };
    this._onEngineStateChanged = () => {
      if (this.engine.state !== "running") {
        return;
      }
      if (this._options.loop && this.state === 2) {
        this.play();
      }
      this.engine.stateChangedObservable.removeCallback(this._onEngineStateChanged);
    };
    this._options = options;
    this._volumeNode = new GainNode(sound.audioContext);
    this._initSourceNode();
  }
  /** @internal */
  get currentTime() {
    if (this._state === 1) {
      return 0;
    }
    const timeSinceLastStart = this._state === 5 ? 0 : this.engine.currentTime - this._enginePlayTime;
    return this._enginePauseTime + timeSinceLastStart + this._options.startOffset;
  }
  set currentTime(value) {
    const restart = this._state === 2 || this._state === 3;
    if (restart) {
      this.stop();
      this._deinitSourceNode();
    }
    this._options.startOffset = value;
    if (restart) {
      this.play();
    }
  }
  get outNode() {
    return this._volumeNode;
  }
  /** @internal */
  set pitch(value) {
    this._options.pitch = value;
    if (this._sourceNode) {
      this._sourceNode.detune.value = value;
    }
  }
  /** @internal */
  set playbackRate(value) {
    this._options.playbackRate = value;
    if (this._sourceNode) {
      this._sourceNode.playbackRate.value = value;
    }
  }
  /** @internal */
  get startTime() {
    if (this._state === 1) {
      return 0;
    }
    return this._enginePlayTime;
  }
  /** @internal */
  dispose() {
    super.dispose();
    this._sourceNode = null;
    this.stop();
    this._deinitSourceNode();
    this.engine.stateChangedObservable.removeCallback(this._onEngineStateChanged);
  }
  /** @internal */
  getClassName() {
    return "_WebAudioStaticSoundInstance";
  }
  /** @internal */
  play(options = {}) {
    var _a;
    if (this._state === 3) {
      return;
    }
    if (options.duration !== void 0) {
      this._options.duration = options.duration;
    }
    if (options.loop !== void 0) {
      this._options.loop = options.loop;
    }
    if (options.loopStart !== void 0) {
      this._options.loopStart = options.loopStart;
    }
    if (options.loopEnd !== void 0) {
      this._options.loopEnd = options.loopEnd;
    }
    if (options.pitch !== void 0) {
      this._options.pitch = options.pitch;
    }
    if (options.playbackRate !== void 0) {
      this._options.playbackRate = options.playbackRate;
    }
    if (options.startOffset !== void 0) {
      this._options.startOffset = options.startOffset;
    }
    let startOffset = this._options.startOffset;
    if (this._state === 5) {
      startOffset += this.currentTime;
      startOffset %= this._sound.buffer.duration;
    }
    this._enginePlayTime = this.engine.currentTime + (options.waitTime ?? 0);
    this._volumeNode.gain.value = options.volume ?? 1;
    this._initSourceNode();
    if (this.engine.state === "running") {
      this._setState(
        3
        /* SoundState.Started */
      );
      (_a = this._sourceNode) == null ? void 0 : _a.start(this._enginePlayTime, startOffset, this._options.duration > 0 ? this._options.duration : void 0);
    } else if (this._options.loop) {
      this._setState(
        2
        /* SoundState.Starting */
      );
      this.engine.stateChangedObservable.add(this._onEngineStateChanged);
    }
  }
  /** @internal */
  pause() {
    var _a;
    if (this._state === 5) {
      return;
    }
    this._setState(
      5
      /* SoundState.Paused */
    );
    this._enginePauseTime += this.engine.currentTime - this._enginePlayTime;
    (_a = this._sourceNode) == null ? void 0 : _a.stop();
    this._deinitSourceNode();
  }
  /** @internal */
  resume() {
    if (this._state === 5) {
      this.play();
    }
  }
  /** @internal */
  stop(options = {}) {
    var _a;
    if (this._state === 1) {
      return;
    }
    this._setState(
      1
      /* SoundState.Stopped */
    );
    const engineStopTime = this.engine.currentTime + (options.waitTime ?? 0);
    (_a = this._sourceNode) == null ? void 0 : _a.stop(engineStopTime);
    this.engine.stateChangedObservable.removeCallback(this._onEngineStateChanged);
  }
  _connect(node) {
    var _a;
    const connected = super._connect(node);
    if (!connected) {
      return false;
    }
    if (node instanceof _WebAudioStaticSound && node.inNode) {
      (_a = this.outNode) == null ? void 0 : _a.connect(node.inNode);
    }
    return true;
  }
  _disconnect(node) {
    var _a;
    const disconnected = super._disconnect(node);
    if (!disconnected) {
      return false;
    }
    if (node instanceof _WebAudioStaticSound && node.inNode) {
      (_a = this.outNode) == null ? void 0 : _a.disconnect(node.inNode);
    }
    return true;
  }
  _deinitSourceNode() {
    if (!this._sourceNode) {
      return;
    }
    if (!this._disconnect(this._sound)) {
      throw new Error("Disconnect failed");
    }
    this._sourceNode.disconnect(this._volumeNode);
    this._sourceNode.removeEventListener("ended", this._onEnded);
    this._sourceNode = null;
  }
  _initSourceNode() {
    if (!this._sourceNode) {
      this._sourceNode = new AudioBufferSourceNode(this._sound.audioContext, { buffer: this._sound.buffer.audioBuffer });
      this._sourceNode.addEventListener("ended", this._onEnded, { once: true });
      this._sourceNode.connect(this._volumeNode);
      if (!this._connect(this._sound)) {
        throw new Error("Connect failed");
      }
    }
    const node = this._sourceNode;
    node.detune.value = this._options.pitch;
    node.loop = this._options.loop;
    node.loopEnd = this._options.loopEnd;
    node.loopStart = this._options.loopStart;
    node.playbackRate.value = this._options.playbackRate;
  }
};

export {
  StaticSound,
  StaticSoundBuffer,
  _WebAudioStaticSound,
  _WebAudioStaticSoundBuffer
};
//# sourceMappingURL=chunk-HNYZAVA5.js.map
