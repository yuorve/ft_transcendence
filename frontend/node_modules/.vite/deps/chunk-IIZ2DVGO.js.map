{
  "version": 3,
  "sources": ["../../../dev/core/src/Shaders/gpuTransform.vertex.ts", "../../../dev/core/src/Shaders/gpuTransform.fragment.ts", "../../../dev/core/src/Culling/Helper/transformFeedbackBoundingHelper.ts"],
  "sourcesContent": ["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/bonesDeclaration\";\nimport \"./ShadersInclude/bakedVertexAnimationDeclaration\";\nimport \"./ShadersInclude/morphTargetsVertexGlobalDeclaration\";\nimport \"./ShadersInclude/morphTargetsVertexDeclaration\";\nimport \"./ShadersInclude/morphTargetsVertexGlobal\";\nimport \"./ShadersInclude/morphTargetsVertex\";\nimport \"./ShadersInclude/bonesVertex\";\nimport \"./ShadersInclude/bakedVertexAnimation\";\n\nconst name = \"gpuTransformVertexShader\";\nconst shader = `attribute vec3 position;\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<morphTargetsVertexGlobalDeclaration>\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\nout vec3 outPosition;const mat4 identity=mat4(\nvec4(1.0,0.0,0.0,0.0),\nvec4(0.0,1.0,0.0,0.0),\nvec4(0.0,0.0,1.0,0.0),\nvec4(0.0,0.0,0.0,1.0)\n);void main(void) {vec3 positionUpdated=position;\n#include<morphTargetsVertexGlobal>\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\nmat4 finalWorld=identity;\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvec4 worldPos=finalWorld*vec4(positionUpdated,1.0);outPosition=worldPos.xyz;}`;\n// Sideeffect\nif (!ShaderStore.ShadersStore[name]) {\n    ShaderStore.ShadersStore[name] = shader;\n}\n/** @internal */\nexport const gpuTransformVertexShader = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"gpuTransformPixelShader\";\nconst shader = `#version 300 es\nvoid main() {discard;}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStore[name]) {\n    ShaderStore.ShadersStore[name] = shader;\n}\n/** @internal */\nexport const gpuTransformPixelShader = { name, shader };\n", "import type { Effect } from \"core/Materials/effect\";\r\nimport type { ThinEngine } from \"core/Engines/thinEngine\";\r\nimport { VertexBuffer, Buffer } from \"core/Buffers/buffer\";\r\nimport type { Engine } from \"core/Engines/engine\";\r\nimport { Constants } from \"core/Engines/constants\";\r\nimport type { Nullable } from \"core/types\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport {\r\n    BindBonesParameters,\r\n    BindMorphTargetParameters,\r\n    PrepareAttributesForBakedVertexAnimation,\r\n    PrepareDefinesAndAttributesForMorphTargets,\r\n} from \"core/Materials/materialHelper.functions\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport type { IBoundingInfoHelperPlatform } from \"./IBoundingInfoHelperPlatform\";\r\nimport { extractMinAndMax } from \"core/Maths/math.functions\";\r\nimport { Vector3 } from \"core/Maths/math.vector\";\r\n\r\nimport \"../../Shaders/gpuTransform.vertex\";\r\nimport \"../../Shaders/gpuTransform.fragment\";\r\n\r\n/** @internal */\r\nexport class TransformFeedbackBoundingHelper implements IBoundingInfoHelperPlatform {\r\n    private static _Min = new Vector3();\r\n    private static _Max = new Vector3();\r\n\r\n    private _engine: Nullable<ThinEngine>;\r\n    private _buffers: { [key: number]: Buffer } = {};\r\n    private _effects: { [key: string]: Effect } = {};\r\n    private _meshList: AbstractMesh[];\r\n    private _meshListCounter = 0;\r\n\r\n    /**\r\n     * Creates a new TransformFeedbackBoundingHelper\r\n     * @param engine defines the engine to use\r\n     */\r\n    constructor(engine: ThinEngine) {\r\n        this._engine = engine;\r\n    }\r\n\r\n    /** @internal */\r\n    public processAsync(meshes: AbstractMesh | AbstractMesh[]): Promise<void> {\r\n        if (!Array.isArray(meshes)) {\r\n            meshes = [meshes];\r\n        }\r\n\r\n        this._meshListCounter = 0;\r\n\r\n        this._processMeshList(meshes);\r\n\r\n        return Promise.resolve();\r\n    }\r\n\r\n    private _processMeshList(meshes: AbstractMesh[]) {\r\n        const parallelShaderCompile = this._engine!.getCaps().parallelShaderCompile;\r\n\r\n        this._engine!.getCaps().parallelShaderCompile = undefined;\r\n\r\n        for (let i = 0; i < meshes.length; ++i) {\r\n            const mesh = meshes[i];\r\n            const vertexCount = mesh.getTotalVertices();\r\n\r\n            if (vertexCount === 0 || !(mesh as Mesh).getVertexBuffer || !(mesh as Mesh).getVertexBuffer(VertexBuffer.PositionKind)) {\r\n                continue;\r\n            }\r\n\r\n            // Get correct effect\r\n            let computeEffect: Effect;\r\n            const defines: string[] = [];\r\n            const attribs = [VertexBuffer.PositionKind];\r\n\r\n            // Bones\r\n            if (mesh && mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {\r\n                attribs.push(VertexBuffer.MatricesIndicesKind);\r\n                attribs.push(VertexBuffer.MatricesWeightsKind);\r\n                if (mesh.numBoneInfluencers > 4) {\r\n                    attribs.push(VertexBuffer.MatricesIndicesExtraKind);\r\n                    attribs.push(VertexBuffer.MatricesWeightsExtraKind);\r\n                }\r\n                defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\r\n                defines.push(\"#define BONETEXTURE \" + mesh.skeleton.isUsingTextureForMatrices);\r\n                defines.push(\"#define BonesPerMesh \" + (mesh.skeleton.bones.length + 1));\r\n            } else {\r\n                defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\r\n            }\r\n\r\n            // Morph\r\n            const numMorphInfluencers = mesh.morphTargetManager\r\n                ? PrepareDefinesAndAttributesForMorphTargets(\r\n                      mesh.morphTargetManager,\r\n                      defines,\r\n                      attribs,\r\n                      mesh,\r\n                      true, // usePositionMorph\r\n                      false, // useNormalMorph\r\n                      false, // useTangentMorph\r\n                      false, // useUVMorph\r\n                      false, // useUV2Morph\r\n                      false // useColorMorph\r\n                  )\r\n                : 0;\r\n\r\n            // Baked Vertex Animation\r\n            const bvaManager = (<Mesh>mesh).bakedVertexAnimationManager;\r\n            if (bvaManager && bvaManager.isEnabled) {\r\n                defines.push(\"#define BAKED_VERTEX_ANIMATION_TEXTURE\");\r\n                PrepareAttributesForBakedVertexAnimation(attribs, mesh, defines);\r\n            }\r\n\r\n            const join = defines.join(\"\\n\");\r\n            if (!this._effects[join]) {\r\n                const uniforms = [\r\n                    \"boneTextureWidth\",\r\n                    \"mBones\",\r\n                    \"morphTargetInfluences\",\r\n                    \"morphTargetCount\",\r\n                    \"morphTargetTextureInfo\",\r\n                    \"morphTargetTextureIndices\",\r\n                    \"bakedVertexAnimationSettings\",\r\n                    \"bakedVertexAnimationTextureSizeInverted\",\r\n                    \"bakedVertexAnimationTime\",\r\n                ];\r\n                const samplers = [\"boneSampler\", \"morphTargets\", \"bakedVertexAnimationTexture\"];\r\n\r\n                const computeEffectOptions = {\r\n                    attributes: attribs,\r\n                    uniformsNames: uniforms,\r\n                    uniformBuffersNames: [],\r\n                    samplers: samplers,\r\n                    defines: join,\r\n                    fallbacks: null,\r\n                    onCompiled: null,\r\n                    onError: null,\r\n                    indexParameters: { maxSimultaneousMorphTargets: numMorphInfluencers },\r\n                    maxSimultaneousLights: 0,\r\n                    transformFeedbackVaryings: [\"outPosition\"],\r\n                };\r\n                computeEffect = this._engine!.createEffect(\"gpuTransform\", computeEffectOptions, this._engine!);\r\n                this._effects[join] = computeEffect;\r\n            } else {\r\n                computeEffect = this._effects[join];\r\n            }\r\n\r\n            this._compute(mesh, computeEffect);\r\n        }\r\n\r\n        this._engine!.getCaps().parallelShaderCompile = parallelShaderCompile;\r\n    }\r\n\r\n    private _compute(mesh: AbstractMesh, effect: Effect): void {\r\n        const engine = this._engine as Engine;\r\n\r\n        // Buffer\r\n        let targetBuffer: Buffer;\r\n        const vertexCount = mesh.getTotalVertices();\r\n\r\n        if (!this._buffers[mesh.uniqueId]) {\r\n            const targetData = new Float32Array(vertexCount * 3);\r\n            targetBuffer = new Buffer(mesh.getEngine(), targetData, true, 3);\r\n            this._buffers[mesh.uniqueId] = targetBuffer;\r\n        } else {\r\n            targetBuffer = this._buffers[mesh.uniqueId];\r\n        }\r\n\r\n        // Bind\r\n        effect.getEngine().enableEffect(effect);\r\n        (mesh as Mesh)._bindDirect(effect, null, true);\r\n\r\n        // Bones\r\n        BindBonesParameters(mesh, effect);\r\n\r\n        // Morph targets\r\n        BindMorphTargetParameters(mesh, effect);\r\n        if (mesh.morphTargetManager && mesh.morphTargetManager.isUsingTextureForTargets) {\r\n            mesh.morphTargetManager._bind(effect);\r\n        }\r\n\r\n        // BVA\r\n        const bvaManager = (<Mesh>mesh).bakedVertexAnimationManager;\r\n\r\n        if (bvaManager && bvaManager.isEnabled) {\r\n            mesh.bakedVertexAnimationManager?.bind(effect, false);\r\n        }\r\n\r\n        // Update\r\n        const arrayBuffer = targetBuffer.getData()! as Float32Array;\r\n        engine.bindTransformFeedbackBuffer(targetBuffer.getBuffer());\r\n        engine.setRasterizerState(false);\r\n        engine.beginTransformFeedback(true);\r\n        engine.drawArraysType(Constants.MATERIAL_PointFillMode, 0, vertexCount);\r\n        engine.endTransformFeedback();\r\n        engine.setRasterizerState(true);\r\n        engine.readTransformFeedbackBuffer(arrayBuffer);\r\n        engine.bindTransformFeedbackBuffer(null);\r\n\r\n        // Update mesh\r\n        if (this._meshListCounter === 0) {\r\n            mesh._refreshBoundingInfo(arrayBuffer, null);\r\n        } else {\r\n            const bb = mesh.getBoundingInfo().boundingBox;\r\n            const extend = extractMinAndMax(arrayBuffer, 0, vertexCount);\r\n\r\n            TransformFeedbackBoundingHelper._Min.copyFrom(bb.minimum).minimizeInPlace(extend.minimum);\r\n            TransformFeedbackBoundingHelper._Max.copyFrom(bb.maximum).maximizeInPlace(extend.maximum);\r\n\r\n            mesh._refreshBoundingInfoDirect({ minimum: TransformFeedbackBoundingHelper._Min, maximum: TransformFeedbackBoundingHelper._Max });\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public registerMeshListAsync(meshes: AbstractMesh | AbstractMesh[]): Promise<void> {\r\n        if (!Array.isArray(meshes)) {\r\n            meshes = [meshes];\r\n        }\r\n\r\n        this._meshList = meshes;\r\n        this._meshListCounter = 0;\r\n\r\n        return Promise.resolve();\r\n    }\r\n\r\n    /** @internal */\r\n    public processMeshList(): void {\r\n        if (this._meshList.length === 0) {\r\n            return;\r\n        }\r\n\r\n        this._processMeshList(this._meshList);\r\n        this._meshListCounter++;\r\n    }\r\n\r\n    /** @internal */\r\n    public fetchResultsForMeshListAsync(): Promise<void> {\r\n        this._meshListCounter = 0;\r\n\r\n        return Promise.resolve();\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose(): void {\r\n        for (const key in this._buffers) {\r\n            this._buffers[key].dispose();\r\n        }\r\n        this._buffers = {};\r\n        this._effects = {};\r\n        this._engine = null;\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": ["name", "shader"]
}
