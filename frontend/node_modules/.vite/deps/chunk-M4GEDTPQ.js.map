{
  "version": 3,
  "sources": ["../../../dev/core/src/Engines/abstractEngine.functions.ts", "../../../dev/core/src/Misc/timingTools.ts", "../../../dev/core/src/Engines/WebGL/webGLPipelineContext.ts", "../../../dev/core/src/Engines/thinEngine.functions.ts", "../../../dev/core/src/Engines/Processors/shaderCodeNode.ts", "../../../dev/core/src/Engines/Processors/shaderCodeCursor.ts", "../../../dev/core/src/Engines/Processors/shaderCodeConditionNode.ts", "../../../dev/core/src/Engines/Processors/shaderCodeTestNode.ts", "../../../dev/core/src/Engines/Processors/Expressions/shaderDefineExpression.ts", "../../../dev/core/src/Engines/Processors/Expressions/Operators/shaderDefineIsDefinedOperator.ts", "../../../dev/core/src/Engines/Processors/Expressions/Operators/shaderDefineOrOperator.ts", "../../../dev/core/src/Engines/Processors/Expressions/Operators/shaderDefineAndOperator.ts", "../../../dev/core/src/Engines/Processors/Expressions/Operators/shaderDefineArithmeticOperator.ts", "../../../dev/core/src/Engines/Processors/shaderProcessor.ts", "../../../dev/core/src/Materials/effect.functions.ts", "../../../dev/core/src/Materials/effect.ts", "../../../dev/core/src/States/depthCullingState.ts", "../../../dev/core/src/States/stencilStateComposer.ts", "../../../dev/core/src/States/stencilState.ts", "../../../dev/core/src/States/alphaCullingState.ts", "../../../dev/core/src/Materials/Textures/textureSampler.ts", "../../../dev/core/src/Materials/Textures/internalTexture.ts", "../../../dev/core/src/Misc/tools.functions.ts", "../../../dev/core/src/Materials/Textures/Loaders/textureLoaderManager.ts", "../../../dev/core/src/Engines/abstractEngine.ts"],
  "sourcesContent": ["import { _WarnImport } from \"core/Misc/devTools\";\r\nimport { IsDocumentAvailable } from \"core/Misc/domManagement\";\r\nimport type { IFileRequest } from \"core/Misc/fileRequest\";\r\nimport type { LoadFileError } from \"core/Misc/fileTools\";\r\nimport type { IWebRequest } from \"core/Misc/interfaces/iWebRequest\";\r\nimport type { WebRequest } from \"core/Misc/webRequest\";\r\nimport type { IOfflineProvider } from \"core/Offline/IOfflineProvider\";\r\nimport type { Nullable } from \"core/types\";\r\nimport { Constants } from \"./constants\";\r\n\r\nexport const EngineFunctionContext: {\r\n    /**\r\n     * Loads a file from a url\r\n     * @param url url to load\r\n     * @param onSuccess callback called when the file successfully loads\r\n     * @param onProgress callback called while file is loading (if the server supports this mode)\r\n     * @param offlineProvider defines the offline provider for caching\r\n     * @param useArrayBuffer defines a boolean indicating that date must be returned as ArrayBuffer\r\n     * @param onError callback called when the file fails to load\r\n     * @returns a file request object\r\n     * @internal\r\n     */\r\n    loadFile?: (\r\n        url: string,\r\n        onSuccess: (data: string | ArrayBuffer, responseURL?: string) => void,\r\n        onProgress?: (ev: ProgressEvent) => void,\r\n        offlineProvider?: IOfflineProvider,\r\n        useArrayBuffer?: boolean,\r\n        onError?: (request?: WebRequest, exception?: LoadFileError) => void\r\n    ) => IFileRequest;\r\n} = {};\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function _ConcatenateShader(source: string, defines: Nullable<string>, shaderVersion: string = \"\"): string {\r\n    return shaderVersion + (defines ? defines + \"\\n\" : \"\") + source;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function _loadFile(\r\n    url: string,\r\n    onSuccess: (data: string | ArrayBuffer, responseURL?: string) => void,\r\n    onProgress?: (data: any) => void,\r\n    offlineProvider?: IOfflineProvider,\r\n    useArrayBuffer?: boolean,\r\n    onError?: (request?: IWebRequest, exception?: any) => void,\r\n    injectedLoadFile?: (\r\n        url: string,\r\n        onSuccess: (data: string | ArrayBuffer, responseURL?: string | undefined) => void,\r\n        onProgress?: ((ev: ProgressEvent<EventTarget>) => void) | undefined,\r\n        offlineProvider?: IOfflineProvider | undefined,\r\n        useArrayBuffer?: boolean | undefined,\r\n        onError?: ((request?: WebRequest | undefined, exception?: LoadFileError | undefined) => void) | undefined\r\n    ) => IFileRequest\r\n): IFileRequest {\r\n    const loadFile = injectedLoadFile || EngineFunctionContext.loadFile;\r\n    if (loadFile) {\r\n        const request = loadFile(url, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError);\r\n        return request;\r\n    }\r\n    throw _WarnImport(\"FileTools\");\r\n}\r\n\r\n/**\r\n * Gets host document\r\n * @param renderingCanvas if provided, the canvas' owner document will be returned\r\n * @returns the host document object\r\n */\r\nexport function getHostDocument(renderingCanvas: Nullable<HTMLCanvasElement> = null): Nullable<Document> {\r\n    if (renderingCanvas && renderingCanvas.ownerDocument) {\r\n        return renderingCanvas.ownerDocument;\r\n    }\r\n\r\n    return IsDocumentAvailable() ? document : null;\r\n}\r\n\r\n/** @internal */\r\nexport function _getGlobalDefines(\r\n    defines?: { [key: string]: string },\r\n    isNDCHalfZRange?: boolean,\r\n    useReverseDepthBuffer?: boolean,\r\n    useExactSrgbConversions?: boolean\r\n): string | undefined {\r\n    if (defines) {\r\n        if (isNDCHalfZRange) {\r\n            defines[\"IS_NDC_HALF_ZRANGE\"] = \"\";\r\n        } else {\r\n            delete defines[\"IS_NDC_HALF_ZRANGE\"];\r\n        }\r\n        if (useReverseDepthBuffer) {\r\n            defines[\"USE_REVERSE_DEPTHBUFFER\"] = \"\";\r\n        } else {\r\n            delete defines[\"USE_REVERSE_DEPTHBUFFER\"];\r\n        }\r\n        if (useExactSrgbConversions) {\r\n            defines[\"USE_EXACT_SRGB_CONVERSIONS\"] = \"\";\r\n        } else {\r\n            delete defines[\"USE_EXACT_SRGB_CONVERSIONS\"];\r\n        }\r\n        return;\r\n    } else {\r\n        let s = \"\";\r\n        if (isNDCHalfZRange) {\r\n            s += \"#define IS_NDC_HALF_ZRANGE\";\r\n        }\r\n        if (useReverseDepthBuffer) {\r\n            if (s) {\r\n                s += \"\\n\";\r\n            }\r\n            s += \"#define USE_REVERSE_DEPTHBUFFER\";\r\n        }\r\n        if (useExactSrgbConversions) {\r\n            if (s) {\r\n                s += \"\\n\";\r\n            }\r\n            s += \"#define USE_EXACT_SRGB_CONVERSIONS\";\r\n        }\r\n        return s;\r\n    }\r\n}\r\n\r\n/**\r\n * Allocate a typed array depending on a texture type. Optionally can copy existing data in the buffer.\r\n * @param type type of the texture\r\n * @param sizeOrDstBuffer size of the array OR an existing buffer that will be used as the destination of the copy (if copyBuffer is provided)\r\n * @param sizeInBytes true if the size of the array is given in bytes, false if it is the number of elements of the array\r\n * @param copyBuffer if provided, buffer to copy into the destination buffer (either a newly allocated buffer if sizeOrDstBuffer is a number or use sizeOrDstBuffer as the destination buffer otherwise)\r\n * @returns the allocated buffer or sizeOrDstBuffer if the latter is an ArrayBuffer\r\n */\r\nexport function allocateAndCopyTypedBuffer(type: number, sizeOrDstBuffer: number | ArrayBuffer, sizeInBytes = false, copyBuffer?: ArrayBuffer): ArrayBufferView {\r\n    switch (type) {\r\n        case Constants.TEXTURETYPE_BYTE: {\r\n            const buffer = sizeOrDstBuffer instanceof ArrayBuffer ? new Int8Array(sizeOrDstBuffer) : new Int8Array(sizeOrDstBuffer);\r\n            if (copyBuffer) {\r\n                buffer.set(new Int8Array(copyBuffer));\r\n            }\r\n            return buffer;\r\n        }\r\n        case Constants.TEXTURETYPE_UNSIGNED_BYTE: {\r\n            const buffer = sizeOrDstBuffer instanceof ArrayBuffer ? new Uint8Array(sizeOrDstBuffer) : new Uint8Array(sizeOrDstBuffer);\r\n            if (copyBuffer) {\r\n                buffer.set(new Uint8Array(copyBuffer));\r\n            }\r\n            return buffer;\r\n        }\r\n        case Constants.TEXTURETYPE_SHORT: {\r\n            const buffer = sizeOrDstBuffer instanceof ArrayBuffer ? new Int16Array(sizeOrDstBuffer) : new Int16Array(sizeInBytes ? sizeOrDstBuffer / 2 : sizeOrDstBuffer);\r\n            if (copyBuffer) {\r\n                buffer.set(new Int16Array(copyBuffer));\r\n            }\r\n            return buffer;\r\n        }\r\n        case Constants.TEXTURETYPE_UNSIGNED_SHORT:\r\n        case Constants.TEXTURETYPE_UNSIGNED_SHORT_4_4_4_4:\r\n        case Constants.TEXTURETYPE_UNSIGNED_SHORT_5_5_5_1:\r\n        case Constants.TEXTURETYPE_UNSIGNED_SHORT_5_6_5:\r\n        case Constants.TEXTURETYPE_HALF_FLOAT: {\r\n            const buffer = sizeOrDstBuffer instanceof ArrayBuffer ? new Uint16Array(sizeOrDstBuffer) : new Uint16Array(sizeInBytes ? sizeOrDstBuffer / 2 : sizeOrDstBuffer);\r\n            if (copyBuffer) {\r\n                buffer.set(new Uint16Array(copyBuffer));\r\n            }\r\n            return buffer;\r\n        }\r\n        case Constants.TEXTURETYPE_INT: {\r\n            const buffer = sizeOrDstBuffer instanceof ArrayBuffer ? new Int32Array(sizeOrDstBuffer) : new Int32Array(sizeInBytes ? sizeOrDstBuffer / 4 : sizeOrDstBuffer);\r\n            if (copyBuffer) {\r\n                buffer.set(new Int32Array(copyBuffer));\r\n            }\r\n            return buffer;\r\n        }\r\n        case Constants.TEXTURETYPE_UNSIGNED_INTEGER:\r\n        case Constants.TEXTURETYPE_UNSIGNED_INT_2_10_10_10_REV:\r\n        case Constants.TEXTURETYPE_UNSIGNED_INT_24_8:\r\n        case Constants.TEXTURETYPE_UNSIGNED_INT_10F_11F_11F_REV:\r\n        case Constants.TEXTURETYPE_UNSIGNED_INT_5_9_9_9_REV:\r\n        case Constants.TEXTURETYPE_FLOAT_32_UNSIGNED_INT_24_8_REV: {\r\n            const buffer = sizeOrDstBuffer instanceof ArrayBuffer ? new Uint32Array(sizeOrDstBuffer) : new Uint32Array(sizeInBytes ? sizeOrDstBuffer / 4 : sizeOrDstBuffer);\r\n            if (copyBuffer) {\r\n                buffer.set(new Uint32Array(copyBuffer));\r\n            }\r\n            return buffer;\r\n        }\r\n        case Constants.TEXTURETYPE_FLOAT: {\r\n            const buffer = sizeOrDstBuffer instanceof ArrayBuffer ? new Float32Array(sizeOrDstBuffer) : new Float32Array(sizeInBytes ? sizeOrDstBuffer / 4 : sizeOrDstBuffer);\r\n            if (copyBuffer) {\r\n                buffer.set(new Float32Array(copyBuffer));\r\n            }\r\n            return buffer;\r\n        }\r\n    }\r\n\r\n    const buffer = sizeOrDstBuffer instanceof ArrayBuffer ? new Uint8Array(sizeOrDstBuffer) : new Uint8Array(sizeOrDstBuffer);\r\n    if (copyBuffer) {\r\n        buffer.set(new Uint8Array(copyBuffer));\r\n    }\r\n    return buffer;\r\n}\r\n", "let _immediateQueue: Array<() => void> = [];\r\n\r\n/**\r\n * Class used to provide helper for timing\r\n */\r\nexport class TimingTools {\r\n    /**\r\n     * Execute a function after the current execution block\r\n     * @param action defines the action to execute after the current execution block\r\n     */\r\n    public static SetImmediate(action: () => void) {\r\n        if (_immediateQueue.length === 0) {\r\n            setTimeout(() => {\r\n                // Execute all immediate functions\r\n                const functionsToCall = _immediateQueue;\r\n                _immediateQueue = [];\r\n\r\n                for (const func of functionsToCall) {\r\n                    func();\r\n                }\r\n            }, 1);\r\n        }\r\n        _immediateQueue.push(action);\r\n    }\r\n}\r\n\r\nfunction _runWithCondition(condition: () => boolean, onSuccess: () => void, onError?: (e?: any, isTimeout?: boolean) => void) {\r\n    try {\r\n        if (condition()) {\r\n            onSuccess();\r\n            return true;\r\n        }\r\n    } catch (e) {\r\n        onError?.(e);\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport const _retryWithInterval = (\r\n    condition: () => boolean,\r\n    onSuccess: () => void,\r\n    onError?: (e?: any, isTimeout?: boolean) => void,\r\n    step = 16,\r\n    maxTimeout = 30000,\r\n    checkConditionOnCall: boolean = true,\r\n    additionalStringOnTimeout?: string\r\n) => {\r\n    // if checkConditionOnCall is true, we check the condition immediately. If it is true, run everything synchronously\r\n    if (checkConditionOnCall) {\r\n        // that means that one of the two happened - either the condition is true or an exception was thrown when checking the condition\r\n        if (_runWithCondition(condition, onSuccess, onError)) {\r\n            // don't schedule the interval, no reason to check it again.\r\n            return null;\r\n        }\r\n    }\r\n    const int = setInterval(() => {\r\n        if (_runWithCondition(condition, onSuccess, onError)) {\r\n            clearInterval(int);\r\n        } else {\r\n            maxTimeout -= step;\r\n            if (maxTimeout < 0) {\r\n                clearInterval(int);\r\n                onError?.(new Error(\"Operation timed out after maximum retries. \" + (additionalStringOnTimeout || \"\")), true);\r\n            }\r\n        }\r\n    }, step);\r\n    return () => clearInterval(int);\r\n};\r\n", "import type { IPipelineContext } from \"../IPipelineContext\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Effect } from \"../../Materials/effect\";\r\nimport type { IMatrixLike, IVector2Like, IVector3Like, IVector4Like, IColor3Like, IColor4Like, IQuaternionLike } from \"../../Maths/math.like\";\r\nimport type { ThinEngine } from \"../thinEngine\";\r\nimport type { AbstractEngine } from \"../abstractEngine\";\r\n\r\n/** @internal */\r\nexport class WebGLPipelineContext implements IPipelineContext {\r\n    private _valueCache: { [key: string]: any } = {};\r\n    private _uniforms: { [key: string]: Nullable<WebGLUniformLocation> };\r\n\r\n    public engine: ThinEngine;\r\n    public program: Nullable<WebGLProgram>;\r\n    public context?: WebGLRenderingContext;\r\n    public vertexShader?: WebGLShader;\r\n    public fragmentShader?: WebGLShader;\r\n    public isParallelCompiled: boolean;\r\n    public onCompiled?: () => void;\r\n    public transformFeedback?: WebGLTransformFeedback | null;\r\n\r\n    public vertexCompilationError: Nullable<string> = null;\r\n    public fragmentCompilationError: Nullable<string> = null;\r\n    public programLinkError: Nullable<string> = null;\r\n    public programValidationError: Nullable<string> = null;\r\n\r\n    /** @internal */\r\n    public _isDisposed = false;\r\n\r\n    public get isAsync() {\r\n        return this.isParallelCompiled;\r\n    }\r\n\r\n    public get isReady(): boolean {\r\n        if (this.program) {\r\n            if (this.isParallelCompiled) {\r\n                return this.engine._isRenderingStateCompiled(this);\r\n            }\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public _handlesSpectorRebuildCallback(onCompiled: (program: WebGLProgram) => void): void {\r\n        if (onCompiled && this.program) {\r\n            onCompiled(this.program);\r\n        }\r\n    }\r\n\r\n    public setEngine(engine: AbstractEngine): void {\r\n        this.engine = engine as ThinEngine;\r\n    }\r\n\r\n    public _fillEffectInformation(\r\n        effect: Effect,\r\n        uniformBuffersNames: { [key: string]: number },\r\n        uniformsNames: string[],\r\n        uniforms: { [key: string]: Nullable<WebGLUniformLocation> },\r\n        samplerList: string[],\r\n        samplers: { [key: string]: number },\r\n        attributesNames: string[],\r\n        attributes: number[]\r\n    ) {\r\n        const engine = this.engine;\r\n        if (engine.supportsUniformBuffers) {\r\n            for (const name in uniformBuffersNames) {\r\n                effect.bindUniformBlock(name, uniformBuffersNames[name]);\r\n            }\r\n        }\r\n\r\n        const effectAvailableUniforms = this.engine.getUniforms(this, uniformsNames);\r\n        effectAvailableUniforms.forEach((uniform, index) => {\r\n            uniforms[uniformsNames[index]] = uniform;\r\n        });\r\n        this._uniforms = uniforms;\r\n\r\n        let index: number;\r\n        for (index = 0; index < samplerList.length; index++) {\r\n            const sampler = effect.getUniform(samplerList[index]);\r\n            if (sampler == null) {\r\n                samplerList.splice(index, 1);\r\n                index--;\r\n            }\r\n        }\r\n\r\n        samplerList.forEach((name, index) => {\r\n            samplers[name] = index;\r\n        });\r\n\r\n        for (const attr of engine.getAttributes(this, attributesNames)) {\r\n            attributes.push(attr);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Release all associated resources.\r\n     **/\r\n    public dispose() {\r\n        this._uniforms = {};\r\n        this._isDisposed = true;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _cacheMatrix(uniformName: string, matrix: IMatrixLike): boolean {\r\n        const cache = this._valueCache[uniformName];\r\n        const flag = matrix.updateFlag;\r\n        if (cache !== undefined && cache === flag) {\r\n            return false;\r\n        }\r\n\r\n        this._valueCache[uniformName] = flag;\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _cacheFloat2(uniformName: string, x: number, y: number): boolean {\r\n        let cache = this._valueCache[uniformName];\r\n        if (!cache || cache.length !== 2) {\r\n            cache = [x, y];\r\n            this._valueCache[uniformName] = cache;\r\n            return true;\r\n        }\r\n\r\n        let changed = false;\r\n        if (cache[0] !== x) {\r\n            cache[0] = x;\r\n            changed = true;\r\n        }\r\n        if (cache[1] !== y) {\r\n            cache[1] = y;\r\n            changed = true;\r\n        }\r\n\r\n        return changed;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _cacheFloat3(uniformName: string, x: number, y: number, z: number): boolean {\r\n        let cache = this._valueCache[uniformName];\r\n        if (!cache || cache.length !== 3) {\r\n            cache = [x, y, z];\r\n            this._valueCache[uniformName] = cache;\r\n            return true;\r\n        }\r\n\r\n        let changed = false;\r\n        if (cache[0] !== x) {\r\n            cache[0] = x;\r\n            changed = true;\r\n        }\r\n        if (cache[1] !== y) {\r\n            cache[1] = y;\r\n            changed = true;\r\n        }\r\n        if (cache[2] !== z) {\r\n            cache[2] = z;\r\n            changed = true;\r\n        }\r\n\r\n        return changed;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _cacheFloat4(uniformName: string, x: number, y: number, z: number, w: number): boolean {\r\n        let cache = this._valueCache[uniformName];\r\n        if (!cache || cache.length !== 4) {\r\n            cache = [x, y, z, w];\r\n            this._valueCache[uniformName] = cache;\r\n            return true;\r\n        }\r\n\r\n        let changed = false;\r\n        if (cache[0] !== x) {\r\n            cache[0] = x;\r\n            changed = true;\r\n        }\r\n        if (cache[1] !== y) {\r\n            cache[1] = y;\r\n            changed = true;\r\n        }\r\n        if (cache[2] !== z) {\r\n            cache[2] = z;\r\n            changed = true;\r\n        }\r\n        if (cache[3] !== w) {\r\n            cache[3] = w;\r\n            changed = true;\r\n        }\r\n\r\n        return changed;\r\n    }\r\n\r\n    /**\r\n     * Sets an integer value on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param value Value to be set.\r\n     */\r\n    public setInt(uniformName: string, value: number): void {\r\n        const cache = this._valueCache[uniformName];\r\n        if (cache !== undefined && cache === value) {\r\n            return;\r\n        }\r\n\r\n        if (this.engine.setInt(this._uniforms[uniformName], value)) {\r\n            this._valueCache[uniformName] = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a int2 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First int in int2.\r\n     * @param y Second int in int2.\r\n     */\r\n    public setInt2(uniformName: string, x: number, y: number): void {\r\n        if (this._cacheFloat2(uniformName, x, y)) {\r\n            if (!this.engine.setInt2(this._uniforms[uniformName], x, y)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a int3 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First int in int3.\r\n     * @param y Second int in int3.\r\n     * @param z Third int in int3.\r\n     */\r\n    public setInt3(uniformName: string, x: number, y: number, z: number): void {\r\n        if (this._cacheFloat3(uniformName, x, y, z)) {\r\n            if (!this.engine.setInt3(this._uniforms[uniformName], x, y, z)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a int4 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First int in int4.\r\n     * @param y Second int in int4.\r\n     * @param z Third int in int4.\r\n     * @param w Fourth int in int4.\r\n     */\r\n    public setInt4(uniformName: string, x: number, y: number, z: number, w: number): void {\r\n        if (this._cacheFloat4(uniformName, x, y, z, w)) {\r\n            if (!this.engine.setInt4(this._uniforms[uniformName], x, y, z, w)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets an int array on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setIntArray(uniformName: string, array: Int32Array): void {\r\n        this._valueCache[uniformName] = null;\r\n        this.engine.setIntArray(this._uniforms[uniformName], array);\r\n    }\r\n\r\n    /**\r\n     * Sets an int array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setIntArray2(uniformName: string, array: Int32Array): void {\r\n        this._valueCache[uniformName] = null;\r\n        this.engine.setIntArray2(this._uniforms[uniformName], array);\r\n    }\r\n\r\n    /**\r\n     * Sets an int array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setIntArray3(uniformName: string, array: Int32Array): void {\r\n        this._valueCache[uniformName] = null;\r\n        this.engine.setIntArray3(this._uniforms[uniformName], array);\r\n    }\r\n\r\n    /**\r\n     * Sets an int array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setIntArray4(uniformName: string, array: Int32Array): void {\r\n        this._valueCache[uniformName] = null;\r\n        this.engine.setIntArray4(this._uniforms[uniformName], array);\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned integer value on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param value Value to be set.\r\n     */\r\n    public setUInt(uniformName: string, value: number): void {\r\n        const cache = this._valueCache[uniformName];\r\n        if (cache !== undefined && cache === value) {\r\n            return;\r\n        }\r\n\r\n        if (this.engine.setUInt(this._uniforms[uniformName], value)) {\r\n            this._valueCache[uniformName] = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned int2 value on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First unsigned int in uint2.\r\n     * @param y Second unsigned int in uint2.\r\n     */\r\n    public setUInt2(uniformName: string, x: number, y: number): void {\r\n        if (this._cacheFloat2(uniformName, x, y)) {\r\n            if (!this.engine.setUInt2(this._uniforms[uniformName], x, y)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned int3 value on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First unsigned int in uint3.\r\n     * @param y Second unsigned int in uint3.\r\n     * @param z Third unsigned int in uint3.\r\n     */\r\n    public setUInt3(uniformName: string, x: number, y: number, z: number): void {\r\n        if (this._cacheFloat3(uniformName, x, y, z)) {\r\n            if (!this.engine.setUInt3(this._uniforms[uniformName], x, y, z)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned int4 value on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First unsigned int in uint4.\r\n     * @param y Second unsigned int in uint4.\r\n     * @param z Third unsigned int in uint4.\r\n     * @param w Fourth unsigned int in uint4.\r\n     */\r\n    public setUInt4(uniformName: string, x: number, y: number, z: number, w: number): void {\r\n        if (this._cacheFloat4(uniformName, x, y, z, w)) {\r\n            if (!this.engine.setUInt4(this._uniforms[uniformName], x, y, z, w)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned int array on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setUIntArray(uniformName: string, array: Uint32Array): void {\r\n        this._valueCache[uniformName] = null;\r\n        this.engine.setUIntArray(this._uniforms[uniformName], array);\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned int array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setUIntArray2(uniformName: string, array: Uint32Array): void {\r\n        this._valueCache[uniformName] = null;\r\n        this.engine.setUIntArray2(this._uniforms[uniformName], array);\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned int array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setUIntArray3(uniformName: string, array: Uint32Array): void {\r\n        this._valueCache[uniformName] = null;\r\n        this.engine.setUIntArray3(this._uniforms[uniformName], array);\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned int array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setUIntArray4(uniformName: string, array: Uint32Array): void {\r\n        this._valueCache[uniformName] = null;\r\n        this.engine.setUIntArray4(this._uniforms[uniformName], array);\r\n    }\r\n\r\n    /**\r\n     * Sets an array on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setArray(uniformName: string, array: number[]): void {\r\n        this._valueCache[uniformName] = null;\r\n        this.engine.setArray(this._uniforms[uniformName], array);\r\n    }\r\n\r\n    /**\r\n     * Sets an array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setArray2(uniformName: string, array: number[]): void {\r\n        this._valueCache[uniformName] = null;\r\n        this.engine.setArray2(this._uniforms[uniformName], array);\r\n    }\r\n\r\n    /**\r\n     * Sets an array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setArray3(uniformName: string, array: number[]): void {\r\n        this._valueCache[uniformName] = null;\r\n        this.engine.setArray3(this._uniforms[uniformName], array);\r\n    }\r\n\r\n    /**\r\n     * Sets an array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setArray4(uniformName: string, array: number[]): void {\r\n        this._valueCache[uniformName] = null;\r\n        this.engine.setArray4(this._uniforms[uniformName], array);\r\n    }\r\n\r\n    /**\r\n     * Sets matrices on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param matrices matrices to be set.\r\n     */\r\n    public setMatrices(uniformName: string, matrices: Float32Array): void {\r\n        if (!matrices) {\r\n            return;\r\n        }\r\n\r\n        this._valueCache[uniformName] = null;\r\n        this.engine.setMatrices(this._uniforms[uniformName], matrices);\r\n    }\r\n\r\n    /**\r\n     * Sets matrix on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param matrix matrix to be set.\r\n     */\r\n    public setMatrix(uniformName: string, matrix: IMatrixLike): void {\r\n        if (this._cacheMatrix(uniformName, matrix)) {\r\n            if (!this.engine.setMatrices(this._uniforms[uniformName], matrix.asArray())) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a 3x3 matrix on a uniform variable. (Specified as [1,2,3,4,5,6,7,8,9] will result in [1,2,3][4,5,6][7,8,9] matrix)\r\n     * @param uniformName Name of the variable.\r\n     * @param matrix matrix to be set.\r\n     */\r\n    public setMatrix3x3(uniformName: string, matrix: Float32Array): void {\r\n        this._valueCache[uniformName] = null;\r\n        this.engine.setMatrix3x3(this._uniforms[uniformName], matrix);\r\n    }\r\n\r\n    /**\r\n     * Sets a 2x2 matrix on a uniform variable. (Specified as [1,2,3,4] will result in [1,2][3,4] matrix)\r\n     * @param uniformName Name of the variable.\r\n     * @param matrix matrix to be set.\r\n     */\r\n    public setMatrix2x2(uniformName: string, matrix: Float32Array): void {\r\n        this._valueCache[uniformName] = null;\r\n        this.engine.setMatrix2x2(this._uniforms[uniformName], matrix);\r\n    }\r\n\r\n    /**\r\n     * Sets a float on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param value value to be set.\r\n     */\r\n    public setFloat(uniformName: string, value: number): void {\r\n        const cache = this._valueCache[uniformName];\r\n        if (cache !== undefined && cache === value) {\r\n            return;\r\n        }\r\n\r\n        if (this.engine.setFloat(this._uniforms[uniformName], value)) {\r\n            this._valueCache[uniformName] = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a Vector2 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param vector2 vector2 to be set.\r\n     */\r\n    public setVector2(uniformName: string, vector2: IVector2Like): void {\r\n        if (this._cacheFloat2(uniformName, vector2.x, vector2.y)) {\r\n            if (!this.engine.setFloat2(this._uniforms[uniformName], vector2.x, vector2.y)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a float2 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First float in float2.\r\n     * @param y Second float in float2.\r\n     */\r\n    public setFloat2(uniformName: string, x: number, y: number): void {\r\n        if (this._cacheFloat2(uniformName, x, y)) {\r\n            if (!this.engine.setFloat2(this._uniforms[uniformName], x, y)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a Vector3 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param vector3 Value to be set.\r\n     */\r\n    public setVector3(uniformName: string, vector3: IVector3Like): void {\r\n        if (this._cacheFloat3(uniformName, vector3.x, vector3.y, vector3.z)) {\r\n            if (!this.engine.setFloat3(this._uniforms[uniformName], vector3.x, vector3.y, vector3.z)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a float3 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First float in float3.\r\n     * @param y Second float in float3.\r\n     * @param z Third float in float3.\r\n     */\r\n    public setFloat3(uniformName: string, x: number, y: number, z: number): void {\r\n        if (this._cacheFloat3(uniformName, x, y, z)) {\r\n            if (!this.engine.setFloat3(this._uniforms[uniformName], x, y, z)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a Vector4 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param vector4 Value to be set.\r\n     */\r\n    public setVector4(uniformName: string, vector4: IVector4Like): void {\r\n        if (this._cacheFloat4(uniformName, vector4.x, vector4.y, vector4.z, vector4.w)) {\r\n            if (!this.engine.setFloat4(this._uniforms[uniformName], vector4.x, vector4.y, vector4.z, vector4.w)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a Quaternion on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param quaternion Value to be set.\r\n     */\r\n    public setQuaternion(uniformName: string, quaternion: IQuaternionLike): void {\r\n        if (this._cacheFloat4(uniformName, quaternion.x, quaternion.y, quaternion.z, quaternion.w)) {\r\n            if (!this.engine.setFloat4(this._uniforms[uniformName], quaternion.x, quaternion.y, quaternion.z, quaternion.w)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a float4 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First float in float4.\r\n     * @param y Second float in float4.\r\n     * @param z Third float in float4.\r\n     * @param w Fourth float in float4.\r\n     */\r\n    public setFloat4(uniformName: string, x: number, y: number, z: number, w: number): void {\r\n        if (this._cacheFloat4(uniformName, x, y, z, w)) {\r\n            if (!this.engine.setFloat4(this._uniforms[uniformName], x, y, z, w)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a Color3 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param color3 Value to be set.\r\n     */\r\n    public setColor3(uniformName: string, color3: IColor3Like): void {\r\n        if (this._cacheFloat3(uniformName, color3.r, color3.g, color3.b)) {\r\n            if (!this.engine.setFloat3(this._uniforms[uniformName], color3.r, color3.g, color3.b)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a Color4 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param color3 Value to be set.\r\n     * @param alpha Alpha value to be set.\r\n     */\r\n    public setColor4(uniformName: string, color3: IColor3Like, alpha: number): void {\r\n        if (this._cacheFloat4(uniformName, color3.r, color3.g, color3.b, alpha)) {\r\n            if (!this.engine.setFloat4(this._uniforms[uniformName], color3.r, color3.g, color3.b, alpha)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a Color4 on a uniform variable\r\n     * @param uniformName defines the name of the variable\r\n     * @param color4 defines the value to be set\r\n     */\r\n    public setDirectColor4(uniformName: string, color4: IColor4Like): void {\r\n        if (this._cacheFloat4(uniformName, color4.r, color4.g, color4.b, color4.a)) {\r\n            if (!this.engine.setFloat4(this._uniforms[uniformName], color4.r, color4.g, color4.b, color4.a)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    public _getVertexShaderCode(): string | null {\r\n        return this.vertexShader ? this.engine._getShaderSource(this.vertexShader) : null;\r\n    }\r\n\r\n    public _getFragmentShaderCode(): string | null {\r\n        return this.fragmentShader ? this.engine._getShaderSource(this.fragmentShader) : null;\r\n    }\r\n}\r\n", "import type { Nullable } from \"../types\";\r\nimport type { IPipelineContext } from \"./IPipelineContext\";\r\nimport type { ShaderProcessingContext } from \"./Processors/shaderProcessingOptions\";\r\nimport { WebGLPipelineContext } from \"./WebGL/webGLPipelineContext\";\r\nimport type { _loadFile } from \"./abstractEngine.functions\";\r\nimport { _ConcatenateShader } from \"./abstractEngine.functions\";\r\n\r\n/**\r\n * @internal\r\n */\r\nexport interface IThinEngineStateObject {\r\n    _contextWasLost?: boolean;\r\n    validateShaderPrograms?: boolean;\r\n    _webGLVersion: number;\r\n    parallelShaderCompile?: { COMPLETION_STATUS_KHR: number };\r\n    disableParallelShaderCompile?: boolean;\r\n    _context?: WebGLContext;\r\n    _createShaderProgramInjection?: typeof _createShaderProgram;\r\n    createRawShaderProgramInjection?: typeof createRawShaderProgram;\r\n    createShaderProgramInjection?: typeof createShaderProgram;\r\n    loadFileInjection?: typeof _loadFile;\r\n    cachedPipelines: { [name: string]: IPipelineContext };\r\n}\r\n/**\r\n * @internal\r\n */\r\nconst _stateObject: WeakMap<WebGLContext, IThinEngineStateObject> = new WeakMap();\r\n\r\n/**\r\n * This will be used in cases where the engine doesn't have a context (like the nullengine)\r\n */\r\nconst singleStateObject: IThinEngineStateObject = {\r\n    _webGLVersion: 2,\r\n    cachedPipelines: {},\r\n};\r\n\r\n/**\r\n * get or create a state object for the given context\r\n * Note - Used in WebGL only at the moment.\r\n * @param context The context to get the state object from\r\n * @returns the state object\r\n * @internal\r\n */\r\nexport function getStateObject(context: WebGLContext): IThinEngineStateObject {\r\n    let state = _stateObject.get(context);\r\n    if (!state) {\r\n        if (!context) {\r\n            return singleStateObject;\r\n        }\r\n        state = {\r\n            // use feature detection. instanceof returns false. This only exists on WebGL2 context\r\n            _webGLVersion: (context as WebGL2RenderingContext).TEXTURE_BINDING_3D ? 2 : 1,\r\n            _context: context,\r\n            // when using the function without an engine we need to set it to enable parallel compilation\r\n            parallelShaderCompile: context.getExtension(\"KHR_parallel_shader_compile\") || undefined,\r\n            cachedPipelines: {},\r\n        };\r\n        _stateObject.set(context, state);\r\n    }\r\n    return state;\r\n}\r\n/**\r\n * Remove the state object that belongs to the specific context\r\n * @param context the context that is being\r\n */\r\nexport function deleteStateObject(context: WebGLContext): void {\r\n    _stateObject.delete(context);\r\n}\r\n\r\nexport type WebGLContext = WebGLRenderingContext | WebGL2RenderingContext;\r\n/**\r\n * Directly creates a webGL program\r\n * @param pipelineContext  defines the pipeline context to attach to\r\n * @param vertexCode defines the vertex shader code to use\r\n * @param fragmentCode defines the fragment shader code to use\r\n * @param context defines the webGL context to use (if not set, the current one will be used)\r\n * @param transformFeedbackVaryings defines the list of transform feedback varyings to use\r\n * @param _createShaderProgramInjection defines an optional injection to use to create the shader program\r\n * @returns the new webGL program\r\n */\r\nexport function createRawShaderProgram(\r\n    pipelineContext: IPipelineContext,\r\n    vertexCode: string,\r\n    fragmentCode: string,\r\n    context: WebGLContext,\r\n    transformFeedbackVaryings: Nullable<string[]>,\r\n    _createShaderProgramInjection?: typeof _createShaderProgram\r\n): WebGLProgram {\r\n    const stateObject = getStateObject(context);\r\n    if (!_createShaderProgramInjection) {\r\n        _createShaderProgramInjection = stateObject._createShaderProgramInjection ?? _createShaderProgram;\r\n    }\r\n\r\n    const vertexShader = _compileRawShader(vertexCode, \"vertex\", context, stateObject._contextWasLost);\r\n    const fragmentShader = _compileRawShader(fragmentCode, \"fragment\", context, stateObject._contextWasLost);\r\n\r\n    return _createShaderProgramInjection(\r\n        pipelineContext as WebGLPipelineContext,\r\n        vertexShader,\r\n        fragmentShader,\r\n        context,\r\n        transformFeedbackVaryings,\r\n        stateObject.validateShaderPrograms\r\n    );\r\n}\r\n\r\n/**\r\n * Creates a webGL program\r\n * @param pipelineContext  defines the pipeline context to attach to\r\n * @param vertexCode  defines the vertex shader code to use\r\n * @param fragmentCode defines the fragment shader code to use\r\n * @param defines defines the string containing the defines to use to compile the shaders\r\n * @param context defines the webGL context to use (if not set, the current one will be used)\r\n * @param transformFeedbackVaryings defines the list of transform feedback varyings to use\r\n * @param _createShaderProgramInjection defines an optional injection to use to create the shader program\r\n * @returns the new webGL program\r\n */\r\nexport function createShaderProgram(\r\n    pipelineContext: IPipelineContext,\r\n    vertexCode: string,\r\n    fragmentCode: string,\r\n    defines: Nullable<string>,\r\n    context: WebGLContext,\r\n    transformFeedbackVaryings: Nullable<string[]> = null,\r\n    _createShaderProgramInjection?: typeof _createShaderProgram\r\n): WebGLProgram {\r\n    const stateObject = getStateObject(context);\r\n    if (!_createShaderProgramInjection) {\r\n        _createShaderProgramInjection = stateObject._createShaderProgramInjection ?? _createShaderProgram;\r\n    }\r\n    const shaderVersion = stateObject._webGLVersion > 1 ? \"#version 300 es\\n#define WEBGL2 \\n\" : \"\";\r\n    const vertexShader = _compileShader(vertexCode, \"vertex\", defines, shaderVersion, context, stateObject._contextWasLost);\r\n    const fragmentShader = _compileShader(fragmentCode, \"fragment\", defines, shaderVersion, context, stateObject._contextWasLost);\r\n\r\n    return _createShaderProgramInjection(\r\n        pipelineContext as WebGLPipelineContext,\r\n        vertexShader,\r\n        fragmentShader,\r\n        context,\r\n        transformFeedbackVaryings,\r\n        stateObject.validateShaderPrograms\r\n    );\r\n}\r\n\r\n/**\r\n * Creates a new pipeline context. Note, make sure to attach an engine instance to the created context\r\n * @param context defines the webGL context to use (if not set, the current one will be used)\r\n * @param _shaderProcessingContext defines the shader processing context used during the processing if available\r\n * @returns the new pipeline\r\n */\r\nexport function createPipelineContext(context: WebGLContext, _shaderProcessingContext: Nullable<ShaderProcessingContext>): IPipelineContext {\r\n    const pipelineContext = new WebGLPipelineContext();\r\n    const stateObject = getStateObject(context);\r\n    if (stateObject.parallelShaderCompile && !stateObject.disableParallelShaderCompile) {\r\n        pipelineContext.isParallelCompiled = true;\r\n    }\r\n    pipelineContext.context = stateObject._context;\r\n    return pipelineContext;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function _createShaderProgram(\r\n    pipelineContext: WebGLPipelineContext,\r\n    vertexShader: WebGLShader,\r\n    fragmentShader: WebGLShader,\r\n    context: WebGLContext,\r\n    _transformFeedbackVaryings: Nullable<string[]> = null,\r\n    validateShaderPrograms?: boolean\r\n): WebGLProgram {\r\n    const shaderProgram = context.createProgram();\r\n    pipelineContext.program = shaderProgram;\r\n\r\n    if (!shaderProgram) {\r\n        throw new Error(\"Unable to create program\");\r\n    }\r\n\r\n    context.attachShader(shaderProgram, vertexShader);\r\n    context.attachShader(shaderProgram, fragmentShader);\r\n\r\n    context.linkProgram(shaderProgram);\r\n\r\n    pipelineContext.context = context;\r\n    pipelineContext.vertexShader = vertexShader;\r\n    pipelineContext.fragmentShader = fragmentShader;\r\n\r\n    if (!pipelineContext.isParallelCompiled) {\r\n        _finalizePipelineContext(pipelineContext, context, validateShaderPrograms);\r\n    }\r\n\r\n    return shaderProgram;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function _isRenderingStateCompiled(pipelineContext: IPipelineContext, gl: WebGLContext, validateShaderPrograms?: boolean): boolean {\r\n    const webGLPipelineContext = pipelineContext as WebGLPipelineContext;\r\n    if (webGLPipelineContext._isDisposed) {\r\n        return false;\r\n    }\r\n    const stateObject = getStateObject(gl);\r\n    if (stateObject && stateObject.parallelShaderCompile && stateObject.parallelShaderCompile.COMPLETION_STATUS_KHR && webGLPipelineContext.program) {\r\n        if (gl.getProgramParameter(webGLPipelineContext.program, stateObject.parallelShaderCompile.COMPLETION_STATUS_KHR)) {\r\n            _finalizePipelineContext(webGLPipelineContext, gl, validateShaderPrograms);\r\n            return true;\r\n        }\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function _finalizePipelineContext(pipelineContext: WebGLPipelineContext, gl: WebGLContext, validateShaderPrograms?: boolean) {\r\n    const context = pipelineContext.context!;\r\n    const vertexShader = pipelineContext.vertexShader!;\r\n    const fragmentShader = pipelineContext.fragmentShader!;\r\n    const program = pipelineContext.program!;\r\n\r\n    const linked = context.getProgramParameter(program, context.LINK_STATUS);\r\n    if (!linked) {\r\n        // Get more info\r\n        // Vertex\r\n        if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {\r\n            const log = gl.getShaderInfoLog(vertexShader);\r\n            if (log) {\r\n                pipelineContext.vertexCompilationError = log;\r\n                throw new Error(\"VERTEX SHADER \" + log);\r\n            }\r\n        }\r\n\r\n        // Fragment\r\n        if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {\r\n            const log = gl.getShaderInfoLog(fragmentShader);\r\n            if (log) {\r\n                pipelineContext.fragmentCompilationError = log;\r\n                throw new Error(\"FRAGMENT SHADER \" + log);\r\n            }\r\n        }\r\n\r\n        const error = context.getProgramInfoLog(program);\r\n        if (error) {\r\n            pipelineContext.programLinkError = error;\r\n            throw new Error(error);\r\n        }\r\n    }\r\n\r\n    if (/*this.*/ validateShaderPrograms) {\r\n        context.validateProgram(program);\r\n        const validated = context.getProgramParameter(program, context.VALIDATE_STATUS);\r\n\r\n        if (!validated) {\r\n            const error = context.getProgramInfoLog(program);\r\n            if (error) {\r\n                pipelineContext.programValidationError = error;\r\n                throw new Error(error);\r\n            }\r\n        }\r\n    }\r\n\r\n    context.deleteShader(vertexShader);\r\n    context.deleteShader(fragmentShader);\r\n\r\n    pipelineContext.vertexShader = undefined;\r\n    pipelineContext.fragmentShader = undefined;\r\n\r\n    if (pipelineContext.onCompiled) {\r\n        pipelineContext.onCompiled();\r\n        pipelineContext.onCompiled = undefined;\r\n    }\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function _preparePipelineContext(\r\n    pipelineContext: IPipelineContext,\r\n    vertexSourceCode: string,\r\n    fragmentSourceCode: string,\r\n    createAsRaw: boolean,\r\n    _rawVertexSourceCode: string,\r\n    _rawFragmentSourceCode: string,\r\n    rebuildRebind: any,\r\n    defines: Nullable<string>,\r\n    transformFeedbackVaryings: Nullable<string[]>,\r\n    _key: string = \"\",\r\n    onReady: () => void,\r\n    createRawShaderProgramInjection?: typeof createRawShaderProgram,\r\n    createShaderProgramInjection?: typeof createShaderProgram\r\n) {\r\n    const stateObject = getStateObject((pipelineContext as WebGLPipelineContext).context!);\r\n    if (!createRawShaderProgramInjection) {\r\n        createRawShaderProgramInjection = stateObject.createRawShaderProgramInjection ?? createRawShaderProgram;\r\n    }\r\n    if (!createShaderProgramInjection) {\r\n        createShaderProgramInjection = stateObject.createShaderProgramInjection ?? createShaderProgram;\r\n    }\r\n    const webGLRenderingState = pipelineContext as WebGLPipelineContext;\r\n\r\n    if (createAsRaw) {\r\n        webGLRenderingState.program = createRawShaderProgramInjection(\r\n            webGLRenderingState,\r\n            vertexSourceCode,\r\n            fragmentSourceCode,\r\n            webGLRenderingState.context!,\r\n            transformFeedbackVaryings\r\n        );\r\n    } else {\r\n        webGLRenderingState.program = createShaderProgramInjection(\r\n            webGLRenderingState,\r\n            vertexSourceCode,\r\n            fragmentSourceCode,\r\n            defines,\r\n            webGLRenderingState.context!,\r\n            transformFeedbackVaryings\r\n        );\r\n    }\r\n    webGLRenderingState.program.__SPECTOR_rebuildProgram = rebuildRebind;\r\n\r\n    onReady();\r\n}\r\n\r\nfunction _compileShader(source: string, type: string, defines: Nullable<string>, shaderVersion: string, gl: WebGLContext, _contextWasLost?: boolean): WebGLShader {\r\n    return _compileRawShader(_ConcatenateShader(source, defines, shaderVersion), type, gl, _contextWasLost);\r\n}\r\n\r\nfunction _compileRawShader(source: string, type: string, gl: WebGLContext, _contextWasLost?: boolean): WebGLShader {\r\n    const shader = gl.createShader(type === \"vertex\" ? gl.VERTEX_SHADER : gl.FRAGMENT_SHADER);\r\n\r\n    if (!shader) {\r\n        let error: GLenum = gl.NO_ERROR;\r\n        let tempError: GLenum = gl.NO_ERROR;\r\n        while ((tempError = gl.getError()) !== gl.NO_ERROR) {\r\n            error = tempError;\r\n        }\r\n\r\n        throw new Error(\r\n            `Something went wrong while creating a gl ${type} shader object. gl error=${error}, gl isContextLost=${gl.isContextLost()}, _contextWasLost=${_contextWasLost}`\r\n        );\r\n    }\r\n\r\n    gl.shaderSource(shader, source);\r\n    gl.compileShader(shader);\r\n\r\n    return shader;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function _setProgram(program: WebGLProgram, gl: WebGLContext): void {\r\n    gl.useProgram(program);\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function _executeWhenRenderingStateIsCompiled(pipelineContext: IPipelineContext, action: (pipelineContext?: IPipelineContext) => void) {\r\n    const webGLPipelineContext = pipelineContext as WebGLPipelineContext;\r\n\r\n    if (!webGLPipelineContext.isParallelCompiled) {\r\n        action(pipelineContext);\r\n        return;\r\n    }\r\n\r\n    const oldHandler = webGLPipelineContext.onCompiled;\r\n\r\n    webGLPipelineContext.onCompiled = () => {\r\n        oldHandler?.();\r\n        action(pipelineContext);\r\n    };\r\n}\r\n", "import type { ProcessingOptions } from \"./shaderProcessingOptions\";\r\n\r\nconst defaultAttributeKeywordName = \"attribute\";\r\nconst defaultVaryingKeywordName = \"varying\";\r\n\r\n/** @internal */\r\nexport class ShaderCodeNode {\r\n    line: string;\r\n    children: ShaderCodeNode[] = [];\r\n    additionalDefineKey?: string;\r\n    additionalDefineValue?: string;\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    isValid(preprocessors: { [key: string]: string }): boolean {\r\n        return true;\r\n    }\r\n\r\n    process(preprocessors: { [key: string]: string }, options: ProcessingOptions): string {\r\n        let result = \"\";\r\n        if (this.line) {\r\n            let value: string = this.line;\r\n            const processor = options.processor;\r\n            if (processor) {\r\n                // This must be done before other replacements to avoid mistakenly changing something that was already changed.\r\n                if (processor.lineProcessor) {\r\n                    value = processor.lineProcessor(value, options.isFragment, options.processingContext);\r\n                }\r\n\r\n                const attributeKeyword = options.processor?.attributeKeywordName ?? defaultAttributeKeywordName;\r\n                const varyingKeyword =\r\n                    options.isFragment && options.processor?.varyingFragmentKeywordName\r\n                        ? options.processor?.varyingFragmentKeywordName\r\n                        : !options.isFragment && options.processor?.varyingVertexKeywordName\r\n                          ? options.processor?.varyingVertexKeywordName\r\n                          : defaultVaryingKeywordName;\r\n\r\n                if (!options.isFragment && processor.attributeProcessor && this.line.startsWith(attributeKeyword)) {\r\n                    value = processor.attributeProcessor(this.line, preprocessors, options.processingContext);\r\n                } else if (\r\n                    processor.varyingProcessor &&\r\n                    (processor.varyingCheck?.(this.line, options.isFragment) || (!processor.varyingCheck && this.line.startsWith(varyingKeyword)))\r\n                ) {\r\n                    value = processor.varyingProcessor(this.line, options.isFragment, preprocessors, options.processingContext);\r\n                } else if (processor.uniformProcessor && processor.uniformRegexp && processor.uniformRegexp.test(this.line)) {\r\n                    if (!options.lookForClosingBracketForUniformBuffer) {\r\n                        value = processor.uniformProcessor(this.line, options.isFragment, preprocessors, options.processingContext);\r\n                    }\r\n                } else if (processor.uniformBufferProcessor && processor.uniformBufferRegexp && processor.uniformBufferRegexp.test(this.line)) {\r\n                    if (!options.lookForClosingBracketForUniformBuffer) {\r\n                        value = processor.uniformBufferProcessor(this.line, options.isFragment, options.processingContext);\r\n                        options.lookForClosingBracketForUniformBuffer = true;\r\n                    }\r\n                } else if (processor.textureProcessor && processor.textureRegexp && processor.textureRegexp.test(this.line)) {\r\n                    value = processor.textureProcessor(this.line, options.isFragment, preprocessors, options.processingContext);\r\n                } else if ((processor.uniformProcessor || processor.uniformBufferProcessor) && this.line.startsWith(\"uniform\") && !options.lookForClosingBracketForUniformBuffer) {\r\n                    const regex = /uniform\\s+(?:(?:highp)?|(?:lowp)?)\\s*(\\S+)\\s+(\\S+)\\s*;/;\r\n\r\n                    if (regex.test(this.line)) {\r\n                        // uniform\r\n                        if (processor.uniformProcessor) {\r\n                            value = processor.uniformProcessor(this.line, options.isFragment, preprocessors, options.processingContext);\r\n                        }\r\n                    } else {\r\n                        // Uniform buffer\r\n                        if (processor.uniformBufferProcessor) {\r\n                            value = processor.uniformBufferProcessor(this.line, options.isFragment, options.processingContext);\r\n                            options.lookForClosingBracketForUniformBuffer = true;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (options.lookForClosingBracketForUniformBuffer && this.line.indexOf(\"}\") !== -1) {\r\n                    options.lookForClosingBracketForUniformBuffer = false;\r\n                    if (processor.endOfUniformBufferProcessor) {\r\n                        value = processor.endOfUniformBufferProcessor(this.line, options.isFragment, options.processingContext);\r\n                    }\r\n                }\r\n            }\r\n\r\n            result += value + \"\\n\";\r\n        }\r\n\r\n        this.children.forEach((child) => {\r\n            result += child.process(preprocessors, options);\r\n        });\r\n\r\n        if (this.additionalDefineKey) {\r\n            preprocessors[this.additionalDefineKey] = this.additionalDefineValue || \"true\";\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n", "/** @internal */\r\nexport class ShaderCodeCursor {\r\n    private _lines: string[] = [];\r\n    lineIndex: number;\r\n\r\n    get currentLine(): string {\r\n        return this._lines[this.lineIndex];\r\n    }\r\n\r\n    get canRead(): boolean {\r\n        return this.lineIndex < this._lines.length - 1;\r\n    }\r\n\r\n    set lines(value: string[]) {\r\n        this._lines.length = 0;\r\n\r\n        for (const line of value) {\r\n            // Skip empty lines\r\n            if (!line || line === \"\\r\") {\r\n                continue;\r\n            }\r\n\r\n            // Prevent removing line break in macros.\r\n            if (line[0] === \"#\") {\r\n                this._lines.push(line);\r\n                continue;\r\n            }\r\n\r\n            // Do not split single line comments\r\n            const trimmedLine = line.trim();\r\n\r\n            if (!trimmedLine) {\r\n                continue;\r\n            }\r\n\r\n            if (trimmedLine.startsWith(\"//\")) {\r\n                this._lines.push(line);\r\n                continue;\r\n            }\r\n\r\n            // Work with semicolon in the line\r\n            const semicolonIndex = trimmedLine.indexOf(\";\");\r\n\r\n            if (semicolonIndex === -1) {\r\n                // No semicolon in the line\r\n                this._lines.push(trimmedLine);\r\n            } else if (semicolonIndex === trimmedLine.length - 1) {\r\n                // Single semicolon at the end of the line\r\n                // If trimmedLine == \";\", we must not push, to be backward compatible with the old code!\r\n                if (trimmedLine.length > 1) {\r\n                    this._lines.push(trimmedLine);\r\n                }\r\n            } else {\r\n                // Semicolon in the middle of the line\r\n                const split = line.split(\";\");\r\n\r\n                for (let index = 0; index < split.length; index++) {\r\n                    let subLine = split[index];\r\n\r\n                    if (!subLine) {\r\n                        continue;\r\n                    }\r\n\r\n                    subLine = subLine.trim();\r\n\r\n                    if (!subLine) {\r\n                        continue;\r\n                    }\r\n\r\n                    this._lines.push(subLine + (index !== split.length - 1 ? \";\" : \"\"));\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n", "import { ShaderCodeNode } from \"./shaderCodeNode\";\r\nimport type { ProcessingOptions } from \"./shaderProcessingOptions\";\r\n\r\n/** @internal */\r\nexport class ShaderCodeConditionNode extends ShaderCodeNode {\r\n    override process(preprocessors: { [key: string]: string }, options: ProcessingOptions) {\r\n        for (let index = 0; index < this.children.length; index++) {\r\n            const node = this.children[index];\r\n\r\n            if (node.isValid(preprocessors)) {\r\n                return node.process(preprocessors, options);\r\n            }\r\n        }\r\n\r\n        return \"\";\r\n    }\r\n}\r\n", "import { ShaderCodeNode } from \"./shaderCodeNode\";\r\nimport type { ShaderDefineExpression } from \"./Expressions/shaderDefineExpression\";\r\n\r\n/** @internal */\r\nexport class ShaderCodeTestNode extends ShaderCodeNode {\r\n    public testExpression: ShaderDefineExpression;\r\n\r\n    public override isValid(preprocessors: { [key: string]: string }) {\r\n        return this.testExpression.isTrue(preprocessors);\r\n    }\r\n}\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\n/** @internal */\r\nexport class ShaderDefineExpression {\r\n    /**\r\n     * Cache items count limit for the InfixToPostfix cache.\r\n     * It uses to improve the performance of the shader compilation.\r\n     * For details see PR: https://github.com/BabylonJS/Babylon.js/pull/13936\r\n     */\r\n    static InfixToPostfixCacheLimitSize = 50000;\r\n\r\n    /**\r\n     * When the cache size is exceeded, a cache cleanup will be triggered\r\n     * and the cache will be reduced by the size specified\r\n     * in the InfixToPostfixCacheCleanupSize variable, removing entries\r\n     * that have not been accessed the longest.\r\n     */\r\n    static InfixToPostfixCacheCleanupSize = 25000;\r\n\r\n    protected static _InfixToPostfixCache: Map<\r\n        string,\r\n        {\r\n            accessTime: number;\r\n            result: string[];\r\n        }\r\n    > = new Map();\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public isTrue(preprocessors: { [key: string]: string }): boolean {\r\n        return true;\r\n    }\r\n\r\n    private static _OperatorPriority: { [name: string]: number } = {\r\n        \")\": 0,\r\n        \"(\": 1,\r\n        \"||\": 2,\r\n        \"&&\": 3,\r\n    };\r\n\r\n    private static _Stack = [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"];\r\n\r\n    public static postfixToInfix(postfix: string[]): string {\r\n        const stack: string[] = [];\r\n\r\n        for (const c of postfix) {\r\n            if (ShaderDefineExpression._OperatorPriority[c] === undefined) {\r\n                stack.push(c);\r\n            } else {\r\n                const v1 = stack[stack.length - 1],\r\n                    v2 = stack[stack.length - 2];\r\n\r\n                stack.length -= 2;\r\n                stack.push(`(${v2}${c}${v1})`);\r\n            }\r\n        }\r\n\r\n        return stack[stack.length - 1];\r\n    }\r\n\r\n    /**\r\n     * Converts an infix expression to a postfix expression.\r\n     *\r\n     * This method is used to transform infix expressions, which are more human-readable,\r\n     * into postfix expressions, also known as Reverse Polish Notation (RPN), that can be\r\n     * evaluated more efficiently by a computer. The conversion is based on the operator\r\n     * priority defined in _OperatorPriority.\r\n     *\r\n     * The function employs a stack-based algorithm for the conversion and caches the result\r\n     * to improve performance. The cache keeps track of each converted expression's access time\r\n     * to manage the cache size and optimize memory usage. When the cache size exceeds a specified\r\n     * limit, the least recently accessed items in the cache are deleted.\r\n     *\r\n     * The cache mechanism is particularly helpful for shader compilation, where the same infix\r\n     * expressions might be encountered repeatedly, hence the caching can speed up the process.\r\n     *\r\n     * @param infix - The infix expression to be converted.\r\n     * @returns The postfix expression as an array of strings.\r\n     */\r\n    public static infixToPostfix(infix: string): string[] {\r\n        // Is infix already in cache\r\n        const cacheItem = ShaderDefineExpression._InfixToPostfixCache.get(infix);\r\n        if (cacheItem) {\r\n            cacheItem.accessTime = Date.now();\r\n            return cacheItem.result;\r\n        }\r\n\r\n        // Is infix contain any operator\r\n        if (!infix.includes(\"&&\") && !infix.includes(\"||\") && !infix.includes(\")\") && !infix.includes(\"(\")) {\r\n            return [infix];\r\n        }\r\n\r\n        const result: string[] = [];\r\n\r\n        let stackIdx = -1;\r\n\r\n        const pushOperand = () => {\r\n            operand = operand.trim();\r\n            if (operand !== \"\") {\r\n                result.push(operand);\r\n                operand = \"\";\r\n            }\r\n        };\r\n\r\n        const push = (s: string) => {\r\n            if (stackIdx < ShaderDefineExpression._Stack.length - 1) {\r\n                ShaderDefineExpression._Stack[++stackIdx] = s;\r\n            }\r\n        };\r\n\r\n        const peek = () => ShaderDefineExpression._Stack[stackIdx];\r\n\r\n        const pop = () => (stackIdx === -1 ? \"!!INVALID EXPRESSION!!\" : ShaderDefineExpression._Stack[stackIdx--]);\r\n\r\n        let idx = 0,\r\n            operand = \"\";\r\n\r\n        while (idx < infix.length) {\r\n            const c = infix.charAt(idx),\r\n                token = idx < infix.length - 1 ? infix.substring(idx, 2 + idx) : \"\";\r\n\r\n            if (c === \"(\") {\r\n                operand = \"\";\r\n                push(c);\r\n            } else if (c === \")\") {\r\n                pushOperand();\r\n                while (stackIdx !== -1 && peek() !== \"(\") {\r\n                    result.push(pop());\r\n                }\r\n                pop();\r\n            } else if (ShaderDefineExpression._OperatorPriority[token] > 1) {\r\n                pushOperand();\r\n                while (stackIdx !== -1 && ShaderDefineExpression._OperatorPriority[peek()] >= ShaderDefineExpression._OperatorPriority[token]) {\r\n                    result.push(pop());\r\n                }\r\n                push(token);\r\n                idx++;\r\n            } else {\r\n                operand += c;\r\n            }\r\n            idx++;\r\n        }\r\n\r\n        pushOperand();\r\n\r\n        while (stackIdx !== -1) {\r\n            if (peek() === \"(\") {\r\n                pop();\r\n            } else {\r\n                result.push(pop());\r\n            }\r\n        }\r\n\r\n        // If the cache is at capacity, clear it before adding a new item\r\n        if (ShaderDefineExpression._InfixToPostfixCache.size >= ShaderDefineExpression.InfixToPostfixCacheLimitSize) {\r\n            ShaderDefineExpression.ClearCache();\r\n        }\r\n\r\n        // Add the new item to the cache, including the current time as the last access time\r\n        ShaderDefineExpression._InfixToPostfixCache.set(infix, { result, accessTime: Date.now() });\r\n\r\n        return result;\r\n    }\r\n\r\n    private static ClearCache(): void {\r\n        // Convert the cache to an array and sort by last access time\r\n        const sortedCache = Array.from(ShaderDefineExpression._InfixToPostfixCache.entries()).sort((a, b) => a[1].accessTime - b[1].accessTime);\r\n\r\n        // Remove the least recently accessed half of the cache\r\n        for (let i = 0; i < ShaderDefineExpression.InfixToPostfixCacheCleanupSize; i++) {\r\n            ShaderDefineExpression._InfixToPostfixCache.delete(sortedCache[i][0]);\r\n        }\r\n    }\r\n}\r\n", "import { ShaderDefineExpression } from \"../shaderDefineExpression\";\r\n\r\n/** @internal */\r\nexport class ShaderDefineIsDefinedOperator extends ShaderDefineExpression {\r\n    public constructor(\r\n        public define: string,\r\n        public not: boolean = false\r\n    ) {\r\n        super();\r\n    }\r\n\r\n    public override isTrue(preprocessors: { [key: string]: string }) {\r\n        let condition = preprocessors[this.define] !== undefined;\r\n\r\n        if (this.not) {\r\n            condition = !condition;\r\n        }\r\n\r\n        return condition;\r\n    }\r\n}\r\n", "import { ShaderDefineExpression } from \"../shaderDefineExpression\";\r\n\r\n/** @internal */\r\nexport class ShaderDefineOrOperator extends ShaderDefineExpression {\r\n    public leftOperand: ShaderDefineExpression;\r\n    public rightOperand: ShaderDefineExpression;\r\n\r\n    public override isTrue(preprocessors: { [key: string]: string }): boolean {\r\n        return this.leftOperand.isTrue(preprocessors) || this.rightOperand.isTrue(preprocessors);\r\n    }\r\n}\r\n", "import { ShaderDefineExpression } from \"../shaderDefineExpression\";\r\n\r\n/** @internal */\r\nexport class ShaderDefineAndOperator extends ShaderDefineExpression {\r\n    public leftOperand: ShaderDefineExpression;\r\n    public rightOperand: ShaderDefineExpression;\r\n\r\n    public override isTrue(preprocessors: { [key: string]: string }): boolean {\r\n        return this.leftOperand.isTrue(preprocessors) && this.rightOperand.isTrue(preprocessors);\r\n    }\r\n}\r\n", "import { ShaderDefineExpression } from \"../shaderDefineExpression\";\r\n\r\n/** @internal */\r\nexport class ShaderDefineArithmeticOperator extends ShaderDefineExpression {\r\n    public constructor(\r\n        public define: string,\r\n        public operand: string,\r\n        public testValue: string\r\n    ) {\r\n        super();\r\n    }\r\n\r\n    public override isTrue(preprocessors: { [key: string]: string }) {\r\n        let value = preprocessors[this.define];\r\n\r\n        if (value === undefined) {\r\n            value = this.define;\r\n        }\r\n\r\n        let condition = false;\r\n        const left = parseInt(value);\r\n        const right = parseInt(this.testValue);\r\n\r\n        switch (this.operand) {\r\n            case \">\":\r\n                condition = left > right;\r\n                break;\r\n            case \"<\":\r\n                condition = left < right;\r\n                break;\r\n            case \"<=\":\r\n                condition = left <= right;\r\n                break;\r\n            case \">=\":\r\n                condition = left >= right;\r\n                break;\r\n            case \"==\":\r\n                condition = left === right;\r\n                break;\r\n            case \"!=\":\r\n                condition = left !== right;\r\n                break;\r\n        }\r\n\r\n        return condition;\r\n    }\r\n}\r\n", "/* eslint-disable @typescript-eslint/no-unused-vars */\r\nimport { ShaderCodeNode } from \"./shaderCodeNode\";\r\nimport { ShaderCodeCursor } from \"./shaderCodeCursor\";\r\nimport { ShaderCodeConditionNode } from \"./shaderCodeConditionNode\";\r\nimport { ShaderCodeTestNode } from \"./shaderCodeTestNode\";\r\nimport { ShaderDefineIsDefinedOperator } from \"./Expressions/Operators/shaderDefineIsDefinedOperator\";\r\nimport { ShaderDefineOrOperator } from \"./Expressions/Operators/shaderDefineOrOperator\";\r\nimport { ShaderDefineAndOperator } from \"./Expressions/Operators/shaderDefineAndOperator\";\r\nimport { ShaderDefineExpression } from \"./Expressions/shaderDefineExpression\";\r\nimport { ShaderDefineArithmeticOperator } from \"./Expressions/Operators/shaderDefineArithmeticOperator\";\r\nimport type { ProcessingOptions } from \"./shaderProcessingOptions\";\r\nimport { _WarnImport } from \"../../Misc/devTools\";\r\nimport { ShaderLanguage } from \"../../Materials/shaderLanguage\";\r\n\r\nimport type { WebRequest } from \"../../Misc/webRequest\";\r\nimport type { LoadFileError } from \"../../Misc/fileTools\";\r\nimport type { IOfflineProvider } from \"../../Offline/IOfflineProvider\";\r\nimport type { IFileRequest } from \"../../Misc/fileRequest\";\r\nimport { _getGlobalDefines } from \"../abstractEngine.functions\";\r\nimport type { AbstractEngine } from \"../abstractEngine\";\r\n\r\nconst regexSE = /defined\\s*?\\((.+?)\\)/g;\r\nconst regexSERevert = /defined\\s*?\\[(.+?)\\]/g;\r\nconst regexShaderInclude = /#include\\s?<(.+)>(\\((.*)\\))*(\\[(.*)\\])*/g;\r\nconst regexShaderDecl = /__decl__/;\r\nconst regexLightX = /light\\{X\\}.(\\w*)/g;\r\nconst regexX = /\\{X\\}/g;\r\nconst reusableMatches: RegExpMatchArray[] = [];\r\n\r\nconst _MoveCursorRegex = /(#ifdef)|(#else)|(#elif)|(#endif)|(#ifndef)|(#if)/;\r\n\r\n/** @internal */\r\nexport function Initialize(options: ProcessingOptions): void {\r\n    if (options.processor && options.processor.initializeShaders) {\r\n        options.processor.initializeShaders(options.processingContext);\r\n    }\r\n}\r\n\r\n/** @internal */\r\nexport function Process(sourceCode: string, options: ProcessingOptions, callback: (migratedCode: string, codeBeforeMigration: string) => void, engine?: AbstractEngine) {\r\n    if (options.processor?.preProcessShaderCode) {\r\n        sourceCode = options.processor.preProcessShaderCode(sourceCode, options.isFragment);\r\n    }\r\n    _ProcessIncludes(sourceCode, options, (codeWithIncludes) => {\r\n        if (options.processCodeAfterIncludes) {\r\n            codeWithIncludes = options.processCodeAfterIncludes(options.isFragment ? \"fragment\" : \"vertex\", codeWithIncludes, options.defines);\r\n        }\r\n        const migratedCode = _ProcessShaderConversion(codeWithIncludes, options, engine);\r\n        callback(migratedCode, codeWithIncludes);\r\n    });\r\n}\r\n\r\n/** @internal */\r\nexport function PreProcess(sourceCode: string, options: ProcessingOptions, callback: (migratedCode: string, codeBeforeMigration: string) => void, engine: AbstractEngine) {\r\n    if (options.processor?.preProcessShaderCode) {\r\n        sourceCode = options.processor.preProcessShaderCode(sourceCode, options.isFragment);\r\n    }\r\n    _ProcessIncludes(sourceCode, options, (codeWithIncludes) => {\r\n        if (options.processCodeAfterIncludes) {\r\n            codeWithIncludes = options.processCodeAfterIncludes(options.isFragment ? \"fragment\" : \"vertex\", codeWithIncludes, options.defines);\r\n        }\r\n        const migratedCode = _ApplyPreProcessing(codeWithIncludes, options, engine);\r\n        callback(migratedCode, codeWithIncludes);\r\n    });\r\n}\r\n\r\n/** @internal */\r\nexport function Finalize(vertexCode: string, fragmentCode: string, options: ProcessingOptions): { vertexCode: string; fragmentCode: string } {\r\n    if (!options.processor || !options.processor.finalizeShaders) {\r\n        return { vertexCode, fragmentCode };\r\n    }\r\n\r\n    return options.processor.finalizeShaders(vertexCode, fragmentCode, options.processingContext);\r\n}\r\n\r\nfunction _ProcessPrecision(source: string, options: ProcessingOptions): string {\r\n    if (options.processor?.noPrecision) {\r\n        return source;\r\n    }\r\n\r\n    const shouldUseHighPrecisionShader = options.shouldUseHighPrecisionShader;\r\n\r\n    if (source.indexOf(\"precision highp float\") === -1) {\r\n        if (!shouldUseHighPrecisionShader) {\r\n            source = \"precision mediump float;\\n\" + source;\r\n        } else {\r\n            source = \"precision highp float;\\n\" + source;\r\n        }\r\n    } else {\r\n        if (!shouldUseHighPrecisionShader) {\r\n            // Moving highp to mediump\r\n            source = source.replace(\"precision highp float\", \"precision mediump float\");\r\n        }\r\n    }\r\n\r\n    return source;\r\n}\r\n\r\nfunction _ExtractOperation(expression: string) {\r\n    const regex = /defined\\((.+)\\)/;\r\n\r\n    const match = regex.exec(expression);\r\n\r\n    if (match && match.length) {\r\n        return new ShaderDefineIsDefinedOperator(match[1].trim(), expression[0] === \"!\");\r\n    }\r\n\r\n    const operators = [\"==\", \"!=\", \">=\", \"<=\", \"<\", \">\"];\r\n    let operator = \"\";\r\n    let indexOperator = 0;\r\n\r\n    for (operator of operators) {\r\n        indexOperator = expression.indexOf(operator);\r\n\r\n        if (indexOperator > -1) {\r\n            break;\r\n        }\r\n    }\r\n\r\n    if (indexOperator === -1) {\r\n        return new ShaderDefineIsDefinedOperator(expression);\r\n    }\r\n\r\n    const define = expression.substring(0, indexOperator).trim();\r\n    const value = expression.substring(indexOperator + operator.length).trim();\r\n\r\n    return new ShaderDefineArithmeticOperator(define, operator, value);\r\n}\r\n\r\nfunction _BuildSubExpression(expression: string): ShaderDefineExpression {\r\n    expression = expression.replace(regexSE, \"defined[$1]\");\r\n\r\n    const postfix = ShaderDefineExpression.infixToPostfix(expression);\r\n\r\n    const stack: (string | ShaderDefineExpression)[] = [];\r\n\r\n    for (const c of postfix) {\r\n        if (c !== \"||\" && c !== \"&&\") {\r\n            stack.push(c);\r\n        } else if (stack.length >= 2) {\r\n            let v1 = stack[stack.length - 1],\r\n                v2 = stack[stack.length - 2];\r\n\r\n            stack.length -= 2;\r\n\r\n            const operator = c == \"&&\" ? new ShaderDefineAndOperator() : new ShaderDefineOrOperator();\r\n\r\n            if (typeof v1 === \"string\") {\r\n                v1 = v1.replace(regexSERevert, \"defined($1)\");\r\n            }\r\n\r\n            if (typeof v2 === \"string\") {\r\n                v2 = v2.replace(regexSERevert, \"defined($1)\");\r\n            }\r\n\r\n            operator.leftOperand = typeof v2 === \"string\" ? _ExtractOperation(v2) : v2;\r\n            operator.rightOperand = typeof v1 === \"string\" ? _ExtractOperation(v1) : v1;\r\n\r\n            stack.push(operator);\r\n        }\r\n    }\r\n\r\n    let result = stack[stack.length - 1];\r\n\r\n    if (typeof result === \"string\") {\r\n        result = result.replace(regexSERevert, \"defined($1)\");\r\n    }\r\n\r\n    // note: stack.length !== 1 if there was an error in the parsing\r\n\r\n    return typeof result === \"string\" ? _ExtractOperation(result) : result;\r\n}\r\n\r\nfunction _BuildExpression(line: string, start: number): ShaderCodeTestNode {\r\n    const node = new ShaderCodeTestNode();\r\n    const command = line.substring(0, start);\r\n    let expression = line.substring(start);\r\n\r\n    expression = expression.substring(0, (expression.indexOf(\"//\") + 1 || expression.length + 1) - 1).trim();\r\n\r\n    if (command === \"#ifdef\") {\r\n        node.testExpression = new ShaderDefineIsDefinedOperator(expression);\r\n    } else if (command === \"#ifndef\") {\r\n        node.testExpression = new ShaderDefineIsDefinedOperator(expression, true);\r\n    } else {\r\n        node.testExpression = _BuildSubExpression(expression);\r\n    }\r\n\r\n    return node;\r\n}\r\n\r\nfunction _MoveCursorWithinIf(cursor: ShaderCodeCursor, rootNode: ShaderCodeConditionNode, ifNode: ShaderCodeNode) {\r\n    let line = cursor.currentLine;\r\n    while (_MoveCursor(cursor, ifNode)) {\r\n        line = cursor.currentLine;\r\n        const first5 = line.substring(0, 5).toLowerCase();\r\n\r\n        if (first5 === \"#else\") {\r\n            const elseNode = new ShaderCodeNode();\r\n            rootNode.children.push(elseNode);\r\n            _MoveCursor(cursor, elseNode);\r\n            return;\r\n        } else if (first5 === \"#elif\") {\r\n            const elifNode = _BuildExpression(line, 5);\r\n\r\n            rootNode.children.push(elifNode);\r\n            ifNode = elifNode;\r\n        }\r\n    }\r\n}\r\n\r\nfunction _MoveCursor(cursor: ShaderCodeCursor, rootNode: ShaderCodeNode): boolean {\r\n    while (cursor.canRead) {\r\n        cursor.lineIndex++;\r\n        const line = cursor.currentLine;\r\n\r\n        if (line.indexOf(\"#\") >= 0) {\r\n            const matches = _MoveCursorRegex.exec(line);\r\n\r\n            if (matches && matches.length) {\r\n                const keyword = matches[0];\r\n\r\n                switch (keyword) {\r\n                    case \"#ifdef\": {\r\n                        const newRootNode = new ShaderCodeConditionNode();\r\n                        rootNode.children.push(newRootNode);\r\n\r\n                        const ifNode = _BuildExpression(line, 6);\r\n                        newRootNode.children.push(ifNode);\r\n                        _MoveCursorWithinIf(cursor, newRootNode, ifNode);\r\n                        break;\r\n                    }\r\n                    case \"#else\":\r\n                    case \"#elif\":\r\n                        return true;\r\n                    case \"#endif\":\r\n                        return false;\r\n                    case \"#ifndef\": {\r\n                        const newRootNode = new ShaderCodeConditionNode();\r\n                        rootNode.children.push(newRootNode);\r\n\r\n                        const ifNode = _BuildExpression(line, 7);\r\n                        newRootNode.children.push(ifNode);\r\n                        _MoveCursorWithinIf(cursor, newRootNode, ifNode);\r\n                        break;\r\n                    }\r\n                    case \"#if\": {\r\n                        const newRootNode = new ShaderCodeConditionNode();\r\n                        const ifNode = _BuildExpression(line, 3);\r\n                        rootNode.children.push(newRootNode);\r\n\r\n                        newRootNode.children.push(ifNode);\r\n                        _MoveCursorWithinIf(cursor, newRootNode, ifNode);\r\n                        break;\r\n                    }\r\n                }\r\n                continue;\r\n            }\r\n        }\r\n\r\n        const newNode = new ShaderCodeNode();\r\n        newNode.line = line;\r\n        rootNode.children.push(newNode);\r\n\r\n        // Detect additional defines\r\n        if (line[0] === \"#\" && line[1] === \"d\") {\r\n            const split = line.replace(\";\", \"\").split(\" \");\r\n            newNode.additionalDefineKey = split[1];\r\n\r\n            if (split.length === 3) {\r\n                newNode.additionalDefineValue = split[2];\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\nfunction _EvaluatePreProcessors(sourceCode: string, preprocessors: { [key: string]: string }, options: ProcessingOptions): string {\r\n    const rootNode = new ShaderCodeNode();\r\n    const cursor = new ShaderCodeCursor();\r\n\r\n    cursor.lineIndex = -1;\r\n    cursor.lines = sourceCode.split(\"\\n\");\r\n\r\n    // Decompose (We keep it in 2 steps so it is easier to maintain and perf hit is insignificant)\r\n    _MoveCursor(cursor, rootNode);\r\n\r\n    // Recompose\r\n    return rootNode.process(preprocessors, options);\r\n}\r\n\r\nfunction _PreparePreProcessors(options: ProcessingOptions, engine?: AbstractEngine): { [key: string]: string } {\r\n    const defines = options.defines;\r\n    const preprocessors: { [key: string]: string } = {};\r\n\r\n    for (const define of defines) {\r\n        const keyValue = define.replace(\"#define\", \"\").replace(\";\", \"\").trim();\r\n        const split = keyValue.split(\" \");\r\n        preprocessors[split[0]] = split.length > 1 ? split[1] : \"\";\r\n    }\r\n\r\n    if (options.processor?.shaderLanguage === ShaderLanguage.GLSL) {\r\n        preprocessors[\"GL_ES\"] = \"true\";\r\n    }\r\n    preprocessors[\"__VERSION__\"] = options.version;\r\n    preprocessors[options.platformName] = \"true\";\r\n\r\n    _getGlobalDefines(preprocessors, engine?.isNDCHalfZRange, engine?.useReverseDepthBuffer, engine?.useExactSrgbConversions);\r\n\r\n    return preprocessors;\r\n}\r\n\r\nfunction _ProcessShaderConversion(sourceCode: string, options: ProcessingOptions, engine?: AbstractEngine): string {\r\n    let preparedSourceCode = _ProcessPrecision(sourceCode, options);\r\n\r\n    if (!options.processor) {\r\n        return preparedSourceCode;\r\n    }\r\n\r\n    // Already converted\r\n    if (options.processor.shaderLanguage === ShaderLanguage.GLSL && preparedSourceCode.indexOf(\"#version 3\") !== -1) {\r\n        preparedSourceCode = preparedSourceCode.replace(\"#version 300 es\", \"\");\r\n        if (!options.processor.parseGLES3) {\r\n            return preparedSourceCode;\r\n        }\r\n    }\r\n\r\n    const defines = options.defines;\r\n\r\n    const preprocessors = _PreparePreProcessors(options, engine);\r\n\r\n    // General pre processing\r\n    if (options.processor.preProcessor) {\r\n        preparedSourceCode = options.processor.preProcessor(preparedSourceCode, defines, preprocessors, options.isFragment, options.processingContext);\r\n    }\r\n\r\n    preparedSourceCode = _EvaluatePreProcessors(preparedSourceCode, preprocessors, options);\r\n\r\n    // Post processing\r\n    if (options.processor.postProcessor) {\r\n        preparedSourceCode = options.processor.postProcessor(\r\n            preparedSourceCode,\r\n            defines,\r\n            options.isFragment,\r\n            options.processingContext,\r\n            engine\r\n                ? {\r\n                      drawBuffersExtensionDisabled: engine.getCaps().drawBuffersExtension ? false : true,\r\n                  }\r\n                : {}\r\n        );\r\n    }\r\n\r\n    // Inline functions tagged with #define inline\r\n    if (engine?._features.needShaderCodeInlining) {\r\n        preparedSourceCode = engine.inlineShaderCode(preparedSourceCode);\r\n    }\r\n\r\n    return preparedSourceCode;\r\n}\r\n\r\nfunction _ApplyPreProcessing(sourceCode: string, options: ProcessingOptions, engine: AbstractEngine): string {\r\n    let preparedSourceCode = sourceCode;\r\n\r\n    const defines = options.defines;\r\n\r\n    const preprocessors = _PreparePreProcessors(options, engine);\r\n\r\n    // General pre processing\r\n    if (options.processor?.preProcessor) {\r\n        preparedSourceCode = options.processor.preProcessor(preparedSourceCode, defines, preprocessors, options.isFragment, options.processingContext);\r\n    }\r\n\r\n    preparedSourceCode = _EvaluatePreProcessors(preparedSourceCode, preprocessors, options);\r\n\r\n    // Post processing\r\n    if (options.processor?.postProcessor) {\r\n        preparedSourceCode = options.processor.postProcessor(\r\n            preparedSourceCode,\r\n            defines,\r\n            options.isFragment,\r\n            options.processingContext,\r\n            engine\r\n                ? {\r\n                      drawBuffersExtensionDisabled: engine.getCaps().drawBuffersExtension ? false : true,\r\n                  }\r\n                : {}\r\n        );\r\n    }\r\n\r\n    // Inline functions tagged with #define inline\r\n    if (engine._features.needShaderCodeInlining) {\r\n        preparedSourceCode = engine.inlineShaderCode(preparedSourceCode);\r\n    }\r\n\r\n    return preparedSourceCode;\r\n}\r\n\r\n/** @internal */\r\nexport function _ProcessIncludes(sourceCode: string, options: ProcessingOptions, callback: (data: any) => void): void {\r\n    reusableMatches.length = 0;\r\n    let match: RegExpMatchArray | null;\r\n    // stay back-compat to the old matchAll syntax\r\n    while ((match = regexShaderInclude.exec(sourceCode)) !== null) {\r\n        reusableMatches.push(match);\r\n    }\r\n\r\n    let returnValue = String(sourceCode);\r\n    let parts = [sourceCode];\r\n\r\n    let keepProcessing = false;\r\n\r\n    for (const match of reusableMatches) {\r\n        let includeFile = match[1];\r\n\r\n        // Uniform declaration\r\n        if (includeFile.indexOf(\"__decl__\") !== -1) {\r\n            includeFile = includeFile.replace(regexShaderDecl, \"\");\r\n            if (options.supportsUniformBuffers) {\r\n                includeFile = includeFile.replace(\"Vertex\", \"Ubo\").replace(\"Fragment\", \"Ubo\");\r\n            }\r\n            includeFile = includeFile + \"Declaration\";\r\n        }\r\n\r\n        if (options.includesShadersStore[includeFile]) {\r\n            // Substitution\r\n            let includeContent = options.includesShadersStore[includeFile];\r\n            if (match[2]) {\r\n                const splits = match[3].split(\",\");\r\n\r\n                for (let index = 0; index < splits.length; index += 2) {\r\n                    const source = new RegExp(splits[index], \"g\");\r\n                    const dest = splits[index + 1];\r\n\r\n                    includeContent = includeContent.replace(source, dest);\r\n                }\r\n            }\r\n\r\n            if (match[4]) {\r\n                const indexString = match[5];\r\n\r\n                if (indexString.indexOf(\"..\") !== -1) {\r\n                    const indexSplits = indexString.split(\"..\");\r\n                    const minIndex = parseInt(indexSplits[0]);\r\n                    let maxIndex = parseInt(indexSplits[1]);\r\n                    let sourceIncludeContent = includeContent.slice(0);\r\n                    includeContent = \"\";\r\n\r\n                    if (isNaN(maxIndex)) {\r\n                        maxIndex = options.indexParameters[indexSplits[1]];\r\n                    }\r\n\r\n                    for (let i = minIndex; i < maxIndex; i++) {\r\n                        if (!options.supportsUniformBuffers) {\r\n                            // Ubo replacement\r\n                            sourceIncludeContent = sourceIncludeContent.replace(regexLightX, (str: string, p1: string) => {\r\n                                return p1 + \"{X}\";\r\n                            });\r\n                        }\r\n                        includeContent += sourceIncludeContent.replace(regexX, i.toString()) + \"\\n\";\r\n                    }\r\n                } else {\r\n                    if (!options.supportsUniformBuffers) {\r\n                        // Ubo replacement\r\n                        includeContent = includeContent.replace(regexLightX, (str: string, p1: string) => {\r\n                            return p1 + \"{X}\";\r\n                        });\r\n                    }\r\n                    includeContent = includeContent.replace(regexX, indexString);\r\n                }\r\n            }\r\n\r\n            // Replace\r\n            // Split all parts on match[0] and intersperse the parts with the include content\r\n            const newParts = [];\r\n            for (const part of parts) {\r\n                const splitPart = part.split(match[0]);\r\n                for (let i = 0; i < splitPart.length - 1; i++) {\r\n                    newParts.push(splitPart[i]);\r\n                    newParts.push(includeContent);\r\n                }\r\n                newParts.push(splitPart[splitPart.length - 1]);\r\n            }\r\n            parts = newParts;\r\n\r\n            keepProcessing = keepProcessing || includeContent.indexOf(\"#include<\") >= 0 || includeContent.indexOf(\"#include <\") >= 0;\r\n        } else {\r\n            const includeShaderUrl = options.shadersRepository + \"ShadersInclude/\" + includeFile + \".fx\";\r\n\r\n            _functionContainer.loadFile(includeShaderUrl, (fileContent) => {\r\n                options.includesShadersStore[includeFile] = fileContent as string;\r\n                _ProcessIncludes(parts.join(\"\"), options, callback);\r\n            });\r\n            return;\r\n        }\r\n    }\r\n    reusableMatches.length = 0;\r\n\r\n    returnValue = parts.join(\"\");\r\n\r\n    if (keepProcessing) {\r\n        _ProcessIncludes(returnValue.toString(), options, callback);\r\n    } else {\r\n        callback(returnValue);\r\n    }\r\n}\r\n\r\n/** @internal */\r\nexport const _functionContainer = {\r\n    /**\r\n     * Loads a file from a url\r\n     * @param url url to load\r\n     * @param onSuccess callback called when the file successfully loads\r\n     * @param onProgress callback called while file is loading (if the server supports this mode)\r\n     * @param offlineProvider defines the offline provider for caching\r\n     * @param useArrayBuffer defines a boolean indicating that date must be returned as ArrayBuffer\r\n     * @param onError callback called when the file fails to load\r\n     * @returns a file request object\r\n     * @internal\r\n     */\r\n    loadFile: (\r\n        url: string,\r\n        onSuccess: (data: string | ArrayBuffer, responseURL?: string) => void,\r\n        onProgress?: (ev: ProgressEvent) => void,\r\n        offlineProvider?: IOfflineProvider,\r\n        useArrayBuffer?: boolean,\r\n        onError?: (request?: WebRequest, exception?: LoadFileError) => void\r\n    ): IFileRequest => {\r\n        throw _WarnImport(\"FileTools\");\r\n    },\r\n};\r\n", "import type { ProcessingOptions, ShaderCustomProcessingFunction, ShaderProcessingContext } from \"core/Engines/Processors/shaderProcessingOptions\";\r\nimport { GetDOMTextContent, IsWindowObjectExist } from \"core/Misc/domManagement\";\r\nimport type { Nullable } from \"core/types\";\r\nimport { ShaderLanguage } from \"./shaderLanguage\";\r\nimport type { WebGLContext } from \"core/Engines/thinEngine.functions\";\r\nimport { getStateObject } from \"core/Engines/thinEngine.functions\";\r\nimport { ShaderStore } from \"core/Engines/shaderStore\";\r\nimport type { AbstractEngine } from \"core/Engines/abstractEngine\";\r\nimport type { Effect, IShaderPath } from \"./effect\";\r\nimport type { IPipelineContext } from \"core/Engines/IPipelineContext\";\r\nimport { Logger } from \"core/Misc/logger\";\r\nimport { Finalize, Initialize, Process } from \"core/Engines/Processors/shaderProcessor\";\r\nimport { _loadFile } from \"core/Engines/abstractEngine.functions\";\r\nimport type { WebGLPipelineContext } from \"core/Engines/WebGL/webGLPipelineContext\";\r\n\r\n/**\r\n * Options to be used when creating a pipeline\r\n */\r\nexport interface IPipelineGenerationOptions {\r\n    /**\r\n     * The definition of the shader content.\r\n     * Can be either a unified name, name per vertex and frament or the shader code content itself\r\n     */\r\n    shaderNameOrContent: string | IShaderPath;\r\n    /**\r\n     * Unique key to identify the pipeline.\r\n     * Note that though not mandatory, it's recommended to provide a key to be able to use the automated pipeline loading system.\r\n     */\r\n    key?: string;\r\n    /**\r\n     * The list of defines to be used in the shader\r\n     */\r\n    defines?: string[];\r\n\r\n    /**\r\n     * If true, the global defines will be added to the defines array\r\n     */\r\n    addGlobalDefines?: boolean;\r\n    /**\r\n     * The shader language.\r\n     * Defaults to the language suiting the platform name (GLSL for WEBGL2, WGSL for WEBGPU)\r\n     */\r\n    shaderLanguage?: ShaderLanguage;\r\n\r\n    /**\r\n     * The name of the platform to be used when processing the shader\r\n     * defaults to WEBGL2\r\n     */\r\n    platformName?: string /* \"WEBGL2\" | \"WEBGL1\" | \"WEBGPU\" */;\r\n\r\n    /**\r\n     * extend the processing options when running code processing\r\n     */\r\n    extendedProcessingOptions?: Partial<ProcessingOptions>;\r\n\r\n    /**\r\n     * extend the pipeline generation options\r\n     */\r\n    extendedCreatePipelineOptions?: Partial<ICreateAndPreparePipelineContextOptions>;\r\n\r\n    /**\r\n     * If true, generating a new pipeline will return when the pipeline is ready to be used\r\n     */\r\n    waitForIsReady?: boolean;\r\n\r\n    /**\r\n     * If true, the pipeline will be created synchronously, even if parallel shader compilation is available\r\n     */\r\n    disableParallelCompilation?: boolean;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport interface ICreateAndPreparePipelineContextOptions {\r\n    parallelShaderCompile?: { COMPLETION_STATUS_KHR: number };\r\n    shaderProcessingContext: Nullable<ShaderProcessingContext>;\r\n    existingPipelineContext?: Nullable<IPipelineContext>;\r\n    name?: string;\r\n    rebuildRebind?: (vertexSourceCode: string, fragmentSourceCode: string, onCompiled: (pipelineContext: IPipelineContext) => void, onError: (message: string) => void) => void;\r\n    onRenderingStateCompiled?: (pipelineContext?: IPipelineContext) => void;\r\n    context?: WebGL2RenderingContext | WebGLRenderingContext;\r\n    // preparePipeline options\r\n    createAsRaw?: boolean;\r\n    vertex: string;\r\n    fragment: string;\r\n    defines: Nullable<string>;\r\n    transformFeedbackVaryings: Nullable<string[]>;\r\n    disableParallelCompilation?: boolean;\r\n}\r\n\r\n/**\r\n * Get a cached pipeline context\r\n * @param name the pipeline name\r\n * @param context the context to be used when creating the pipeline\r\n * @returns the cached pipeline context if it exists\r\n * @internal\r\n */\r\nexport function getCachedPipeline(name: string, context: WebGLContext): IPipelineContext | undefined {\r\n    const stateObject = getStateObject(context);\r\n    return stateObject.cachedPipelines[name];\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function resetCachedPipeline(pipeline: IPipelineContext): void {\r\n    const name = pipeline._name;\r\n    const context = (pipeline as WebGLPipelineContext).context;\r\n    if (name && context) {\r\n        const stateObject = getStateObject(context!);\r\n        const cachedPipeline = stateObject.cachedPipelines[name];\r\n        cachedPipeline?.dispose();\r\n        delete stateObject.cachedPipelines[name];\r\n    }\r\n}\r\n\r\n/** @internal */\r\nexport function _processShaderCode(\r\n    processorOptions: ProcessingOptions,\r\n    baseName: any,\r\n    processFinalCode?: Nullable<ShaderCustomProcessingFunction>,\r\n    onFinalCodeReady?: (vertexCode: string, fragmentCode: string) => void,\r\n    shaderLanguage?: ShaderLanguage,\r\n    engine?: AbstractEngine,\r\n    effectContext?: Effect\r\n) {\r\n    let vertexSource: string | HTMLElement | IShaderPath;\r\n    let fragmentSource: string | HTMLElement | IShaderPath;\r\n\r\n    // const baseName = this.name;\r\n    const hostDocument = IsWindowObjectExist() ? engine?.getHostDocument() : null;\r\n\r\n    if (typeof baseName === \"string\") {\r\n        vertexSource = baseName;\r\n    } else if (baseName.vertexSource) {\r\n        vertexSource = \"source:\" + baseName.vertexSource;\r\n    } else if (baseName.vertexElement) {\r\n        vertexSource = hostDocument?.getElementById(baseName.vertexElement) || baseName.vertexElement;\r\n    } else {\r\n        vertexSource = baseName.vertex || baseName;\r\n    }\r\n    if (typeof baseName === \"string\") {\r\n        fragmentSource = baseName;\r\n    } else if (baseName.fragmentSource) {\r\n        fragmentSource = \"source:\" + baseName.fragmentSource;\r\n    } else if (baseName.fragmentElement) {\r\n        fragmentSource = hostDocument?.getElementById(baseName.fragmentElement) || baseName.fragmentElement;\r\n    } else {\r\n        fragmentSource = baseName.fragment || baseName;\r\n    }\r\n\r\n    const shaderCodes: [string | undefined, string | undefined] = [undefined, undefined];\r\n    const shadersLoaded = () => {\r\n        if (shaderCodes[0] && shaderCodes[1]) {\r\n            processorOptions.isFragment = true;\r\n            const [migratedVertexCode, fragmentCode] = shaderCodes;\r\n            Process(\r\n                fragmentCode,\r\n                processorOptions,\r\n                (migratedFragmentCode, codeBeforeMigration) => {\r\n                    if (effectContext) {\r\n                        effectContext._fragmentSourceCodeBeforeMigration = codeBeforeMigration;\r\n                    }\r\n                    if (processFinalCode) {\r\n                        migratedFragmentCode = processFinalCode(\"fragment\", migratedFragmentCode);\r\n                    }\r\n                    const finalShaders = Finalize(migratedVertexCode, migratedFragmentCode, processorOptions);\r\n                    processorOptions = null as any;\r\n                    const finalCode = _useFinalCode(finalShaders.vertexCode, finalShaders.fragmentCode, baseName, shaderLanguage);\r\n                    onFinalCodeReady?.(finalCode.vertexSourceCode, finalCode.fragmentSourceCode);\r\n                },\r\n                engine\r\n            );\r\n        }\r\n    };\r\n    _loadShader(\r\n        vertexSource,\r\n        \"Vertex\",\r\n        \"\",\r\n        (vertexCode) => {\r\n            Initialize(processorOptions);\r\n            Process(\r\n                vertexCode,\r\n                processorOptions,\r\n                (migratedVertexCode, codeBeforeMigration) => {\r\n                    if (effectContext) {\r\n                        effectContext._rawVertexSourceCode = vertexCode;\r\n                        effectContext._vertexSourceCodeBeforeMigration = codeBeforeMigration;\r\n                    }\r\n                    if (processFinalCode) {\r\n                        migratedVertexCode = processFinalCode(\"vertex\", migratedVertexCode);\r\n                    }\r\n                    shaderCodes[0] = migratedVertexCode;\r\n                    shadersLoaded();\r\n                },\r\n                engine\r\n            );\r\n        },\r\n        shaderLanguage\r\n    );\r\n    _loadShader(\r\n        fragmentSource,\r\n        \"Fragment\",\r\n        \"Pixel\",\r\n        (fragmentCode) => {\r\n            if (effectContext) {\r\n                effectContext._rawFragmentSourceCode = fragmentCode;\r\n            }\r\n            shaderCodes[1] = fragmentCode;\r\n            shadersLoaded();\r\n        },\r\n        shaderLanguage\r\n    );\r\n}\r\n\r\nfunction _loadShader(shader: any, key: string, optionalKey: string, callback: (data: any) => void, shaderLanguage?: ShaderLanguage, _loadFileInjection?: typeof _loadFile) {\r\n    if (typeof HTMLElement !== \"undefined\") {\r\n        // DOM element ?\r\n        if (shader instanceof HTMLElement) {\r\n            const shaderCode = GetDOMTextContent(shader);\r\n            callback(shaderCode);\r\n            return;\r\n        }\r\n    }\r\n\r\n    // Direct source ?\r\n    if (shader.substring(0, 7) === \"source:\") {\r\n        callback(shader.substring(7));\r\n        return;\r\n    }\r\n\r\n    // Base64 encoded ?\r\n    if (shader.substring(0, 7) === \"base64:\") {\r\n        const shaderBinary = window.atob(shader.substring(7));\r\n        callback(shaderBinary);\r\n        return;\r\n    }\r\n\r\n    const shaderStore = ShaderStore.GetShadersStore(shaderLanguage);\r\n\r\n    // Is in local store ?\r\n    if (shaderStore[shader + key + \"Shader\"]) {\r\n        callback(shaderStore[shader + key + \"Shader\"]);\r\n        return;\r\n    }\r\n\r\n    if (optionalKey && shaderStore[shader + optionalKey + \"Shader\"]) {\r\n        callback(shaderStore[shader + optionalKey + \"Shader\"]);\r\n        return;\r\n    }\r\n\r\n    let shaderUrl;\r\n\r\n    if (shader[0] === \".\" || shader[0] === \"/\" || shader.indexOf(\"http\") > -1) {\r\n        shaderUrl = shader;\r\n    } else {\r\n        shaderUrl = ShaderStore.GetShadersRepository(shaderLanguage) + shader;\r\n    }\r\n    _loadFileInjection = _loadFileInjection || _loadFile;\r\n    if (!_loadFileInjection) {\r\n        // we got to this point and loadFile was not injected - throw an error\r\n        throw new Error(\"loadFileInjection is not defined\");\r\n    }\r\n    // Vertex shader\r\n    _loadFileInjection(shaderUrl + \".\" + key.toLowerCase() + \".fx\", callback);\r\n}\r\n\r\nfunction _useFinalCode(migratedVertexCode: string, migratedFragmentCode: string, baseName: any, shaderLanguage?: ShaderLanguage) {\r\n    if (baseName) {\r\n        const vertex = baseName.vertexElement || baseName.vertex || baseName.spectorName || baseName;\r\n        const fragment = baseName.fragmentElement || baseName.fragment || baseName.spectorName || baseName;\r\n\r\n        return {\r\n            vertexSourceCode: (shaderLanguage === ShaderLanguage.WGSL ? \"//\" : \"\") + \"#define SHADER_NAME vertex:\" + vertex + \"\\n\" + migratedVertexCode,\r\n            fragmentSourceCode: (shaderLanguage === ShaderLanguage.WGSL ? \"//\" : \"\") + \"#define SHADER_NAME fragment:\" + fragment + \"\\n\" + migratedFragmentCode,\r\n        };\r\n    } else {\r\n        return {\r\n            vertexSourceCode: migratedVertexCode,\r\n            fragmentSourceCode: migratedFragmentCode,\r\n        };\r\n    }\r\n}\r\n\r\n/**\r\n * Creates and prepares a pipeline context\r\n * @internal\r\n */\r\nexport const createAndPreparePipelineContext = (\r\n    options: ICreateAndPreparePipelineContextOptions,\r\n    createPipelineContext: typeof AbstractEngine.prototype.createPipelineContext,\r\n    _preparePipelineContext: typeof AbstractEngine.prototype._preparePipelineContext,\r\n    _executeWhenRenderingStateIsCompiled: typeof AbstractEngine.prototype._executeWhenRenderingStateIsCompiled\r\n): IPipelineContext => {\r\n    try {\r\n        const stateObject = options.context ? getStateObject(options.context) : null;\r\n        if (stateObject) {\r\n            // will not remove the reference to parallelShaderPrecompile, but will prevent it from being used in the next shader compilation\r\n            stateObject.disableParallelShaderCompile = options.disableParallelCompilation;\r\n        }\r\n        const pipelineContext: IPipelineContext = options.existingPipelineContext || createPipelineContext(options.shaderProcessingContext);\r\n        pipelineContext._name = options.name;\r\n        if (options.name && stateObject) {\r\n            stateObject.cachedPipelines[options.name] = pipelineContext;\r\n        }\r\n\r\n        // Flagged as async as we may need to delay load some processing tools\r\n        // This does not break anything as the execution is waiting for _executeWhenRenderingStateIsCompiled\r\n        _preparePipelineContext(\r\n            pipelineContext,\r\n            options.vertex,\r\n            options.fragment,\r\n            !!options.createAsRaw,\r\n            \"\",\r\n            \"\",\r\n            options.rebuildRebind,\r\n            options.defines,\r\n            options.transformFeedbackVaryings,\r\n            \"\",\r\n            () => {\r\n                _executeWhenRenderingStateIsCompiled(pipelineContext, () => {\r\n                    options.onRenderingStateCompiled?.(pipelineContext);\r\n                });\r\n            }\r\n        );\r\n\r\n        return pipelineContext;\r\n    } catch (e) {\r\n        Logger.Error(\"Error compiling effect\");\r\n        throw e;\r\n    }\r\n};\r\n", "import { Observable } from \"../Misc/observable\";\r\nimport type { FloatArray, Nullable } from \"../types\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport type { IDisposable } from \"../scene\";\r\nimport type { IPipelineContext } from \"../Engines/IPipelineContext\";\r\nimport type { DataBuffer } from \"../Buffers/dataBuffer\";\r\nimport type { IShaderProcessor } from \"../Engines/Processors/iShaderProcessor\";\r\nimport type { ProcessingOptions, ShaderCustomProcessingFunction, ShaderProcessingContext } from \"../Engines/Processors/shaderProcessingOptions\";\r\nimport type { IMatrixLike, IVector2Like, IVector3Like, IVector4Like, IColor3Like, IColor4Like, IQuaternionLike } from \"../Maths/math.like\";\r\nimport type { AbstractEngine } from \"../Engines/abstractEngine\";\r\nimport type { IEffectFallbacks } from \"./iEffectFallbacks\";\r\nimport { ShaderStore as EngineShaderStore } from \"../Engines/shaderStore\";\r\nimport { ShaderLanguage } from \"./shaderLanguage\";\r\nimport type { InternalTexture } from \"../Materials/Textures/internalTexture\";\r\nimport type { ThinTexture } from \"../Materials/Textures/thinTexture\";\r\nimport type { IPipelineGenerationOptions } from \"./effect.functions\";\r\nimport { _processShaderCode, getCachedPipeline, createAndPreparePipelineContext, resetCachedPipeline } from \"./effect.functions\";\r\nimport { _retryWithInterval } from \"core/Misc/timingTools\";\r\n\r\n/**\r\n * Defines the route to the shader code. The priority is as follows:\r\n *  * object: `{ vertexSource: \"vertex shader code string\", fragmentSource: \"fragment shader code string\" }` for directly passing the shader code\r\n *  * object: `{ vertexElement: \"vertexShaderCode\", fragmentElement: \"fragmentShaderCode\" }`, used with shader code in script tags\r\n *  * object: `{ vertex: \"custom\", fragment: \"custom\" }`, used with `Effect.ShadersStore[\"customVertexShader\"]` and `Effect.ShadersStore[\"customFragmentShader\"]`\r\n *  * string: `\"./COMMON_NAME\"`, used with external files COMMON_NAME.vertex.fx and COMMON_NAME.fragment.fx in index.html folder.\r\n */\r\nexport type IShaderPath = {\r\n    /**\r\n     * Directly pass the shader code\r\n     */\r\n    vertexSource?: string;\r\n    /**\r\n     * Directly pass the shader code\r\n     */\r\n    fragmentSource?: string;\r\n    /**\r\n     * Used with Effect.ShadersStore. If the `vertex` is set to `\"custom`, then\r\n     * Babylon.js will read from Effect.ShadersStore[\"customVertexShader\"]\r\n     */\r\n    vertex?: string;\r\n    /**\r\n     * Used with Effect.ShadersStore. If the `fragment` is set to `\"custom`, then\r\n     * Babylon.js will read from Effect.ShadersStore[\"customFragmentShader\"]\r\n     */\r\n    fragment?: string;\r\n    /**\r\n     * Used with shader code in script tags\r\n     */\r\n    vertexElement?: string;\r\n    /**\r\n     * Used with shader code in script tags\r\n     */\r\n    fragmentElement?: string;\r\n    /**\r\n     * Defines the name appearing in spector when framgent/vertex...source are being used\r\n     */\r\n    spectorName?: string;\r\n};\r\n\r\n/**\r\n * Options to be used when creating an effect.\r\n */\r\nexport interface IEffectCreationOptions {\r\n    /**\r\n     * Attributes that will be used in the shader.\r\n     */\r\n    attributes: string[];\r\n    /**\r\n     * Uniform variable names that will be set in the shader.\r\n     */\r\n    uniformsNames: string[];\r\n    /**\r\n     * Uniform buffer variable names that will be set in the shader.\r\n     */\r\n    uniformBuffersNames?: string[];\r\n    /**\r\n     * Sampler texture variable names that will be set in the shader.\r\n     */\r\n    samplers: string[];\r\n    /**\r\n     * Define statements that will be set in the shader.\r\n     */\r\n    defines: any;\r\n    /**\r\n     * Possible fallbacks for this effect to improve performance when needed.\r\n     */\r\n    fallbacks: Nullable<IEffectFallbacks>;\r\n    /**\r\n     * Callback that will be called when the shader is compiled.\r\n     */\r\n    onCompiled: Nullable<(effect: Effect) => void>;\r\n    /**\r\n     * Callback that will be called if an error occurs during shader compilation.\r\n     */\r\n    onError: Nullable<(effect: Effect, errors: string) => void>;\r\n    /**\r\n     * Parameters to be used with Babylons include syntax to iterate over an array (eg. \\{lights: 10\\})\r\n     */\r\n    indexParameters?: any;\r\n    /**\r\n     * Max number of lights that can be used in the shader.\r\n     */\r\n    maxSimultaneousLights?: number;\r\n    /**\r\n     * See https://developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext/transformFeedbackVaryings\r\n     */\r\n    transformFeedbackVaryings?: Nullable<string[]>;\r\n    /**\r\n     * If provided, will be called two times with the vertex and fragment code so that this code can be updated before it is compiled by the GPU\r\n     */\r\n    processFinalCode?: Nullable<ShaderCustomProcessingFunction>;\r\n    /**\r\n     * If provided, will be called two times with the vertex and fragment code so that this code can be updated after the #include have been processed\r\n     */\r\n    processCodeAfterIncludes?: Nullable<ShaderCustomProcessingFunction>;\r\n    /**\r\n     * Is this effect rendering to several color attachments ?\r\n     */\r\n    multiTarget?: boolean;\r\n    /**\r\n     * The language the shader is written in (default: GLSL)\r\n     */\r\n    shaderLanguage?: ShaderLanguage;\r\n\r\n    /**\r\n     * Provide an existing pipeline context to avoid creating a new one\r\n     */\r\n    existingPipelineContext?: IPipelineContext;\r\n    /**\r\n     * Additional async code to run before preparing the effect\r\n     */\r\n    extraInitializationsAsync?: () => Promise<void>;\r\n\r\n    /**\r\n     * If set to true the shader will not be compiles asynchronously, even if the engine allows it.\r\n     */\r\n    disableParallelShaderCompilation?: boolean;\r\n}\r\n\r\n/**\r\n * Effect containing vertex and fragment shader that can be executed on an object.\r\n */\r\nexport class Effect implements IDisposable {\r\n    /**\r\n     * Gets or sets the relative url used to load shaders if using the engine in non-minified mode\r\n     */\r\n    public static get ShadersRepository(): string {\r\n        return EngineShaderStore.ShadersRepository;\r\n    }\r\n    public static set ShadersRepository(repo: string) {\r\n        EngineShaderStore.ShadersRepository = repo;\r\n    }\r\n    /**\r\n     * Enable logging of the shader code when a compilation error occurs\r\n     */\r\n    public static LogShaderCodeOnCompilationError = true;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that effect ref counting is disabled\r\n     * If true, the effect will persist in memory until engine is disposed\r\n     */\r\n    public static PersistentMode: boolean = false;\r\n\r\n    /**\r\n     * Use this with caution\r\n     * See ClearCodeCache function comments\r\n     */\r\n    public static AutomaticallyClearCodeCache = false;\r\n\r\n    /**\r\n     * Name of the effect.\r\n     */\r\n    public name: IShaderPath | string;\r\n    /**\r\n     * String container all the define statements that should be set on the shader.\r\n     */\r\n    public defines: string = \"\";\r\n    /**\r\n     * Callback that will be called when the shader is compiled.\r\n     */\r\n    public onCompiled: Nullable<(effect: Effect) => void> = null;\r\n    /**\r\n     * Callback that will be called if an error occurs during shader compilation.\r\n     */\r\n    public onError: Nullable<(effect: Effect, errors: string) => void> = null;\r\n    /**\r\n     * Callback that will be called when effect is bound.\r\n     */\r\n    public onBind: Nullable<(effect: Effect) => void> = null;\r\n    /**\r\n     * Unique ID of the effect.\r\n     */\r\n    public uniqueId = 0;\r\n    /**\r\n     * Observable that will be called when the shader is compiled.\r\n     * It is recommended to use executeWhenCompile() or to make sure that scene.isReady() is called to get this observable raised.\r\n     */\r\n    public onCompileObservable = new Observable<Effect>();\r\n    /**\r\n     * Observable that will be called if an error occurs during shader compilation.\r\n     */\r\n    public onErrorObservable = new Observable<Effect>();\r\n\r\n    /** @internal */\r\n    public _onBindObservable: Nullable<Observable<Effect>> = null;\r\n\r\n    private _isDisposed = false;\r\n\r\n    /**\r\n     * Gets a boolean indicating that the effect was already disposed\r\n     */\r\n    public get isDisposed(): boolean {\r\n        return this._isDisposed;\r\n    }\r\n\r\n    /** @internal */\r\n    public _refCount = 1;\r\n\r\n    /**\r\n     * Observable that will be called when effect is bound.\r\n     */\r\n    public get onBindObservable(): Observable<Effect> {\r\n        if (!this._onBindObservable) {\r\n            this._onBindObservable = new Observable<Effect>();\r\n        }\r\n\r\n        return this._onBindObservable;\r\n    }\r\n\r\n    /** @internal */\r\n    public _bonesComputationForcedToCPU = false;\r\n    /** @internal */\r\n    public _uniformBuffersNames: { [key: string]: number } = {};\r\n    /** @internal */\r\n    public _samplerList: string[];\r\n    /** @internal */\r\n    public _multiTarget: boolean = false;\r\n\r\n    private static _UniqueIdSeed = 0;\r\n    /** @internal */\r\n    public _engine: AbstractEngine;\r\n    private _uniformBuffersNamesList: string[];\r\n    private _uniformsNames: string[];\r\n    /** @internal */\r\n    public _samplers: { [key: string]: number } = {};\r\n    private _isReady = false;\r\n    private _compilationError = \"\";\r\n    private _allFallbacksProcessed = false;\r\n    private _attributesNames: string[];\r\n    private _attributes: number[];\r\n    private _attributeLocationByName: { [name: string]: number };\r\n    /** @internal */\r\n    public _uniforms: { [key: string]: Nullable<WebGLUniformLocation> } = {};\r\n    /**\r\n     * Key for the effect.\r\n     * @internal\r\n     */\r\n    public _key: string = \"\";\r\n    private _indexParameters: any;\r\n    private _fallbacks: Nullable<IEffectFallbacks> = null;\r\n    private _vertexSourceCodeOverride: string = \"\";\r\n    private _fragmentSourceCodeOverride: string = \"\";\r\n    private _transformFeedbackVaryings: Nullable<string[]> = null;\r\n    private _shaderLanguage: ShaderLanguage;\r\n    private _disableParallelShaderCompilation: boolean = false;\r\n    /**\r\n     * Compiled shader to webGL program.\r\n     * @internal\r\n     */\r\n    public _pipelineContext: Nullable<IPipelineContext> = null;\r\n    /** @internal */\r\n    public _vertexSourceCode: string = \"\";\r\n    /** @internal */\r\n    public _fragmentSourceCode: string = \"\";\r\n\r\n    /** @internal */\r\n    public _vertexSourceCodeBeforeMigration: string = \"\";\r\n    /** @internal */\r\n    public _fragmentSourceCodeBeforeMigration: string = \"\";\r\n\r\n    /** @internal */\r\n    public _rawVertexSourceCode: string = \"\";\r\n    /** @internal */\r\n    public _rawFragmentSourceCode: string = \"\";\r\n\r\n    private static _BaseCache: { [key: number]: DataBuffer } = {};\r\n    private _processingContext: Nullable<ShaderProcessingContext>;\r\n\r\n    private _processCodeAfterIncludes: ShaderCustomProcessingFunction | undefined = undefined;\r\n    private _processFinalCode: Nullable<ShaderCustomProcessingFunction> = null;\r\n\r\n    /**\r\n     * Gets the shader language type used to write vertex and fragment source code.\r\n     */\r\n    public get shaderLanguage(): ShaderLanguage {\r\n        return this._shaderLanguage;\r\n    }\r\n\r\n    /**\r\n     * Instantiates an effect.\r\n     * An effect can be used to create/manage/execute vertex and fragment shaders.\r\n     * @param baseName Name of the effect.\r\n     * @param attributesNamesOrOptions List of attribute names that will be passed to the shader or set of all options to create the effect.\r\n     * @param uniformsNamesOrEngine List of uniform variable names that will be passed to the shader or the engine that will be used to render effect.\r\n     * @param samplers List of sampler variables that will be passed to the shader.\r\n     * @param engine Engine to be used to render the effect\r\n     * @param defines Define statements to be added to the shader.\r\n     * @param fallbacks Possible fallbacks for this effect to improve performance when needed.\r\n     * @param onCompiled Callback that will be called when the shader is compiled.\r\n     * @param onError Callback that will be called if an error occurs during shader compilation.\r\n     * @param indexParameters Parameters to be used with Babylons include syntax to iterate over an array (eg. \\{lights: 10\\})\r\n     * @param key Effect Key identifying uniquely compiled shader variants\r\n     * @param shaderLanguage the language the shader is written in (default: GLSL)\r\n     * @param extraInitializationsAsync additional async code to run before preparing the effect\r\n     */\r\n    constructor(\r\n        baseName: IShaderPath | string,\r\n        attributesNamesOrOptions: string[] | IEffectCreationOptions,\r\n        uniformsNamesOrEngine: string[] | AbstractEngine,\r\n        samplers: Nullable<string[]> = null,\r\n        engine?: AbstractEngine,\r\n        defines: Nullable<string> = null,\r\n        fallbacks: Nullable<IEffectFallbacks> = null,\r\n        onCompiled: Nullable<(effect: Effect) => void> = null,\r\n        onError: Nullable<(effect: Effect, errors: string) => void> = null,\r\n        indexParameters?: any,\r\n        key: string = \"\",\r\n        shaderLanguage = ShaderLanguage.GLSL,\r\n        extraInitializationsAsync?: () => Promise<void>\r\n    ) {\r\n        this.name = baseName;\r\n        this._key = key;\r\n        const pipelineName = this._key.replace(/\\r/g, \"\").replace(/\\n/g, \"|\");\r\n        let cachedPipeline: IPipelineContext | undefined = undefined;\r\n\r\n        if ((<IEffectCreationOptions>attributesNamesOrOptions).attributes) {\r\n            const options = <IEffectCreationOptions>attributesNamesOrOptions;\r\n            this._engine = <AbstractEngine>uniformsNamesOrEngine;\r\n\r\n            this._attributesNames = options.attributes;\r\n            this._uniformsNames = options.uniformsNames.concat(options.samplers);\r\n            this._samplerList = options.samplers.slice();\r\n            this.defines = options.defines;\r\n            this.onError = options.onError;\r\n            this.onCompiled = options.onCompiled;\r\n            this._fallbacks = options.fallbacks;\r\n            this._indexParameters = options.indexParameters;\r\n            this._transformFeedbackVaryings = options.transformFeedbackVaryings || null;\r\n            this._multiTarget = !!options.multiTarget;\r\n            this._shaderLanguage = options.shaderLanguage ?? ShaderLanguage.GLSL;\r\n            this._disableParallelShaderCompilation = !!options.disableParallelShaderCompilation;\r\n\r\n            if (options.uniformBuffersNames) {\r\n                this._uniformBuffersNamesList = options.uniformBuffersNames.slice();\r\n                for (let i = 0; i < options.uniformBuffersNames.length; i++) {\r\n                    this._uniformBuffersNames[options.uniformBuffersNames[i]] = i;\r\n                }\r\n            }\r\n\r\n            this._processFinalCode = options.processFinalCode ?? null;\r\n            this._processCodeAfterIncludes = options.processCodeAfterIncludes ?? undefined;\r\n            extraInitializationsAsync = options.extraInitializationsAsync;\r\n\r\n            cachedPipeline = options.existingPipelineContext;\r\n        } else {\r\n            this._engine = <AbstractEngine>engine;\r\n            this.defines = defines == null ? \"\" : defines;\r\n            this._uniformsNames = (<string[]>uniformsNamesOrEngine).concat(<string[]>samplers);\r\n            this._samplerList = samplers ? <string[]>samplers.slice() : [];\r\n            this._attributesNames = <string[]>attributesNamesOrOptions;\r\n            this._uniformBuffersNamesList = [];\r\n            this._shaderLanguage = shaderLanguage;\r\n\r\n            this.onError = onError;\r\n            this.onCompiled = onCompiled;\r\n\r\n            this._indexParameters = indexParameters;\r\n            this._fallbacks = fallbacks;\r\n        }\r\n\r\n        // Use the cache if we can. For now, WebGL2 only.\r\n        if (this._engine.shaderPlatformName === \"WEBGL2\") {\r\n            cachedPipeline = getCachedPipeline(pipelineName, (this._engine as any)._gl) ?? cachedPipeline;\r\n        }\r\n\r\n        this._attributeLocationByName = {};\r\n\r\n        this.uniqueId = Effect._UniqueIdSeed++;\r\n        if (!cachedPipeline) {\r\n            this._processShaderCodeAsync(null, false, null, extraInitializationsAsync);\r\n        } else {\r\n            this._pipelineContext = cachedPipeline;\r\n            this._pipelineContext.setEngine(this._engine);\r\n            this._onRenderingStateCompiled(this._pipelineContext);\r\n            // rebuildRebind for spector\r\n            if ((this._pipelineContext as any).program) {\r\n                (this._pipelineContext as any).program.__SPECTOR_rebuildProgram = this._rebuildProgram.bind(this);\r\n            }\r\n        }\r\n\r\n        this._engine.onReleaseEffectsObservable.addOnce(() => {\r\n            if (this.isDisposed) {\r\n                return;\r\n            }\r\n\r\n            this.dispose(true);\r\n        });\r\n    }\r\n\r\n    /** @internal */\r\n    public async _processShaderCodeAsync(\r\n        shaderProcessor: Nullable<IShaderProcessor> = null,\r\n        keepExistingPipelineContext = false,\r\n        shaderProcessingContext: Nullable<ShaderProcessingContext> = null,\r\n        extraInitializationsAsync?: () => Promise<void>\r\n    ) {\r\n        if (extraInitializationsAsync) {\r\n            await extraInitializationsAsync();\r\n        }\r\n\r\n        this._processingContext = shaderProcessingContext || this._engine._getShaderProcessingContext(this._shaderLanguage, false);\r\n\r\n        const processorOptions: ProcessingOptions = {\r\n            defines: this.defines.split(\"\\n\"),\r\n            indexParameters: this._indexParameters,\r\n            isFragment: false,\r\n            shouldUseHighPrecisionShader: this._engine._shouldUseHighPrecisionShader,\r\n            processor: shaderProcessor ?? this._engine._getShaderProcessor(this._shaderLanguage),\r\n            supportsUniformBuffers: this._engine.supportsUniformBuffers,\r\n            shadersRepository: EngineShaderStore.GetShadersRepository(this._shaderLanguage),\r\n            includesShadersStore: EngineShaderStore.GetIncludesShadersStore(this._shaderLanguage),\r\n            version: (this._engine.version * 100).toString(),\r\n            platformName: this._engine.shaderPlatformName,\r\n            processingContext: this._processingContext,\r\n            isNDCHalfZRange: this._engine.isNDCHalfZRange,\r\n            useReverseDepthBuffer: this._engine.useReverseDepthBuffer,\r\n            processCodeAfterIncludes: this._processCodeAfterIncludes,\r\n        };\r\n\r\n        _processShaderCode(\r\n            processorOptions,\r\n            this.name,\r\n            this._processFinalCode,\r\n            (migratedVertexCode, migratedFragmentCode) => {\r\n                this._vertexSourceCode = migratedVertexCode;\r\n                this._fragmentSourceCode = migratedFragmentCode;\r\n                this._prepareEffect(keepExistingPipelineContext);\r\n            },\r\n            this._shaderLanguage,\r\n            this._engine,\r\n            this\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Unique key for this effect\r\n     */\r\n    public get key(): string {\r\n        return this._key;\r\n    }\r\n\r\n    /**\r\n     * If the effect has been compiled and prepared.\r\n     * @returns if the effect is compiled and prepared.\r\n     */\r\n    public isReady(): boolean {\r\n        try {\r\n            return this._isReadyInternal();\r\n        } catch {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    private _isReadyInternal(): boolean {\r\n        if (this._engine.isDisposed) {\r\n            // Engine is disposed, we return true to prevent looping over the setTimeout call in _checkIsReady\r\n            return true;\r\n        }\r\n        if (this._isReady) {\r\n            return true;\r\n        }\r\n        if (this._pipelineContext) {\r\n            return this._pipelineContext.isReady;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * The engine the effect was initialized with.\r\n     * @returns the engine.\r\n     */\r\n    public getEngine(): AbstractEngine {\r\n        return this._engine;\r\n    }\r\n\r\n    /**\r\n     * The pipeline context for this effect\r\n     * @returns the associated pipeline context\r\n     */\r\n    public getPipelineContext(): Nullable<IPipelineContext> {\r\n        return this._pipelineContext;\r\n    }\r\n\r\n    /**\r\n     * The set of names of attribute variables for the shader.\r\n     * @returns An array of attribute names.\r\n     */\r\n    public getAttributesNames(): string[] {\r\n        return this._attributesNames;\r\n    }\r\n\r\n    /**\r\n     * Returns the attribute at the given index.\r\n     * @param index The index of the attribute.\r\n     * @returns The location of the attribute.\r\n     */\r\n    public getAttributeLocation(index: number): number {\r\n        return this._attributes[index];\r\n    }\r\n\r\n    /**\r\n     * Returns the attribute based on the name of the variable.\r\n     * @param name of the attribute to look up.\r\n     * @returns the attribute location.\r\n     */\r\n    public getAttributeLocationByName(name: string): number {\r\n        return this._attributeLocationByName[name];\r\n    }\r\n\r\n    /**\r\n     * The number of attributes.\r\n     * @returns the number of attributes.\r\n     */\r\n    public getAttributesCount(): number {\r\n        return this._attributes.length;\r\n    }\r\n\r\n    /**\r\n     * Gets the index of a uniform variable.\r\n     * @param uniformName of the uniform to look up.\r\n     * @returns the index.\r\n     */\r\n    public getUniformIndex(uniformName: string): number {\r\n        return this._uniformsNames.indexOf(uniformName);\r\n    }\r\n\r\n    /**\r\n     * Returns the attribute based on the name of the variable.\r\n     * @param uniformName of the uniform to look up.\r\n     * @returns the location of the uniform.\r\n     */\r\n    public getUniform(uniformName: string): Nullable<WebGLUniformLocation> {\r\n        return this._uniforms[uniformName];\r\n    }\r\n\r\n    /**\r\n     * Returns an array of sampler variable names\r\n     * @returns The array of sampler variable names.\r\n     */\r\n    public getSamplers(): string[] {\r\n        return this._samplerList;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of uniform variable names\r\n     * @returns The array of uniform variable names.\r\n     */\r\n    public getUniformNames(): string[] {\r\n        return this._uniformsNames;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of uniform buffer variable names\r\n     * @returns The array of uniform buffer variable names.\r\n     */\r\n    public getUniformBuffersNames(): string[] {\r\n        return this._uniformBuffersNamesList;\r\n    }\r\n\r\n    /**\r\n     * Returns the index parameters used to create the effect\r\n     * @returns The index parameters object\r\n     */\r\n    public getIndexParameters(): any {\r\n        return this._indexParameters;\r\n    }\r\n\r\n    /**\r\n     * The error from the last compilation.\r\n     * @returns the error string.\r\n     */\r\n    public getCompilationError(): string {\r\n        return this._compilationError;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that all fallbacks were used during compilation\r\n     * @returns true if all fallbacks were used\r\n     */\r\n    public allFallbacksProcessed(): boolean {\r\n        return this._allFallbacksProcessed;\r\n    }\r\n\r\n    /**\r\n     * Wait until compilation before fulfilling.\r\n     * @returns a promise to wait for completion.\r\n     */\r\n    public whenCompiledAsync(): Promise<Effect> {\r\n        return new Promise((resolve) => {\r\n            this.executeWhenCompiled(resolve);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Adds a callback to the onCompiled observable and call the callback immediately if already ready.\r\n     * @param func The callback to be used.\r\n     */\r\n    public executeWhenCompiled(func: (effect: Effect) => void): void {\r\n        if (this.isReady()) {\r\n            func(this);\r\n            return;\r\n        }\r\n\r\n        this.onCompileObservable.add((effect) => {\r\n            func(effect);\r\n        });\r\n\r\n        if (!this._pipelineContext || this._pipelineContext.isAsync) {\r\n            this._checkIsReady(null);\r\n        }\r\n    }\r\n\r\n    private _checkIsReady(previousPipelineContext: Nullable<IPipelineContext>) {\r\n        _retryWithInterval(\r\n            () => {\r\n                return this._isReadyInternal() || this._isDisposed;\r\n            },\r\n            () => {\r\n                // no-op - done in the _isReadyInternal call\r\n            },\r\n            (e) => {\r\n                this._processCompilationErrors(e, previousPipelineContext);\r\n            },\r\n            16,\r\n            120000,\r\n            true,\r\n            ` - Effect: ${typeof this.name === \"string\" ? this.name : this.key}`\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Gets the vertex shader source code of this effect\r\n     * This is the final source code that will be compiled, after all the processing has been done (pre-processing applied, code injection/replacement, etc)\r\n     */\r\n    public get vertexSourceCode(): string {\r\n        return this._vertexSourceCodeOverride && this._fragmentSourceCodeOverride\r\n            ? this._vertexSourceCodeOverride\r\n            : (this._pipelineContext?._getVertexShaderCode() ?? this._vertexSourceCode);\r\n    }\r\n\r\n    /**\r\n     * Gets the fragment shader source code of this effect\r\n     * This is the final source code that will be compiled, after all the processing has been done (pre-processing applied, code injection/replacement, etc)\r\n     */\r\n    public get fragmentSourceCode(): string {\r\n        return this._vertexSourceCodeOverride && this._fragmentSourceCodeOverride\r\n            ? this._fragmentSourceCodeOverride\r\n            : (this._pipelineContext?._getFragmentShaderCode() ?? this._fragmentSourceCode);\r\n    }\r\n\r\n    /**\r\n     * Gets the vertex shader source code before migration.\r\n     * This is the source code after the include directives have been replaced by their contents but before the code is migrated, i.e. before ShaderProcess._ProcessShaderConversion is executed.\r\n     * This method is, among other things, responsible for parsing #if/#define directives as well as converting GLES2 syntax to GLES3 (in the case of WebGL).\r\n     */\r\n    public get vertexSourceCodeBeforeMigration(): string {\r\n        return this._vertexSourceCodeBeforeMigration;\r\n    }\r\n\r\n    /**\r\n     * Gets the fragment shader source code before migration.\r\n     * This is the source code after the include directives have been replaced by their contents but before the code is migrated, i.e. before ShaderProcess._ProcessShaderConversion is executed.\r\n     * This method is, among other things, responsible for parsing #if/#define directives as well as converting GLES2 syntax to GLES3 (in the case of WebGL).\r\n     */\r\n    public get fragmentSourceCodeBeforeMigration(): string {\r\n        return this._fragmentSourceCodeBeforeMigration;\r\n    }\r\n\r\n    /**\r\n     * Gets the vertex shader source code before it has been modified by any processing\r\n     */\r\n    public get rawVertexSourceCode(): string {\r\n        return this._rawVertexSourceCode;\r\n    }\r\n\r\n    /**\r\n     * Gets the fragment shader source code before it has been modified by any processing\r\n     */\r\n    public get rawFragmentSourceCode(): string {\r\n        return this._rawFragmentSourceCode;\r\n    }\r\n\r\n    public getPipelineGenerationOptions(): IPipelineGenerationOptions {\r\n        return {\r\n            platformName: this._engine.shaderPlatformName,\r\n            shaderLanguage: this._shaderLanguage,\r\n            shaderNameOrContent: this.name,\r\n            key: this._key,\r\n            defines: this.defines.split(\"\\n\"),\r\n            addGlobalDefines: false,\r\n            extendedProcessingOptions: {\r\n                indexParameters: this._indexParameters,\r\n                isNDCHalfZRange: this._engine.isNDCHalfZRange,\r\n                useReverseDepthBuffer: this._engine.useReverseDepthBuffer,\r\n                supportsUniformBuffers: this._engine.supportsUniformBuffers,\r\n            },\r\n            extendedCreatePipelineOptions: {\r\n                transformFeedbackVaryings: this._transformFeedbackVaryings,\r\n                createAsRaw: !!(this._vertexSourceCodeOverride && this._fragmentSourceCodeOverride),\r\n            },\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Recompiles the webGL program\r\n     * @param vertexSourceCode The source code for the vertex shader.\r\n     * @param fragmentSourceCode The source code for the fragment shader.\r\n     * @param onCompiled Callback called when completed.\r\n     * @param onError Callback called on error.\r\n     * @internal\r\n     */\r\n    public _rebuildProgram(vertexSourceCode: string, fragmentSourceCode: string, onCompiled: (pipelineContext: IPipelineContext) => void, onError: (message: string) => void) {\r\n        this._isReady = false;\r\n\r\n        this._vertexSourceCodeOverride = vertexSourceCode;\r\n        this._fragmentSourceCodeOverride = fragmentSourceCode;\r\n        this.onError = (effect, error) => {\r\n            if (onError) {\r\n                onError(error);\r\n            }\r\n        };\r\n        this.onCompiled = () => {\r\n            const scenes = this.getEngine().scenes;\r\n            if (scenes) {\r\n                for (let i = 0; i < scenes.length; i++) {\r\n                    scenes[i].markAllMaterialsAsDirty(Constants.MATERIAL_AllDirtyFlag);\r\n                }\r\n            }\r\n\r\n            this._pipelineContext!._handlesSpectorRebuildCallback?.(onCompiled);\r\n        };\r\n        this._fallbacks = null;\r\n        this._prepareEffect();\r\n    }\r\n\r\n    private _onRenderingStateCompiled(pipelineContext: IPipelineContext) {\r\n        this._pipelineContext = pipelineContext;\r\n        this._pipelineContext.setEngine(this._engine);\r\n        this._attributes = [];\r\n        this._pipelineContext!._fillEffectInformation(\r\n            this,\r\n            this._uniformBuffersNames,\r\n            this._uniformsNames,\r\n            this._uniforms,\r\n            this._samplerList,\r\n            this._samplers,\r\n            this._attributesNames,\r\n            this._attributes\r\n        );\r\n\r\n        // Caches attribute locations.\r\n        if (this._attributesNames) {\r\n            for (let i = 0; i < this._attributesNames.length; i++) {\r\n                const name = this._attributesNames[i];\r\n                this._attributeLocationByName[name] = this._attributes[i];\r\n            }\r\n        }\r\n\r\n        this._engine.bindSamplers(this);\r\n\r\n        this._compilationError = \"\";\r\n        this._isReady = true;\r\n        if (this.onCompiled) {\r\n            this.onCompiled(this);\r\n        }\r\n        this.onCompileObservable.notifyObservers(this);\r\n        this.onCompileObservable.clear();\r\n\r\n        // Unbind mesh reference in fallbacks\r\n        if (this._fallbacks) {\r\n            this._fallbacks.unBindMesh();\r\n        }\r\n\r\n        if (Effect.AutomaticallyClearCodeCache) {\r\n            this.clearCodeCache();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Prepares the effect\r\n     * @internal\r\n     */\r\n    public _prepareEffect(keepExistingPipelineContext = false) {\r\n        const previousPipelineContext = this._pipelineContext;\r\n\r\n        this._isReady = false;\r\n\r\n        try {\r\n            const overrides = !!(this._vertexSourceCodeOverride && this._fragmentSourceCodeOverride);\r\n            const defines = overrides ? null : this.defines;\r\n            const vertex = overrides ? this._vertexSourceCodeOverride : this._vertexSourceCode;\r\n            const fragment = overrides ? this._fragmentSourceCodeOverride : this._fragmentSourceCode;\r\n            const engine = this._engine;\r\n            this._pipelineContext = createAndPreparePipelineContext(\r\n                {\r\n                    existingPipelineContext: keepExistingPipelineContext ? previousPipelineContext : null,\r\n                    vertex,\r\n                    fragment,\r\n                    context: engine.shaderPlatformName === \"WEBGL2\" || engine.shaderPlatformName === \"WEBGL1\" ? (engine as any)._gl : undefined,\r\n                    rebuildRebind: (\r\n                        vertexSourceCode: string,\r\n                        fragmentSourceCode: string,\r\n                        onCompiled: (pipelineContext: IPipelineContext) => void,\r\n                        onError: (message: string) => void\r\n                    ) => this._rebuildProgram(vertexSourceCode, fragmentSourceCode, onCompiled, onError),\r\n                    defines,\r\n                    transformFeedbackVaryings: this._transformFeedbackVaryings,\r\n                    name: this._key.replace(/\\r/g, \"\").replace(/\\n/g, \"|\"),\r\n                    createAsRaw: overrides,\r\n                    disableParallelCompilation: this._disableParallelShaderCompilation,\r\n                    shaderProcessingContext: this._processingContext,\r\n                    onRenderingStateCompiled: (pipelineContext) => {\r\n                        if (previousPipelineContext && !keepExistingPipelineContext) {\r\n                            this._engine._deletePipelineContext(previousPipelineContext);\r\n                        }\r\n                        if (pipelineContext) {\r\n                            this._onRenderingStateCompiled(pipelineContext);\r\n                        }\r\n                    },\r\n                },\r\n                this._engine.createPipelineContext.bind(this._engine),\r\n                this._engine._preparePipelineContext.bind(this._engine),\r\n                this._engine._executeWhenRenderingStateIsCompiled.bind(this._engine)\r\n            );\r\n\r\n            if (this._pipelineContext.isAsync) {\r\n                this._checkIsReady(previousPipelineContext);\r\n            }\r\n        } catch (e) {\r\n            this._processCompilationErrors(e, previousPipelineContext);\r\n        }\r\n    }\r\n\r\n    private _getShaderCodeAndErrorLine(code: Nullable<string>, error: Nullable<string>, isFragment: boolean): [Nullable<string>, Nullable<string>] {\r\n        const regexp = isFragment ? /FRAGMENT SHADER ERROR: 0:(\\d+?):/ : /VERTEX SHADER ERROR: 0:(\\d+?):/;\r\n\r\n        let errorLine = null;\r\n\r\n        if (error && code) {\r\n            const res = error.match(regexp);\r\n            if (res && res.length === 2) {\r\n                const lineNumber = parseInt(res[1]);\r\n                const lines = code.split(\"\\n\", -1);\r\n                if (lines.length >= lineNumber) {\r\n                    errorLine = `Offending line [${lineNumber}] in ${isFragment ? \"fragment\" : \"vertex\"} code: ${lines[lineNumber - 1]}`;\r\n                }\r\n            }\r\n        }\r\n\r\n        return [code, errorLine];\r\n    }\r\n\r\n    private _processCompilationErrors(e: any, previousPipelineContext: Nullable<IPipelineContext> = null) {\r\n        this._compilationError = e.message;\r\n        const attributesNames = this._attributesNames;\r\n        const fallbacks = this._fallbacks;\r\n\r\n        // Let's go through fallbacks then\r\n        Logger.Error(\"Unable to compile effect:\");\r\n        Logger.Error(\r\n            \"Uniforms: \" +\r\n                this._uniformsNames.map(function (uniform) {\r\n                    return \" \" + uniform;\r\n                })\r\n        );\r\n        Logger.Error(\r\n            \"Attributes: \" +\r\n                attributesNames.map(function (attribute) {\r\n                    return \" \" + attribute;\r\n                })\r\n        );\r\n        Logger.Error(\"Defines:\\n\" + this.defines);\r\n        if (Effect.LogShaderCodeOnCompilationError) {\r\n            let lineErrorVertex = null,\r\n                lineErrorFragment = null,\r\n                code = null;\r\n            if (this._pipelineContext?._getVertexShaderCode()) {\r\n                [code, lineErrorVertex] = this._getShaderCodeAndErrorLine(this._pipelineContext._getVertexShaderCode(), this._compilationError, false);\r\n                if (code) {\r\n                    Logger.Error(\"Vertex code:\");\r\n                    Logger.Error(code);\r\n                }\r\n            }\r\n            if (this._pipelineContext?._getFragmentShaderCode()) {\r\n                [code, lineErrorFragment] = this._getShaderCodeAndErrorLine(this._pipelineContext?._getFragmentShaderCode(), this._compilationError, true);\r\n                if (code) {\r\n                    Logger.Error(\"Fragment code:\");\r\n                    Logger.Error(code);\r\n                }\r\n            }\r\n            if (lineErrorVertex) {\r\n                Logger.Error(lineErrorVertex);\r\n            }\r\n            if (lineErrorFragment) {\r\n                Logger.Error(lineErrorFragment);\r\n            }\r\n        }\r\n        Logger.Error(\"Error: \" + this._compilationError);\r\n\r\n        const notifyErrors = () => {\r\n            if (this.onError) {\r\n                this.onError(this, this._compilationError);\r\n            }\r\n            this.onErrorObservable.notifyObservers(this);\r\n            this._engine.onEffectErrorObservable.notifyObservers({ effect: this, errors: this._compilationError });\r\n        };\r\n\r\n        // In case a previous compilation was successful, we need to restore the previous pipeline context\r\n        if (previousPipelineContext) {\r\n            this._pipelineContext = previousPipelineContext;\r\n            this._isReady = true;\r\n            notifyErrors();\r\n        }\r\n\r\n        // Lets try to compile fallbacks as long as we have some.\r\n        if (fallbacks) {\r\n            this._pipelineContext = null;\r\n            if (fallbacks.hasMoreFallbacks) {\r\n                this._allFallbacksProcessed = false;\r\n                Logger.Error(\"Trying next fallback.\");\r\n                this.defines = fallbacks.reduce(this.defines, this);\r\n                this._prepareEffect();\r\n            } else {\r\n                // Sorry we did everything we can\r\n                this._allFallbacksProcessed = true;\r\n                notifyErrors();\r\n                this.onErrorObservable.clear();\r\n\r\n                // Unbind mesh reference in fallbacks\r\n                if (this._fallbacks) {\r\n                    this._fallbacks.unBindMesh();\r\n                }\r\n            }\r\n        } else {\r\n            this._allFallbacksProcessed = true;\r\n\r\n            // In case of error, without any prior successful compilation, let s notify observers\r\n            if (!previousPipelineContext) {\r\n                notifyErrors();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks if the effect is supported. (Must be called after compilation)\r\n     */\r\n    public get isSupported(): boolean {\r\n        return this._compilationError === \"\";\r\n    }\r\n\r\n    /**\r\n     * Binds a texture to the engine to be used as output of the shader.\r\n     * @param channel Name of the output variable.\r\n     * @param texture Texture to bind.\r\n     * @internal\r\n     */\r\n    public _bindTexture(channel: string, texture: Nullable<InternalTexture>): void {\r\n        this._engine._bindTexture(this._samplers[channel], texture, channel);\r\n    }\r\n\r\n    /**\r\n     * Sets a texture on the engine to be used in the shader.\r\n     * @param channel Name of the sampler variable.\r\n     * @param texture Texture to set.\r\n     */\r\n    public setTexture(channel: string, texture: Nullable<ThinTexture>): void {\r\n        this._engine.setTexture(this._samplers[channel], this._uniforms[channel], texture, channel);\r\n    }\r\n\r\n    /**\r\n     * Sets an array of textures on the engine to be used in the shader.\r\n     * @param channel Name of the variable.\r\n     * @param textures Textures to set.\r\n     */\r\n    public setTextureArray(channel: string, textures: ThinTexture[]): void {\r\n        const exName = channel + \"Ex\";\r\n        if (this._samplerList.indexOf(exName + \"0\") === -1) {\r\n            const initialPos = this._samplerList.indexOf(channel);\r\n            for (let index = 1; index < textures.length; index++) {\r\n                const currentExName = exName + (index - 1).toString();\r\n                this._samplerList.splice(initialPos + index, 0, currentExName);\r\n            }\r\n\r\n            // Reset every channels\r\n            let channelIndex = 0;\r\n            for (const key of this._samplerList) {\r\n                this._samplers[key] = channelIndex;\r\n                channelIndex += 1;\r\n            }\r\n        }\r\n\r\n        this._engine.setTextureArray(this._samplers[channel], this._uniforms[channel], textures, channel);\r\n    }\r\n\r\n    /**\r\n     * Binds a buffer to a uniform.\r\n     * @param buffer Buffer to bind.\r\n     * @param name Name of the uniform variable to bind to.\r\n     */\r\n    public bindUniformBuffer(buffer: DataBuffer, name: string): void {\r\n        const bufferName = this._uniformBuffersNames[name];\r\n        if (bufferName === undefined || (Effect._BaseCache[bufferName] === buffer && this._engine._features.useUBOBindingCache)) {\r\n            return;\r\n        }\r\n        Effect._BaseCache[bufferName] = buffer;\r\n        this._engine.bindUniformBufferBase(buffer, bufferName, name);\r\n    }\r\n\r\n    /**\r\n     * Binds block to a uniform.\r\n     * @param blockName Name of the block to bind.\r\n     * @param index Index to bind.\r\n     */\r\n    public bindUniformBlock(blockName: string, index: number): void {\r\n        this._engine.bindUniformBlock(this._pipelineContext!, blockName, index);\r\n    }\r\n\r\n    /**\r\n     * Sets an integer value on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param value Value to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setInt(uniformName: string, value: number): Effect {\r\n        this._pipelineContext!.setInt(uniformName, value);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an int2 value on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First int in int2.\r\n     * @param y Second int in int2.\r\n     * @returns this effect.\r\n     */\r\n    public setInt2(uniformName: string, x: number, y: number): Effect {\r\n        this._pipelineContext!.setInt2(uniformName, x, y);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an int3 value on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First int in int3.\r\n     * @param y Second int in int3.\r\n     * @param z Third int in int3.\r\n     * @returns this effect.\r\n     */\r\n    public setInt3(uniformName: string, x: number, y: number, z: number): Effect {\r\n        this._pipelineContext!.setInt3(uniformName, x, y, z);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an int4 value on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First int in int4.\r\n     * @param y Second int in int4.\r\n     * @param z Third int in int4.\r\n     * @param w Fourth int in int4.\r\n     * @returns this effect.\r\n     */\r\n    public setInt4(uniformName: string, x: number, y: number, z: number, w: number): Effect {\r\n        this._pipelineContext!.setInt4(uniformName, x, y, z, w);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an int array on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setIntArray(uniformName: string, array: Int32Array): Effect {\r\n        this._pipelineContext!.setIntArray(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an int array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setIntArray2(uniformName: string, array: Int32Array): Effect {\r\n        this._pipelineContext!.setIntArray2(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an int array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setIntArray3(uniformName: string, array: Int32Array): Effect {\r\n        this._pipelineContext!.setIntArray3(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an int array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setIntArray4(uniformName: string, array: Int32Array): Effect {\r\n        this._pipelineContext!.setIntArray4(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned integer value on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param value Value to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setUInt(uniformName: string, value: number): Effect {\r\n        this._pipelineContext!.setUInt(uniformName, value);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned int2 value on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First unsigned int in uint2.\r\n     * @param y Second unsigned int in uint2.\r\n     * @returns this effect.\r\n     */\r\n    public setUInt2(uniformName: string, x: number, y: number): Effect {\r\n        this._pipelineContext!.setUInt2(uniformName, x, y);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned int3 value on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First unsigned int in uint3.\r\n     * @param y Second unsigned int in uint3.\r\n     * @param z Third unsigned int in uint3.\r\n     * @returns this effect.\r\n     */\r\n    public setUInt3(uniformName: string, x: number, y: number, z: number): Effect {\r\n        this._pipelineContext!.setUInt3(uniformName, x, y, z);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned int4 value on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First unsigned int in uint4.\r\n     * @param y Second unsigned int in uint4.\r\n     * @param z Third unsigned int in uint4.\r\n     * @param w Fourth unsigned int in uint4.\r\n     * @returns this effect.\r\n     */\r\n    public setUInt4(uniformName: string, x: number, y: number, z: number, w: number): Effect {\r\n        this._pipelineContext!.setUInt4(uniformName, x, y, z, w);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned int array on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setUIntArray(uniformName: string, array: Uint32Array): Effect {\r\n        this._pipelineContext!.setUIntArray(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned int array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setUIntArray2(uniformName: string, array: Uint32Array): Effect {\r\n        this._pipelineContext!.setUIntArray2(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned int array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setUIntArray3(uniformName: string, array: Uint32Array): Effect {\r\n        this._pipelineContext!.setUIntArray3(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned int array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setUIntArray4(uniformName: string, array: Uint32Array): Effect {\r\n        this._pipelineContext!.setUIntArray4(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an float array on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setFloatArray(uniformName: string, array: FloatArray): Effect {\r\n        this._pipelineContext!.setArray(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an float array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setFloatArray2(uniformName: string, array: FloatArray): Effect {\r\n        this._pipelineContext!.setArray2(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an float array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setFloatArray3(uniformName: string, array: FloatArray): Effect {\r\n        this._pipelineContext!.setArray3(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an float array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setFloatArray4(uniformName: string, array: FloatArray): Effect {\r\n        this._pipelineContext!.setArray4(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an array on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setArray(uniformName: string, array: number[]): Effect {\r\n        this._pipelineContext!.setArray(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setArray2(uniformName: string, array: number[]): Effect {\r\n        this._pipelineContext!.setArray2(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setArray3(uniformName: string, array: number[]): Effect {\r\n        this._pipelineContext!.setArray3(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setArray4(uniformName: string, array: number[]): Effect {\r\n        this._pipelineContext!.setArray4(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets matrices on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param matrices matrices to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setMatrices(uniformName: string, matrices: Float32Array | Array<number>): Effect {\r\n        this._pipelineContext!.setMatrices(uniformName, matrices as Float32Array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets matrix on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param matrix matrix to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setMatrix(uniformName: string, matrix: IMatrixLike): Effect {\r\n        this._pipelineContext!.setMatrix(uniformName, matrix);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a 3x3 matrix on a uniform variable. (Specified as [1,2,3,4,5,6,7,8,9] will result in [1,2,3][4,5,6][7,8,9] matrix)\r\n     * @param uniformName Name of the variable.\r\n     * @param matrix matrix to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setMatrix3x3(uniformName: string, matrix: Float32Array | Array<number>): Effect {\r\n        // the cast is ok because it is gl.uniformMatrix3fv() which is called at the end, and this function accepts Float32Array and Array<number>\r\n        this._pipelineContext!.setMatrix3x3(uniformName, matrix as Float32Array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a 2x2 matrix on a uniform variable. (Specified as [1,2,3,4] will result in [1,2][3,4] matrix)\r\n     * @param uniformName Name of the variable.\r\n     * @param matrix matrix to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setMatrix2x2(uniformName: string, matrix: Float32Array | Array<number>): Effect {\r\n        // the cast is ok because it is gl.uniformMatrix3fv() which is called at the end, and this function accepts Float32Array and Array<number>\r\n        this._pipelineContext!.setMatrix2x2(uniformName, matrix as Float32Array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a float on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param value value to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setFloat(uniformName: string, value: number): Effect {\r\n        this._pipelineContext!.setFloat(uniformName, value);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a boolean on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param bool value to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setBool(uniformName: string, bool: boolean): Effect {\r\n        this._pipelineContext!.setInt(uniformName, bool ? 1 : 0);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a Vector2 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param vector2 vector2 to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setVector2(uniformName: string, vector2: IVector2Like): Effect {\r\n        this._pipelineContext!.setVector2(uniformName, vector2);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a float2 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First float in float2.\r\n     * @param y Second float in float2.\r\n     * @returns this effect.\r\n     */\r\n    public setFloat2(uniformName: string, x: number, y: number): Effect {\r\n        this._pipelineContext!.setFloat2(uniformName, x, y);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a Vector3 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param vector3 Value to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setVector3(uniformName: string, vector3: IVector3Like): Effect {\r\n        this._pipelineContext!.setVector3(uniformName, vector3);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a float3 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First float in float3.\r\n     * @param y Second float in float3.\r\n     * @param z Third float in float3.\r\n     * @returns this effect.\r\n     */\r\n    public setFloat3(uniformName: string, x: number, y: number, z: number): Effect {\r\n        this._pipelineContext!.setFloat3(uniformName, x, y, z);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a Vector4 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param vector4 Value to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setVector4(uniformName: string, vector4: IVector4Like): Effect {\r\n        this._pipelineContext!.setVector4(uniformName, vector4);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a Quaternion on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param quaternion Value to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setQuaternion(uniformName: string, quaternion: IQuaternionLike): Effect {\r\n        this._pipelineContext!.setQuaternion(uniformName, quaternion);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a float4 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First float in float4.\r\n     * @param y Second float in float4.\r\n     * @param z Third float in float4.\r\n     * @param w Fourth float in float4.\r\n     * @returns this effect.\r\n     */\r\n    public setFloat4(uniformName: string, x: number, y: number, z: number, w: number): Effect {\r\n        this._pipelineContext!.setFloat4(uniformName, x, y, z, w);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a Color3 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param color3 Value to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setColor3(uniformName: string, color3: IColor3Like): Effect {\r\n        this._pipelineContext!.setColor3(uniformName, color3);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a Color4 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param color3 Value to be set.\r\n     * @param alpha Alpha value to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setColor4(uniformName: string, color3: IColor3Like, alpha: number): Effect {\r\n        this._pipelineContext!.setColor4(uniformName, color3, alpha);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a Color4 on a uniform variable\r\n     * @param uniformName defines the name of the variable\r\n     * @param color4 defines the value to be set\r\n     * @returns this effect.\r\n     */\r\n    public setDirectColor4(uniformName: string, color4: IColor4Like): Effect {\r\n        this._pipelineContext!.setDirectColor4(uniformName, color4);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Use this wisely: It will remove the cached code from this effect\r\n     * It is probably ok to call it if you are not using ShadowDepthWrapper or if everything is already up and running\r\n     * DO NOT CALL IT if you want to have support for context lost recovery\r\n     */\r\n    public clearCodeCache() {\r\n        this._vertexSourceCode = \"\";\r\n        this._fragmentSourceCode = \"\";\r\n        this._fragmentSourceCodeBeforeMigration = \"\";\r\n        this._vertexSourceCodeBeforeMigration = \"\";\r\n    }\r\n\r\n    /**\r\n     * Release all associated resources.\r\n     * @param force specifies if the effect must be released no matter what\r\n     **/\r\n    public dispose(force = false) {\r\n        if (force) {\r\n            this._refCount = 0;\r\n        } else {\r\n            if (Effect.PersistentMode) {\r\n                return;\r\n            }\r\n            this._refCount--;\r\n        }\r\n\r\n        if (this._refCount > 0 || this._isDisposed) {\r\n            // Others are still using the effect or the effect was already disposed\r\n            return;\r\n        }\r\n\r\n        if (this._pipelineContext) {\r\n            resetCachedPipeline(this._pipelineContext);\r\n        }\r\n        this._engine._releaseEffect(this);\r\n\r\n        this.clearCodeCache();\r\n\r\n        this._isDisposed = true;\r\n    }\r\n\r\n    /**\r\n     * This function will add a new shader to the shader store\r\n     * @param name the name of the shader\r\n     * @param pixelShader optional pixel shader content\r\n     * @param vertexShader optional vertex shader content\r\n     * @param shaderLanguage the language the shader is written in (default: GLSL)\r\n     */\r\n    public static RegisterShader(name: string, pixelShader?: string, vertexShader?: string, shaderLanguage = ShaderLanguage.GLSL) {\r\n        if (pixelShader) {\r\n            EngineShaderStore.GetShadersStore(shaderLanguage)[`${name}PixelShader`] = pixelShader;\r\n        }\r\n\r\n        if (vertexShader) {\r\n            EngineShaderStore.GetShadersStore(shaderLanguage)[`${name}VertexShader`] = vertexShader;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Store of each shader (The can be looked up using effect.key)\r\n     */\r\n    public static ShadersStore: { [key: string]: string } = EngineShaderStore.ShadersStore;\r\n    /**\r\n     * Store of each included file for a shader (The can be looked up using effect.key)\r\n     */\r\n    public static IncludesShadersStore: { [key: string]: string } = EngineShaderStore.IncludesShadersStore;\r\n\r\n    /**\r\n     * Resets the cache of effects.\r\n     */\r\n    public static ResetCache() {\r\n        Effect._BaseCache = {};\r\n    }\r\n}\r\n", "import type { Nullable } from \"../types\";\r\n\r\n/**\r\n * @internal\r\n **/\r\nexport class DepthCullingState {\r\n    protected _isDepthTestDirty = false;\r\n    protected _isDepthMaskDirty = false;\r\n    protected _isDepthFuncDirty = false;\r\n    protected _isCullFaceDirty = false;\r\n    protected _isCullDirty = false;\r\n    protected _isZOffsetDirty = false;\r\n    protected _isFrontFaceDirty = false;\r\n\r\n    protected _depthTest: boolean;\r\n    protected _depthMask: boolean;\r\n    protected _depthFunc: Nullable<number>;\r\n    protected _cull: Nullable<boolean>;\r\n    protected _cullFace: Nullable<number>;\r\n    protected _zOffset: number;\r\n    protected _zOffsetUnits: number;\r\n    protected _frontFace: Nullable<number>;\r\n\r\n    /**\r\n     * Initializes the state.\r\n     * @param reset\r\n     */\r\n    public constructor(reset = true) {\r\n        if (reset) {\r\n            this.reset();\r\n        }\r\n    }\r\n\r\n    public get isDirty(): boolean {\r\n        return (\r\n            this._isDepthFuncDirty ||\r\n            this._isDepthTestDirty ||\r\n            this._isDepthMaskDirty ||\r\n            this._isCullFaceDirty ||\r\n            this._isCullDirty ||\r\n            this._isZOffsetDirty ||\r\n            this._isFrontFaceDirty\r\n        );\r\n    }\r\n\r\n    public get zOffset(): number {\r\n        return this._zOffset;\r\n    }\r\n\r\n    public set zOffset(value: number) {\r\n        if (this._zOffset === value) {\r\n            return;\r\n        }\r\n\r\n        this._zOffset = value;\r\n        this._isZOffsetDirty = true;\r\n    }\r\n\r\n    public get zOffsetUnits(): number {\r\n        return this._zOffsetUnits;\r\n    }\r\n\r\n    public set zOffsetUnits(value: number) {\r\n        if (this._zOffsetUnits === value) {\r\n            return;\r\n        }\r\n\r\n        this._zOffsetUnits = value;\r\n        this._isZOffsetDirty = true;\r\n    }\r\n\r\n    public get cullFace(): Nullable<number> {\r\n        return this._cullFace;\r\n    }\r\n\r\n    public set cullFace(value: Nullable<number>) {\r\n        if (this._cullFace === value) {\r\n            return;\r\n        }\r\n\r\n        this._cullFace = value;\r\n        this._isCullFaceDirty = true;\r\n    }\r\n\r\n    public get cull(): Nullable<boolean> {\r\n        return this._cull;\r\n    }\r\n\r\n    public set cull(value: Nullable<boolean>) {\r\n        if (this._cull === value) {\r\n            return;\r\n        }\r\n\r\n        this._cull = value;\r\n        this._isCullDirty = true;\r\n    }\r\n\r\n    public get depthFunc(): Nullable<number> {\r\n        return this._depthFunc;\r\n    }\r\n\r\n    public set depthFunc(value: Nullable<number>) {\r\n        if (this._depthFunc === value) {\r\n            return;\r\n        }\r\n\r\n        this._depthFunc = value;\r\n        this._isDepthFuncDirty = true;\r\n    }\r\n\r\n    public get depthMask(): boolean {\r\n        return this._depthMask;\r\n    }\r\n\r\n    public set depthMask(value: boolean) {\r\n        if (this._depthMask === value) {\r\n            return;\r\n        }\r\n\r\n        this._depthMask = value;\r\n        this._isDepthMaskDirty = true;\r\n    }\r\n\r\n    public get depthTest(): boolean {\r\n        return this._depthTest;\r\n    }\r\n\r\n    public set depthTest(value: boolean) {\r\n        if (this._depthTest === value) {\r\n            return;\r\n        }\r\n\r\n        this._depthTest = value;\r\n        this._isDepthTestDirty = true;\r\n    }\r\n\r\n    public get frontFace(): Nullable<number> {\r\n        return this._frontFace;\r\n    }\r\n\r\n    public set frontFace(value: Nullable<number>) {\r\n        if (this._frontFace === value) {\r\n            return;\r\n        }\r\n\r\n        this._frontFace = value;\r\n        this._isFrontFaceDirty = true;\r\n    }\r\n\r\n    public reset() {\r\n        this._depthMask = true;\r\n        this._depthTest = true;\r\n        this._depthFunc = null;\r\n        this._cullFace = null;\r\n        this._cull = null;\r\n        this._zOffset = 0;\r\n        this._zOffsetUnits = 0;\r\n        this._frontFace = null;\r\n\r\n        this._isDepthTestDirty = true;\r\n        this._isDepthMaskDirty = true;\r\n        this._isDepthFuncDirty = false;\r\n        this._isCullFaceDirty = false;\r\n        this._isCullDirty = false;\r\n        this._isZOffsetDirty = true;\r\n        this._isFrontFaceDirty = false;\r\n    }\r\n\r\n    public apply(gl: WebGLRenderingContext) {\r\n        if (!this.isDirty) {\r\n            return;\r\n        }\r\n\r\n        // Cull\r\n        if (this._isCullDirty) {\r\n            if (this.cull) {\r\n                gl.enable(gl.CULL_FACE);\r\n            } else {\r\n                gl.disable(gl.CULL_FACE);\r\n            }\r\n\r\n            this._isCullDirty = false;\r\n        }\r\n\r\n        // Cull face\r\n        if (this._isCullFaceDirty) {\r\n            gl.cullFace(<number>this.cullFace);\r\n            this._isCullFaceDirty = false;\r\n        }\r\n\r\n        // Depth mask\r\n        if (this._isDepthMaskDirty) {\r\n            gl.depthMask(this.depthMask);\r\n            this._isDepthMaskDirty = false;\r\n        }\r\n\r\n        // Depth test\r\n        if (this._isDepthTestDirty) {\r\n            if (this.depthTest) {\r\n                gl.enable(gl.DEPTH_TEST);\r\n            } else {\r\n                gl.disable(gl.DEPTH_TEST);\r\n            }\r\n            this._isDepthTestDirty = false;\r\n        }\r\n\r\n        // Depth func\r\n        if (this._isDepthFuncDirty) {\r\n            gl.depthFunc(<number>this.depthFunc);\r\n            this._isDepthFuncDirty = false;\r\n        }\r\n\r\n        // zOffset\r\n        if (this._isZOffsetDirty) {\r\n            if (this.zOffset || this.zOffsetUnits) {\r\n                gl.enable(gl.POLYGON_OFFSET_FILL);\r\n                gl.polygonOffset(this.zOffset, this.zOffsetUnits);\r\n            } else {\r\n                gl.disable(gl.POLYGON_OFFSET_FILL);\r\n            }\r\n\r\n            this._isZOffsetDirty = false;\r\n        }\r\n\r\n        // Front face\r\n        if (this._isFrontFaceDirty) {\r\n            gl.frontFace(<number>this.frontFace);\r\n            this._isFrontFaceDirty = false;\r\n        }\r\n    }\r\n}\r\n", "import type { IStencilState } from \"./IStencilState\";\r\n\r\n/**\r\n * @internal\r\n **/\r\nexport class StencilStateComposer {\r\n    protected _isStencilTestDirty = false;\r\n    protected _isStencilMaskDirty = false;\r\n    protected _isStencilFuncDirty = false;\r\n    protected _isStencilOpDirty = false;\r\n\r\n    protected _enabled: boolean;\r\n\r\n    protected _mask: number;\r\n\r\n    protected _func: number;\r\n    protected _funcRef: number;\r\n    protected _funcMask: number;\r\n\r\n    protected _opStencilFail: number;\r\n    protected _opDepthFail: number;\r\n    protected _opStencilDepthPass: number;\r\n\r\n    public stencilGlobal: IStencilState;\r\n    public stencilMaterial: IStencilState | undefined;\r\n\r\n    public useStencilGlobalOnly = false;\r\n\r\n    public get isDirty(): boolean {\r\n        return this._isStencilTestDirty || this._isStencilMaskDirty || this._isStencilFuncDirty || this._isStencilOpDirty;\r\n    }\r\n\r\n    public get func(): number {\r\n        return this._func;\r\n    }\r\n\r\n    public set func(value: number) {\r\n        if (this._func === value) {\r\n            return;\r\n        }\r\n\r\n        this._func = value;\r\n        this._isStencilFuncDirty = true;\r\n    }\r\n\r\n    public get funcRef(): number {\r\n        return this._funcRef;\r\n    }\r\n\r\n    public set funcRef(value: number) {\r\n        if (this._funcRef === value) {\r\n            return;\r\n        }\r\n\r\n        this._funcRef = value;\r\n        this._isStencilFuncDirty = true;\r\n    }\r\n\r\n    public get funcMask(): number {\r\n        return this._funcMask;\r\n    }\r\n\r\n    public set funcMask(value: number) {\r\n        if (this._funcMask === value) {\r\n            return;\r\n        }\r\n\r\n        this._funcMask = value;\r\n        this._isStencilFuncDirty = true;\r\n    }\r\n\r\n    public get opStencilFail(): number {\r\n        return this._opStencilFail;\r\n    }\r\n\r\n    public set opStencilFail(value: number) {\r\n        if (this._opStencilFail === value) {\r\n            return;\r\n        }\r\n\r\n        this._opStencilFail = value;\r\n        this._isStencilOpDirty = true;\r\n    }\r\n\r\n    public get opDepthFail(): number {\r\n        return this._opDepthFail;\r\n    }\r\n\r\n    public set opDepthFail(value: number) {\r\n        if (this._opDepthFail === value) {\r\n            return;\r\n        }\r\n\r\n        this._opDepthFail = value;\r\n        this._isStencilOpDirty = true;\r\n    }\r\n\r\n    public get opStencilDepthPass(): number {\r\n        return this._opStencilDepthPass;\r\n    }\r\n\r\n    public set opStencilDepthPass(value: number) {\r\n        if (this._opStencilDepthPass === value) {\r\n            return;\r\n        }\r\n\r\n        this._opStencilDepthPass = value;\r\n        this._isStencilOpDirty = true;\r\n    }\r\n\r\n    public get mask(): number {\r\n        return this._mask;\r\n    }\r\n\r\n    public set mask(value: number) {\r\n        if (this._mask === value) {\r\n            return;\r\n        }\r\n\r\n        this._mask = value;\r\n        this._isStencilMaskDirty = true;\r\n    }\r\n\r\n    public get enabled(): boolean {\r\n        return this._enabled;\r\n    }\r\n\r\n    public set enabled(value: boolean) {\r\n        if (this._enabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._enabled = value;\r\n        this._isStencilTestDirty = true;\r\n    }\r\n\r\n    public constructor(reset = true) {\r\n        if (reset) {\r\n            this.reset();\r\n        }\r\n    }\r\n\r\n    public reset() {\r\n        this.stencilMaterial = undefined;\r\n\r\n        this.stencilGlobal?.reset();\r\n\r\n        this._isStencilTestDirty = true;\r\n        this._isStencilMaskDirty = true;\r\n        this._isStencilFuncDirty = true;\r\n        this._isStencilOpDirty = true;\r\n    }\r\n\r\n    public apply(gl?: WebGLRenderingContext) {\r\n        if (!gl) {\r\n            return;\r\n        }\r\n\r\n        const stencilMaterialEnabled = !this.useStencilGlobalOnly && !!this.stencilMaterial?.enabled;\r\n\r\n        this.enabled = stencilMaterialEnabled ? this.stencilMaterial!.enabled : this.stencilGlobal.enabled;\r\n        this.func = stencilMaterialEnabled ? this.stencilMaterial!.func : this.stencilGlobal.func;\r\n        this.funcRef = stencilMaterialEnabled ? this.stencilMaterial!.funcRef : this.stencilGlobal.funcRef;\r\n        this.funcMask = stencilMaterialEnabled ? this.stencilMaterial!.funcMask : this.stencilGlobal.funcMask;\r\n        this.opStencilFail = stencilMaterialEnabled ? this.stencilMaterial!.opStencilFail : this.stencilGlobal.opStencilFail;\r\n        this.opDepthFail = stencilMaterialEnabled ? this.stencilMaterial!.opDepthFail : this.stencilGlobal.opDepthFail;\r\n        this.opStencilDepthPass = stencilMaterialEnabled ? this.stencilMaterial!.opStencilDepthPass : this.stencilGlobal.opStencilDepthPass;\r\n        this.mask = stencilMaterialEnabled ? this.stencilMaterial!.mask : this.stencilGlobal.mask;\r\n\r\n        if (!this.isDirty) {\r\n            return;\r\n        }\r\n\r\n        // Stencil test\r\n        if (this._isStencilTestDirty) {\r\n            if (this.enabled) {\r\n                gl.enable(gl.STENCIL_TEST);\r\n            } else {\r\n                gl.disable(gl.STENCIL_TEST);\r\n            }\r\n            this._isStencilTestDirty = false;\r\n        }\r\n\r\n        // Stencil mask\r\n        if (this._isStencilMaskDirty) {\r\n            gl.stencilMask(this.mask);\r\n            this._isStencilMaskDirty = false;\r\n        }\r\n\r\n        // Stencil func\r\n        if (this._isStencilFuncDirty) {\r\n            gl.stencilFunc(this.func, this.funcRef, this.funcMask);\r\n            this._isStencilFuncDirty = false;\r\n        }\r\n\r\n        // Stencil op\r\n        if (this._isStencilOpDirty) {\r\n            gl.stencilOp(this.opStencilFail, this.opDepthFail, this.opStencilDepthPass);\r\n            this._isStencilOpDirty = false;\r\n        }\r\n    }\r\n}\r\n", "import { Constants } from \"../Engines/constants\";\r\nimport type { IStencilState } from \"./IStencilState\";\r\n\r\n/**\r\n * @internal\r\n **/\r\nexport class StencilState implements IStencilState {\r\n    /** Passed to depthFunction or stencilFunction to specify depth or stencil tests will always pass. i.e. Pixels will be drawn in the order they are drawn */\r\n    public static readonly ALWAYS = Constants.ALWAYS;\r\n    /** Passed to stencilOperation to specify that stencil value must be kept */\r\n    public static readonly KEEP = Constants.KEEP;\r\n    /** Passed to stencilOperation to specify that stencil value must be replaced */\r\n    public static readonly REPLACE = Constants.REPLACE;\r\n\r\n    public constructor() {\r\n        this.reset();\r\n    }\r\n\r\n    public reset() {\r\n        this.enabled = false;\r\n        this.mask = 0xff;\r\n\r\n        this.func = StencilState.ALWAYS;\r\n        this.funcRef = 1;\r\n        this.funcMask = 0xff;\r\n\r\n        this.opStencilFail = StencilState.KEEP;\r\n        this.opDepthFail = StencilState.KEEP;\r\n        this.opStencilDepthPass = StencilState.REPLACE;\r\n    }\r\n\r\n    public func: number;\r\n    public get stencilFunc(): number {\r\n        return this.func;\r\n    }\r\n\r\n    public set stencilFunc(value: number) {\r\n        this.func = value;\r\n    }\r\n\r\n    public funcRef: number;\r\n    public get stencilFuncRef(): number {\r\n        return this.funcRef;\r\n    }\r\n\r\n    public set stencilFuncRef(value: number) {\r\n        this.funcRef = value;\r\n    }\r\n\r\n    public funcMask: number;\r\n    public get stencilFuncMask(): number {\r\n        return this.funcMask;\r\n    }\r\n\r\n    public set stencilFuncMask(value: number) {\r\n        this.funcMask = value;\r\n    }\r\n\r\n    public opStencilFail: number;\r\n    public get stencilOpStencilFail(): number {\r\n        return this.opStencilFail;\r\n    }\r\n\r\n    public set stencilOpStencilFail(value: number) {\r\n        this.opStencilFail = value;\r\n    }\r\n\r\n    public opDepthFail: number;\r\n    public get stencilOpDepthFail(): number {\r\n        return this.opDepthFail;\r\n    }\r\n\r\n    public set stencilOpDepthFail(value: number) {\r\n        this.opDepthFail = value;\r\n    }\r\n\r\n    public opStencilDepthPass: number;\r\n    public get stencilOpStencilDepthPass(): number {\r\n        return this.opStencilDepthPass;\r\n    }\r\n\r\n    public set stencilOpStencilDepthPass(value: number) {\r\n        this.opStencilDepthPass = value;\r\n    }\r\n\r\n    public mask: number;\r\n    public get stencilMask(): number {\r\n        return this.mask;\r\n    }\r\n\r\n    public set stencilMask(value: number) {\r\n        this.mask = value;\r\n    }\r\n\r\n    public enabled: boolean;\r\n    public get stencilTest(): boolean {\r\n        return this.enabled;\r\n    }\r\n\r\n    public set stencilTest(value: boolean) {\r\n        this.enabled = value;\r\n    }\r\n}\r\n", "import type { Nullable } from \"../types\";\r\n\r\n/**\r\n * @internal\r\n **/\r\nexport class AlphaState {\r\n    public _blendFunctionParameters = new Array<Nullable<number>>(4);\r\n    public _blendEquationParameters = new Array<Nullable<number>>(2);\r\n    public _blendConstants = new Array<Nullable<number>>(4);\r\n    public _isBlendConstantsDirty = false;\r\n\r\n    private _alphaBlend = false;\r\n    private _isAlphaBlendDirty = false;\r\n    private _isBlendFunctionParametersDirty = false;\r\n    private _isBlendEquationParametersDirty = false;\r\n\r\n    /**\r\n     * Initializes the state.\r\n     */\r\n    public constructor() {\r\n        this.reset();\r\n    }\r\n\r\n    public get isDirty(): boolean {\r\n        return this._isAlphaBlendDirty || this._isBlendFunctionParametersDirty || this._isBlendEquationParametersDirty;\r\n    }\r\n\r\n    public get alphaBlend(): boolean {\r\n        return this._alphaBlend;\r\n    }\r\n\r\n    public set alphaBlend(value: boolean) {\r\n        if (this._alphaBlend === value) {\r\n            return;\r\n        }\r\n\r\n        this._alphaBlend = value;\r\n        this._isAlphaBlendDirty = true;\r\n    }\r\n\r\n    public setAlphaBlendConstants(r: number, g: number, b: number, a: number): void {\r\n        if (this._blendConstants[0] === r && this._blendConstants[1] === g && this._blendConstants[2] === b && this._blendConstants[3] === a) {\r\n            return;\r\n        }\r\n\r\n        this._blendConstants[0] = r;\r\n        this._blendConstants[1] = g;\r\n        this._blendConstants[2] = b;\r\n        this._blendConstants[3] = a;\r\n\r\n        this._isBlendConstantsDirty = true;\r\n    }\r\n\r\n    public setAlphaBlendFunctionParameters(value0: number, value1: number, value2: number, value3: number): void {\r\n        if (\r\n            this._blendFunctionParameters[0] === value0 &&\r\n            this._blendFunctionParameters[1] === value1 &&\r\n            this._blendFunctionParameters[2] === value2 &&\r\n            this._blendFunctionParameters[3] === value3\r\n        ) {\r\n            return;\r\n        }\r\n\r\n        this._blendFunctionParameters[0] = value0;\r\n        this._blendFunctionParameters[1] = value1;\r\n        this._blendFunctionParameters[2] = value2;\r\n        this._blendFunctionParameters[3] = value3;\r\n\r\n        this._isBlendFunctionParametersDirty = true;\r\n    }\r\n\r\n    public setAlphaEquationParameters(rgb: number, alpha: number): void {\r\n        if (this._blendEquationParameters[0] === rgb && this._blendEquationParameters[1] === alpha) {\r\n            return;\r\n        }\r\n\r\n        this._blendEquationParameters[0] = rgb;\r\n        this._blendEquationParameters[1] = alpha;\r\n\r\n        this._isBlendEquationParametersDirty = true;\r\n    }\r\n\r\n    public reset() {\r\n        this._alphaBlend = false;\r\n        this._blendFunctionParameters[0] = null;\r\n        this._blendFunctionParameters[1] = null;\r\n        this._blendFunctionParameters[2] = null;\r\n        this._blendFunctionParameters[3] = null;\r\n\r\n        this._blendEquationParameters[0] = null;\r\n        this._blendEquationParameters[1] = null;\r\n\r\n        this._blendConstants[0] = null;\r\n        this._blendConstants[1] = null;\r\n        this._blendConstants[2] = null;\r\n        this._blendConstants[3] = null;\r\n\r\n        this._isAlphaBlendDirty = true;\r\n        this._isBlendFunctionParametersDirty = false;\r\n        this._isBlendEquationParametersDirty = false;\r\n        this._isBlendConstantsDirty = false;\r\n    }\r\n\r\n    public apply(gl: WebGLRenderingContext) {\r\n        if (!this.isDirty) {\r\n            return;\r\n        }\r\n\r\n        // Alpha blend\r\n        if (this._isAlphaBlendDirty) {\r\n            if (this._alphaBlend) {\r\n                gl.enable(gl.BLEND);\r\n            } else {\r\n                gl.disable(gl.BLEND);\r\n            }\r\n\r\n            this._isAlphaBlendDirty = false;\r\n        }\r\n\r\n        // Alpha function\r\n        if (this._isBlendFunctionParametersDirty) {\r\n            gl.blendFuncSeparate(\r\n                <number>this._blendFunctionParameters[0],\r\n                <number>this._blendFunctionParameters[1],\r\n                <number>this._blendFunctionParameters[2],\r\n                <number>this._blendFunctionParameters[3]\r\n            );\r\n            this._isBlendFunctionParametersDirty = false;\r\n        }\r\n\r\n        // Alpha equation\r\n        if (this._isBlendEquationParametersDirty) {\r\n            gl.blendEquationSeparate(this._blendEquationParameters[0]!, this._blendEquationParameters[1]!);\r\n            this._isBlendEquationParametersDirty = false;\r\n        }\r\n\r\n        // Constants\r\n        if (this._isBlendConstantsDirty) {\r\n            gl.blendColor(<number>this._blendConstants[0], <number>this._blendConstants[1], <number>this._blendConstants[2], <number>this._blendConstants[3]);\r\n            this._isBlendConstantsDirty = false;\r\n        }\r\n    }\r\n}\r\n", "import { Constants } from \"../../Engines/constants\";\r\nimport type { Nullable } from \"../../types\";\r\n\r\n/**\r\n * Class used to store a texture sampler data\r\n */\r\nexport class TextureSampler {\r\n    /**\r\n     * Gets the sampling mode of the texture\r\n     */\r\n    public samplingMode: number = -1;\r\n\r\n    /**\r\n     * | Value | Type               | Description |\r\n     * | ----- | ------------------ | ----------- |\r\n     * | 0     | CLAMP_ADDRESSMODE  |             |\r\n     * | 1     | WRAP_ADDRESSMODE   |             |\r\n     * | 2     | MIRROR_ADDRESSMODE |             |\r\n     */\r\n    public get wrapU() {\r\n        return this._cachedWrapU;\r\n    }\r\n\r\n    public set wrapU(value: Nullable<number>) {\r\n        this._cachedWrapU = value;\r\n    }\r\n\r\n    /**\r\n     * | Value | Type               | Description |\r\n     * | ----- | ------------------ | ----------- |\r\n     * | 0     | CLAMP_ADDRESSMODE  |             |\r\n     * | 1     | WRAP_ADDRESSMODE   |             |\r\n     * | 2     | MIRROR_ADDRESSMODE |             |\r\n     */\r\n    public get wrapV() {\r\n        return this._cachedWrapV;\r\n    }\r\n\r\n    public set wrapV(value: Nullable<number>) {\r\n        this._cachedWrapV = value;\r\n    }\r\n\r\n    /**\r\n     * | Value | Type               | Description |\r\n     * | ----- | ------------------ | ----------- |\r\n     * | 0     | CLAMP_ADDRESSMODE  |             |\r\n     * | 1     | WRAP_ADDRESSMODE   |             |\r\n     * | 2     | MIRROR_ADDRESSMODE |             |\r\n     */\r\n    public get wrapR() {\r\n        return this._cachedWrapR;\r\n    }\r\n\r\n    public set wrapR(value: Nullable<number>) {\r\n        this._cachedWrapR = value;\r\n    }\r\n\r\n    /**\r\n     * With compliant hardware and browser (supporting anisotropic filtering)\r\n     * this defines the level of anisotropic filtering in the texture.\r\n     * The higher the better but the slower.\r\n     */\r\n    public get anisotropicFilteringLevel() {\r\n        return this._cachedAnisotropicFilteringLevel;\r\n    }\r\n\r\n    public set anisotropicFilteringLevel(value: Nullable<number>) {\r\n        this._cachedAnisotropicFilteringLevel = value;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the comparison function (Constants.LESS, Constants.EQUAL, etc). Set 0 to not use a comparison function\r\n     */\r\n    public get comparisonFunction() {\r\n        return this._comparisonFunction;\r\n    }\r\n\r\n    public set comparisonFunction(value: number) {\r\n        this._comparisonFunction = value;\r\n    }\r\n\r\n    private _useMipMaps = true;\r\n    /**\r\n     * Indicates to use the mip maps (if available on the texture).\r\n     * Thanks to this flag, you can instruct the sampler to not sample the mipmaps even if they exist (and if the sampling mode is set to a value that normally samples the mipmaps!)\r\n     */\r\n    public get useMipMaps() {\r\n        return this._useMipMaps;\r\n    }\r\n\r\n    public set useMipMaps(value: boolean) {\r\n        this._useMipMaps = value;\r\n    }\r\n\r\n    /** @internal */\r\n    public _cachedWrapU: Nullable<number> = null;\r\n\r\n    /** @internal */\r\n    public _cachedWrapV: Nullable<number> = null;\r\n\r\n    /** @internal */\r\n    public _cachedWrapR: Nullable<number> = null;\r\n\r\n    /** @internal */\r\n    public _cachedAnisotropicFilteringLevel: Nullable<number> = null;\r\n\r\n    /** @internal */\r\n    public _comparisonFunction: number = 0;\r\n\r\n    /**\r\n     * General label used for debugging or storing a name.\r\n     */\r\n    public label?: string;\r\n\r\n    /**\r\n     * Creates a Sampler instance\r\n     */\r\n    constructor() {}\r\n\r\n    /**\r\n     * Sets all the parameters of the sampler\r\n     * @param wrapU u address mode (default: TEXTURE_WRAP_ADDRESSMODE)\r\n     * @param wrapV v address mode (default: TEXTURE_WRAP_ADDRESSMODE)\r\n     * @param wrapR r address mode (default: TEXTURE_WRAP_ADDRESSMODE)\r\n     * @param anisotropicFilteringLevel anisotropic level (default: 1)\r\n     * @param samplingMode sampling mode (default: Constants.TEXTURE_BILINEAR_SAMPLINGMODE)\r\n     * @param comparisonFunction comparison function (default: 0 - no comparison function)\r\n     * @returns the current sampler instance\r\n     */\r\n    public setParameters(\r\n        wrapU = Constants.TEXTURE_WRAP_ADDRESSMODE,\r\n        wrapV = Constants.TEXTURE_WRAP_ADDRESSMODE,\r\n        wrapR = Constants.TEXTURE_WRAP_ADDRESSMODE,\r\n        anisotropicFilteringLevel = 1,\r\n        samplingMode = Constants.TEXTURE_BILINEAR_SAMPLINGMODE,\r\n        comparisonFunction = 0\r\n    ): TextureSampler {\r\n        this._cachedWrapU = wrapU;\r\n        this._cachedWrapV = wrapV;\r\n        this._cachedWrapR = wrapR;\r\n        this._cachedAnisotropicFilteringLevel = anisotropicFilteringLevel;\r\n        this.samplingMode = samplingMode;\r\n        this._comparisonFunction = comparisonFunction;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Compares this sampler with another one\r\n     * @param other sampler to compare with\r\n     * @returns true if the samplers have the same parametres, else false\r\n     */\r\n    public compareSampler(other: TextureSampler): boolean {\r\n        return (\r\n            this._cachedWrapU === other._cachedWrapU &&\r\n            this._cachedWrapV === other._cachedWrapV &&\r\n            this._cachedWrapR === other._cachedWrapR &&\r\n            this._cachedAnisotropicFilteringLevel === other._cachedAnisotropicFilteringLevel &&\r\n            this.samplingMode === other.samplingMode &&\r\n            this._comparisonFunction === other._comparisonFunction &&\r\n            this._useMipMaps === other._useMipMaps\r\n        );\r\n    }\r\n}\r\n", "import { Observable } from \"../../Misc/observable\";\r\nimport type { ImageSource, Nullable, int } from \"../../types\";\r\nimport type { ICanvas, ICanvasRenderingContext } from \"../../Engines/ICanvas\";\r\nimport type { HardwareTextureWrapper } from \"./hardwareTextureWrapper\";\r\nimport { TextureSampler } from \"./textureSampler\";\r\n\r\nimport type { AbstractEngine } from \"../../Engines/abstractEngine\";\r\nimport type { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport type { SphericalPolynomial } from \"../../Maths/sphericalPolynomial\";\r\n\r\n/**\r\n * Defines the source of the internal texture\r\n */\r\nexport const enum InternalTextureSource {\r\n    /**\r\n     * The source of the texture data is unknown\r\n     */\r\n    Unknown,\r\n    /**\r\n     * Texture data comes from an URL\r\n     */\r\n    Url,\r\n    /**\r\n     * Texture data is only used for temporary storage\r\n     */\r\n    Temp,\r\n    /**\r\n     * Texture data comes from raw data (ArrayBuffer)\r\n     */\r\n    Raw,\r\n    /**\r\n     * Texture content is dynamic (video or dynamic texture)\r\n     */\r\n    Dynamic,\r\n    /**\r\n     * Texture content is generated by rendering to it\r\n     */\r\n    RenderTarget,\r\n    /**\r\n     * Texture content is part of a multi render target process\r\n     */\r\n    MultiRenderTarget,\r\n    /**\r\n     * Texture data comes from a cube data file\r\n     */\r\n    Cube,\r\n    /**\r\n     * Texture data comes from a raw cube data\r\n     */\r\n    CubeRaw,\r\n    /**\r\n     * Texture data come from a prefiltered cube data file\r\n     */\r\n    CubePrefiltered,\r\n    /**\r\n     * Texture content is raw 3D data\r\n     */\r\n    Raw3D,\r\n    /**\r\n     * Texture content is raw 2D array data\r\n     */\r\n    Raw2DArray,\r\n    /**\r\n     * Texture content is a depth/stencil texture\r\n     */\r\n    DepthStencil,\r\n    /**\r\n     * Texture data comes from a raw cube data encoded with RGBD\r\n     */\r\n    CubeRawRGBD,\r\n    /**\r\n     * Texture content is a depth texture\r\n     */\r\n    Depth,\r\n}\r\n\r\n/**\r\n * Class used to store data associated with WebGL texture data for the engine\r\n * This class should not be used directly\r\n */\r\nexport class InternalTexture extends TextureSampler {\r\n    /**\r\n     * Defines if the texture is ready\r\n     */\r\n    public isReady: boolean = false;\r\n    /**\r\n     * Defines if the texture is a cube texture\r\n     */\r\n    public isCube: boolean = false;\r\n    /**\r\n     * Defines if the texture contains 3D data\r\n     */\r\n    public is3D: boolean = false;\r\n    /**\r\n     * Defines if the texture contains 2D array data\r\n     */\r\n    public is2DArray: boolean = false;\r\n    /**\r\n     * Defines if the texture contains multiview data\r\n     */\r\n    public isMultiview: boolean = false;\r\n    /**\r\n     * Gets the URL used to load this texture\r\n     */\r\n    public url: string = \"\";\r\n    /** @internal */\r\n    public _originalUrl: string; // not empty only if different from url\r\n    /**\r\n     * Gets a boolean indicating if the texture needs mipmaps generation\r\n     */\r\n    public generateMipMaps: boolean = false;\r\n    /**\r\n     * Gets a boolean indicating if the texture uses mipmaps\r\n     * TODO implements useMipMaps as a separate setting from generateMipMaps\r\n     */\r\n    public override get useMipMaps() {\r\n        return this.generateMipMaps;\r\n    }\r\n    public override set useMipMaps(value: boolean) {\r\n        this.generateMipMaps = value;\r\n    }\r\n    /**\r\n     * Gets the number of samples used by the texture (WebGL2+ only)\r\n     */\r\n    public samples: number = 0;\r\n    /**\r\n     * Gets the type of the texture (int, float...)\r\n     */\r\n    public type: number = -1;\r\n    /**\r\n     * Gets the format of the texture (RGB, RGBA...)\r\n     */\r\n    public format: number = -1;\r\n    /**\r\n     * Observable called when the texture is loaded\r\n     */\r\n    public onLoadedObservable = new Observable<InternalTexture>();\r\n    /**\r\n     * Observable called when the texture load is raising an error\r\n     */\r\n    public onErrorObservable = new Observable<Partial<{ message: string; exception: any }>>();\r\n    /**\r\n     * If this callback is defined it will be called instead of the default _rebuild function\r\n     */\r\n    public onRebuildCallback: Nullable<\r\n        (internalTexture: InternalTexture) => {\r\n            proxy: Nullable<InternalTexture | Promise<InternalTexture>>;\r\n            isReady: boolean;\r\n            isAsync: boolean;\r\n        }\r\n    > = null;\r\n    /**\r\n     * Gets the width of the texture\r\n     */\r\n    public width: number = 0;\r\n    /**\r\n     * Gets the height of the texture\r\n     */\r\n    public height: number = 0;\r\n    /**\r\n     * Gets the depth of the texture\r\n     */\r\n    public depth: number = 0;\r\n    /**\r\n     * Gets the initial width of the texture (It could be rescaled if the current system does not support non power of two textures)\r\n     */\r\n    public baseWidth: number = 0;\r\n    /**\r\n     * Gets the initial height of the texture (It could be rescaled if the current system does not support non power of two textures)\r\n     */\r\n    public baseHeight: number = 0;\r\n    /**\r\n     * Gets the initial depth of the texture (It could be rescaled if the current system does not support non power of two textures)\r\n     */\r\n    public baseDepth: number = 0;\r\n    /**\r\n     * Gets a boolean indicating if the texture is inverted on Y axis\r\n     */\r\n    public invertY: boolean = false;\r\n\r\n    // Private\r\n    /** @internal */\r\n    public _invertVScale = false;\r\n    /** @internal */\r\n    public _associatedChannel = -1;\r\n    /** @internal */\r\n    public _source = InternalTextureSource.Unknown;\r\n    /** @internal */\r\n    public _buffer: Nullable<string | ArrayBuffer | ArrayBufferView | HTMLImageElement | Blob | ImageBitmap> = null;\r\n    /** @internal */\r\n    public _bufferView: Nullable<ArrayBufferView> = null;\r\n    /** @internal */\r\n    public _bufferViewArray: Nullable<ArrayBufferView[]> = null;\r\n    /** @internal */\r\n    public _bufferViewArrayArray: Nullable<ArrayBufferView[][]> = null;\r\n    /** @internal */\r\n    public _size: number = 0;\r\n    /** @internal */\r\n    public _extension: string = \"\";\r\n    /** @internal */\r\n    public _files: Nullable<string[]> = null;\r\n    /** @internal */\r\n    public _workingCanvas: Nullable<ICanvas> = null;\r\n    /** @internal */\r\n    public _workingContext: Nullable<ICanvasRenderingContext> = null;\r\n    /** @internal */\r\n    public _cachedCoordinatesMode: Nullable<number> = null;\r\n    /** @internal */\r\n    public _isDisabled: boolean = false;\r\n    /** @internal */\r\n    public _compression: Nullable<string> = null;\r\n    /** @internal */\r\n    public _sphericalPolynomial: Nullable<SphericalPolynomial> = null;\r\n    /** @internal */\r\n    public _sphericalPolynomialPromise: Nullable<Promise<SphericalPolynomial>> = null;\r\n    /** @internal */\r\n    public _sphericalPolynomialComputed = false;\r\n    /** @internal */\r\n    public _lodGenerationScale: number = 0;\r\n    /** @internal */\r\n    public _lodGenerationOffset: number = 0;\r\n    /** @internal */\r\n    public _useSRGBBuffer: boolean = false;\r\n    /** @internal */\r\n    public _creationFlags: number = 0;\r\n    /** @internal */\r\n    public _originalFormat?: number;\r\n\r\n    // The following three fields helps sharing generated fixed LODs for texture filtering\r\n    // In environment not supporting the textureLOD extension like EDGE. They are for internal use only.\r\n    // They are at the level of the gl texture to benefit from the cache.\r\n    /** @internal */\r\n    public _lodTextureHigh: Nullable<BaseTexture> = null;\r\n    /** @internal */\r\n    public _lodTextureMid: Nullable<BaseTexture> = null;\r\n    /** @internal */\r\n    public _lodTextureLow: Nullable<BaseTexture> = null;\r\n    /** @internal */\r\n    public _isRGBD: boolean = false;\r\n\r\n    /** @internal */\r\n    public _linearSpecularLOD: boolean = false;\r\n    /** @internal */\r\n    public _irradianceTexture: Nullable<BaseTexture> = null;\r\n\r\n    /** @internal */\r\n    public _hardwareTexture: Nullable<HardwareTextureWrapper> = null;\r\n\r\n    /** @internal */\r\n    public _maxLodLevel: Nullable<number> = null;\r\n\r\n    /** @internal */\r\n    public _references: number = 1;\r\n\r\n    /** @internal */\r\n    public _gammaSpace: Nullable<boolean> = null;\r\n\r\n    /** @internal */\r\n    public _premulAlpha = false;\r\n\r\n    /** @internal */\r\n    public _dynamicTextureSource: Nullable<ImageSource> = null;\r\n\r\n    /** @internal */\r\n    public _autoMSAAManagement = false;\r\n\r\n    private _engine: AbstractEngine;\r\n    private _uniqueId: number;\r\n\r\n    /** @internal */\r\n    public static _Counter = 0;\r\n\r\n    /** Gets the unique id of the internal texture */\r\n    public get uniqueId() {\r\n        return this._uniqueId;\r\n    }\r\n\r\n    /** @internal */\r\n    public _setUniqueId(id: number) {\r\n        this._uniqueId = id;\r\n    }\r\n\r\n    /**\r\n     * Gets the Engine the texture belongs to.\r\n     * @returns The babylon engine\r\n     */\r\n    public getEngine(): AbstractEngine {\r\n        return this._engine;\r\n    }\r\n\r\n    /**\r\n     * Gets the data source type of the texture\r\n     */\r\n    public get source(): InternalTextureSource {\r\n        return this._source;\r\n    }\r\n\r\n    /**\r\n     * Creates a new InternalTexture\r\n     * @param engine defines the engine to use\r\n     * @param source defines the type of data that will be used\r\n     * @param delayAllocation if the texture allocation should be delayed (default: false)\r\n     */\r\n    constructor(engine: AbstractEngine, source: InternalTextureSource, delayAllocation = false) {\r\n        super();\r\n\r\n        this._engine = engine;\r\n        this._source = source;\r\n        this._uniqueId = InternalTexture._Counter++;\r\n\r\n        if (!delayAllocation) {\r\n            this._hardwareTexture = engine._createHardwareTexture();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Increments the number of references (ie. the number of Texture that point to it)\r\n     */\r\n    public incrementReferences(): void {\r\n        this._references++;\r\n    }\r\n\r\n    /**\r\n     * Change the size of the texture (not the size of the content)\r\n     * @param width defines the new width\r\n     * @param height defines the new height\r\n     * @param depth defines the new depth (1 by default)\r\n     */\r\n    public updateSize(width: int, height: int, depth: int = 1): void {\r\n        this._engine.updateTextureDimensions(this, width, height, depth);\r\n\r\n        this.width = width;\r\n        this.height = height;\r\n        this.depth = depth;\r\n\r\n        this.baseWidth = width;\r\n        this.baseHeight = height;\r\n        this.baseDepth = depth;\r\n\r\n        this._size = width * height * depth;\r\n    }\r\n\r\n    /** @internal */\r\n    public _rebuild(): void {\r\n        this.isReady = false;\r\n        this._cachedCoordinatesMode = null;\r\n        this._cachedWrapU = null;\r\n        this._cachedWrapV = null;\r\n        this._cachedWrapR = null;\r\n        this._cachedAnisotropicFilteringLevel = null;\r\n        if (this.onRebuildCallback) {\r\n            const data = this.onRebuildCallback(this);\r\n            const swapAndSetIsReady = (proxyInternalTexture: InternalTexture) => {\r\n                proxyInternalTexture._swapAndDie(this, false);\r\n                this.isReady = data.isReady;\r\n            };\r\n            if (data.isAsync) {\r\n                (data.proxy as Promise<InternalTexture>).then(swapAndSetIsReady);\r\n            } else {\r\n                swapAndSetIsReady(data.proxy as InternalTexture);\r\n            }\r\n            return;\r\n        }\r\n\r\n        let proxy: InternalTexture;\r\n        switch (this.source) {\r\n            case InternalTextureSource.Temp:\r\n                break;\r\n\r\n            case InternalTextureSource.Url:\r\n                proxy = this._engine.createTexture(\r\n                    this._originalUrl ?? this.url,\r\n                    !this.generateMipMaps,\r\n                    this.invertY,\r\n                    null,\r\n                    this.samplingMode,\r\n                    // Do not use Proxy here as it could be fully synchronous\r\n                    // and proxy would be undefined.\r\n                    (temp) => {\r\n                        temp._swapAndDie(this, false);\r\n                        this.isReady = true;\r\n                    },\r\n                    null,\r\n                    this._buffer,\r\n                    undefined,\r\n                    this.format,\r\n                    this._extension,\r\n                    undefined,\r\n                    undefined,\r\n                    undefined,\r\n                    this._useSRGBBuffer\r\n                );\r\n                return;\r\n\r\n            case InternalTextureSource.Raw:\r\n                proxy = this._engine.createRawTexture(\r\n                    this._bufferView,\r\n                    this.baseWidth,\r\n                    this.baseHeight,\r\n                    this.format,\r\n                    this.generateMipMaps,\r\n                    this.invertY,\r\n                    this.samplingMode,\r\n                    this._compression,\r\n                    this.type,\r\n                    this._creationFlags,\r\n                    this._useSRGBBuffer\r\n                );\r\n                proxy._swapAndDie(this, false);\r\n\r\n                this.isReady = true;\r\n                break;\r\n\r\n            case InternalTextureSource.Raw3D:\r\n                proxy = this._engine.createRawTexture3D(\r\n                    this._bufferView,\r\n                    this.baseWidth,\r\n                    this.baseHeight,\r\n                    this.baseDepth,\r\n                    this.format,\r\n                    this.generateMipMaps,\r\n                    this.invertY,\r\n                    this.samplingMode,\r\n                    this._compression,\r\n                    this.type\r\n                );\r\n                proxy._swapAndDie(this, false);\r\n\r\n                this.isReady = true;\r\n                break;\r\n\r\n            case InternalTextureSource.Raw2DArray:\r\n                proxy = this._engine.createRawTexture2DArray(\r\n                    this._bufferView,\r\n                    this.baseWidth,\r\n                    this.baseHeight,\r\n                    this.baseDepth,\r\n                    this.format,\r\n                    this.generateMipMaps,\r\n                    this.invertY,\r\n                    this.samplingMode,\r\n                    this._compression,\r\n                    this.type\r\n                );\r\n                proxy._swapAndDie(this, false);\r\n\r\n                this.isReady = true;\r\n                break;\r\n\r\n            case InternalTextureSource.Dynamic:\r\n                proxy = this._engine.createDynamicTexture(this.baseWidth, this.baseHeight, this.generateMipMaps, this.samplingMode);\r\n                proxy._swapAndDie(this, false);\r\n                if (this._dynamicTextureSource) {\r\n                    this._engine.updateDynamicTexture(this, this._dynamicTextureSource, this.invertY, this._premulAlpha, this.format, true);\r\n                }\r\n\r\n                // The engine will make sure to update content so no need to flag it as isReady = true\r\n                break;\r\n\r\n            case InternalTextureSource.Cube:\r\n                proxy = this._engine.createCubeTexture(\r\n                    this.url,\r\n                    null,\r\n                    this._files,\r\n                    !this.generateMipMaps,\r\n                    () => {\r\n                        proxy._swapAndDie(this, false);\r\n                        this.isReady = true;\r\n                    },\r\n                    null,\r\n                    this.format,\r\n                    this._extension,\r\n                    false,\r\n                    0,\r\n                    0,\r\n                    null,\r\n                    undefined,\r\n                    this._useSRGBBuffer,\r\n                    ArrayBuffer.isView(this._buffer) ? this._buffer : null\r\n                );\r\n                return;\r\n\r\n            case InternalTextureSource.CubeRaw:\r\n                proxy = this._engine.createRawCubeTexture(\r\n                    this._bufferViewArray!,\r\n                    this.width,\r\n                    this._originalFormat ?? this.format,\r\n                    this.type,\r\n                    this.generateMipMaps,\r\n                    this.invertY,\r\n                    this.samplingMode,\r\n                    this._compression\r\n                );\r\n                proxy._swapAndDie(this, false);\r\n                this.isReady = true;\r\n                break;\r\n\r\n            case InternalTextureSource.CubeRawRGBD:\r\n                // This case is being handeled by the environment texture tools and is not a part of the rebuild process.\r\n                // To use CubeRawRGBD use updateRGBDAsync on the cube texture.\r\n                return;\r\n\r\n            case InternalTextureSource.CubePrefiltered:\r\n                proxy = this._engine.createPrefilteredCubeTexture(\r\n                    this.url,\r\n                    null,\r\n                    this._lodGenerationScale,\r\n                    this._lodGenerationOffset,\r\n                    (proxy) => {\r\n                        if (proxy) {\r\n                            proxy._swapAndDie(this, false);\r\n                        }\r\n                        this.isReady = true;\r\n                    },\r\n                    null,\r\n                    this.format,\r\n                    this._extension\r\n                );\r\n                proxy._sphericalPolynomial = this._sphericalPolynomial;\r\n                return;\r\n\r\n            case InternalTextureSource.DepthStencil:\r\n            case InternalTextureSource.Depth: {\r\n                // Will be handled at the RenderTargetWrapper level\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _swapAndDie(target: InternalTexture, swapAll = true): void {\r\n        // TODO what about refcount on target?\r\n\r\n        this._hardwareTexture?.setUsage(target._source, this.generateMipMaps, this.is2DArray, this.isCube, this.is3D, this.width, this.height, this.depth);\r\n\r\n        target._hardwareTexture = this._hardwareTexture;\r\n        if (swapAll) {\r\n            target._isRGBD = this._isRGBD;\r\n        }\r\n\r\n        if (this._lodTextureHigh) {\r\n            if (target._lodTextureHigh) {\r\n                target._lodTextureHigh.dispose();\r\n            }\r\n            target._lodTextureHigh = this._lodTextureHigh;\r\n        }\r\n\r\n        if (this._lodTextureMid) {\r\n            if (target._lodTextureMid) {\r\n                target._lodTextureMid.dispose();\r\n            }\r\n            target._lodTextureMid = this._lodTextureMid;\r\n        }\r\n\r\n        if (this._lodTextureLow) {\r\n            if (target._lodTextureLow) {\r\n                target._lodTextureLow.dispose();\r\n            }\r\n            target._lodTextureLow = this._lodTextureLow;\r\n        }\r\n\r\n        if (this._irradianceTexture) {\r\n            if (target._irradianceTexture) {\r\n                target._irradianceTexture.dispose();\r\n            }\r\n            target._irradianceTexture = this._irradianceTexture;\r\n        }\r\n\r\n        const cache = this._engine.getLoadedTexturesCache();\r\n        let index = cache.indexOf(this);\r\n        if (index !== -1) {\r\n            cache.splice(index, 1);\r\n        }\r\n\r\n        index = cache.indexOf(target);\r\n        if (index === -1) {\r\n            cache.push(target);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Dispose the current allocated resources\r\n     */\r\n    public dispose(): void {\r\n        this._references--;\r\n        if (this._references === 0) {\r\n            this.onLoadedObservable.clear();\r\n            this.onErrorObservable.clear();\r\n            this._engine._releaseTexture(this);\r\n            this._hardwareTexture = null;\r\n            this._dynamicTextureSource = null;\r\n        }\r\n    }\r\n}\r\n", "import { Constants } from \"../Engines/constants\";\r\n\r\n/**\r\n * Function indicating if a number is an exponent of 2\r\n * @param value defines the value to test\r\n * @returns true if the value is an exponent of 2\r\n */\r\nexport function IsExponentOfTwo(value: number): boolean {\r\n    let count = 1;\r\n\r\n    do {\r\n        count *= 2;\r\n    } while (count < value);\r\n\r\n    return count === value;\r\n}\r\n\r\n/**\r\n * Interpolates between a and b via alpha\r\n * @param a The lower value (returned when alpha = 0)\r\n * @param b The upper value (returned when alpha = 1)\r\n * @param alpha The interpolation-factor\r\n * @returns The mixed value\r\n */\r\nexport function Mix(a: number, b: number, alpha: number): number {\r\n    return a * (1 - alpha) + b * alpha;\r\n}\r\n\r\n/**\r\n * Find the nearest power of two.\r\n * @param x Number to start search from.\r\n * @returns Next nearest power of two.\r\n */\r\nexport function NearestPOT(x: number): number {\r\n    const c = CeilingPOT(x);\r\n    const f = FloorPOT(x);\r\n    return c - x > x - f ? f : c;\r\n}\r\n\r\n/**\r\n * Find the next highest power of two.\r\n * @param x Number to start search from.\r\n * @returns Next highest power of two.\r\n */\r\nexport function CeilingPOT(x: number): number {\r\n    x--;\r\n    x |= x >> 1;\r\n    x |= x >> 2;\r\n    x |= x >> 4;\r\n    x |= x >> 8;\r\n    x |= x >> 16;\r\n    x++;\r\n    return x;\r\n}\r\n\r\n/**\r\n * Find the next lowest power of two.\r\n * @param x Number to start search from.\r\n * @returns Next lowest power of two.\r\n */\r\nexport function FloorPOT(x: number): number {\r\n    x = x | (x >> 1);\r\n    x = x | (x >> 2);\r\n    x = x | (x >> 4);\r\n    x = x | (x >> 8);\r\n    x = x | (x >> 16);\r\n    return x - (x >> 1);\r\n}\r\n\r\n/**\r\n * Get the closest exponent of two\r\n * @param value defines the value to approximate\r\n * @param max defines the maximum value to return\r\n * @param mode defines how to define the closest value\r\n * @returns closest exponent of two of the given value\r\n */\r\nexport function GetExponentOfTwo(value: number, max: number, mode = Constants.SCALEMODE_NEAREST): number {\r\n    let pot;\r\n\r\n    switch (mode) {\r\n        case Constants.SCALEMODE_FLOOR:\r\n            pot = FloorPOT(value);\r\n            break;\r\n        case Constants.SCALEMODE_NEAREST:\r\n            pot = NearestPOT(value);\r\n            break;\r\n        case Constants.SCALEMODE_CEILING:\r\n        default:\r\n            pot = CeilingPOT(value);\r\n            break;\r\n    }\r\n\r\n    return Math.min(pot, max);\r\n}\r\n", "import type { IInternalTextureLoader } from \"./internalTextureLoader\";\r\nimport type { Nullable } from \"../../../types\";\r\nimport { Logger } from \"core/Misc/logger\";\r\n\r\nconst _registeredTextureLoaders = new Map<string, (mimeType?: string) => IInternalTextureLoader | Promise<IInternalTextureLoader>>();\r\n\r\n/**\r\n * Registers a texture loader.\r\n * If a loader for the extension exists in the registry, it will be replaced.\r\n * @param extension The name of the loader extension.\r\n * @param loaderFactory The factory function that creates the loader extension.\r\n */\r\nexport function registerTextureLoader(extension: string, loaderFactory: (mimeType?: string) => IInternalTextureLoader | Promise<IInternalTextureLoader>): void {\r\n    if (unregisterTextureLoader(extension)) {\r\n        Logger.Warn(`Extension with the name '${name}' already exists`);\r\n    }\r\n    _registeredTextureLoaders.set(extension, loaderFactory);\r\n}\r\n\r\n/**\r\n * Unregisters a texture loader.\r\n * @param extension The name of the loader extension.\r\n * @returns A boolean indicating whether the extension has been unregistered\r\n */\r\nexport function unregisterTextureLoader(extension: string): boolean {\r\n    return _registeredTextureLoaders.delete(extension);\r\n}\r\n\r\n/**\r\n * Function used to get the correct texture loader for a specific extension.\r\n * @param extension defines the file extension of the file being loaded\r\n * @param mimeType defines the optional mime type of the file being loaded\r\n * @returns the IInternalTextureLoader or null if it wasn't found\r\n */\r\nexport function _GetCompatibleTextureLoader(extension: string, mimeType?: string): Nullable<Promise<IInternalTextureLoader>> {\r\n    if (mimeType === \"image/ktx\" || mimeType === \"image/ktx2\") {\r\n        extension = \".ktx\";\r\n    }\r\n    if (!_registeredTextureLoaders.has(extension)) {\r\n        if (extension.endsWith(\".ies\")) {\r\n            registerTextureLoader(\".ies\", () => import(\"./iesTextureLoader\").then((module) => new module._IESTextureLoader()));\r\n        }\r\n        if (extension.endsWith(\".dds\")) {\r\n            registerTextureLoader(\".dds\", () => import(\"./ddsTextureLoader\").then((module) => new module._DDSTextureLoader()));\r\n        }\r\n        if (extension.endsWith(\".basis\")) {\r\n            registerTextureLoader(\".basis\", () => import(\"./basisTextureLoader\").then((module) => new module._BasisTextureLoader()));\r\n        }\r\n        if (extension.endsWith(\".env\")) {\r\n            registerTextureLoader(\".env\", () => import(\"./envTextureLoader\").then((module) => new module._ENVTextureLoader()));\r\n        }\r\n        if (extension.endsWith(\".hdr\")) {\r\n            registerTextureLoader(\".hdr\", () => import(\"./hdrTextureLoader\").then((module) => new module._HDRTextureLoader()));\r\n        }\r\n        // The \".ktx2\" file extension is still up for debate: https://github.com/KhronosGroup/KTX-Specification/issues/18\r\n        if (extension.endsWith(\".ktx\") || extension.endsWith(\".ktx2\")) {\r\n            registerTextureLoader(\".ktx\", () => import(\"./ktxTextureLoader\").then((module) => new module._KTXTextureLoader()));\r\n            registerTextureLoader(\".ktx2\", () => import(\"./ktxTextureLoader\").then((module) => new module._KTXTextureLoader()));\r\n        }\r\n        if (extension.endsWith(\".tga\")) {\r\n            registerTextureLoader(\".tga\", () => import(\"./tgaTextureLoader\").then((module) => new module._TGATextureLoader()));\r\n        }\r\n        if (extension.endsWith(\".exr\")) {\r\n            registerTextureLoader(\".exr\", () => import(\"./exrTextureLoader\").then((module) => new module._ExrTextureLoader()));\r\n        }\r\n    }\r\n    const registered = _registeredTextureLoaders.get(extension);\r\n    return registered ? Promise.resolve(registered(mimeType)) : null;\r\n}\r\n", "import type { Observer } from \"../Misc/observable\";\r\nimport type { DataArray, FloatArray, IndicesArray, Nullable } from \"../types\";\r\nimport type { PerfCounter } from \"../Misc/perfCounter\";\r\nimport type { PostProcess } from \"../PostProcesses/postProcess\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { IColor4Like, IViewportLike } from \"../Maths/math.like\";\r\nimport type { ICanvas, IImage, IPath2D } from \"./ICanvas\";\r\nimport type { HardwareTextureWrapper } from \"../Materials/Textures/hardwareTextureWrapper\";\r\nimport type { EngineCapabilities } from \"./engineCapabilities\";\r\nimport type { DataBuffer } from \"../Buffers/dataBuffer\";\r\nimport type { RenderTargetWrapper } from \"./renderTargetWrapper\";\r\nimport type { IShaderProcessor } from \"./Processors/iShaderProcessor\";\r\nimport type { ShaderLanguage } from \"../Materials/shaderLanguage\";\r\nimport type { IAudioEngineOptions } from \"../Audio/Interfaces/IAudioEngineOptions\";\r\nimport type { EngineFeatures } from \"./engineFeatures\";\r\nimport type { UniformBuffer } from \"../Materials/uniformBuffer\";\r\nimport type { StorageBuffer } from \"../Buffers/storageBuffer\";\r\nimport type { IEffectCreationOptions, IShaderPath } from \"../Materials/effect\";\r\nimport type { IOfflineProvider } from \"../Offline/IOfflineProvider\";\r\nimport type { IWebRequest } from \"../Misc/interfaces/iWebRequest\";\r\nimport type { IFileRequest } from \"../Misc/fileRequest\";\r\nimport type { Texture } from \"../Materials/Textures/texture\";\r\nimport type { LoadFileError } from \"../Misc/fileTools\";\r\nimport type { ShaderProcessingContext } from \"./Processors/shaderProcessingOptions\";\r\nimport type { IPipelineContext } from \"./IPipelineContext\";\r\nimport type { ThinTexture } from \"../Materials/Textures/thinTexture\";\r\nimport type { InternalTextureCreationOptions, TextureSize } from \"../Materials/Textures/textureCreationOptions\";\r\nimport type { EffectFallbacks } from \"../Materials/effectFallbacks\";\r\nimport type { IMaterialContext } from \"./IMaterialContext\";\r\nimport type { IStencilState } from \"../States/IStencilState\";\r\nimport type { DrawWrapper } from \"../Materials/drawWrapper\";\r\nimport type { IDrawContext } from \"./IDrawContext\";\r\nimport type { VertexBuffer } from \"../Meshes/buffer\";\r\nimport type { IAudioEngine } from \"../Audio/Interfaces/IAudioEngine\";\r\nimport type { WebRequest } from \"core/Misc/webRequest\";\r\nimport type { PerformanceMonitor } from \"core/Misc/performanceMonitor\";\r\nimport type { ILoadingScreen } from \"../Loading/loadingScreen\";\r\nimport { EngineStore } from \"./engineStore\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { Effect } from \"../Materials/effect\";\r\nimport { PerformanceConfigurator } from \"./performanceConfigurator\";\r\nimport { PrecisionDate } from \"../Misc/precisionDate\";\r\nimport { DepthCullingState } from \"../States/depthCullingState\";\r\nimport { StencilStateComposer } from \"../States/stencilStateComposer\";\r\nimport { StencilState } from \"../States/stencilState\";\r\nimport { AlphaState } from \"../States/alphaCullingState\";\r\nimport { _WarnImport } from \"../Misc/devTools\";\r\nimport { InternalTexture, InternalTextureSource } from \"../Materials/Textures/internalTexture\";\r\nimport { IsDocumentAvailable, IsNavigatorAvailable, IsWindowObjectExist } from \"../Misc/domManagement\";\r\nimport { Constants } from \"./constants\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { EngineFunctionContext, _loadFile } from \"./abstractEngine.functions\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport { _GetCompatibleTextureLoader } from \"core/Materials/Textures/Loaders/textureLoaderManager\";\r\n\r\n/**\r\n * Defines the interface used by objects working like Scene\r\n * @internal\r\n */\r\nexport interface ISceneLike {\r\n    /** Add pending data  (to load) */\r\n    addPendingData(data: any): void;\r\n    /** Remove pending data */\r\n    removePendingData(data: any): void;\r\n    /** Offline provider */\r\n    offlineProvider: IOfflineProvider;\r\n}\r\n\r\n/**\r\n * Queue a new function into the requested animation frame pool (ie. this function will be executed by the browser (or the javascript engine) for the next frame)\r\n * @param func - the function to be called\r\n * @param requester - the object that will request the next frame. Falls back to window.\r\n * @returns frame number\r\n */\r\nexport function QueueNewFrame(func: () => void, requester?: any): number {\r\n    // Note that there is kind of a typing issue here, as `setTimeout` might return something else than a number (NodeJs returns a NodeJS.Timeout object).\r\n    // Also if the global `requestAnimationFrame`'s returnType is number, `requester.requestPostAnimationFrame` and `requester.requestAnimationFrame` types\r\n    // are `any`.\r\n\r\n    if (!IsWindowObjectExist()) {\r\n        if (typeof requestAnimationFrame === \"function\") {\r\n            return requestAnimationFrame(func);\r\n        }\r\n    } else {\r\n        const { requestAnimationFrame } = requester || window;\r\n        if (typeof requestAnimationFrame === \"function\") {\r\n            return requestAnimationFrame(func);\r\n        }\r\n    }\r\n\r\n    // fallback to the global `setTimeout`.\r\n    // In most cases (aka in the browser), `window` is the global object, so instead of calling `window.setTimeout` we could call the global `setTimeout`.\r\n    return setTimeout(func, 16) as unknown as number;\r\n}\r\n\r\n/** Interface defining initialization parameters for AbstractEngine class */\r\nexport interface AbstractEngineOptions {\r\n    /**\r\n     * Defines if the engine should no exceed a specified device ratio\r\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/Window/devicePixelRatio\r\n     */\r\n    limitDeviceRatio?: number;\r\n    /**\r\n     * Defines if webaudio should be initialized as well\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic\r\n     */\r\n    audioEngine?: boolean;\r\n    /**\r\n     * Specifies options for the audio engine\r\n     */\r\n    audioEngineOptions?: IAudioEngineOptions;\r\n\r\n    /**\r\n     * Defines if animations should run using a deterministic lock step\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#deterministic-lockstep\r\n     */\r\n    deterministicLockstep?: boolean;\r\n    /** Defines the maximum steps to use with deterministic lock step mode */\r\n    lockstepMaxSteps?: number;\r\n    /** Defines the seconds between each deterministic lock step */\r\n    timeStep?: number;\r\n    /**\r\n     * Defines that engine should ignore context lost events\r\n     * If this event happens when this parameter is true, you will have to reload the page to restore rendering\r\n     */\r\n    doNotHandleContextLost?: boolean;\r\n    /**\r\n     * Defines that engine should ignore modifying touch action attribute and style\r\n     * If not handle, you might need to set it up on your side for expected touch devices behavior.\r\n     */\r\n    doNotHandleTouchAction?: boolean;\r\n\r\n    /**\r\n     * Make the matrix computations to be performed in 64 bits instead of 32 bits. False by default\r\n     */\r\n    useHighPrecisionMatrix?: boolean;\r\n\r\n    /**\r\n     * Defines whether to adapt to the device's viewport characteristics (default: false)\r\n     */\r\n    adaptToDeviceRatio?: boolean;\r\n\r\n    /**\r\n     * Defines whether MSAA is enabled on the canvas.\r\n     */\r\n    antialias?: boolean;\r\n\r\n    /**\r\n     * Defines whether the stencil buffer should be enabled.\r\n     */\r\n    stencil?: boolean;\r\n\r\n    /**\r\n     * Defines whether the canvas should be created in \"premultiplied\" mode (if false, the canvas is created in the \"opaque\" mode) (true by default)\r\n     */\r\n    premultipliedAlpha?: boolean;\r\n    /**\r\n     * True if the more expensive but exact conversions should be used for transforming colors to and from linear space within shaders.\r\n     * Otherwise, the default is to use a cheaper approximation.\r\n     */\r\n    useExactSrgbConversions?: boolean;\r\n}\r\n\r\n/**\r\n * Information about the current host\r\n */\r\nexport interface HostInformation {\r\n    /**\r\n     * Defines if the current host is a mobile\r\n     */\r\n    isMobile: boolean;\r\n}\r\n\r\nexport type PrepareTextureProcessFunction = (\r\n    width: number,\r\n    height: number,\r\n    img: HTMLImageElement | ImageBitmap | { width: number; height: number },\r\n    extension: string,\r\n    texture: InternalTexture,\r\n    continuationCallback: () => void\r\n) => boolean;\r\n\r\nexport type PrepareTextureFunction = (\r\n    texture: InternalTexture,\r\n    extension: string,\r\n    scene: Nullable<ISceneLike>,\r\n    img: HTMLImageElement | ImageBitmap | { width: number; height: number },\r\n    invertY: boolean,\r\n    noMipmap: boolean,\r\n    isCompressed: boolean,\r\n    processFunction: PrepareTextureProcessFunction,\r\n    samplingMode: number\r\n) => void;\r\n\r\n/**\r\n * The parent class for specialized engines (WebGL, WebGPU)\r\n */\r\nexport abstract class AbstractEngine {\r\n    // States\r\n    /** @internal */\r\n    protected _colorWrite = true;\r\n    /** @internal */\r\n    protected _colorWriteChanged = true;\r\n    /** @internal */\r\n    public _depthCullingState = new DepthCullingState();\r\n    /** @internal */\r\n    protected _stencilStateComposer = new StencilStateComposer();\r\n    /** @internal */\r\n    public _stencilState = new StencilState();\r\n    /** @internal */\r\n    public _alphaState = new AlphaState();\r\n    /** @internal */\r\n    public _alphaMode = Constants.ALPHA_ADD;\r\n    /** @internal */\r\n    public _alphaEquation = Constants.ALPHA_DISABLE;\r\n\r\n    protected _activeRequests: IFileRequest[] = [];\r\n\r\n    /** @internal */\r\n    public _badOS = false;\r\n    /** @internal */\r\n    public _badDesktopOS = false;\r\n    /** @internal */\r\n    public _videoTextureSupported: boolean;\r\n\r\n    protected _compatibilityMode = true;\r\n    /** @internal */\r\n    public _pointerLockRequested: boolean;\r\n    /** @internal */\r\n    public _loadingScreen: ILoadingScreen;\r\n    /** @internal */\r\n    public _renderingCanvas: Nullable<HTMLCanvasElement>;\r\n    /** @internal */\r\n    public _internalTexturesCache = new Array<InternalTexture>();\r\n    protected _currentEffect: Nullable<Effect>;\r\n    /** @internal */\r\n    protected _cachedVertexBuffers: any;\r\n    /** @internal */\r\n    protected _cachedIndexBuffer: Nullable<DataBuffer>;\r\n    /** @internal */\r\n    protected _cachedEffectForVertexBuffers: Nullable<Effect>;\r\n    /** @internal */\r\n    public _currentRenderTarget: Nullable<RenderTargetWrapper> = null;\r\n    /** @internal */\r\n    public _caps: EngineCapabilities;\r\n    /** @internal */\r\n    protected _cachedViewport: Nullable<IViewportLike>;\r\n    /** @internal */\r\n    public _currentDrawContext: IDrawContext;\r\n\r\n    /** @internal */\r\n    protected _boundTexturesCache: { [key: string]: Nullable<InternalTexture> } = {};\r\n    /** @internal */\r\n    protected _activeChannel = 0;\r\n    /** @internal */\r\n    protected _currentTextureChannel = -1;\r\n    /** @internal */\r\n    protected _viewportCached = { x: 0, y: 0, z: 0, w: 0 };\r\n\r\n    /** @internal */\r\n    protected _isWebGPU: boolean = false;\r\n\r\n    // Focus\r\n    /** @internal */\r\n    public _onFocus: () => void;\r\n    /** @internal */\r\n    public _onBlur: () => void;\r\n    /** @internal */\r\n    public _onCanvasPointerOut: (event: PointerEvent) => void;\r\n    /** @internal */\r\n    public _onCanvasBlur: () => void;\r\n    /** @internal */\r\n    public _onCanvasFocus: () => void;\r\n    /** @internal */\r\n    public _onCanvasContextMenu: (evt: Event) => void;\r\n    /** @internal */\r\n    public _onFullscreenChange: () => void;\r\n\r\n    /**\r\n     * Observable event triggered each time the canvas loses focus\r\n     */\r\n    public onCanvasBlurObservable = new Observable<AbstractEngine>();\r\n    /**\r\n     * Observable event triggered each time the canvas gains focus\r\n     */\r\n    public onCanvasFocusObservable = new Observable<AbstractEngine>();\r\n\r\n    /**\r\n     * Event raised when a new scene is created\r\n     */\r\n    public onNewSceneAddedObservable = new Observable<Scene>();\r\n\r\n    /**\r\n     * Observable event triggered each time the rendering canvas is resized\r\n     */\r\n    public onResizeObservable = new Observable<AbstractEngine>();\r\n\r\n    /**\r\n     * Observable event triggered each time the canvas receives pointerout event\r\n     */\r\n    public onCanvasPointerOutObservable = new Observable<PointerEvent>();\r\n\r\n    /**\r\n     * Observable event triggered each time an effect compilation fails\r\n     */\r\n    public onEffectErrorObservable = new Observable<{ effect: Effect; errors: string }>();\r\n\r\n    /**\r\n     * Turn this value on if you want to pause FPS computation when in background\r\n     */\r\n    public disablePerformanceMonitorInBackground = false;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that vertex array object must be disabled even if they are supported\r\n     */\r\n    public disableVertexArrayObjects = false;\r\n\r\n    /** @internal */\r\n    protected _frameId = 0;\r\n    /**\r\n     * Gets the current frame id\r\n     */\r\n    public get frameId(): number {\r\n        return this._frameId;\r\n    }\r\n    /**\r\n     * Gets a boolean indicating if the engine runs in WebGPU or not.\r\n     */\r\n    public get isWebGPU(): boolean {\r\n        return this._isWebGPU;\r\n    }\r\n\r\n    protected _shaderProcessor: Nullable<IShaderProcessor>;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getShaderProcessor(shaderLanguage: ShaderLanguage): Nullable<IShaderProcessor> {\r\n        return this._shaderProcessor;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if all created effects are ready\r\n     * @returns true if all effects are ready\r\n     */\r\n    public abstract areAllEffectsReady(): boolean;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public abstract _executeWhenRenderingStateIsCompiled(pipelineContext: IPipelineContext, action: () => void): void;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public abstract _setTexture(channel: number, texture: Nullable<ThinTexture>, isPartOfTextureArray?: boolean, depthStencilTexture?: boolean, name?: string): boolean;\r\n\r\n    /**\r\n     * Sets a texture to the according uniform.\r\n     * @param channel The texture channel\r\n     * @param unused unused parameter\r\n     * @param texture The texture to apply\r\n     * @param name The name of the uniform in the effect\r\n     */\r\n    public abstract setTexture(channel: number, unused: Nullable<WebGLUniformLocation>, texture: Nullable<ThinTexture>, name: string): void;\r\n\r\n    /**\r\n     * Binds an effect to the webGL context\r\n     * @param effect defines the effect to bind\r\n     */\r\n    public abstract bindSamplers(effect: Effect): void;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public abstract _bindTexture(channel: number, texture: Nullable<InternalTexture>, name: string): void;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public abstract _deletePipelineContext(pipelineContext: IPipelineContext): void;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public abstract _preparePipelineContext(\r\n        pipelineContext: IPipelineContext,\r\n        vertexSourceCode: string,\r\n        fragmentSourceCode: string,\r\n        createAsRaw: boolean,\r\n        rawVertexSourceCode: string,\r\n        rawFragmentSourceCode: string,\r\n        rebuildRebind: any,\r\n        defines: Nullable<string>,\r\n        transformFeedbackVaryings: Nullable<string[]>,\r\n        key: string,\r\n        onReady: () => void\r\n    ): void;\r\n\r\n    /** @internal */\r\n    protected _shaderPlatformName: string;\r\n    /**\r\n     * Gets the shader platform name used by the effects.\r\n     */\r\n    public get shaderPlatformName(): string {\r\n        return this._shaderPlatformName;\r\n    }\r\n\r\n    /**\r\n     * Gets information about the current host\r\n     */\r\n    public hostInformation: HostInformation = {\r\n        isMobile: false,\r\n    };\r\n\r\n    /**\r\n     * Gets a boolean indicating if the engine is currently rendering in fullscreen mode\r\n     */\r\n    public isFullscreen = false;\r\n\r\n    /**\r\n     * Gets or sets a boolean to enable/disable IndexedDB support and avoid XHR on .manifest\r\n     **/\r\n    public enableOfflineSupport = false;\r\n\r\n    /**\r\n     * Gets or sets a boolean to enable/disable checking manifest if IndexedDB support is enabled (js will always consider the database is up to date)\r\n     **/\r\n    public disableManifestCheck = false;\r\n\r\n    /**\r\n     * Gets or sets a boolean to enable/disable the context menu (right-click) from appearing on the main canvas\r\n     */\r\n    public disableContextMenu: boolean = true;\r\n\r\n    /**\r\n     * Gets or sets the current render pass id\r\n     */\r\n    public currentRenderPassId = Constants.RENDERPASS_MAIN;\r\n\r\n    /**\r\n     * Gets a boolean indicating if the pointer is currently locked\r\n     */\r\n    public isPointerLock = false;\r\n\r\n    /**\r\n     * Gets the list of created postprocesses\r\n     */\r\n    public postProcesses: PostProcess[] = [];\r\n\r\n    /** Gets or sets the tab index to set to the rendering canvas. 1 is the minimum value to set to be able to capture keyboard events */\r\n    public canvasTabIndex = 1;\r\n\r\n    /** @internal */\r\n    protected _onContextLost: (evt: Event) => void;\r\n    /** @internal */\r\n    protected _onContextRestored: (evt: Event) => void;\r\n    /** @internal */\r\n    protected _contextWasLost = false;\r\n\r\n    private _emptyTexture: Nullable<InternalTexture>;\r\n    private _emptyCubeTexture: Nullable<InternalTexture>;\r\n    private _emptyTexture3D: Nullable<InternalTexture>;\r\n    private _emptyTexture2DArray: Nullable<InternalTexture>;\r\n\r\n    protected _clearEmptyResources(): void {\r\n        this._emptyTexture = null;\r\n        this._emptyCubeTexture = null;\r\n        this._emptyTexture3D = null;\r\n        this._emptyTexture2DArray = null;\r\n    }\r\n\r\n    public abstract wipeCaches(bruteForce?: boolean): void;\r\n\r\n    private _useReverseDepthBuffer = false;\r\n    /**\r\n     * Gets or sets a boolean indicating if depth buffer should be reverse, going from far to near.\r\n     * This can provide greater z depth for distant objects.\r\n     */\r\n    public get useReverseDepthBuffer(): boolean {\r\n        return this._useReverseDepthBuffer;\r\n    }\r\n\r\n    public set useReverseDepthBuffer(useReverse) {\r\n        if (useReverse === this._useReverseDepthBuffer) {\r\n            return;\r\n        }\r\n\r\n        this._useReverseDepthBuffer = useReverse;\r\n\r\n        if (useReverse) {\r\n            this._depthCullingState.depthFunc = Constants.GEQUAL;\r\n        } else {\r\n            this._depthCullingState.depthFunc = Constants.LEQUAL;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Enable or disable color writing\r\n     * @param enable defines the state to set\r\n     */\r\n    public setColorWrite(enable: boolean): void {\r\n        if (enable !== this._colorWrite) {\r\n            this._colorWriteChanged = true;\r\n            this._colorWrite = enable;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if color writing is enabled\r\n     * @returns the current color writing state\r\n     */\r\n    public getColorWrite(): boolean {\r\n        return this._colorWrite;\r\n    }\r\n\r\n    /**\r\n     * Gets the depth culling state manager\r\n     */\r\n    public get depthCullingState(): DepthCullingState {\r\n        return this._depthCullingState;\r\n    }\r\n\r\n    /**\r\n     * Gets the alpha state manager\r\n     */\r\n    public get alphaState(): AlphaState {\r\n        return this._alphaState;\r\n    }\r\n\r\n    /**\r\n     * Gets the stencil state manager\r\n     */\r\n    public get stencilState(): StencilState {\r\n        return this._stencilState;\r\n    }\r\n\r\n    /**\r\n     * Gets the stencil state composer\r\n     */\r\n    public get stencilStateComposer(): StencilStateComposer {\r\n        return this._stencilStateComposer;\r\n    }\r\n\r\n    /**\r\n     * Indicates if the z range in NDC space is 0..1 (value: true) or -1..1 (value: false)\r\n     */\r\n    public readonly isNDCHalfZRange: boolean = false;\r\n\r\n    /**\r\n     * Indicates that the origin of the texture/framebuffer space is the bottom left corner. If false, the origin is top left\r\n     */\r\n    public readonly hasOriginBottomLeft: boolean = true;\r\n\r\n    /**\r\n     * Gets a boolean indicating if the exact sRGB conversions or faster approximations are used for converting to and from linear space.\r\n     */\r\n    public readonly useExactSrgbConversions: boolean;\r\n\r\n    /** @internal */\r\n    public _getGlobalDefines(defines?: { [key: string]: string }): string | undefined {\r\n        if (defines) {\r\n            if (this.isNDCHalfZRange) {\r\n                defines[\"IS_NDC_HALF_ZRANGE\"] = \"\";\r\n            } else {\r\n                delete defines[\"IS_NDC_HALF_ZRANGE\"];\r\n            }\r\n            if (this.useReverseDepthBuffer) {\r\n                defines[\"USE_REVERSE_DEPTHBUFFER\"] = \"\";\r\n            } else {\r\n                delete defines[\"USE_REVERSE_DEPTHBUFFER\"];\r\n            }\r\n            if (this.useExactSrgbConversions) {\r\n                defines[\"USE_EXACT_SRGB_CONVERSIONS\"] = \"\";\r\n            } else {\r\n                delete defines[\"USE_EXACT_SRGB_CONVERSIONS\"];\r\n            }\r\n            return;\r\n        } else {\r\n            let s = \"\";\r\n            if (this.isNDCHalfZRange) {\r\n                s += \"#define IS_NDC_HALF_ZRANGE\";\r\n            }\r\n            if (this.useReverseDepthBuffer) {\r\n                if (s) {\r\n                    s += \"\\n\";\r\n                }\r\n                s += \"#define USE_REVERSE_DEPTHBUFFER\";\r\n            }\r\n            if (this.useExactSrgbConversions) {\r\n                if (s) {\r\n                    s += \"\\n\";\r\n                }\r\n                s += \"#define USE_EXACT_SRGB_CONVERSIONS\";\r\n            }\r\n            return s;\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _renderTargetWrapperCache = new Array<RenderTargetWrapper>();\r\n    /** @internal */\r\n    protected _compiledEffects: { [key: string]: Effect } = {};\r\n\r\n    private _rebuildInternalTextures(): void {\r\n        const currentState = this._internalTexturesCache.slice(); // Do a copy because the rebuild will add proxies\r\n\r\n        for (const internalTexture of currentState) {\r\n            internalTexture._rebuild();\r\n        }\r\n    }\r\n\r\n    private _rebuildRenderTargetWrappers(): void {\r\n        const currentState = this._renderTargetWrapperCache.slice(); // Do a copy because the rebuild will add proxies\r\n\r\n        for (const renderTargetWrapper of currentState) {\r\n            renderTargetWrapper._rebuild();\r\n        }\r\n    }\r\n\r\n    private _rebuildEffects(): void {\r\n        for (const key in this._compiledEffects) {\r\n            const effect = <Effect>this._compiledEffects[key];\r\n\r\n            effect._pipelineContext = null; // because _prepareEffect will try to dispose this pipeline before recreating it and that would lead to webgl errors\r\n            effect._prepareEffect();\r\n        }\r\n\r\n        Effect.ResetCache();\r\n    }\r\n\r\n    protected _rebuildGraphicsResources(): void {\r\n        // Ensure webgl and engine states are matching\r\n        this.wipeCaches(true);\r\n\r\n        // Rebuild effects\r\n        this._rebuildEffects();\r\n        this._rebuildComputeEffects?.();\r\n\r\n        // Note:\r\n        //  The call to _rebuildBuffers must be made before the call to _rebuildInternalTextures because in the process of _rebuildBuffers the buffers used by the post process managers will be rebuilt\r\n        //  and we may need to use the post process manager of the scene during _rebuildInternalTextures (in WebGL1, non-POT textures are rescaled using a post process + post process manager of the scene)\r\n\r\n        // Rebuild buffers\r\n        this._rebuildBuffers();\r\n        // Rebuild textures\r\n        this._rebuildInternalTextures();\r\n        // Rebuild textures\r\n        this._rebuildTextures();\r\n        // Rebuild textures\r\n        this._rebuildRenderTargetWrappers();\r\n\r\n        // Reset engine states after all the buffer/textures/... have been rebuilt\r\n        this.wipeCaches(true);\r\n    }\r\n\r\n    protected _flagContextRestored(): void {\r\n        Logger.Warn(this.name + \" context successfully restored.\");\r\n        this.onContextRestoredObservable.notifyObservers(this);\r\n        this._contextWasLost = false;\r\n    }\r\n\r\n    protected _restoreEngineAfterContextLost(initEngine: () => void): void {\r\n        // Adding a timeout to avoid race condition at browser level\r\n        setTimeout(async () => {\r\n            this._clearEmptyResources();\r\n\r\n            const depthTest = this._depthCullingState.depthTest; // backup those values because the call to initEngine / wipeCaches will reset them\r\n            const depthFunc = this._depthCullingState.depthFunc;\r\n            const depthMask = this._depthCullingState.depthMask;\r\n            const stencilTest = this._stencilState.stencilTest;\r\n\r\n            // Rebuild context\r\n            await initEngine();\r\n            this._rebuildGraphicsResources();\r\n\r\n            this._depthCullingState.depthTest = depthTest;\r\n            this._depthCullingState.depthFunc = depthFunc;\r\n            this._depthCullingState.depthMask = depthMask;\r\n            this._stencilState.stencilTest = stencilTest;\r\n\r\n            this._flagContextRestored();\r\n        }, 0);\r\n    }\r\n\r\n    /** @internal */\r\n    protected _isDisposed = false;\r\n\r\n    /** Gets a boolean indicating if the engine was disposed */\r\n    public get isDisposed(): boolean {\r\n        return this._isDisposed;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of created scenes\r\n     */\r\n    public scenes: Scene[] = [];\r\n\r\n    /** @internal */\r\n    public _virtualScenes = new Array<Scene>();\r\n\r\n    /** @internal */\r\n    public _features: EngineFeatures;\r\n\r\n    /**\r\n     * Enables or disables the snapshot rendering mode\r\n     * Note that the WebGL engine does not support snapshot rendering so setting the value won't have any effect for this engine\r\n     */\r\n    public get snapshotRendering(): boolean {\r\n        return false;\r\n    }\r\n\r\n    public set snapshotRendering(activate) {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the snapshot rendering mode\r\n     */\r\n    public get snapshotRenderingMode(): number {\r\n        return Constants.SNAPSHOTRENDERING_STANDARD;\r\n    }\r\n\r\n    public set snapshotRenderingMode(mode: number) {}\r\n\r\n    /**\r\n     * Observable event triggered before each texture is initialized\r\n     */\r\n    public onBeforeTextureInitObservable = new Observable<Texture>();\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if the engine must keep rendering even if the window is not in foreground\r\n     */\r\n    public renderEvenInBackground = true;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that cache can be kept between frames\r\n     */\r\n    public preventCacheWipeBetweenFrames = false;\r\n\r\n    /**\r\n     * Returns the string \"AbstractEngine\"\r\n     * @returns \"AbstractEngine\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"AbstractEngine\";\r\n    }\r\n\r\n    /**\r\n     * Gets the default empty texture\r\n     */\r\n    public get emptyTexture(): InternalTexture {\r\n        if (!this._emptyTexture) {\r\n            this._emptyTexture = this.createRawTexture(new Uint8Array(4), 1, 1, Constants.TEXTUREFORMAT_RGBA, false, false, Constants.TEXTURE_NEAREST_SAMPLINGMODE);\r\n        }\r\n\r\n        return this._emptyTexture;\r\n    }\r\n\r\n    /**\r\n     * Gets the default empty 3D texture\r\n     */\r\n    public get emptyTexture3D(): InternalTexture {\r\n        if (!this._emptyTexture3D) {\r\n            this._emptyTexture3D = this.createRawTexture3D(new Uint8Array(4), 1, 1, 1, Constants.TEXTUREFORMAT_RGBA, false, false, Constants.TEXTURE_NEAREST_SAMPLINGMODE);\r\n        }\r\n\r\n        return this._emptyTexture3D;\r\n    }\r\n\r\n    /**\r\n     * Gets the default empty 2D array texture\r\n     */\r\n    public get emptyTexture2DArray(): InternalTexture {\r\n        if (!this._emptyTexture2DArray) {\r\n            this._emptyTexture2DArray = this.createRawTexture2DArray(\r\n                new Uint8Array(4),\r\n                1,\r\n                1,\r\n                1,\r\n                Constants.TEXTUREFORMAT_RGBA,\r\n                false,\r\n                false,\r\n                Constants.TEXTURE_NEAREST_SAMPLINGMODE\r\n            );\r\n        }\r\n\r\n        return this._emptyTexture2DArray;\r\n    }\r\n\r\n    /**\r\n     * Gets the default empty cube texture\r\n     */\r\n    public get emptyCubeTexture(): InternalTexture {\r\n        if (!this._emptyCubeTexture) {\r\n            const faceData = new Uint8Array(4);\r\n            const cubeData = [faceData, faceData, faceData, faceData, faceData, faceData];\r\n            this._emptyCubeTexture = this.createRawCubeTexture(\r\n                cubeData,\r\n                1,\r\n                Constants.TEXTUREFORMAT_RGBA,\r\n                Constants.TEXTURETYPE_UNSIGNED_BYTE,\r\n                false,\r\n                false,\r\n                Constants.TEXTURE_NEAREST_SAMPLINGMODE\r\n            );\r\n        }\r\n\r\n        return this._emptyCubeTexture;\r\n    }\r\n\r\n    /** @internal */\r\n    public _frameHandler: number = 0;\r\n\r\n    /** @internal */\r\n    protected _activeRenderLoops = new Array<() => void>();\r\n\r\n    /**\r\n     * Gets the list of current active render loop functions\r\n     * @returns a read only array with the current render loop functions\r\n     */\r\n    public get activeRenderLoops(): ReadonlyArray<() => void> {\r\n        return this._activeRenderLoops;\r\n    }\r\n\r\n    /**\r\n     * stop executing a render loop function and remove it from the execution array\r\n     * @param renderFunction defines the function to be removed. If not provided all functions will be removed.\r\n     */\r\n    public stopRenderLoop(renderFunction?: () => void): void {\r\n        if (!renderFunction) {\r\n            this._activeRenderLoops.length = 0;\r\n            this._cancelFrame();\r\n            return;\r\n        }\r\n\r\n        const index = this._activeRenderLoops.indexOf(renderFunction);\r\n\r\n        if (index >= 0) {\r\n            this._activeRenderLoops.splice(index, 1);\r\n            if (this._activeRenderLoops.length == 0) {\r\n                this._cancelFrame();\r\n            }\r\n        }\r\n    }\r\n\r\n    protected _cancelFrame() {\r\n        if (this._frameHandler !== 0) {\r\n            const handlerToCancel = this._frameHandler;\r\n            this._frameHandler = 0;\r\n\r\n            if (!IsWindowObjectExist()) {\r\n                if (typeof cancelAnimationFrame === \"function\") {\r\n                    return cancelAnimationFrame(handlerToCancel);\r\n                }\r\n            } else {\r\n                const { cancelAnimationFrame } = this.getHostWindow() || window;\r\n                if (typeof cancelAnimationFrame === \"function\") {\r\n                    return cancelAnimationFrame(handlerToCancel);\r\n                }\r\n            }\r\n            return clearTimeout(handlerToCancel);\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _windowIsBackground = false;\r\n\r\n    /**\r\n     * Begin a new frame\r\n     */\r\n    public beginFrame(): void {\r\n        this.onBeginFrameObservable.notifyObservers(this);\r\n    }\r\n\r\n    /**\r\n     * End the current frame\r\n     */\r\n    public endFrame(): void {\r\n        this._frameId++;\r\n\r\n        this.onEndFrameObservable.notifyObservers(this);\r\n    }\r\n\r\n    /**\r\n     * Gets the performance monitor attached to this engine\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/optimize_your_scene#engineinstrumentation\r\n     */\r\n    public abstract get performanceMonitor(): PerformanceMonitor;\r\n\r\n    /** @internal */\r\n    public _boundRenderFunction: any = (timestamp: number) => this._renderLoop(timestamp);\r\n\r\n    protected _maxFPS: number | undefined;\r\n    protected _minFrameTime: number;\r\n    protected _lastFrameTime: number = 0;\r\n\r\n    /**\r\n     * Skip frame rendering but keep the frame heartbeat (begin/end frame).\r\n     * This is useful if you need all the plumbing but not the rendering work.\r\n     * (for instance when capturing a screenshot where you do not want to mix rendering to the screen and to the screenshot)\r\n     */\r\n    public skipFrameRender = false;\r\n\r\n    /** Gets or sets max frame per second allowed. Will return undefined if not capped */\r\n    public get maxFPS(): number | undefined {\r\n        return this._maxFPS;\r\n    }\r\n\r\n    public set maxFPS(value: number | undefined) {\r\n        this._maxFPS = value;\r\n\r\n        if (value === undefined) {\r\n            return;\r\n        }\r\n\r\n        if (value <= 0) {\r\n            this._minFrameTime = Number.MAX_VALUE;\r\n            return;\r\n        }\r\n\r\n        this._minFrameTime = 1000 / (value + 1); // We need to provide a bit of leeway to ensure we don't go under because of vbl sync\r\n    }\r\n\r\n    protected _isOverFrameTime(timestamp?: number): boolean {\r\n        if (!timestamp) {\r\n            return false;\r\n        }\r\n\r\n        const elapsedTime = timestamp - this._lastFrameTime;\r\n        if (this._maxFPS === undefined || elapsedTime >= this._minFrameTime) {\r\n            this._lastFrameTime = timestamp;\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    protected _processFrame(timestamp?: number) {\r\n        this._frameHandler = 0;\r\n\r\n        if (!this._contextWasLost && !this._isOverFrameTime(timestamp)) {\r\n            let shouldRender = true;\r\n            if (this.isDisposed || (!this.renderEvenInBackground && this._windowIsBackground)) {\r\n                shouldRender = false;\r\n            }\r\n\r\n            if (shouldRender) {\r\n                // Start new frame\r\n                this.beginFrame();\r\n\r\n                // Child canvases\r\n                if (!this.skipFrameRender && !this._renderViews()) {\r\n                    // Main frame\r\n                    this._renderFrame();\r\n                }\r\n\r\n                // Present\r\n                this.endFrame();\r\n            }\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _renderLoop(timestamp: number | undefined): void {\r\n        this._processFrame(timestamp);\r\n\r\n        // The first condition prevents queuing another frame if we no longer have active render loops (e.g., if\r\n        // `stopRenderLoop` is called mid frame). The second condition prevents queuing another frame if one has\r\n        // already been queued (e.g., if `stopRenderLoop` and `runRenderLoop` is called mid frame).\r\n        if (this._activeRenderLoops.length > 0 && this._frameHandler === 0) {\r\n            this._frameHandler = this._queueNewFrame(this._boundRenderFunction, this.getHostWindow());\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _renderFrame() {\r\n        for (let index = 0; index < this._activeRenderLoops.length; index++) {\r\n            const renderFunction = this._activeRenderLoops[index];\r\n\r\n            renderFunction();\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _renderViews() {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Can be used to override the current requestAnimationFrame requester.\r\n     * @internal\r\n     */\r\n    protected _queueNewFrame(bindedRenderFunction: any, requester?: any): number {\r\n        return QueueNewFrame(bindedRenderFunction, requester);\r\n    }\r\n\r\n    /**\r\n     * Register and execute a render loop. The engine can have more than one render function\r\n     * @param renderFunction defines the function to continuously execute\r\n     */\r\n    public runRenderLoop(renderFunction: () => void): void {\r\n        if (this._activeRenderLoops.indexOf(renderFunction) !== -1) {\r\n            return;\r\n        }\r\n\r\n        this._activeRenderLoops.push(renderFunction);\r\n\r\n        // On the first added function, start the render loop.\r\n        if (this._activeRenderLoops.length === 1 && this._frameHandler === 0) {\r\n            this._frameHandler = this._queueNewFrame(this._boundRenderFunction, this.getHostWindow());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if depth testing is enabled\r\n     * @returns the current state\r\n     */\r\n    public getDepthBuffer(): boolean {\r\n        return this._depthCullingState.depthTest;\r\n    }\r\n\r\n    /**\r\n     * Enable or disable depth buffering\r\n     * @param enable defines the state to set\r\n     */\r\n    public setDepthBuffer(enable: boolean): void {\r\n        this._depthCullingState.depthTest = enable;\r\n    }\r\n\r\n    /**\r\n     * Set the z offset Factor to apply to current rendering\r\n     * @param value defines the offset to apply\r\n     */\r\n    public setZOffset(value: number): void {\r\n        this._depthCullingState.zOffset = this.useReverseDepthBuffer ? -value : value;\r\n    }\r\n\r\n    /**\r\n     * Gets the current value of the zOffset Factor\r\n     * @returns the current zOffset Factor state\r\n     */\r\n    public getZOffset(): number {\r\n        const zOffset = this._depthCullingState.zOffset;\r\n        return this.useReverseDepthBuffer ? -zOffset : zOffset;\r\n    }\r\n\r\n    /**\r\n     * Set the z offset Units to apply to current rendering\r\n     * @param value defines the offset to apply\r\n     */\r\n    public setZOffsetUnits(value: number): void {\r\n        this._depthCullingState.zOffsetUnits = this.useReverseDepthBuffer ? -value : value;\r\n    }\r\n\r\n    /**\r\n     * Gets the current value of the zOffset Units\r\n     * @returns the current zOffset Units state\r\n     */\r\n    public getZOffsetUnits(): number {\r\n        const zOffsetUnits = this._depthCullingState.zOffsetUnits;\r\n        return this.useReverseDepthBuffer ? -zOffsetUnits : zOffsetUnits;\r\n    }\r\n\r\n    /**\r\n     * Gets host window\r\n     * @returns the host window object\r\n     */\r\n    public getHostWindow(): Nullable<Window> {\r\n        if (!IsWindowObjectExist()) {\r\n            return null;\r\n        }\r\n\r\n        if (this._renderingCanvas && this._renderingCanvas.ownerDocument && this._renderingCanvas.ownerDocument.defaultView) {\r\n            return this._renderingCanvas.ownerDocument.defaultView;\r\n        }\r\n\r\n        return window;\r\n    }\r\n\r\n    /**\r\n     * (WebGPU only) True (default) to be in compatibility mode, meaning rendering all existing scenes without artifacts (same rendering than WebGL).\r\n     * Setting the property to false will improve performances but may not work in some scenes if some precautions are not taken.\r\n     * See https://doc.babylonjs.com/setup/support/webGPU/webGPUOptimization/webGPUNonCompatibilityMode for more details\r\n     */\r\n    public get compatibilityMode() {\r\n        return this._compatibilityMode;\r\n    }\r\n\r\n    public set compatibilityMode(mode: boolean) {\r\n        // not supported in WebGL\r\n        this._compatibilityMode = true;\r\n    }\r\n\r\n    /**\r\n     * Observable raised when the engine is about to compile a shader\r\n     */\r\n    public onBeforeShaderCompilationObservable = new Observable<AbstractEngine>();\r\n\r\n    /**\r\n     * Observable raised when the engine has just compiled a shader\r\n     */\r\n    public onAfterShaderCompilationObservable = new Observable<AbstractEngine>();\r\n\r\n    /**\r\n     * Observable raised when the engine begins a new frame\r\n     */\r\n    public onBeginFrameObservable = new Observable<AbstractEngine>();\r\n\r\n    /**\r\n     * Observable raised when the engine ends the current frame\r\n     */\r\n    public onEndFrameObservable = new Observable<AbstractEngine>();\r\n\r\n    protected _rebuildTextures(): void {\r\n        for (const scene of this.scenes) {\r\n            scene._rebuildTextures();\r\n        }\r\n\r\n        for (const scene of this._virtualScenes) {\r\n            scene._rebuildTextures();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public abstract _getRGBABufferInternalSizedFormat(type: number, format?: number, useSRGBBuffer?: boolean): number;\r\n\r\n    /** @internal */\r\n    public abstract _getUnpackAlignement(): number;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public abstract _uploadCompressedDataToTextureDirectly(\r\n        texture: InternalTexture,\r\n        internalFormat: number,\r\n        width: number,\r\n        height: number,\r\n        data: ArrayBufferView,\r\n        faceIndex: number,\r\n        lod?: number\r\n    ): void;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public abstract _bindTextureDirectly(target: number, texture: Nullable<InternalTexture>, forTextureDataUpdate?: boolean, force?: boolean): boolean;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public abstract _uploadDataToTextureDirectly(\r\n        texture: InternalTexture,\r\n        imageData: ArrayBufferView,\r\n        faceIndex?: number,\r\n        lod?: number,\r\n        babylonInternalFormat?: number,\r\n        useTextureWidthAndHeight?: boolean\r\n    ): void;\r\n\r\n    /** @internal */\r\n    public abstract _unpackFlipY(value: boolean): void;\r\n\r\n    /**\r\n     * Reads pixels from the current frame buffer. Please note that this function can be slow\r\n     * @param x defines the x coordinate of the rectangle where pixels must be read\r\n     * @param y defines the y coordinate of the rectangle where pixels must be read\r\n     * @param width defines the width of the rectangle where pixels must be read\r\n     * @param height defines the height of the rectangle where pixels must be read\r\n     * @param hasAlpha defines whether the output should have alpha or not (defaults to true)\r\n     * @param flushRenderer true to flush the renderer from the pending commands before reading the pixels\r\n     * @returns a ArrayBufferView promise (Uint8Array) containing RGBA colors\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public abstract readPixels(x: number, y: number, width: number, height: number, hasAlpha?: boolean, flushRenderer?: boolean): Promise<ArrayBufferView>;\r\n\r\n    /**\r\n     * Generates mipmaps for a texture\r\n     * @param texture The texture to generate the mipmaps for\r\n     */\r\n    public abstract generateMipmaps(texture: InternalTexture): void;\r\n\r\n    /**\r\n     * Force a flush (ie. a flush of all waiting commands)\r\n     */\r\n    public abstract flushFramebuffer(): void;\r\n\r\n    /** @internal */\r\n    public abstract _currentFrameBufferIsDefaultFrameBuffer(): boolean;\r\n\r\n    /**\r\n     * Creates an internal texture without binding it to a framebuffer\r\n     * @internal\r\n     * @param size defines the size of the texture\r\n     * @param options defines the options used to create the texture\r\n     * @param delayGPUTextureCreation true to delay the texture creation the first time it is really needed. false to create it right away\r\n     * @param source source type of the texture\r\n     * @returns a new internal texture\r\n     */\r\n    public abstract _createInternalTexture(\r\n        size: TextureSize,\r\n        options: boolean | InternalTextureCreationOptions,\r\n        delayGPUTextureCreation?: boolean,\r\n        source?: InternalTextureSource\r\n    ): InternalTexture;\r\n\r\n    /** @internal */\r\n    public abstract applyStates(): void;\r\n\r\n    /**\r\n     * Binds the frame buffer to the specified texture.\r\n     * @param texture The render target wrapper to render to\r\n     * @param faceIndex The face of the texture to render to in case of cube texture\r\n     * @param requiredWidth The width of the target to render to\r\n     * @param requiredHeight The height of the target to render to\r\n     * @param forceFullscreenViewport Forces the viewport to be the entire texture/screen if true\r\n     * @param lodLevel defines the lod level to bind to the frame buffer\r\n     * @param layer defines the 2d array index to bind to frame buffer to\r\n     */\r\n    public abstract bindFramebuffer(\r\n        texture: RenderTargetWrapper,\r\n        faceIndex?: number,\r\n        requiredWidth?: number,\r\n        requiredHeight?: number,\r\n        forceFullscreenViewport?: boolean,\r\n        lodLevel?: number,\r\n        layer?: number\r\n    ): void;\r\n\r\n    /**\r\n     * Update the sampling mode of a given texture\r\n     * @param texture defines the texture to update\r\n     * @param wrapU defines the texture wrap mode of the u coordinates\r\n     * @param wrapV defines the texture wrap mode of the v coordinates\r\n     * @param wrapR defines the texture wrap mode of the r coordinates\r\n     */\r\n    public abstract updateTextureWrappingMode(texture: InternalTexture, wrapU: Nullable<number>, wrapV?: Nullable<number>, wrapR?: Nullable<number>): void;\r\n\r\n    /**\r\n     * Unbind the current render target and bind the default framebuffer\r\n     */\r\n    public abstract restoreDefaultFramebuffer(): void;\r\n\r\n    /**\r\n     * Draw a list of indexed primitives\r\n     * @param fillMode defines the primitive to use\r\n     * @param indexStart defines the starting index\r\n     * @param indexCount defines the number of index to draw\r\n     * @param instancesCount defines the number of instances to draw (if instantiation is enabled)\r\n     */\r\n    public abstract drawElementsType(fillMode: number, indexStart: number, indexCount: number, instancesCount?: number): void;\r\n\r\n    /**\r\n     * Unbind the current render target texture from the webGL context\r\n     * @param texture defines the render target wrapper to unbind\r\n     * @param disableGenerateMipMaps defines a boolean indicating that mipmaps must not be generated\r\n     * @param onBeforeUnbind defines a function which will be called before the effective unbind\r\n     */\r\n    public abstract unBindFramebuffer(texture: RenderTargetWrapper, disableGenerateMipMaps?: boolean, onBeforeUnbind?: () => void): void;\r\n\r\n    /**\r\n     * Generates mipmaps for the texture of the (single) render target\r\n     * @param texture The render target containing the texture to generate the mipmaps for\r\n     */\r\n    public abstract generateMipMapsFramebuffer(texture: RenderTargetWrapper): void;\r\n\r\n    /**\r\n     * Resolves the MSAA texture of the (single) render target into its non-MSAA version.\r\n     * Note that if \"texture\" is not a MSAA render target, no resolve is performed.\r\n     * @param texture The render target texture containing the MSAA texture to resolve\r\n     */\r\n    public abstract resolveFramebuffer(texture: RenderTargetWrapper): void;\r\n\r\n    /**Gets driver info if available */\r\n    public abstract extractDriverInfo(): string;\r\n\r\n    /**\r\n     * Bind a list of vertex buffers to the webGL context\r\n     * @param vertexBuffers defines the list of vertex buffers to bind\r\n     * @param indexBuffer defines the index buffer to bind\r\n     * @param effect defines the effect associated with the vertex buffers\r\n     * @param overrideVertexBuffers defines optional list of avertex buffers that overrides the entries in vertexBuffers\r\n     */\r\n    public abstract bindBuffers(\r\n        vertexBuffers: { [key: string]: Nullable<VertexBuffer> },\r\n        indexBuffer: Nullable<DataBuffer>,\r\n        effect: Effect,\r\n        overrideVertexBuffers?: { [kind: string]: Nullable<VertexBuffer> }\r\n    ): void;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _releaseRenderTargetWrapper(rtWrapper: RenderTargetWrapper): void {\r\n        const index = this._renderTargetWrapperCache.indexOf(rtWrapper);\r\n        if (index !== -1) {\r\n            this._renderTargetWrapperCache.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Activates an effect, making it the current one (ie. the one used for rendering)\r\n     * @param effect defines the effect to activate\r\n     */\r\n    public abstract enableEffect(effect: Nullable<Effect | DrawWrapper>): void;\r\n\r\n    /**\r\n     * Sets the type of faces to cull\r\n     * @param cullBackFaces true to cull back faces, false to cull front faces (if culling is enabled)\r\n     * @param force defines if states must be applied even if cache is up to date\r\n     */\r\n    public abstract setStateCullFaceType(cullBackFaces?: boolean, force?: boolean): void;\r\n\r\n    /**\r\n     * Set various states to the webGL context\r\n     * @param culling defines culling state: true to enable culling, false to disable it\r\n     * @param zOffset defines the value to apply to zOffset (0 by default)\r\n     * @param force defines if states must be applied even if cache is up to date\r\n     * @param reverseSide defines if culling must be reversed (CCW if false, CW if true)\r\n     * @param cullBackFaces true to cull back faces, false to cull front faces (if culling is enabled)\r\n     * @param stencil stencil states to set\r\n     * @param zOffsetUnits defines the value to apply to zOffsetUnits (0 by default)\r\n     */\r\n    public abstract setState(\r\n        culling: boolean,\r\n        zOffset?: number,\r\n        force?: boolean,\r\n        reverseSide?: boolean,\r\n        cullBackFaces?: boolean,\r\n        stencil?: IStencilState,\r\n        zOffsetUnits?: number\r\n    ): void;\r\n\r\n    /**\r\n     * Creates a new material context\r\n     * @returns the new context\r\n     */\r\n    public abstract createMaterialContext(): IMaterialContext | undefined;\r\n\r\n    /**\r\n     * Creates a new draw context\r\n     * @returns the new context\r\n     */\r\n    public abstract createDrawContext(): IDrawContext | undefined;\r\n\r\n    /**\r\n     * Create a new effect (used to store vertex/fragment shaders)\r\n     * @param baseName defines the base name of the effect (The name of file without .fragment.fx or .vertex.fx)\r\n     * @param attributesNamesOrOptions defines either a list of attribute names or an IEffectCreationOptions object\r\n     * @param uniformsNamesOrEngine defines either a list of uniform names or the engine to use\r\n     * @param samplers defines an array of string used to represent textures\r\n     * @param defines defines the string containing the defines to use to compile the shaders\r\n     * @param fallbacks defines the list of potential fallbacks to use if shader compilation fails\r\n     * @param onCompiled defines a function to call when the effect creation is successful\r\n     * @param onError defines a function to call when the effect creation has failed\r\n     * @param indexParameters defines an object containing the index values to use to compile shaders (like the maximum number of simultaneous lights)\r\n     * @param shaderLanguage the language the shader is written in (default: GLSL)\r\n     * @param extraInitializationsAsync additional async code to run before preparing the effect\r\n     * @returns the new Effect\r\n     */\r\n    public abstract createEffect(\r\n        baseName: string | (IShaderPath & { vertexToken?: string; fragmentToken?: string }),\r\n        attributesNamesOrOptions: string[] | IEffectCreationOptions,\r\n        uniformsNamesOrEngine: string[] | AbstractEngine,\r\n        samplers?: string[],\r\n        defines?: string,\r\n        fallbacks?: EffectFallbacks,\r\n        onCompiled?: Nullable<(effect: Effect) => void>,\r\n        onError?: Nullable<(effect: Effect, errors: string) => void>,\r\n        indexParameters?: any,\r\n        shaderLanguage?: ShaderLanguage,\r\n        extraInitializationsAsync?: () => Promise<void>\r\n    ): Effect;\r\n\r\n    /**\r\n     * Clear the current render buffer or the current render target (if any is set up)\r\n     * @param color defines the color to use\r\n     * @param backBuffer defines if the back buffer must be cleared\r\n     * @param depth defines if the depth buffer must be cleared\r\n     * @param stencil defines if the stencil buffer must be cleared\r\n     */\r\n    public abstract clear(color: Nullable<IColor4Like>, backBuffer: boolean, depth: boolean, stencil?: boolean): void;\r\n\r\n    /**\r\n     * Gets a boolean indicating that only power of 2 textures are supported\r\n     * Please note that you can still use non power of 2 textures but in this case the engine will forcefully convert them\r\n     */\r\n    public abstract get needPOTTextures(): boolean;\r\n\r\n    /**\r\n     * Creates a new index buffer\r\n     * @param indices defines the content of the index buffer\r\n     * @param _updatable defines if the index buffer must be updatable\r\n     * @param label defines the label of the buffer (for debug purpose)\r\n     * @returns a new buffer\r\n     */\r\n    public abstract createIndexBuffer(indices: IndicesArray, _updatable?: boolean, label?: string): DataBuffer;\r\n\r\n    /**\r\n     * Draw a list of unindexed primitives\r\n     * @param fillMode defines the primitive to use\r\n     * @param verticesStart defines the index of first vertex to draw\r\n     * @param verticesCount defines the count of vertices to draw\r\n     * @param instancesCount defines the number of instances to draw (if instantiation is enabled)\r\n     */\r\n    public abstract drawArraysType(fillMode: number, verticesStart: number, verticesCount: number, instancesCount?: number): void;\r\n\r\n    /**\r\n     * Force the engine to release all cached effects.\r\n     * This means that next effect compilation will have to be done completely even if a similar effect was already compiled\r\n     */\r\n    public abstract releaseEffects(): void;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public abstract _viewport(x: number, y: number, width: number, height: number): void;\r\n\r\n    /**\r\n     * Gets the current viewport\r\n     */\r\n    public get currentViewport(): Nullable<IViewportLike> {\r\n        return this._cachedViewport;\r\n    }\r\n\r\n    /**\r\n     * Set the WebGL's viewport\r\n     * @param viewport defines the viewport element to be used\r\n     * @param requiredWidth defines the width required for rendering. If not provided the rendering canvas' width is used\r\n     * @param requiredHeight defines the height required for rendering. If not provided the rendering canvas' height is used\r\n     */\r\n    public setViewport(viewport: IViewportLike, requiredWidth?: number, requiredHeight?: number): void {\r\n        const width = requiredWidth || this.getRenderWidth();\r\n        const height = requiredHeight || this.getRenderHeight();\r\n        const x = viewport.x || 0;\r\n        const y = viewport.y || 0;\r\n\r\n        this._cachedViewport = viewport;\r\n\r\n        this._viewport(x * width, y * height, width * viewport.width, height * viewport.height);\r\n    }\r\n\r\n    /**\r\n     * Update the sampling mode of a given texture\r\n     * @param samplingMode defines the required sampling mode\r\n     * @param texture defines the texture to update\r\n     * @param generateMipMaps defines whether to generate mipmaps for the texture\r\n     */\r\n    public abstract updateTextureSamplingMode(samplingMode: number, texture: InternalTexture, generateMipMaps?: boolean): void;\r\n\r\n    /**\r\n     * Sets an array of texture to the webGL context\r\n     * @param channel defines the channel where the texture array must be set\r\n     * @param uniform defines the associated uniform location\r\n     * @param textures defines the array of textures to bind\r\n     * @param name name of the channel\r\n     */\r\n    public abstract setTextureArray(channel: number, uniform: Nullable<WebGLUniformLocation>, textures: ThinTexture[], name: string): void;\r\n\r\n    /** @internal */\r\n    public _transformTextureUrl: Nullable<(url: string) => string> = null;\r\n\r\n    /**\r\n     * Unbind all instance attributes\r\n     */\r\n    public abstract unbindInstanceAttributes(): void;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public abstract _getUseSRGBBuffer(useSRGBBuffer: boolean, noMipmap: boolean): boolean;\r\n\r\n    /**\r\n     * Create an image to use with canvas\r\n     * @returns IImage interface\r\n     */\r\n    public createCanvasImage(): IImage {\r\n        return document.createElement(\"img\");\r\n    }\r\n\r\n    /**\r\n     * Create a 2D path to use with canvas\r\n     * @returns IPath2D interface\r\n     * @param d SVG path string\r\n     */\r\n    public createCanvasPath2D(d?: string): IPath2D {\r\n        return new Path2D(d);\r\n    }\r\n\r\n    /**\r\n     * Returns a string describing the current engine\r\n     */\r\n    public get description(): string {\r\n        let description = this.name + this.version;\r\n\r\n        if (this._caps.parallelShaderCompile) {\r\n            description += \" - Parallel shader compilation\";\r\n        }\r\n\r\n        return description;\r\n    }\r\n\r\n    protected _createTextureBase(\r\n        url: Nullable<string>,\r\n        noMipmap: boolean,\r\n        invertY: boolean,\r\n        scene: Nullable<ISceneLike>,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n        onLoad: Nullable<(texture: InternalTexture) => void> = null,\r\n        onError: Nullable<(message: string, exception: any) => void> = null,\r\n        prepareTexture: PrepareTextureFunction,\r\n        prepareTextureProcess: PrepareTextureProcessFunction,\r\n        buffer: Nullable<string | ArrayBuffer | ArrayBufferView | HTMLImageElement | Blob | ImageBitmap> = null,\r\n        fallback: Nullable<InternalTexture> = null,\r\n        format: Nullable<number> = null,\r\n        forcedExtension: Nullable<string> = null,\r\n        mimeType?: string,\r\n        loaderOptions?: any,\r\n        useSRGBBuffer?: boolean\r\n    ): InternalTexture {\r\n        url = url || \"\";\r\n        const fromData = url.substr(0, 5) === \"data:\";\r\n        const fromBlob = url.substr(0, 5) === \"blob:\";\r\n        const isBase64 = fromData && url.indexOf(\";base64,\") !== -1;\r\n\r\n        const texture = fallback ? fallback : new InternalTexture(this, InternalTextureSource.Url);\r\n\r\n        if (texture !== fallback) {\r\n            texture.label = url.substring(0, 60); // default label, can be overriden by the caller\r\n        }\r\n\r\n        const originalUrl = url;\r\n        if (this._transformTextureUrl && !isBase64 && !fallback && !buffer) {\r\n            url = this._transformTextureUrl(url);\r\n        }\r\n\r\n        if (originalUrl !== url) {\r\n            texture._originalUrl = originalUrl;\r\n        }\r\n\r\n        // establish the file extension, if possible\r\n        const lastDot = url.lastIndexOf(\".\");\r\n        let extension = forcedExtension ? forcedExtension : lastDot > -1 ? url.substring(lastDot).toLowerCase() : \"\";\r\n\r\n        // Remove query string\r\n        const queryStringIndex = extension.indexOf(\"?\");\r\n\r\n        if (queryStringIndex > -1) {\r\n            extension = extension.split(\"?\")[0];\r\n        }\r\n\r\n        const loaderPromise = _GetCompatibleTextureLoader(extension, mimeType);\r\n\r\n        if (scene) {\r\n            scene.addPendingData(texture);\r\n        }\r\n        texture.url = url;\r\n        texture.generateMipMaps = !noMipmap;\r\n        texture.samplingMode = samplingMode;\r\n        texture.invertY = invertY;\r\n        texture._useSRGBBuffer = this._getUseSRGBBuffer(!!useSRGBBuffer, noMipmap);\r\n\r\n        if (!this._doNotHandleContextLost) {\r\n            // Keep a link to the buffer only if we plan to handle context lost\r\n            texture._buffer = buffer;\r\n        }\r\n\r\n        let onLoadObserver: Nullable<Observer<InternalTexture>> = null;\r\n        if (onLoad && !fallback) {\r\n            onLoadObserver = texture.onLoadedObservable.add(onLoad);\r\n        }\r\n\r\n        if (!fallback) {\r\n            this._internalTexturesCache.push(texture);\r\n        }\r\n\r\n        const onInternalError = (message?: string, exception?: any) => {\r\n            if (scene) {\r\n                scene.removePendingData(texture);\r\n            }\r\n\r\n            if (url === originalUrl) {\r\n                if (onLoadObserver) {\r\n                    texture.onLoadedObservable.remove(onLoadObserver);\r\n                }\r\n\r\n                if (EngineStore.UseFallbackTexture && url !== EngineStore.FallbackTexture) {\r\n                    this._createTextureBase(\r\n                        EngineStore.FallbackTexture,\r\n                        noMipmap,\r\n                        texture.invertY,\r\n                        scene,\r\n                        samplingMode,\r\n                        null,\r\n                        onError,\r\n                        prepareTexture,\r\n                        prepareTextureProcess,\r\n                        buffer,\r\n                        texture\r\n                    );\r\n                }\r\n\r\n                message = (message || \"Unknown error\") + (EngineStore.UseFallbackTexture ? \" - Fallback texture was used\" : \"\");\r\n                texture.onErrorObservable.notifyObservers({ message, exception });\r\n                if (onError) {\r\n                    onError(message, exception);\r\n                }\r\n            } else {\r\n                // fall back to the original url if the transformed url fails to load\r\n                Logger.Warn(`Failed to load ${url}, falling back to ${originalUrl}`);\r\n                this._createTextureBase(\r\n                    originalUrl,\r\n                    noMipmap,\r\n                    texture.invertY,\r\n                    scene,\r\n                    samplingMode,\r\n                    onLoad,\r\n                    onError,\r\n                    prepareTexture,\r\n                    prepareTextureProcess,\r\n                    buffer,\r\n                    texture,\r\n                    format,\r\n                    forcedExtension,\r\n                    mimeType,\r\n                    loaderOptions,\r\n                    useSRGBBuffer\r\n                );\r\n            }\r\n        };\r\n\r\n        // processing for non-image formats\r\n        if (loaderPromise) {\r\n            const callback = async (data: ArrayBufferView) => {\r\n                const loader = await loaderPromise;\r\n                loader.loadData(\r\n                    data,\r\n                    texture,\r\n                    (width: number, height: number, loadMipmap: boolean, isCompressed: boolean, done: () => void, loadFailed) => {\r\n                        if (loadFailed) {\r\n                            onInternalError(\"TextureLoader failed to load data\");\r\n                        } else {\r\n                            prepareTexture(\r\n                                texture,\r\n                                extension,\r\n                                scene,\r\n                                { width, height },\r\n                                texture.invertY,\r\n                                !loadMipmap,\r\n                                isCompressed,\r\n                                () => {\r\n                                    done();\r\n                                    return false;\r\n                                },\r\n                                samplingMode\r\n                            );\r\n                        }\r\n                    },\r\n                    loaderOptions\r\n                );\r\n            };\r\n\r\n            if (!buffer) {\r\n                this._loadFile(\r\n                    url,\r\n                    (data) => callback(new Uint8Array(data as ArrayBuffer)),\r\n                    undefined,\r\n                    scene ? scene.offlineProvider : undefined,\r\n                    true,\r\n                    (request?: IWebRequest, exception?: any) => {\r\n                        onInternalError(\"Unable to load \" + (request ? request.responseURL : url, exception));\r\n                    }\r\n                );\r\n            } else {\r\n                if (buffer instanceof ArrayBuffer) {\r\n                    callback(new Uint8Array(buffer));\r\n                } else if (ArrayBuffer.isView(buffer)) {\r\n                    callback(buffer);\r\n                } else {\r\n                    if (onError) {\r\n                        onError(\"Unable to load: only ArrayBuffer or ArrayBufferView is supported\", null);\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            const onload = (img: HTMLImageElement | ImageBitmap) => {\r\n                if (fromBlob && !this._doNotHandleContextLost) {\r\n                    // We need to store the image if we need to rebuild the texture\r\n                    // in case of a webgl context lost\r\n                    texture._buffer = img;\r\n                }\r\n\r\n                prepareTexture(texture, extension, scene, img, texture.invertY, noMipmap, false, prepareTextureProcess, samplingMode);\r\n            };\r\n            // According to the WebGL spec section 6.10, ImageBitmaps must be inverted on creation.\r\n            // So, we pass imageOrientation to _FileToolsLoadImage() as it may create an ImageBitmap.\r\n\r\n            if (!fromData || isBase64) {\r\n                if (buffer && (typeof (<HTMLImageElement>buffer).decoding === \"string\" || (<ImageBitmap>buffer).close)) {\r\n                    onload(<HTMLImageElement>buffer);\r\n                } else {\r\n                    AbstractEngine._FileToolsLoadImage(\r\n                        url || \"\",\r\n                        onload,\r\n                        onInternalError,\r\n                        scene ? scene.offlineProvider : null,\r\n                        mimeType,\r\n                        texture.invertY && this._features.needsInvertingBitmap ? { imageOrientation: \"flipY\" } : undefined,\r\n                        this\r\n                    );\r\n                }\r\n            } else if (typeof buffer === \"string\" || buffer instanceof ArrayBuffer || ArrayBuffer.isView(buffer) || buffer instanceof Blob) {\r\n                AbstractEngine._FileToolsLoadImage(\r\n                    buffer,\r\n                    onload,\r\n                    onInternalError,\r\n                    scene ? scene.offlineProvider : null,\r\n                    mimeType,\r\n                    texture.invertY && this._features.needsInvertingBitmap ? { imageOrientation: \"flipY\" } : undefined,\r\n                    this\r\n                );\r\n            } else if (buffer) {\r\n                onload(buffer);\r\n            }\r\n        }\r\n\r\n        return texture;\r\n    }\r\n\r\n    /**\r\n     * Creates a new pipeline context\r\n     * @param shaderProcessingContext defines the shader processing context used during the processing if available\r\n     * @returns the new pipeline\r\n     */\r\n    public abstract createPipelineContext(shaderProcessingContext: Nullable<ShaderProcessingContext>): IPipelineContext;\r\n\r\n    /**\r\n     * Inline functions in shader code that are marked to be inlined\r\n     * @param code code to inline\r\n     * @returns inlined code\r\n     */\r\n    public abstract inlineShaderCode(code: string): string;\r\n\r\n    /**\r\n     * Gets a boolean indicating that the engine supports uniform buffers\r\n     */\r\n    public abstract get supportsUniformBuffers(): boolean;\r\n\r\n    /**\r\n     * Returns the version of the engine\r\n     */\r\n    public abstract get version(): number;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public abstract _releaseEffect(effect: Effect): void;\r\n\r\n    /**\r\n     * Bind a buffer to the current draw context\r\n     * @param buffer defines the buffer to bind\r\n     * @param _location not used in WebGPU\r\n     * @param name Name of the uniform variable to bind\r\n     */\r\n    public abstract bindUniformBufferBase(buffer: DataBuffer, _location: number, name: string): void;\r\n\r\n    /**\r\n     * Bind a specific block at a given index in a specific shader program\r\n     * @param pipelineContext defines the pipeline context to use\r\n     * @param blockName defines the block name\r\n     * @param index defines the index where to bind the block\r\n     */\r\n    public abstract bindUniformBlock(pipelineContext: IPipelineContext, blockName: string, index: number): void;\r\n\r\n    /** @internal */\r\n    public _uniformBuffers = new Array<UniformBuffer>();\r\n    /** @internal */\r\n    public _storageBuffers = new Array<StorageBuffer>();\r\n    protected _rebuildBuffers(): void {\r\n        // Uniforms\r\n        for (const uniformBuffer of this._uniformBuffers) {\r\n            uniformBuffer._rebuildAfterContextLost();\r\n        }\r\n    }\r\n\r\n    protected _highPrecisionShadersAllowed = true;\r\n    /** @internal */\r\n    public get _shouldUseHighPrecisionShader(): boolean {\r\n        return !!(this._caps.highPrecisionShaderSupported && this._highPrecisionShadersAllowed);\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    public abstract _getShaderProcessingContext(shaderLanguage: ShaderLanguage, pureMode: boolean): Nullable<ShaderProcessingContext>;\r\n\r\n    /**\r\n     * Gets host document\r\n     * @returns the host document object\r\n     */\r\n    public getHostDocument(): Nullable<Document> {\r\n        if (this._renderingCanvas && this._renderingCanvas.ownerDocument) {\r\n            return this._renderingCanvas.ownerDocument;\r\n        }\r\n\r\n        return IsDocumentAvailable() ? document : null;\r\n    }\r\n\r\n    // Lost context\r\n    /**\r\n     * Observable signaled when a context lost event is raised\r\n     */\r\n    public onContextLostObservable = new Observable<AbstractEngine>();\r\n    /**\r\n     * Observable signaled when a context restored event is raised\r\n     */\r\n    public onContextRestoredObservable = new Observable<AbstractEngine>();\r\n\r\n    /**\r\n     * Gets the list of loaded textures\r\n     * @returns an array containing all loaded textures\r\n     */\r\n    public getLoadedTexturesCache(): InternalTexture[] {\r\n        return this._internalTexturesCache;\r\n    }\r\n\r\n    /**\r\n     * Clears the list of texture accessible through engine.\r\n     * This can help preventing texture load conflict due to name collision.\r\n     */\r\n    public clearInternalTexturesCache() {\r\n        this._internalTexturesCache.length = 0;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public abstract _releaseTexture(texture: InternalTexture): void;\r\n\r\n    /**\r\n     * Gets the object containing all engine capabilities\r\n     * @returns the EngineCapabilities object\r\n     */\r\n    public getCaps(): EngineCapabilities {\r\n        return this._caps;\r\n    }\r\n\r\n    /**\r\n     * Reset the texture cache to empty state\r\n     */\r\n    public resetTextureCache() {\r\n        for (const key in this._boundTexturesCache) {\r\n            if (!Object.prototype.hasOwnProperty.call(this._boundTexturesCache, key)) {\r\n                continue;\r\n            }\r\n            this._boundTexturesCache[key] = null;\r\n        }\r\n\r\n        this._currentTextureChannel = -1;\r\n    }\r\n\r\n    /** @internal */\r\n    protected _name = \"\";\r\n\r\n    /**\r\n     * Gets or sets the name of the engine\r\n     */\r\n    public get name(): string {\r\n        return this._name;\r\n    }\r\n\r\n    public set name(value: string) {\r\n        this._name = value;\r\n    }\r\n\r\n    /**\r\n     * Returns the current npm package of the sdk\r\n     */\r\n    // Not mixed with Version for tooling purpose.\r\n    public static get NpmPackage(): string {\r\n        return \"babylonjs@7.54.3\";\r\n    }\r\n\r\n    /**\r\n     * Returns the current version of the framework\r\n     */\r\n    public static get Version(): string {\r\n        return \"7.54.3\";\r\n    }\r\n\r\n    /**\r\n     * The time (in milliseconds elapsed since the current page has been loaded) when the engine was initialized\r\n     */\r\n    public readonly startTime: number;\r\n\r\n    /** @internal */\r\n    protected _audioContext: Nullable<AudioContext>;\r\n    /** @internal */\r\n    protected _audioDestination: Nullable<AudioDestinationNode | MediaStreamAudioDestinationNode>;\r\n    /**\r\n     * Gets the HTML canvas attached with the current webGL context\r\n     * @returns a HTML canvas\r\n     */\r\n    public getRenderingCanvas(): Nullable<HTMLCanvasElement> {\r\n        return this._renderingCanvas;\r\n    }\r\n\r\n    /**\r\n     * Gets the audio context specified in engine initialization options\r\n     * @deprecated please use AudioEngineV2 instead\r\n     * @returns an Audio Context\r\n     */\r\n    public getAudioContext(): Nullable<AudioContext> {\r\n        return this._audioContext;\r\n    }\r\n\r\n    /**\r\n     * Gets the audio destination specified in engine initialization options\r\n     * @deprecated please use AudioEngineV2 instead\r\n     * @returns an audio destination node\r\n     */\r\n    public getAudioDestination(): Nullable<AudioDestinationNode | MediaStreamAudioDestinationNode> {\r\n        return this._audioDestination;\r\n    }\r\n\r\n    /**\r\n     * Defines whether the engine has been created with the premultipliedAlpha option on or not.\r\n     */\r\n    public premultipliedAlpha: boolean = true;\r\n\r\n    /**\r\n     * If set to true zooming in and out in the browser will rescale the hardware-scaling correctly.\r\n     */\r\n    public adaptToDeviceRatio: boolean = false;\r\n\r\n    /** @internal */\r\n    protected _lastDevicePixelRatio: number = 1.0;\r\n\r\n    /** @internal */\r\n    public _hardwareScalingLevel: number;\r\n\r\n    /**\r\n     * Defines the hardware scaling level.\r\n     * By default the hardware scaling level is computed from the window device ratio.\r\n     * if level = 1 then the engine will render at the exact resolution of the canvas. If level = 0.5 then the engine will render at twice the size of the canvas.\r\n     * @param level defines the level to use\r\n     */\r\n    public setHardwareScalingLevel(level: number): void {\r\n        this._hardwareScalingLevel = level;\r\n        this.resize();\r\n    }\r\n\r\n    /**\r\n     * Gets the current hardware scaling level.\r\n     * By default the hardware scaling level is computed from the window device ratio.\r\n     * if level = 1 then the engine will render at the exact resolution of the canvas. If level = 0.5 then the engine will render at twice the size of the canvas.\r\n     * @returns a number indicating the current hardware scaling level\r\n     */\r\n    public getHardwareScalingLevel(): number {\r\n        return this._hardwareScalingLevel;\r\n    }\r\n\r\n    /** @internal */\r\n    public _doNotHandleContextLost = false;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if resources should be retained to be able to handle context lost events\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/optimize_your_scene#handling-webgl-context-lost\r\n     */\r\n    public get doNotHandleContextLost(): boolean {\r\n        return this._doNotHandleContextLost;\r\n    }\r\n\r\n    public set doNotHandleContextLost(value: boolean) {\r\n        this._doNotHandleContextLost = value;\r\n    }\r\n\r\n    /** @internal */\r\n    protected _isStencilEnable: boolean;\r\n\r\n    /**\r\n     * Returns true if the stencil buffer has been enabled through the creation option of the context.\r\n     */\r\n    public get isStencilEnable(): boolean {\r\n        return this._isStencilEnable;\r\n    }\r\n\r\n    /** @internal */\r\n    protected _creationOptions: AbstractEngineOptions;\r\n\r\n    /**\r\n     * Gets the options used for engine creation\r\n     * @returns EngineOptions object\r\n     */\r\n    public getCreationOptions() {\r\n        return this._creationOptions;\r\n    }\r\n\r\n    /**\r\n     * Creates a new engine\r\n     * @param antialias defines whether anti-aliasing should be enabled. If undefined, it means that the underlying engine is free to enable it or not\r\n     * @param options defines further options to be sent to the creation context\r\n     * @param adaptToDeviceRatio defines whether to adapt to the device's viewport characteristics (default: false)\r\n     */\r\n    constructor(antialias: boolean | undefined, options: AbstractEngineOptions, adaptToDeviceRatio?: boolean) {\r\n        EngineStore.Instances.push(this);\r\n        this.startTime = PrecisionDate.Now;\r\n\r\n        this._stencilStateComposer.stencilGlobal = this._stencilState;\r\n\r\n        PerformanceConfigurator.SetMatrixPrecision(!!options.useHighPrecisionMatrix);\r\n\r\n        if (IsNavigatorAvailable() && navigator.userAgent) {\r\n            // Detect if we are running on a faulty buggy OS.\r\n            this._badOS = /iPad/i.test(navigator.userAgent) || /iPhone/i.test(navigator.userAgent);\r\n\r\n            // Detect if we are running on a faulty buggy desktop OS.\r\n            this._badDesktopOS = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\r\n        }\r\n\r\n        // Save this off for use in resize().\r\n        this.adaptToDeviceRatio = adaptToDeviceRatio ?? false;\r\n\r\n        options.antialias = antialias ?? options.antialias;\r\n        options.deterministicLockstep = options.deterministicLockstep ?? false;\r\n        options.lockstepMaxSteps = options.lockstepMaxSteps ?? 4;\r\n        options.timeStep = options.timeStep ?? 1 / 60;\r\n        options.stencil = options.stencil ?? true;\r\n\r\n        this._audioContext = options.audioEngineOptions?.audioContext ?? null;\r\n        this._audioDestination = options.audioEngineOptions?.audioDestination ?? null;\r\n        this.premultipliedAlpha = options.premultipliedAlpha ?? true;\r\n        this._doNotHandleContextLost = !!options.doNotHandleContextLost;\r\n        this._isStencilEnable = options.stencil ? true : false;\r\n        this.useExactSrgbConversions = options.useExactSrgbConversions ?? false;\r\n\r\n        const devicePixelRatio = IsWindowObjectExist() ? window.devicePixelRatio || 1.0 : 1.0;\r\n\r\n        const limitDeviceRatio = options.limitDeviceRatio || devicePixelRatio;\r\n        // Viewport\r\n        adaptToDeviceRatio = adaptToDeviceRatio || options.adaptToDeviceRatio || false;\r\n        this._hardwareScalingLevel = adaptToDeviceRatio ? 1.0 / Math.min(limitDeviceRatio, devicePixelRatio) : 1.0;\r\n        this._lastDevicePixelRatio = devicePixelRatio;\r\n\r\n        this._creationOptions = options;\r\n    }\r\n\r\n    /**\r\n     * Resize the view according to the canvas' size\r\n     * @param forceSetSize true to force setting the sizes of the underlying canvas\r\n     */\r\n    public resize(forceSetSize = false): void {\r\n        let width: number;\r\n        let height: number;\r\n\r\n        // Re-query hardware scaling level to handle zoomed-in resizing.\r\n        if (this.adaptToDeviceRatio) {\r\n            const devicePixelRatio = IsWindowObjectExist() ? window.devicePixelRatio || 1.0 : 1.0;\r\n            const changeRatio = this._lastDevicePixelRatio / devicePixelRatio;\r\n            this._lastDevicePixelRatio = devicePixelRatio;\r\n            this._hardwareScalingLevel *= changeRatio;\r\n        }\r\n\r\n        if (IsWindowObjectExist() && IsDocumentAvailable()) {\r\n            // make sure it is a Node object, and is a part of the document.\r\n            if (this._renderingCanvas) {\r\n                const boundingRect = this._renderingCanvas.getBoundingClientRect?.();\r\n                width = this._renderingCanvas.clientWidth || boundingRect?.width || this._renderingCanvas.width * this._hardwareScalingLevel || 100;\r\n                height = this._renderingCanvas.clientHeight || boundingRect?.height || this._renderingCanvas.height * this._hardwareScalingLevel || 100;\r\n            } else {\r\n                width = window.innerWidth;\r\n                height = window.innerHeight;\r\n            }\r\n        } else {\r\n            width = this._renderingCanvas ? this._renderingCanvas.width : 100;\r\n            height = this._renderingCanvas ? this._renderingCanvas.height : 100;\r\n        }\r\n\r\n        this.setSize(width / this._hardwareScalingLevel, height / this._hardwareScalingLevel, forceSetSize);\r\n    }\r\n\r\n    /**\r\n     * Force a specific size of the canvas\r\n     * @param width defines the new canvas' width\r\n     * @param height defines the new canvas' height\r\n     * @param forceSetSize true to force setting the sizes of the underlying canvas\r\n     * @returns true if the size was changed\r\n     */\r\n    public setSize(width: number, height: number, forceSetSize = false): boolean {\r\n        if (!this._renderingCanvas) {\r\n            return false;\r\n        }\r\n\r\n        width = width | 0;\r\n        height = height | 0;\r\n\r\n        if (!forceSetSize && this._renderingCanvas.width === width && this._renderingCanvas.height === height) {\r\n            return false;\r\n        }\r\n\r\n        this._renderingCanvas.width = width;\r\n        this._renderingCanvas.height = height;\r\n\r\n        if (this.scenes) {\r\n            for (let index = 0; index < this.scenes.length; index++) {\r\n                const scene = this.scenes[index];\r\n\r\n                for (let camIndex = 0; camIndex < scene.cameras.length; camIndex++) {\r\n                    const cam = scene.cameras[camIndex];\r\n\r\n                    cam._currentRenderId = 0;\r\n                }\r\n            }\r\n\r\n            if (this.onResizeObservable.hasObservers()) {\r\n                this.onResizeObservable.notifyObservers(this);\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public abstract _releaseBuffer(buffer: DataBuffer): boolean;\r\n\r\n    /**\r\n     * Create a dynamic uniform buffer\r\n     * @see https://doc.babylonjs.com/setup/support/webGL2#uniform-buffer-objets\r\n     * @param elements defines the content of the uniform buffer\r\n     * @param label defines a name for the buffer (for debugging purpose)\r\n     * @returns the webGL uniform buffer\r\n     */\r\n    public abstract createDynamicUniformBuffer(elements: FloatArray, label?: string): DataBuffer;\r\n\r\n    /**\r\n     * Create an uniform buffer\r\n     * @see https://doc.babylonjs.com/setup/support/webGL2#uniform-buffer-objets\r\n     * @param elements defines the content of the uniform buffer\r\n     * @param label defines a name for the buffer (for debugging purpose)\r\n     * @returns the webGL uniform buffer\r\n     */\r\n    public abstract createUniformBuffer(elements: FloatArray, label?: string): DataBuffer;\r\n\r\n    /**\r\n     * Update an existing uniform buffer\r\n     * @see https://doc.babylonjs.com/setup/support/webGL2#uniform-buffer-objets\r\n     * @param uniformBuffer defines the target uniform buffer\r\n     * @param elements defines the content to update\r\n     * @param offset defines the offset in the uniform buffer where update should start\r\n     * @param count defines the size of the data to update\r\n     */\r\n    public abstract updateUniformBuffer(uniformBuffer: DataBuffer, elements: FloatArray, offset?: number, count?: number): void;\r\n\r\n    /**\r\n     * Creates a dynamic vertex buffer\r\n     * @param data the data for the dynamic vertex buffer\r\n     * @param _label defines the label of the buffer (for debug purpose)\r\n     * @returns the new WebGL dynamic buffer\r\n     */\r\n    public abstract createDynamicVertexBuffer(data: DataArray | number, _label?: string): DataBuffer;\r\n\r\n    /**\r\n     * Creates a vertex buffer\r\n     * @param data the data or size for the vertex buffer\r\n     * @param _updatable whether the buffer should be created as updatable\r\n     * @param _label defines the label of the buffer (for debug purpose)\r\n     * @returns the new WebGL static buffer\r\n     */\r\n    public abstract createVertexBuffer(data: DataArray | number, _updatable?: boolean, _label?: string): DataBuffer;\r\n\r\n    /**\r\n     * Update the dimensions of a texture\r\n     * @param texture texture to update\r\n     * @param width new width of the texture\r\n     * @param height new height of the texture\r\n     * @param depth new depth of the texture\r\n     */\r\n    public abstract updateTextureDimensions(texture: InternalTexture, width: number, height: number, depth: number): void;\r\n\r\n    /**\r\n     * Usually called from Texture.ts.\r\n     * Passed information to create a WebGLTexture\r\n     * @param url defines a value which contains one of the following:\r\n     * * A conventional http URL, e.g. 'http://...' or 'file://...'\r\n     * * A base64 string of in-line texture data, e.g. 'data:image/jpg;base64,/...'\r\n     * * An indicator that data being passed using the buffer parameter, e.g. 'data:mytexture.jpg'\r\n     * @param noMipmap defines a boolean indicating that no mipmaps shall be generated.  Ignored for compressed textures.  They must be in the file\r\n     * @param invertY when true, image is flipped when loaded.  You probably want true. Certain compressed textures may invert this if their default is inverted (eg. ktx)\r\n     * @param scene needed for loading to the correct scene\r\n     * @param samplingMode mode with should be used sample / access the texture (Default: Texture.TRILINEAR_SAMPLINGMODE)\r\n     * @param onLoad optional callback to be called upon successful completion\r\n     * @param onError optional callback to be called upon failure\r\n     * @param buffer a source of a file previously fetched as either a base64 string, an ArrayBuffer (compressed or image format), HTMLImageElement (image format), or a Blob\r\n     * @param fallback an internal argument in case the function must be called again, due to etc1 not having alpha capabilities\r\n     * @param format internal format.  Default: RGB when extension is '.jpg' else RGBA.  Ignored for compressed textures\r\n     * @param forcedExtension defines the extension to use to pick the right loader\r\n     * @param mimeType defines an optional mime type\r\n     * @param loaderOptions options to be passed to the loader\r\n     * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\r\n     * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\r\n     * @returns a InternalTexture for assignment back into BABYLON.Texture\r\n     */\r\n    public abstract createTexture(\r\n        url: Nullable<string>,\r\n        noMipmap: boolean,\r\n        invertY: boolean,\r\n        scene: Nullable<ISceneLike>,\r\n        samplingMode?: number,\r\n        onLoad?: Nullable<(texture: InternalTexture) => void>,\r\n        onError?: Nullable<(message: string, exception: any) => void>,\r\n        buffer?: Nullable<string | ArrayBuffer | ArrayBufferView | HTMLImageElement | Blob | ImageBitmap>,\r\n        fallback?: Nullable<InternalTexture>,\r\n        format?: Nullable<number>,\r\n        forcedExtension?: Nullable<string>,\r\n        mimeType?: string,\r\n        loaderOptions?: any,\r\n        creationFlags?: number,\r\n        useSRGBBuffer?: boolean\r\n    ): InternalTexture;\r\n\r\n    // eslint-disable-next-line jsdoc/require-returns-check\r\n    /**\r\n     * Creates a raw texture\r\n     * @param data defines the data to store in the texture\r\n     * @param width defines the width of the texture\r\n     * @param height defines the height of the texture\r\n     * @param format defines the format of the data\r\n     * @param generateMipMaps defines if the engine should generate the mip levels\r\n     * @param invertY defines if data must be stored with Y axis inverted\r\n     * @param samplingMode defines the required sampling mode (Texture.NEAREST_SAMPLINGMODE by default)\r\n     * @param compression defines the compression used (null by default)\r\n     * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_BYTE by default)\r\n     * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\r\n     * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\r\n     * @returns the raw texture inside an InternalTexture\r\n     */\r\n    public createRawTexture(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        format: number,\r\n        generateMipMaps: boolean,\r\n        invertY: boolean,\r\n        samplingMode: number,\r\n        compression?: Nullable<string>,\r\n        type?: number,\r\n        creationFlags?: number,\r\n        useSRGBBuffer?: boolean\r\n    ): InternalTexture {\r\n        throw _WarnImport(\"engine.rawTexture\");\r\n    }\r\n\r\n    // eslint-disable-next-line jsdoc/require-returns-check\r\n    /**\r\n     * Creates a new raw cube texture\r\n     * @param data defines the array of data to use to create each face\r\n     * @param size defines the size of the textures\r\n     * @param format defines the format of the data\r\n     * @param type defines the type of the data (like Engine.TEXTURETYPE_UNSIGNED_BYTE)\r\n     * @param generateMipMaps  defines if the engine should generate the mip levels\r\n     * @param invertY defines if data must be stored with Y axis inverted\r\n     * @param samplingMode defines the required sampling mode (like Texture.NEAREST_SAMPLINGMODE)\r\n     * @param compression defines the compression used (null by default)\r\n     * @returns the cube texture as an InternalTexture\r\n     */\r\n    public createRawCubeTexture(\r\n        data: Nullable<ArrayBufferView[]>,\r\n        size: number,\r\n        format: number,\r\n        type: number,\r\n        generateMipMaps: boolean,\r\n        invertY: boolean,\r\n        samplingMode: number,\r\n        compression?: Nullable<string>\r\n    ): InternalTexture {\r\n        throw _WarnImport(\"engine.rawTexture\");\r\n    }\r\n    // eslint-disable-next-line jsdoc/require-returns-check\r\n    /**\r\n     * Creates a new raw 3D texture\r\n     * @param data defines the data used to create the texture\r\n     * @param width defines the width of the texture\r\n     * @param height defines the height of the texture\r\n     * @param depth defines the depth of the texture\r\n     * @param format defines the format of the texture\r\n     * @param generateMipMaps defines if the engine must generate mip levels\r\n     * @param invertY defines if data must be stored with Y axis inverted\r\n     * @param samplingMode defines the required sampling mode (like Texture.NEAREST_SAMPLINGMODE)\r\n     * @param compression defines the compressed used (can be null)\r\n     * @param textureType defines the compressed used (can be null)\r\n     * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\r\n     * @returns a new raw 3D texture (stored in an InternalTexture)\r\n     */\r\n    public createRawTexture3D(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        depth: number,\r\n        format: number,\r\n        generateMipMaps: boolean,\r\n        invertY: boolean,\r\n        samplingMode: number,\r\n        compression?: Nullable<string>,\r\n        textureType?: number,\r\n        creationFlags?: number\r\n    ): InternalTexture {\r\n        throw _WarnImport(\"engine.rawTexture\");\r\n    }\r\n\r\n    // eslint-disable-next-line jsdoc/require-returns-check\r\n    /**\r\n     * Creates a new raw 2D array texture\r\n     * @param data defines the data used to create the texture\r\n     * @param width defines the width of the texture\r\n     * @param height defines the height of the texture\r\n     * @param depth defines the number of layers of the texture\r\n     * @param format defines the format of the texture\r\n     * @param generateMipMaps defines if the engine must generate mip levels\r\n     * @param invertY defines if data must be stored with Y axis inverted\r\n     * @param samplingMode defines the required sampling mode (like Texture.NEAREST_SAMPLINGMODE)\r\n     * @param compression defines the compressed used (can be null)\r\n     * @param textureType defines the compressed used (can be null)\r\n     * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\r\n     * @returns a new raw 2D array texture (stored in an InternalTexture)\r\n     */\r\n    public createRawTexture2DArray(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        depth: number,\r\n        format: number,\r\n        generateMipMaps: boolean,\r\n        invertY: boolean,\r\n        samplingMode: number,\r\n        compression?: Nullable<string>,\r\n        textureType?: number,\r\n        creationFlags?: number\r\n    ): InternalTexture {\r\n        throw _WarnImport(\"engine.rawTexture\");\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if back faces must be culled. If false, front faces are culled instead (true by default)\r\n     * If non null, this takes precedence over the value from the material\r\n     */\r\n    public cullBackFaces: Nullable<boolean> = null;\r\n\r\n    /**\r\n     * Gets the current render width\r\n     * @param useScreen defines if screen size must be used (or the current render target if any)\r\n     * @returns a number defining the current render width\r\n     */\r\n    public abstract getRenderWidth(useScreen?: boolean): number;\r\n\r\n    /**\r\n     * Gets the current render height\r\n     * @param useScreen defines if screen size must be used (or the current render target if any)\r\n     * @returns a number defining the current render height\r\n     */\r\n    public abstract getRenderHeight(useScreen?: boolean): number;\r\n\r\n    /**\r\n     * Shared initialization across engines types.\r\n     * @param canvas The canvas associated with this instance of the engine.\r\n     */\r\n    protected _sharedInit(canvas: HTMLCanvasElement) {\r\n        this._renderingCanvas = canvas;\r\n    }\r\n\r\n    private _checkForMobile: () => void;\r\n\r\n    protected _setupMobileChecks(): void {\r\n        if (!(navigator && navigator.userAgent)) {\r\n            return;\r\n        }\r\n\r\n        // Function to check if running on mobile device\r\n        this._checkForMobile = () => {\r\n            const currentUA = navigator.userAgent;\r\n            this.hostInformation.isMobile =\r\n                currentUA.indexOf(\"Mobile\") !== -1 ||\r\n                // Needed for iOS 13+ detection on iPad (inspired by solution from https://stackoverflow.com/questions/9038625/detect-if-device-is-ios)\r\n                (currentUA.indexOf(\"Mac\") !== -1 && IsDocumentAvailable() && \"ontouchend\" in document);\r\n        };\r\n\r\n        // Set initial isMobile value\r\n        this._checkForMobile();\r\n\r\n        // Set up event listener to check when window is resized (used to get emulator activation to work properly)\r\n        if (IsWindowObjectExist()) {\r\n            window.addEventListener(\"resize\", this._checkForMobile);\r\n        }\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    /** @internal */\r\n    public static _RenderPassIdCounter = 0;\r\n\r\n    /** @internal */\r\n    public _renderPassNames: string[] = [\"main\"];\r\n\r\n    /** @internal */\r\n    public abstract _createHardwareTexture(): HardwareTextureWrapper;\r\n\r\n    /**\r\n     * creates and returns a new video element\r\n     * @param constraints video constraints\r\n     * @returns video element\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public createVideoElement(constraints: MediaTrackConstraints): any {\r\n        return document.createElement(\"video\");\r\n    }\r\n\r\n    // FPS\r\n    protected _fps = 60;\r\n    protected _deltaTime = 0;\r\n\r\n    /** @internal */\r\n    public _drawCalls: PerfCounter;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _reportDrawCall(numDrawCalls = 1) {\r\n        this._drawCalls?.addCount(numDrawCalls, false);\r\n    }\r\n    /**\r\n     * Gets the current framerate\r\n     * @returns a number representing the framerate\r\n     */\r\n    public getFps(): number {\r\n        return this._fps;\r\n    }\r\n\r\n    /**\r\n     * Gets the time spent between current and previous frame\r\n     * @returns a number representing the delta time in ms\r\n     */\r\n    public getDeltaTime(): number {\r\n        return this._deltaTime;\r\n    }\r\n\r\n    // Deterministic lockstepMaxSteps\r\n    /** @internal */\r\n    public _deterministicLockstep: boolean = false;\r\n    /** @internal */\r\n    public _lockstepMaxSteps: number = 4;\r\n    /** @internal */\r\n    public _timeStep: number = 1 / 60;\r\n\r\n    /**\r\n     * Gets a boolean indicating that the engine is running in deterministic lock step mode\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#deterministic-lockstep\r\n     * @returns true if engine is in deterministic lock step mode\r\n     */\r\n    public isDeterministicLockStep(): boolean {\r\n        return this._deterministicLockstep;\r\n    }\r\n\r\n    /**\r\n     * Gets the max steps when engine is running in deterministic lock step\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#deterministic-lockstep\r\n     * @returns the max steps\r\n     */\r\n    public getLockstepMaxSteps(): number {\r\n        return this._lockstepMaxSteps;\r\n    }\r\n\r\n    /**\r\n     * Returns the time in ms between steps when using deterministic lock step.\r\n     * @returns time step in (ms)\r\n     */\r\n    public getTimeStep(): number {\r\n        return this._timeStep * 1000;\r\n    }\r\n\r\n    /**\r\n     * Engine abstraction for loading and creating an image bitmap from a given source string.\r\n     * @param imageSource source to load the image from.\r\n     * @param options An object that sets options for the image's extraction.\r\n     */\r\n    public _createImageBitmapFromSource(imageSource: string, options?: ImageBitmapOptions): Promise<ImageBitmap> {\r\n        throw new Error(\"createImageBitmapFromSource is not implemented\");\r\n    }\r\n\r\n    /**\r\n     * Engine abstraction for createImageBitmap\r\n     * @param image source for image\r\n     * @param options An object that sets options for the image's extraction.\r\n     * @returns ImageBitmap\r\n     */\r\n    public createImageBitmap(image: ImageBitmapSource, options?: ImageBitmapOptions): Promise<ImageBitmap> {\r\n        return createImageBitmap(image, options);\r\n    }\r\n\r\n    /**\r\n     * Resize an image and returns the image data as an uint8array\r\n     * @param image image to resize\r\n     * @param bufferWidth destination buffer width\r\n     * @param bufferHeight destination buffer height\r\n     */\r\n    public resizeImageBitmap(image: HTMLImageElement | ImageBitmap, bufferWidth: number, bufferHeight: number): Uint8Array {\r\n        throw new Error(\"resizeImageBitmap is not implemented\");\r\n    }\r\n\r\n    /**\r\n     * Get the current error code of the webGL context\r\n     * @returns the error code\r\n     */\r\n    public abstract getError(): number;\r\n\r\n    /**\r\n     * Get Font size information\r\n     * @param font font name\r\n     */\r\n    public getFontOffset(font: string): { ascent: number; height: number; descent: number } {\r\n        throw new Error(\"getFontOffset is not implemented\");\r\n    }\r\n\r\n    protected static _CreateCanvas(width: number, height: number): ICanvas {\r\n        if (typeof document === \"undefined\") {\r\n            return <ICanvas>(<any>new OffscreenCanvas(width, height));\r\n        }\r\n        const canvas = <ICanvas>(<any>document.createElement(\"canvas\"));\r\n        canvas.width = width;\r\n        canvas.height = height;\r\n        return canvas;\r\n    }\r\n\r\n    /**\r\n     * Create a canvas. This method is overridden by other engines\r\n     * @param width width\r\n     * @param height height\r\n     * @returns ICanvas interface\r\n     */\r\n    public createCanvas(width: number, height: number): ICanvas {\r\n        return AbstractEngine._CreateCanvas(width, height);\r\n    }\r\n\r\n    /**\r\n     * Loads an image as an HTMLImageElement.\r\n     * @param input url string, ArrayBuffer, or Blob to load\r\n     * @param onLoad callback called when the image successfully loads\r\n     * @param onError callback called when the image fails to load\r\n     * @param offlineProvider offline provider for caching\r\n     * @param mimeType optional mime type\r\n     * @param imageBitmapOptions optional the options to use when creating an ImageBitmap\r\n     * @param engine the engine instance to use\r\n     * @returns the HTMLImageElement of the loaded image\r\n     * @internal\r\n     */\r\n    public static _FileToolsLoadImage(\r\n        input: string | ArrayBuffer | ArrayBufferView | Blob,\r\n        onLoad: (img: HTMLImageElement | ImageBitmap) => void,\r\n        onError: (message?: string, exception?: any) => void,\r\n        offlineProvider: Nullable<IOfflineProvider>,\r\n        mimeType?: string,\r\n        imageBitmapOptions?: ImageBitmapOptions,\r\n        engine?: AbstractEngine\r\n    ): Nullable<HTMLImageElement> {\r\n        throw _WarnImport(\"FileTools\");\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _loadFile(\r\n        url: string,\r\n        onSuccess: (data: string | ArrayBuffer, responseURL?: string) => void,\r\n        onProgress?: (data: any) => void,\r\n        offlineProvider?: IOfflineProvider,\r\n        useArrayBuffer?: boolean,\r\n        onError?: (request?: IWebRequest, exception?: any) => void\r\n    ): IFileRequest {\r\n        const request = _loadFile(url, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError);\r\n        this._activeRequests.push(request);\r\n        request.onCompleteObservable.add(() => {\r\n            const index = this._activeRequests.indexOf(request);\r\n            if (index !== -1) {\r\n                this._activeRequests.splice(index, 1);\r\n            }\r\n        });\r\n        return request;\r\n    }\r\n\r\n    /**\r\n     * Loads a file from a url\r\n     * @param url url to load\r\n     * @param onSuccess callback called when the file successfully loads\r\n     * @param onProgress callback called while file is loading (if the server supports this mode)\r\n     * @param offlineProvider defines the offline provider for caching\r\n     * @param useArrayBuffer defines a boolean indicating that date must be returned as ArrayBuffer\r\n     * @param onError callback called when the file fails to load\r\n     * @returns a file request object\r\n     * @internal\r\n     */\r\n    public static _FileToolsLoadFile(\r\n        url: string,\r\n        onSuccess: (data: string | ArrayBuffer, responseURL?: string) => void,\r\n        onProgress?: (ev: ProgressEvent) => void,\r\n        offlineProvider?: IOfflineProvider,\r\n        useArrayBuffer?: boolean,\r\n        onError?: (request?: WebRequest, exception?: LoadFileError) => void\r\n    ): IFileRequest {\r\n        if (EngineFunctionContext.loadFile) {\r\n            return EngineFunctionContext.loadFile(url, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError);\r\n        }\r\n        throw _WarnImport(\"FileTools\");\r\n    }\r\n\r\n    /**\r\n     * An event triggered when the engine is disposed.\r\n     */\r\n    public readonly onDisposeObservable = new Observable<AbstractEngine>();\r\n\r\n    /**\r\n     * An event triggered when a global cleanup of all effects is required\r\n     */\r\n    public readonly onReleaseEffectsObservable = new Observable<AbstractEngine>();\r\n\r\n    /**\r\n     * Dispose and release all associated resources\r\n     */\r\n    public dispose(): void {\r\n        this.releaseEffects();\r\n\r\n        this._isDisposed = true;\r\n        this.stopRenderLoop();\r\n\r\n        // Empty texture\r\n        if (this._emptyTexture) {\r\n            this._releaseTexture(this._emptyTexture);\r\n            this._emptyTexture = null;\r\n        }\r\n        if (this._emptyCubeTexture) {\r\n            this._releaseTexture(this._emptyCubeTexture);\r\n            this._emptyCubeTexture = null;\r\n        }\r\n\r\n        this._renderingCanvas = null;\r\n\r\n        // Clear observables\r\n        if (this.onBeforeTextureInitObservable) {\r\n            this.onBeforeTextureInitObservable.clear();\r\n        }\r\n\r\n        // Release postProcesses\r\n        while (this.postProcesses.length) {\r\n            this.postProcesses[0].dispose();\r\n        }\r\n\r\n        // Release scenes\r\n        while (this.scenes.length) {\r\n            this.scenes[0].dispose();\r\n        }\r\n\r\n        while (this._virtualScenes.length) {\r\n            this._virtualScenes[0].dispose();\r\n        }\r\n\r\n        // Release effects\r\n        this.releaseComputeEffects?.();\r\n\r\n        Effect.ResetCache();\r\n\r\n        // Abort active requests\r\n        for (const request of this._activeRequests) {\r\n            request.abort();\r\n        }\r\n\r\n        this._boundRenderFunction = null;\r\n\r\n        this.onDisposeObservable.notifyObservers(this);\r\n        this.onDisposeObservable.clear();\r\n\r\n        this.onResizeObservable.clear();\r\n        this.onCanvasBlurObservable.clear();\r\n        this.onCanvasFocusObservable.clear();\r\n        this.onCanvasPointerOutObservable.clear();\r\n        this.onNewSceneAddedObservable.clear();\r\n        this.onEffectErrorObservable.clear();\r\n\r\n        if (IsWindowObjectExist()) {\r\n            window.removeEventListener(\"resize\", this._checkForMobile);\r\n        }\r\n\r\n        // Remove from Instances\r\n        const index = EngineStore.Instances.indexOf(this);\r\n\r\n        if (index >= 0) {\r\n            EngineStore.Instances.splice(index, 1);\r\n        }\r\n\r\n        // no more engines left in the engine store? Notify!\r\n        if (!EngineStore.Instances.length) {\r\n            EngineStore.OnEnginesDisposedObservable.notifyObservers(this);\r\n            EngineStore.OnEnginesDisposedObservable.clear();\r\n        }\r\n\r\n        // Observables\r\n        this.onBeginFrameObservable.clear();\r\n        this.onEndFrameObservable.clear();\r\n    }\r\n\r\n    /**\r\n     * Method called to create the default rescale post process on each engine.\r\n     */\r\n    public static _RescalePostProcessFactory: Nullable<(engine: AbstractEngine) => PostProcess> = null;\r\n\r\n    /**\r\n     * Method called to create the default loading screen.\r\n     * This can be overridden in your own app.\r\n     * @param canvas The rendering canvas element\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public static DefaultLoadingScreenFactory(canvas: HTMLCanvasElement): ILoadingScreen {\r\n        throw _WarnImport(\"LoadingScreen\");\r\n    }\r\n\r\n    /**\r\n     * Gets the audio engine\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic\r\n     * @deprecated please use AudioEngineV2 instead\r\n     * @ignorenaming\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public static audioEngine: Nullable<IAudioEngine>;\r\n\r\n    /**\r\n     * Default AudioEngine factory responsible of creating the Audio Engine.\r\n     * By default, this will create a BabylonJS Audio Engine if the workload has been embedded.\r\n     * @deprecated please use AudioEngineV2 instead\r\n     */\r\n    public static AudioEngineFactory: (\r\n        hostElement: Nullable<HTMLElement>,\r\n        audioContext: Nullable<AudioContext>,\r\n        audioDestination: Nullable<AudioDestinationNode | MediaStreamAudioDestinationNode>\r\n    ) => IAudioEngine;\r\n\r\n    /**\r\n     * Default offline support factory responsible of creating a tool used to store data locally.\r\n     * By default, this will create a Database object if the workload has been embedded.\r\n     */\r\n    public static OfflineProviderFactory: (urlToScene: string, callbackManifestChecked: (checked: boolean) => any, disableManifestCheck: boolean) => IOfflineProvider;\r\n\r\n    /**\r\n     * Will flag all materials in all scenes in all engines as dirty to trigger new shader compilation\r\n     * @param flag defines which part of the materials must be marked as dirty\r\n     * @param predicate defines a predicate used to filter which materials should be affected\r\n     */\r\n    public static MarkAllMaterialsAsDirty(flag: number, predicate?: (mat: Material) => boolean): void {\r\n        for (let engineIndex = 0; engineIndex < EngineStore.Instances.length; engineIndex++) {\r\n            const engine = EngineStore.Instances[engineIndex];\r\n\r\n            for (let sceneIndex = 0; sceneIndex < engine.scenes.length; sceneIndex++) {\r\n                engine.scenes[sceneIndex].markAllMaterialsAsDirty(flag, predicate);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Updatable statics so stick with vars here\r\n\r\n    /**\r\n     * Gets or sets the epsilon value used by collision engine\r\n     */\r\n    public static CollisionsEpsilon = 0.001;\r\n\r\n    /**\r\n     * Queue a new function into the requested animation frame pool (ie. this function will be executed by the browser (or the javascript engine) for the next frame)\r\n     * @param func - the function to be called\r\n     * @param requester - the object that will request the next frame. Falls back to window.\r\n     * @returns frame number\r\n     */\r\n    public static QueueNewFrame: (func: () => void, requester?: any) => number = QueueNewFrame;\r\n}\r\n"],
  "mappings": "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",
  "names": ["buffer", "name", "index", "match", "name", "createPipelineContext", "_preparePipelineContext", "_executeWhenRenderingStateIsCompiled", "name", "InternalTextureSource", "proxy", "requestAnimationFrame", "cancelAnimationFrame"]
}
