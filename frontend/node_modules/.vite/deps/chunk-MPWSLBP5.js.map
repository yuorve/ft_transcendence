{
  "version": 3,
  "sources": ["../../../dev/core/src/FlowGraph/Blocks/Execution/Animation/flowGraphPlayAnimationBlock.ts"],
  "sourcesContent": ["import type { FlowGraphContext } from \"../../../flowGraphContext\";\r\nimport type { FlowGraphDataConnection } from \"../../../flowGraphDataConnection\";\r\nimport { FlowGraphAsyncExecutionBlock } from \"../../../flowGraphAsyncExecutionBlock\";\r\nimport { RichTypeAny, RichTypeNumber, RichTypeBoolean } from \"../../../flowGraphRichTypes\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport type { IFlowGraphBlockConfiguration } from \"../../../flowGraphBlock\";\r\nimport { AnimationGroup } from \"core/Animations/animationGroup\";\r\nimport type { Animation } from \"core/Animations/animation\";\r\nimport { FlowGraphBlockNames } from \"../../flowGraphBlockNames\";\r\n\r\n/**\r\n * @experimental\r\n * A block that plays an animation on an animatable object.\r\n */\r\nexport class FlowGraphPlayAnimationBlock extends FlowGraphAsyncExecutionBlock {\r\n    /**\r\n     * Input connection: The speed of the animation.\r\n     */\r\n    public readonly speed: FlowGraphDataConnection<number>;\r\n    /**\r\n     * Input connection: Should the animation loop?\r\n     * Not in glTF specs, but useful for the engine.\r\n     */\r\n    public readonly loop: FlowGraphDataConnection<boolean>;\r\n    /**\r\n     * Input connection: The starting frame of the animation.\r\n     */\r\n    public readonly from: FlowGraphDataConnection<number>;\r\n    /**\r\n     * Input connection: The ending frame of the animation.\r\n     */\r\n    public readonly to: FlowGraphDataConnection<number>;\r\n\r\n    /**\r\n     * Output connection: The current frame of the animation.\r\n     */\r\n    public readonly currentFrame: FlowGraphDataConnection<number>;\r\n\r\n    /**\r\n     * Output connection: The current time of the animation.\r\n     */\r\n    public readonly currentTime: FlowGraphDataConnection<number>;\r\n\r\n    /**\r\n     * Output connection: The animatable that is currently running.\r\n     */\r\n    public readonly currentAnimationGroup: FlowGraphDataConnection<AnimationGroup>;\r\n\r\n    /**\r\n     * Input: Will be initialized if no animation group was provided in the configuration.\r\n     */\r\n    public readonly animationGroup: FlowGraphDataConnection<AnimationGroup>;\r\n\r\n    /**\r\n     * Input: If provided this animation will be used. Priority will be given to the animation group input.\r\n     */\r\n    public readonly animation: FlowGraphDataConnection<Animation | Animation[]>;\r\n\r\n    /**\r\n     * Input connection: The target object that will be animated. If animation group is provided this input will be ignored.\r\n     */\r\n    public readonly object: FlowGraphDataConnection<any>;\r\n\r\n    public constructor(\r\n        /**\r\n         * the configuration of the block\r\n         */\r\n        public override config?: IFlowGraphBlockConfiguration\r\n    ) {\r\n        super(config, [\"animationLoop\", \"animationEnd\", \"animationGroupLoop\"]);\r\n\r\n        this.speed = this.registerDataInput(\"speed\", RichTypeNumber);\r\n        this.loop = this.registerDataInput(\"loop\", RichTypeBoolean);\r\n        this.from = this.registerDataInput(\"from\", RichTypeNumber, 0);\r\n        this.to = this.registerDataInput(\"to\", RichTypeNumber);\r\n\r\n        this.currentFrame = this.registerDataOutput(\"currentFrame\", RichTypeNumber);\r\n        this.currentTime = this.registerDataOutput(\"currentTime\", RichTypeNumber);\r\n\r\n        this.currentAnimationGroup = this.registerDataOutput(\"currentAnimationGroup\", RichTypeAny);\r\n        this.animationGroup = this.registerDataInput(\"animationGroup\", RichTypeAny, config?.animationGroup);\r\n        this.animation = this.registerDataInput(\"animation\", RichTypeAny);\r\n        this.object = this.registerDataInput(\"object\", RichTypeAny);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * @param context\r\n     */\r\n    public _preparePendingTasks(context: FlowGraphContext): void {\r\n        const ag = this.animationGroup.getValue(context);\r\n        const animation = this.animation.getValue(context);\r\n        if (!ag && !animation) {\r\n            return this._reportError(context, \"No animation or animation group provided\");\r\n        } else {\r\n            // if an animation group was already created, dispose it and create a new one\r\n            const currentAnimationGroup = this.currentAnimationGroup.getValue(context);\r\n            if (currentAnimationGroup && currentAnimationGroup !== ag) {\r\n                currentAnimationGroup.dispose();\r\n            }\r\n            let animationGroupToUse = ag;\r\n            // check which animation to use. If no animationGroup was defined and an animation was provided, use the animation\r\n            if (animation && !animationGroupToUse) {\r\n                const target = this.object.getValue(context);\r\n                if (!target) {\r\n                    return this._reportError(context, \"No target object provided\");\r\n                }\r\n                const animationsArray = Array.isArray(animation) ? animation : [animation];\r\n                const name = animationsArray[0].name;\r\n                animationGroupToUse = new AnimationGroup(\"flowGraphAnimationGroup-\" + name + \"-\" + target.name, context.configuration.scene);\r\n                let isInterpolation = false;\r\n                const interpolationAnimations = context._getGlobalContextVariable(\"interpolationAnimations\", []) as number[];\r\n                for (const anim of animationsArray) {\r\n                    animationGroupToUse.addTargetedAnimation(anim, target);\r\n                    if (interpolationAnimations.indexOf(anim.uniqueId) !== -1) {\r\n                        isInterpolation = true;\r\n                    }\r\n                }\r\n\r\n                if (isInterpolation) {\r\n                    this._checkInterpolationDuplications(context, animationsArray, target);\r\n                }\r\n            }\r\n            // not accepting 0\r\n            const speed = this.speed.getValue(context) || 1;\r\n            const from = this.from.getValue(context) ?? 0;\r\n            // not accepting 0\r\n            const to = this.to.getValue(context) || animationGroupToUse.to;\r\n            const loop = !isFinite(to) || this.loop.getValue(context);\r\n            this.currentAnimationGroup.setValue(animationGroupToUse, context);\r\n\r\n            const currentlyRunningAnimationGroups = context._getGlobalContextVariable(\"currentlyRunningAnimationGroups\", []) as number[];\r\n            // check if it already running\r\n            if (currentlyRunningAnimationGroups.indexOf(animationGroupToUse.uniqueId) !== -1) {\r\n                animationGroupToUse.stop();\r\n            }\r\n            try {\r\n                animationGroupToUse.start(loop, speed, from, to);\r\n                animationGroupToUse.onAnimationGroupEndObservable.add(() => this._onAnimationGroupEnd(context));\r\n                animationGroupToUse.onAnimationEndObservable.add(() => this._eventsSignalOutputs[\"animationEnd\"]._activateSignal(context));\r\n                animationGroupToUse.onAnimationLoopObservable.add(() => this._eventsSignalOutputs[\"animationLoop\"]._activateSignal(context));\r\n                animationGroupToUse.onAnimationGroupLoopObservable.add(() => this._eventsSignalOutputs[\"animationGroupLoop\"]._activateSignal(context));\r\n                currentlyRunningAnimationGroups.push(animationGroupToUse.uniqueId);\r\n                context._setGlobalContextVariable(\"currentlyRunningAnimationGroups\", currentlyRunningAnimationGroups);\r\n            } catch (e) {\r\n                this._reportError(context, e);\r\n            }\r\n        }\r\n    }\r\n\r\n    protected override _reportError(context: FlowGraphContext, error: string | Error): void {\r\n        super._reportError(context, error);\r\n        this.currentFrame.setValue(-1, context);\r\n        this.currentTime.setValue(-1, context);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public override _executeOnTick(_context: FlowGraphContext): void {\r\n        const ag = this.currentAnimationGroup.getValue(_context);\r\n        if (ag) {\r\n            this.currentFrame.setValue(ag.getCurrentFrame(), _context);\r\n            this.currentTime.setValue(ag.animatables[0]?.elapsedTime ?? 0, _context);\r\n        }\r\n    }\r\n\r\n    public _execute(context: FlowGraphContext): void {\r\n        this._startPendingTasks(context);\r\n    }\r\n\r\n    private _onAnimationGroupEnd(context: FlowGraphContext) {\r\n        this._removeFromCurrentlyRunning(context, this.currentAnimationGroup.getValue(context));\r\n        this._resetAfterCanceled(context);\r\n        this.done._activateSignal(context);\r\n    }\r\n\r\n    /**\r\n     * The idea behind this function is to check every running animation group and check if the targeted animations it uses are interpolation animations.\r\n     * If they are, we want to see that they don't collide with the current interpolation animations that are starting to play.\r\n     * If they do, we want to stop the already-running animation group.\r\n     * @internal\r\n     */\r\n    private _checkInterpolationDuplications(context: FlowGraphContext, animation: Animation[], target: any) {\r\n        const currentlyRunningAnimationGroups = context._getGlobalContextVariable(\"currentlyRunningAnimationGroups\", []) as number[];\r\n        for (const uniqueId of currentlyRunningAnimationGroups) {\r\n            const ag = context.assetsContext.animationGroups.find((ag) => ag.uniqueId === uniqueId);\r\n            if (ag) {\r\n                for (const anim of ag.targetedAnimations) {\r\n                    for (const animToCheck of animation) {\r\n                        if (anim.animation.targetProperty === animToCheck.targetProperty && anim.target === target) {\r\n                            this._stopAnimationGroup(context, ag);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private _stopAnimationGroup(context: FlowGraphContext, animationGroup: AnimationGroup) {\r\n        // stop, while skipping the on AnimationEndObservable to avoid the \"done\" signal\r\n        animationGroup.stop(true);\r\n        animationGroup.dispose();\r\n        this._removeFromCurrentlyRunning(context, animationGroup);\r\n    }\r\n\r\n    private _removeFromCurrentlyRunning(context: FlowGraphContext, animationGroup: AnimationGroup) {\r\n        const currentlyRunningAnimationGroups = context._getGlobalContextVariable(\"currentlyRunningAnimationGroups\", []) as number[];\r\n        const idx = currentlyRunningAnimationGroups.indexOf(animationGroup.uniqueId);\r\n        if (idx !== -1) {\r\n            currentlyRunningAnimationGroups.splice(idx, 1);\r\n            context._setGlobalContextVariable(\"currentlyRunningAnimationGroups\", currentlyRunningAnimationGroups);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Stop any currently running animations.\r\n     */\r\n    public _cancelPendingTasks(context: FlowGraphContext): void {\r\n        const ag = this.currentAnimationGroup.getValue(context);\r\n        if (ag) {\r\n            this._stopAnimationGroup(context, ag);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @returns class name of the block.\r\n     */\r\n    public override getClassName(): string {\r\n        return FlowGraphBlockNames.PlayAnimation;\r\n    }\r\n}\r\n\r\nRegisterClass(FlowGraphBlockNames.PlayAnimation, FlowGraphPlayAnimationBlock);\r\n"],
  "mappings": "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",
  "names": ["ag"]
}
