{
  "version": 3,
  "sources": ["../../../dev/core/src/FlowGraph/Blocks/Execution/ControlFlow/flowGraphThrottleBlock.ts"],
  "sourcesContent": ["import type { FlowGraphContext } from \"../../../flowGraphContext\";\r\nimport type { FlowGraphDataConnection } from \"../../../flowGraphDataConnection\";\r\nimport { RichTypeNumber } from \"../../../flowGraphRichTypes\";\r\nimport type { FlowGraphSignalConnection } from \"../../../flowGraphSignalConnection\";\r\nimport { FlowGraphExecutionBlockWithOutSignal } from \"../../../flowGraphExecutionBlockWithOutSignal\";\r\nimport type { IFlowGraphBlockConfiguration } from \"../../../flowGraphBlock\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport { FlowGraphBlockNames } from \"../../flowGraphBlockNames\";\r\n/**\r\n * A block that throttles the execution of its output flow.\r\n */\r\nexport class FlowGraphThrottleBlock extends FlowGraphExecutionBlockWithOutSignal {\r\n    /**\r\n     * Input connection: The duration of the throttle, in seconds.\r\n     */\r\n    public readonly duration: FlowGraphDataConnection<number>;\r\n    /**\r\n     * Input connection: Resets the throttle.\r\n     */\r\n    public readonly reset: FlowGraphSignalConnection;\r\n    /**\r\n     * Output connection: The time remaining before the throttle is triggering again, in seconds.\r\n     */\r\n    public readonly lastRemainingTime: FlowGraphDataConnection<number>;\r\n\r\n    constructor(config?: IFlowGraphBlockConfiguration) {\r\n        super(config);\r\n        this.reset = this._registerSignalInput(\"reset\");\r\n        this.duration = this.registerDataInput(\"duration\", RichTypeNumber);\r\n        this.lastRemainingTime = this.registerDataOutput(\"lastRemainingTime\", RichTypeNumber, NaN);\r\n    }\r\n    public _execute(context: FlowGraphContext, callingSignal: FlowGraphSignalConnection): void {\r\n        if (callingSignal === this.reset) {\r\n            this.lastRemainingTime.setValue(NaN, context);\r\n            context._setExecutionVariable(this, \"lastRemainingTime\", NaN);\r\n            context._setExecutionVariable(this, \"timestamp\", 0);\r\n            return;\r\n        }\r\n        // in seconds\r\n        const durationValue = this.duration.getValue(context);\r\n        if (durationValue <= 0 || isNaN(durationValue) || !isFinite(durationValue)) {\r\n            return this._reportError(context, \"Invalid duration in Throttle block\");\r\n        }\r\n        const lastRemainingTime = context._getExecutionVariable(this, \"lastRemainingTime\", NaN);\r\n        // Using Date.now() to get ms since epoch. not using performance.now() because its precision is not needed here\r\n        const currentTime = Date.now();\r\n        if (isNaN(lastRemainingTime)) {\r\n            this.lastRemainingTime.setValue(0, context);\r\n            context._setExecutionVariable(this, \"lastRemainingTime\", 0);\r\n            context._setExecutionVariable(this, \"timestamp\", currentTime);\r\n            // according to glTF interactivity specs\r\n            return this.out._activateSignal(context);\r\n        } else {\r\n            const elapsedTime = currentTime - context._getExecutionVariable(this, \"timestamp\", 0);\r\n            // duration is in seconds, so we need to multiply by 1000\r\n            const durationInMs = durationValue * 1000;\r\n            if (durationInMs <= elapsedTime) {\r\n                this.lastRemainingTime.setValue(0, context);\r\n                context._setExecutionVariable(this, \"lastRemainingTime\", 0);\r\n                context._setExecutionVariable(this, \"timestamp\", currentTime);\r\n                return this.out._activateSignal(context);\r\n            } else {\r\n                const remainingTime = durationInMs - elapsedTime;\r\n                // output is in seconds\r\n                this.lastRemainingTime.setValue(remainingTime / 1000, context);\r\n                context._setExecutionVariable(this, \"lastRemainingTime\", remainingTime);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * @returns class name of the block.\r\n     */\r\n    public override getClassName(): string {\r\n        return FlowGraphBlockNames.Throttle;\r\n    }\r\n}\r\nRegisterClass(FlowGraphBlockNames.Throttle, FlowGraphThrottleBlock);\r\n"],
  "mappings": ";;;;;;;;;;;AAWM,IAAO,yBAAP,cAAsC,qCAAoC;EAc5E,YAAY,QAAqC;AAC7C,UAAM,MAAM;AACZ,SAAK,QAAQ,KAAK,qBAAqB,OAAO;AAC9C,SAAK,WAAW,KAAK,kBAAkB,YAAY,cAAc;AACjE,SAAK,oBAAoB,KAAK,mBAAmB,qBAAqB,gBAAgB,GAAG;EAC7F;EACO,SAAS,SAA2B,eAAwC;AAC/E,QAAI,kBAAkB,KAAK,OAAO;AAC9B,WAAK,kBAAkB,SAAS,KAAK,OAAO;AAC5C,cAAQ,sBAAsB,MAAM,qBAAqB,GAAG;AAC5D,cAAQ,sBAAsB,MAAM,aAAa,CAAC;AAClD;IACJ;AAEA,UAAM,gBAAgB,KAAK,SAAS,SAAS,OAAO;AACpD,QAAI,iBAAiB,KAAK,MAAM,aAAa,KAAK,CAAC,SAAS,aAAa,GAAG;AACxE,aAAO,KAAK,aAAa,SAAS,oCAAoC;IAC1E;AACA,UAAM,oBAAoB,QAAQ,sBAAsB,MAAM,qBAAqB,GAAG;AAEtF,UAAM,cAAc,KAAK,IAAG;AAC5B,QAAI,MAAM,iBAAiB,GAAG;AAC1B,WAAK,kBAAkB,SAAS,GAAG,OAAO;AAC1C,cAAQ,sBAAsB,MAAM,qBAAqB,CAAC;AAC1D,cAAQ,sBAAsB,MAAM,aAAa,WAAW;AAE5D,aAAO,KAAK,IAAI,gBAAgB,OAAO;IAC3C,OAAO;AACH,YAAM,cAAc,cAAc,QAAQ,sBAAsB,MAAM,aAAa,CAAC;AAEpF,YAAM,eAAe,gBAAgB;AACrC,UAAI,gBAAgB,aAAa;AAC7B,aAAK,kBAAkB,SAAS,GAAG,OAAO;AAC1C,gBAAQ,sBAAsB,MAAM,qBAAqB,CAAC;AAC1D,gBAAQ,sBAAsB,MAAM,aAAa,WAAW;AAC5D,eAAO,KAAK,IAAI,gBAAgB,OAAO;MAC3C,OAAO;AACH,cAAM,gBAAgB,eAAe;AAErC,aAAK,kBAAkB,SAAS,gBAAgB,KAAM,OAAO;AAC7D,gBAAQ,sBAAsB,MAAM,qBAAqB,aAAa;MAC1E;IACJ;EACJ;;;;EAIgB,eAAY;AACxB,WAAA;EACJ;;AAEJ,cAAa,0BAA+B,sBAAsB;",
  "names": []
}
