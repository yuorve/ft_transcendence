import {
  FlowGraphBlock,
  FlowGraphConnection
} from "./chunk-QU5NJF7N.js";
import {
  RegisterClass
} from "./chunk-LMH7SWDS.js";

// node_modules/@babylonjs/core/FlowGraph/flowGraphSignalConnection.js
var FlowGraphSignalConnection = class extends FlowGraphConnection {
  constructor() {
    super(...arguments);
    this.priority = 0;
  }
  _isSingularConnection() {
    return false;
  }
  connectTo(point) {
    super.connectTo(point);
    this._connectedPoint.sort((a, b) => b.priority - a.priority);
  }
  /**
   * @internal
   */
  _activateSignal(context) {
    var _a;
    (_a = context.logger) == null ? void 0 : _a.addLogItem({
      action: "ActivateSignal",
      className: this._ownerBlock.getClassName(),
      uniqueId: this._ownerBlock.uniqueId,
      payload: {
        connectionType: this.connectionType,
        name: this.name
      }
    });
    if (this.connectionType === 0) {
      context._notifyExecuteNode(this._ownerBlock);
      this._ownerBlock._execute(context, this);
      context._increaseExecutionId();
    } else {
      for (const connectedPoint of this._connectedPoint) {
        connectedPoint._activateSignal(context);
      }
    }
  }
};
RegisterClass("FlowGraphSignalConnection", FlowGraphSignalConnection);

// node_modules/@babylonjs/core/FlowGraph/flowGraphExecutionBlock.js
var FlowGraphExecutionBlock = class extends FlowGraphBlock {
  constructor(config) {
    super(config);
    this.priority = 0;
    this.signalInputs = [];
    this.signalOutputs = [];
    this.in = this._registerSignalInput("in");
    this.error = this._registerSignalOutput("error");
  }
  _registerSignalInput(name) {
    const input = new FlowGraphSignalConnection(name, 0, this);
    this.signalInputs.push(input);
    return input;
  }
  _registerSignalOutput(name) {
    const output = new FlowGraphSignalConnection(name, 1, this);
    this.signalOutputs.push(output);
    return output;
  }
  _unregisterSignalInput(name) {
    const index = this.signalInputs.findIndex((input) => input.name === name);
    if (index !== -1) {
      this.signalInputs[index].dispose();
      this.signalInputs.splice(index, 1);
    }
  }
  _unregisterSignalOutput(name) {
    const index = this.signalOutputs.findIndex((output) => output.name === name);
    if (index !== -1) {
      this.signalOutputs[index].dispose();
      this.signalOutputs.splice(index, 1);
    }
  }
  _reportError(context, error) {
    this.error.payload = typeof error === "string" ? new Error(error) : error;
    this.error._activateSignal(context);
  }
  /**
   * Given a name of a signal input, return that input if it exists
   * @param name the name of the input
   * @returns if the input exists, the input. Otherwise, undefined.
   */
  getSignalInput(name) {
    return this.signalInputs.find((input) => input.name === name);
  }
  /**
   * Given a name of a signal output, return that input if it exists
   * @param name the name of the input
   * @returns if the input exists, the input. Otherwise, undefined.
   */
  getSignalOutput(name) {
    return this.signalOutputs.find((output) => output.name === name);
  }
  /**
   * Serializes this block
   * @param serializationObject the object to serialize in
   */
  serialize(serializationObject = {}) {
    super.serialize(serializationObject);
    serializationObject.signalInputs = [];
    serializationObject.signalOutputs = [];
    for (const input of this.signalInputs) {
      const serializedInput = {};
      input.serialize(serializedInput);
      serializationObject.signalInputs.push(serializedInput);
    }
    for (const output of this.signalOutputs) {
      const serializedOutput = {};
      output.serialize(serializedOutput);
      serializationObject.signalOutputs.push(serializedOutput);
    }
  }
  /**
   * Deserializes from an object
   * @param serializationObject the object to deserialize from
   */
  deserialize(serializationObject) {
    for (let i = 0; i < serializationObject.signalInputs.length; i++) {
      const signalInput = this.getSignalInput(serializationObject.signalInputs[i].name);
      if (signalInput) {
        signalInput.deserialize(serializationObject.signalInputs[i]);
      } else {
        throw new Error("Could not find signal input with name " + serializationObject.signalInputs[i].name + " in block " + serializationObject.className);
      }
    }
    for (let i = 0; i < serializationObject.signalOutputs.length; i++) {
      const signalOutput = this.getSignalOutput(serializationObject.signalOutputs[i].name);
      if (signalOutput) {
        signalOutput.deserialize(serializationObject.signalOutputs[i]);
      } else {
        throw new Error("Could not find signal output with name " + serializationObject.signalOutputs[i].name + " in block " + serializationObject.className);
      }
    }
  }
  /**
   * @returns the class name
   */
  getClassName() {
    return "FlowGraphExecutionBlock";
  }
};

export {
  FlowGraphSignalConnection,
  FlowGraphExecutionBlock
};
//# sourceMappingURL=chunk-O24ALDLE.js.map
