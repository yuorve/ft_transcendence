{
  "version": 3,
  "sources": ["../../../dev/core/src/FlowGraph/flowGraphSignalConnection.ts", "../../../dev/core/src/FlowGraph/flowGraphExecutionBlock.ts"],
  "sourcesContent": ["import type { FlowGraphExecutionBlock } from \"./flowGraphExecutionBlock\";\r\nimport { FlowGraphConnection, FlowGraphConnectionType } from \"./flowGraphConnection\";\r\nimport type { FlowGraphContext } from \"./flowGraphContext\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\nimport { FlowGraphAction } from \"./flowGraphLogger\";\r\n\r\n/**\r\n * Represents a connection point for a signal.\r\n * When an output point is activated, it will activate the connected input point.\r\n * When an input point is activated, it will execute the block it belongs to.\r\n */\r\nexport class FlowGraphSignalConnection extends FlowGraphConnection<FlowGraphExecutionBlock, FlowGraphSignalConnection> {\r\n    /**\r\n     * Optional payload. Can be used, for example, when an error is thrown to pass additional information.\r\n     */\r\n    public payload: any;\r\n\r\n    /**\r\n     * The priority of the signal. Signals with higher priority will be executed first.\r\n     * Set priority before adding the connection as sorting happens only when the connection is added.\r\n     */\r\n    public priority: number = 0;\r\n\r\n    public override _isSingularConnection(): boolean {\r\n        return false;\r\n    }\r\n\r\n    public override connectTo(point: FlowGraphSignalConnection): void {\r\n        super.connectTo(point);\r\n        // sort according to priority to handle execution order\r\n        this._connectedPoint.sort((a, b) => b.priority - a.priority);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _activateSignal(context: FlowGraphContext): void {\r\n        context.logger?.addLogItem({\r\n            action: FlowGraphAction.ActivateSignal,\r\n            className: this._ownerBlock.getClassName(),\r\n            uniqueId: this._ownerBlock.uniqueId,\r\n            payload: {\r\n                connectionType: this.connectionType,\r\n                name: this.name,\r\n            },\r\n        });\r\n        if (this.connectionType === FlowGraphConnectionType.Input) {\r\n            context._notifyExecuteNode(this._ownerBlock);\r\n            this._ownerBlock._execute(context, this);\r\n            context._increaseExecutionId();\r\n        } else {\r\n            for (const connectedPoint of this._connectedPoint) {\r\n                connectedPoint._activateSignal(context);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nRegisterClass(\"FlowGraphSignalConnection\", FlowGraphSignalConnection);\r\n", "import type { IFlowGraphBlockConfiguration } from \"./flowGraphBlock\";\r\nimport { FlowGraphBlock } from \"./flowGraphBlock\";\r\nimport { FlowGraphConnectionType } from \"./flowGraphConnection\";\r\nimport type { FlowGraphContext } from \"./flowGraphContext\";\r\nimport { FlowGraphSignalConnection } from \"./flowGraphSignalConnection\";\r\n\r\n/**\r\n * A block that executes some action. Always has an input signal (which is not used by event blocks).\r\n * Can have one or more output signals.\r\n */\r\nexport abstract class FlowGraphExecutionBlock extends FlowGraphBlock {\r\n    /**\r\n     * Input connection: The input signal of the block.\r\n     */\r\n    public readonly in: FlowGraphSignalConnection;\r\n\r\n    /**\r\n     * An output connection that can be used to signal an error, if the block defines it.\r\n     */\r\n    public readonly error: FlowGraphSignalConnection;\r\n    /**\r\n     * Input connections that activate the block.\r\n     */\r\n    public signalInputs: FlowGraphSignalConnection[];\r\n    /**\r\n     * Output connections that can activate downstream blocks.\r\n     */\r\n    public signalOutputs: FlowGraphSignalConnection[];\r\n\r\n    /**\r\n     * The priority of the block. Higher priority blocks will be executed first.\r\n     * Note that priority cannot be change AFTER the block was added as sorting happens when the block is added to the execution queue.\r\n     */\r\n    public readonly priority: number = 0;\r\n\r\n    protected constructor(config?: IFlowGraphBlockConfiguration) {\r\n        super(config);\r\n        this.signalInputs = [];\r\n        this.signalOutputs = [];\r\n        this.in = this._registerSignalInput(\"in\");\r\n        this.error = this._registerSignalOutput(\"error\");\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Executes the flow graph execution block.\r\n     */\r\n    public abstract _execute(context: FlowGraphContext, callingSignal: FlowGraphSignalConnection): void;\r\n\r\n    protected _registerSignalInput(name: string): FlowGraphSignalConnection {\r\n        const input = new FlowGraphSignalConnection(name, FlowGraphConnectionType.Input, this);\r\n        this.signalInputs.push(input);\r\n        return input;\r\n    }\r\n\r\n    protected _registerSignalOutput(name: string): FlowGraphSignalConnection {\r\n        const output = new FlowGraphSignalConnection(name, FlowGraphConnectionType.Output, this);\r\n        this.signalOutputs.push(output);\r\n        return output;\r\n    }\r\n\r\n    protected _unregisterSignalInput(name: string): void {\r\n        const index = this.signalInputs.findIndex((input) => input.name === name);\r\n        if (index !== -1) {\r\n            this.signalInputs[index].dispose();\r\n            this.signalInputs.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    protected _unregisterSignalOutput(name: string): void {\r\n        const index = this.signalOutputs.findIndex((output) => output.name === name);\r\n        if (index !== -1) {\r\n            this.signalOutputs[index].dispose();\r\n            this.signalOutputs.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    protected _reportError(context: FlowGraphContext, error: Error | string) {\r\n        this.error.payload = typeof error === \"string\" ? new Error(error) : error;\r\n        this.error._activateSignal(context);\r\n    }\r\n\r\n    /**\r\n     * Given a name of a signal input, return that input if it exists\r\n     * @param name the name of the input\r\n     * @returns if the input exists, the input. Otherwise, undefined.\r\n     */\r\n    public getSignalInput(name: string): FlowGraphSignalConnection | undefined {\r\n        return this.signalInputs.find((input) => input.name === name);\r\n    }\r\n\r\n    /**\r\n     * Given a name of a signal output, return that input if it exists\r\n     * @param name the name of the input\r\n     * @returns if the input exists, the input. Otherwise, undefined.\r\n     */\r\n    public getSignalOutput(name: string): FlowGraphSignalConnection | undefined {\r\n        return this.signalOutputs.find((output) => output.name === name);\r\n    }\r\n\r\n    /**\r\n     * Serializes this block\r\n     * @param serializationObject the object to serialize in\r\n     */\r\n    public override serialize(serializationObject: any = {}) {\r\n        super.serialize(serializationObject);\r\n        serializationObject.signalInputs = [];\r\n        serializationObject.signalOutputs = [];\r\n        for (const input of this.signalInputs) {\r\n            const serializedInput: any = {};\r\n            input.serialize(serializedInput);\r\n            serializationObject.signalInputs.push(serializedInput);\r\n        }\r\n        for (const output of this.signalOutputs) {\r\n            const serializedOutput: any = {};\r\n            output.serialize(serializedOutput);\r\n            serializationObject.signalOutputs.push(serializedOutput);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Deserializes from an object\r\n     * @param serializationObject the object to deserialize from\r\n     */\r\n    public override deserialize(serializationObject: any) {\r\n        for (let i = 0; i < serializationObject.signalInputs.length; i++) {\r\n            const signalInput = this.getSignalInput(serializationObject.signalInputs[i].name);\r\n            if (signalInput) {\r\n                signalInput.deserialize(serializationObject.signalInputs[i]);\r\n            } else {\r\n                throw new Error(\"Could not find signal input with name \" + serializationObject.signalInputs[i].name + \" in block \" + serializationObject.className);\r\n            }\r\n        }\r\n        for (let i = 0; i < serializationObject.signalOutputs.length; i++) {\r\n            const signalOutput = this.getSignalOutput(serializationObject.signalOutputs[i].name);\r\n            if (signalOutput) {\r\n                signalOutput.deserialize(serializationObject.signalOutputs[i]);\r\n            } else {\r\n                throw new Error(\"Could not find signal output with name \" + serializationObject.signalOutputs[i].name + \" in block \" + serializationObject.className);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @returns the class name\r\n     */\r\n    public override getClassName(): string {\r\n        return \"FlowGraphExecutionBlock\";\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": []
}
