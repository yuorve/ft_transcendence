{
  "version": 3,
  "sources": ["../../../dev/core/src/Misc/dumpTools.ts"],
  "sourcesContent": ["/* eslint-disable @typescript-eslint/no-unused-vars */\r\nimport { _WarnImport } from \"./devTools\";\r\n\r\nimport type { ThinEngine } from \"../Engines/thinEngine\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { EffectRenderer, EffectWrapper } from \"../Materials/effectRenderer\";\r\nimport { Tools } from \"./tools\";\r\nimport type { Nullable } from \"../types\";\r\nimport { Clamp } from \"../Maths/math.scalar.functions\";\r\nimport type { AbstractEngine } from \"../Engines/abstractEngine\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\n\r\ntype DumpToolsEngine = {\r\n    canvas: HTMLCanvasElement | OffscreenCanvas;\r\n    engine: ThinEngine;\r\n    renderer: EffectRenderer;\r\n    wrapper: EffectWrapper;\r\n};\r\n\r\nlet _dumpToolsEngine: Nullable<DumpToolsEngine>;\r\n\r\nlet _enginePromise: Promise<DumpToolsEngine> | null = null;\r\n\r\nasync function _CreateDumpRenderer(): Promise<DumpToolsEngine> {\r\n    if (!_enginePromise) {\r\n        _enginePromise = new Promise((resolve, reject) => {\r\n            let canvas: HTMLCanvasElement | OffscreenCanvas;\r\n            let engine: Nullable<ThinEngine> = null;\r\n            const options = {\r\n                preserveDrawingBuffer: true,\r\n                depth: false,\r\n                stencil: false,\r\n                alpha: true,\r\n                premultipliedAlpha: false,\r\n                antialias: false,\r\n                failIfMajorPerformanceCaveat: false,\r\n            };\r\n            import(\"../Engines/thinEngine\")\r\n                .then(({ ThinEngine: thinEngineClass }) => {\r\n                    const engineInstanceCount = EngineStore.Instances.length;\r\n                    try {\r\n                        canvas = new OffscreenCanvas(100, 100); // will be resized later\r\n                        engine = new thinEngineClass(canvas, false, options);\r\n                    } catch (e) {\r\n                        if (engineInstanceCount < EngineStore.Instances.length) {\r\n                            // The engine was created by another instance, let's use it\r\n                            EngineStore.Instances.pop()?.dispose();\r\n                        }\r\n                        // The browser either does not support OffscreenCanvas or WebGL context in OffscreenCanvas, fallback on a regular canvas\r\n                        canvas = document.createElement(\"canvas\");\r\n                        engine = new thinEngineClass(canvas, false, options);\r\n                    }\r\n                    // remove this engine from the list of instances to avoid using it for other purposes\r\n                    EngineStore.Instances.pop();\r\n                    // However, make sure to dispose it when no other engines are left\r\n                    EngineStore.OnEnginesDisposedObservable.add((e) => {\r\n                        // guaranteed to run when no other instances are left\r\n                        // only dispose if it's not the current engine\r\n                        if (engine && e !== engine && !engine.isDisposed && EngineStore.Instances.length === 0) {\r\n                            // Dump the engine and the associated resources\r\n                            Dispose();\r\n                        }\r\n                    });\r\n                    engine.getCaps().parallelShaderCompile = undefined;\r\n                    const renderer = new EffectRenderer(engine);\r\n                    import(\"../Shaders/pass.fragment\").then(({ passPixelShader }) => {\r\n                        if (!engine) {\r\n                            reject(\"Engine is not defined\");\r\n                            return;\r\n                        }\r\n                        const wrapper = new EffectWrapper({\r\n                            engine,\r\n                            name: passPixelShader.name,\r\n                            fragmentShader: passPixelShader.shader,\r\n                            samplerNames: [\"textureSampler\"],\r\n                        });\r\n                        _dumpToolsEngine = {\r\n                            canvas,\r\n                            engine,\r\n                            renderer,\r\n                            wrapper,\r\n                        };\r\n                        resolve(_dumpToolsEngine);\r\n                    });\r\n                })\r\n                .catch(reject);\r\n        });\r\n    }\r\n    return await _enginePromise;\r\n}\r\n\r\n/**\r\n * Dumps the current bound framebuffer\r\n * @param width defines the rendering width\r\n * @param height defines the rendering height\r\n * @param engine defines the hosting engine\r\n * @param successCallback defines the callback triggered once the data are available\r\n * @param mimeType defines the mime type of the result\r\n * @param fileName defines the filename to download. If present, the result will automatically be downloaded\r\n * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.\r\n * @returns a void promise\r\n */\r\nexport async function DumpFramebuffer(\r\n    width: number,\r\n    height: number,\r\n    engine: AbstractEngine,\r\n    successCallback?: (data: string) => void,\r\n    mimeType = \"image/png\",\r\n    fileName?: string,\r\n    quality?: number\r\n) {\r\n    // Read the contents of the framebuffer\r\n    const bufferView = await engine.readPixels(0, 0, width, height);\r\n\r\n    const data = new Uint8Array(bufferView.buffer);\r\n\r\n    DumpData(width, height, data, successCallback as (data: string | ArrayBuffer) => void, mimeType, fileName, true, undefined, quality);\r\n}\r\n\r\n/**\r\n * Dumps an array buffer\r\n * @param width defines the rendering width\r\n * @param height defines the rendering height\r\n * @param data the data array\r\n * @param mimeType defines the mime type of the result\r\n * @param fileName defines the filename to download. If present, the result will automatically be downloaded\r\n * @param invertY true to invert the picture in the Y dimension\r\n * @param toArrayBuffer true to convert the data to an ArrayBuffer (encoded as `mimeType`) instead of a base64 string\r\n * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.\r\n * @returns a promise that resolve to the final data\r\n */\r\nexport function DumpDataAsync(\r\n    width: number,\r\n    height: number,\r\n    data: ArrayBufferView,\r\n    mimeType = \"image/png\",\r\n    fileName?: string,\r\n    invertY = false,\r\n    toArrayBuffer = false,\r\n    quality?: number\r\n): Promise<string | ArrayBuffer> {\r\n    return new Promise((resolve) => {\r\n        DumpData(width, height, data, (result) => resolve(result), mimeType, fileName, invertY, toArrayBuffer, quality);\r\n    });\r\n}\r\n\r\n/**\r\n * Dumps an array buffer\r\n * @param width defines the rendering width\r\n * @param height defines the rendering height\r\n * @param data the data array\r\n * @param successCallback defines the callback triggered once the data are available\r\n * @param mimeType defines the mime type of the result\r\n * @param fileName defines the filename to download. If present, the result will automatically be downloaded\r\n * @param invertY true to invert the picture in the Y dimension\r\n * @param toArrayBuffer true to convert the data to an ArrayBuffer (encoded as `mimeType`) instead of a base64 string\r\n * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.\r\n */\r\nexport function DumpData(\r\n    width: number,\r\n    height: number,\r\n    data: ArrayBufferView,\r\n    successCallback?: (data: string | ArrayBuffer) => void,\r\n    mimeType = \"image/png\",\r\n    fileName?: string,\r\n    invertY = false,\r\n    toArrayBuffer = false,\r\n    quality?: number\r\n): void {\r\n    _CreateDumpRenderer().then((renderer) => {\r\n        renderer.engine.setSize(width, height, true);\r\n\r\n        // Convert if data are float32\r\n        if (data instanceof Float32Array) {\r\n            const data2 = new Uint8Array(data.length);\r\n            let n = data.length;\r\n            while (n--) {\r\n                const v = data[n];\r\n                data2[n] = Math.round(Clamp(v) * 255);\r\n            }\r\n            data = data2;\r\n        }\r\n\r\n        // Create the image\r\n        const texture = renderer.engine.createRawTexture(data, width, height, Constants.TEXTUREFORMAT_RGBA, false, !invertY, Constants.TEXTURE_NEAREST_NEAREST);\r\n\r\n        renderer.renderer.setViewport();\r\n        renderer.renderer.applyEffectWrapper(renderer.wrapper);\r\n        renderer.wrapper.effect._bindTexture(\"textureSampler\", texture);\r\n        renderer.renderer.draw();\r\n\r\n        if (toArrayBuffer) {\r\n            Tools.ToBlob(\r\n                renderer.canvas,\r\n                (blob) => {\r\n                    const fileReader = new FileReader();\r\n                    fileReader.onload = (event: any) => {\r\n                        const arrayBuffer = event.target!.result as ArrayBuffer;\r\n                        if (successCallback) {\r\n                            successCallback(arrayBuffer);\r\n                        }\r\n                    };\r\n                    fileReader.readAsArrayBuffer(blob!);\r\n                },\r\n                mimeType,\r\n                quality\r\n            );\r\n        } else {\r\n            Tools.EncodeScreenshotCanvasData(renderer.canvas, successCallback, mimeType, fileName, quality);\r\n        }\r\n\r\n        texture.dispose();\r\n    });\r\n}\r\n\r\n/**\r\n * Dispose the dump tools associated resources\r\n */\r\nexport function Dispose() {\r\n    if (_dumpToolsEngine) {\r\n        _dumpToolsEngine.wrapper.dispose();\r\n        _dumpToolsEngine.renderer.dispose();\r\n        _dumpToolsEngine.engine.dispose();\r\n    } else {\r\n        // in cases where the engine is not yet created, we need to wait for it to dispose it\r\n        _enginePromise?.then((dumpToolsEngine) => {\r\n            dumpToolsEngine.wrapper.dispose();\r\n            dumpToolsEngine.renderer.dispose();\r\n            dumpToolsEngine.engine.dispose();\r\n        });\r\n    }\r\n    _enginePromise = null;\r\n    _dumpToolsEngine = null;\r\n}\r\n\r\n/**\r\n * Object containing a set of static utilities functions to dump data from a canvas\r\n * @deprecated use functions\r\n */\r\nexport const DumpTools = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    DumpData,\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    DumpDataAsync,\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    DumpFramebuffer,\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    Dispose,\r\n};\r\n\r\n/**\r\n * This will be executed automatically for UMD and es5.\r\n * If esm dev wants the side effects to execute they will have to run it manually\r\n * Once we build native modules those need to be exported.\r\n * @internal\r\n */\r\nconst initSideEffects = () => {\r\n    // References the dependencies.\r\n    Tools.DumpData = DumpData;\r\n    Tools.DumpDataAsync = DumpDataAsync;\r\n    Tools.DumpFramebuffer = DumpFramebuffer;\r\n};\r\n\r\ninitSideEffects();\r\n"],
  "mappings": "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",
  "names": []
}
