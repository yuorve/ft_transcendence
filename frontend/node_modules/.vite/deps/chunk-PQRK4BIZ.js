import {
  Color3,
  Color4
} from "./chunk-7PW7UHPH.js";
import {
  Matrix,
  Quaternion,
  Vector2,
  Vector3,
  Vector4
} from "./chunk-PY7JDJIY.js";
import {
  RandomGUID
} from "./chunk-IW7YW5OA.js";
import {
  RegisterClass
} from "./chunk-LMH7SWDS.js";
import {
  Observable
} from "./chunk-GWFZRJMO.js";

// node_modules/@babylonjs/core/FlowGraph/CustomTypes/flowGraphInteger.js
var FlowGraphInteger = class _FlowGraphInteger {
  constructor(value) {
    this.value = this._toInt(value);
  }
  /**
   * Converts a float to an integer.
   * @param n the float to convert
   * @returns the result of n | 0 - converting it to a int
   */
  _toInt(n) {
    return n | 0;
  }
  /**
   * Adds two integers together.
   * @param other the other integer to add
   * @returns a FlowGraphInteger with the result of the addition
   */
  add(other) {
    return new _FlowGraphInteger(this.value + other.value);
  }
  /**
   * Subtracts two integers.
   * @param other the other integer to subtract
   * @returns a FlowGraphInteger with the result of the subtraction
   */
  subtract(other) {
    return new _FlowGraphInteger(this.value - other.value);
  }
  /**
   * Multiplies two integers.
   * @param other the other integer to multiply
   * @returns a FlowGraphInteger with the result of the multiplication
   */
  multiply(other) {
    return new _FlowGraphInteger(Math.imul(this.value, other.value));
  }
  /**
   * Divides two integers.
   * @param other the other integer to divide
   * @returns a FlowGraphInteger with the result of the division
   */
  divide(other) {
    return new _FlowGraphInteger(this.value / other.value);
  }
  /**
   * The class name of this type.
   * @returns
   */
  getClassName() {
    return _FlowGraphInteger.ClassName;
  }
  /**
   * Compares two integers for equality.
   * @param other the other integer to compare
   * @returns
   */
  equals(other) {
    return this.value === other.value;
  }
  /**
   * Parses a FlowGraphInteger from a serialization object.
   * @param value te number to parse
   * @returns
   */
  static FromValue(value) {
    return new _FlowGraphInteger(value);
  }
  toString() {
    return this.value.toString();
  }
};
FlowGraphInteger.ClassName = "FlowGraphInteger";
RegisterClass("FlowGraphInteger", FlowGraphInteger);

// node_modules/@babylonjs/core/FlowGraph/CustomTypes/flowGraphMatrix.js
var FlowGraphMatrix2D = class _FlowGraphMatrix2D {
  constructor(m = [1, 0, 0, 1]) {
    this._m = m;
  }
  get m() {
    return this._m;
  }
  transformVector(v) {
    return this.transformVectorToRef(v, new Vector2());
  }
  transformVectorToRef(v, result) {
    result.x = v.x * this._m[0] + v.y * this._m[1];
    result.y = v.x * this._m[2] + v.y * this._m[3];
    return result;
  }
  asArray() {
    return this.toArray();
  }
  toArray(emptyArray = []) {
    for (let i = 0; i < 4; i++) {
      emptyArray[i] = this._m[i];
    }
    return emptyArray;
  }
  fromArray(array) {
    for (let i = 0; i < 4; i++) {
      this._m[i] = array[i];
    }
    return this;
  }
  multiplyToRef(other, result) {
    const otherMatrix = other._m;
    const thisMatrix = this._m;
    const r = result._m;
    r[0] = otherMatrix[0] * thisMatrix[0] + otherMatrix[1] * thisMatrix[2];
    r[1] = otherMatrix[0] * thisMatrix[1] + otherMatrix[1] * thisMatrix[3];
    r[2] = otherMatrix[2] * thisMatrix[0] + otherMatrix[3] * thisMatrix[2];
    r[3] = otherMatrix[2] * thisMatrix[1] + otherMatrix[3] * thisMatrix[3];
    return result;
  }
  multiply(other) {
    return this.multiplyToRef(other, new _FlowGraphMatrix2D());
  }
  divideToRef(other, result) {
    const m = this._m;
    const o = other._m;
    const r = result._m;
    r[0] = m[0] / o[0];
    r[1] = m[1] / o[1];
    r[2] = m[2] / o[2];
    r[3] = m[3] / o[3];
    return result;
  }
  divide(other) {
    return this.divideToRef(other, new _FlowGraphMatrix2D());
  }
  addToRef(other, result) {
    const m = this._m;
    const o = other.m;
    const r = result.m;
    r[0] = m[0] + o[0];
    r[1] = m[1] + o[1];
    r[2] = m[2] + o[2];
    r[3] = m[3] + o[3];
    return result;
  }
  add(other) {
    return this.addToRef(other, new _FlowGraphMatrix2D());
  }
  subtractToRef(other, result) {
    const m = this._m;
    const o = other.m;
    const r = result.m;
    r[0] = m[0] - o[0];
    r[1] = m[1] - o[1];
    r[2] = m[2] - o[2];
    r[3] = m[3] - o[3];
    return result;
  }
  subtract(other) {
    return this.subtractToRef(other, new _FlowGraphMatrix2D());
  }
  transpose() {
    const m = this._m;
    return new _FlowGraphMatrix2D([m[0], m[2], m[1], m[3]]);
  }
  determinant() {
    const m = this._m;
    return m[0] * m[3] - m[1] * m[2];
  }
  inverse() {
    const det = this.determinant();
    if (det === 0) {
      throw new Error("Matrix is not invertible");
    }
    const m = this._m;
    const invDet = 1 / det;
    return new _FlowGraphMatrix2D([m[3] * invDet, -m[1] * invDet, -m[2] * invDet, m[0] * invDet]);
  }
  equals(other, epsilon = 0) {
    const m = this._m;
    const o = other.m;
    if (epsilon === 0) {
      return m[0] === o[0] && m[1] === o[1] && m[2] === o[2] && m[3] === o[3];
    }
    return Math.abs(m[0] - o[0]) < epsilon && Math.abs(m[1] - o[1]) < epsilon && Math.abs(m[2] - o[2]) < epsilon && Math.abs(m[3] - o[3]) < epsilon;
  }
  getClassName() {
    return "FlowGraphMatrix2D";
  }
  toString() {
    return `FlowGraphMatrix2D(${this._m.join(", ")})`;
  }
};
var FlowGraphMatrix3D = class _FlowGraphMatrix3D {
  constructor(array = [1, 0, 0, 0, 1, 0, 0, 0, 1]) {
    this._m = array;
  }
  get m() {
    return this._m;
  }
  transformVector(v) {
    return this.transformVectorToRef(v, new Vector3());
  }
  transformVectorToRef(v, result) {
    const m = this._m;
    result.x = v.x * m[0] + v.y * m[1] + v.z * m[2];
    result.y = v.x * m[3] + v.y * m[4] + v.z * m[5];
    result.z = v.x * m[6] + v.y * m[7] + v.z * m[8];
    return result;
  }
  multiplyToRef(other, result) {
    const otherMatrix = other._m;
    const thisMatrix = this._m;
    const r = result.m;
    r[0] = otherMatrix[0] * thisMatrix[0] + otherMatrix[1] * thisMatrix[3] + otherMatrix[2] * thisMatrix[6];
    r[1] = otherMatrix[0] * thisMatrix[1] + otherMatrix[1] * thisMatrix[4] + otherMatrix[2] * thisMatrix[7];
    r[2] = otherMatrix[0] * thisMatrix[2] + otherMatrix[1] * thisMatrix[5] + otherMatrix[2] * thisMatrix[8];
    r[3] = otherMatrix[3] * thisMatrix[0] + otherMatrix[4] * thisMatrix[3] + otherMatrix[5] * thisMatrix[6];
    r[4] = otherMatrix[3] * thisMatrix[1] + otherMatrix[4] * thisMatrix[4] + otherMatrix[5] * thisMatrix[7];
    r[5] = otherMatrix[3] * thisMatrix[2] + otherMatrix[4] * thisMatrix[5] + otherMatrix[5] * thisMatrix[8];
    r[6] = otherMatrix[6] * thisMatrix[0] + otherMatrix[7] * thisMatrix[3] + otherMatrix[8] * thisMatrix[6];
    r[7] = otherMatrix[6] * thisMatrix[1] + otherMatrix[7] * thisMatrix[4] + otherMatrix[8] * thisMatrix[7];
    r[8] = otherMatrix[6] * thisMatrix[2] + otherMatrix[7] * thisMatrix[5] + otherMatrix[8] * thisMatrix[8];
    return result;
  }
  multiply(other) {
    return this.multiplyToRef(other, new _FlowGraphMatrix3D());
  }
  divideToRef(other, result) {
    const m = this._m;
    const o = other.m;
    const r = result.m;
    r[0] = m[0] / o[0];
    r[1] = m[1] / o[1];
    r[2] = m[2] / o[2];
    r[3] = m[3] / o[3];
    r[4] = m[4] / o[4];
    r[5] = m[5] / o[5];
    r[6] = m[6] / o[6];
    r[7] = m[7] / o[7];
    r[8] = m[8] / o[8];
    return result;
  }
  divide(other) {
    return this.divideToRef(other, new _FlowGraphMatrix3D());
  }
  addToRef(other, result) {
    const m = this._m;
    const o = other.m;
    const r = result.m;
    r[0] = m[0] + o[0];
    r[1] = m[1] + o[1];
    r[2] = m[2] + o[2];
    r[3] = m[3] + o[3];
    r[4] = m[4] + o[4];
    r[5] = m[5] + o[5];
    r[6] = m[6] + o[6];
    r[7] = m[7] + o[7];
    r[8] = m[8] + o[8];
    return result;
  }
  add(other) {
    return this.addToRef(other, new _FlowGraphMatrix3D());
  }
  subtractToRef(other, result) {
    const m = this._m;
    const o = other.m;
    const r = result.m;
    r[0] = m[0] - o[0];
    r[1] = m[1] - o[1];
    r[2] = m[2] - o[2];
    r[3] = m[3] - o[3];
    r[4] = m[4] - o[4];
    r[5] = m[5] - o[5];
    r[6] = m[6] - o[6];
    r[7] = m[7] - o[7];
    r[8] = m[8] - o[8];
    return result;
  }
  subtract(other) {
    return this.subtractToRef(other, new _FlowGraphMatrix3D());
  }
  toArray(emptyArray = []) {
    for (let i = 0; i < 9; i++) {
      emptyArray[i] = this._m[i];
    }
    return emptyArray;
  }
  asArray() {
    return this.toArray();
  }
  fromArray(array) {
    for (let i = 0; i < 9; i++) {
      this._m[i] = array[i];
    }
    return this;
  }
  transpose() {
    const m = this._m;
    return new _FlowGraphMatrix3D([m[0], m[3], m[6], m[1], m[4], m[7], m[2], m[5], m[8]]);
  }
  determinant() {
    const m = this._m;
    return m[0] * (m[4] * m[8] - m[5] * m[7]) - m[1] * (m[3] * m[8] - m[5] * m[6]) + m[2] * (m[3] * m[7] - m[4] * m[6]);
  }
  inverse() {
    const det = this.determinant();
    if (det === 0) {
      throw new Error("Matrix is not invertible");
    }
    const m = this._m;
    const invDet = 1 / det;
    return new _FlowGraphMatrix3D([
      (m[4] * m[8] - m[5] * m[7]) * invDet,
      (m[2] * m[7] - m[1] * m[8]) * invDet,
      (m[1] * m[5] - m[2] * m[4]) * invDet,
      (m[5] * m[6] - m[3] * m[8]) * invDet,
      (m[0] * m[8] - m[2] * m[6]) * invDet,
      (m[2] * m[3] - m[0] * m[5]) * invDet,
      (m[3] * m[7] - m[4] * m[6]) * invDet,
      (m[1] * m[6] - m[0] * m[7]) * invDet,
      (m[0] * m[4] - m[1] * m[3]) * invDet
    ]);
  }
  equals(other, epsilon = 0) {
    const m = this._m;
    const o = other.m;
    if (epsilon === 0) {
      return m[0] === o[0] && m[1] === o[1] && m[2] === o[2] && m[3] === o[3] && m[4] === o[4] && m[5] === o[5] && m[6] === o[6] && m[7] === o[7] && m[8] === o[8];
    }
    return Math.abs(m[0] - o[0]) < epsilon && Math.abs(m[1] - o[1]) < epsilon && Math.abs(m[2] - o[2]) < epsilon && Math.abs(m[3] - o[3]) < epsilon && Math.abs(m[4] - o[4]) < epsilon && Math.abs(m[5] - o[5]) < epsilon && Math.abs(m[6] - o[6]) < epsilon && Math.abs(m[7] - o[7]) < epsilon && Math.abs(m[8] - o[8]) < epsilon;
  }
  getClassName() {
    return "FlowGraphMatrix3D";
  }
  toString() {
    return `FlowGraphMatrix3D(${this._m.join(", ")})`;
  }
};

// node_modules/@babylonjs/core/FlowGraph/flowGraphRichTypes.js
var FlowGraphTypes;
(function(FlowGraphTypes2) {
  FlowGraphTypes2["Any"] = "any";
  FlowGraphTypes2["String"] = "string";
  FlowGraphTypes2["Number"] = "number";
  FlowGraphTypes2["Boolean"] = "boolean";
  FlowGraphTypes2["Object"] = "object";
  FlowGraphTypes2["Integer"] = "FlowGraphInteger";
  FlowGraphTypes2["Vector2"] = "Vector2";
  FlowGraphTypes2["Vector3"] = "Vector3";
  FlowGraphTypes2["Vector4"] = "Vector4";
  FlowGraphTypes2["Quaternion"] = "Quaternion";
  FlowGraphTypes2["Matrix"] = "Matrix";
  FlowGraphTypes2["Matrix2D"] = "Matrix2D";
  FlowGraphTypes2["Matrix3D"] = "Matrix3D";
  FlowGraphTypes2["Color3"] = "Color3";
  FlowGraphTypes2["Color4"] = "Color4";
})(FlowGraphTypes || (FlowGraphTypes = {}));
var RichType = class {
  constructor(typeName, defaultValue, animationType = -1) {
    this.typeName = typeName;
    this.defaultValue = defaultValue;
    this.animationType = animationType;
  }
  /**
   * Serializes this rich type into a serialization object.
   * @param serializationObject the object to serialize to
   */
  serialize(serializationObject) {
    serializationObject.typeName = this.typeName;
    serializationObject.defaultValue = this.defaultValue;
  }
};
var RichTypeAny = new RichType("any", void 0);
var RichTypeString = new RichType("string", "");
var RichTypeNumber = new RichType("number", 0, 0);
var RichTypeBoolean = new RichType("boolean", false);
var RichTypeVector2 = new RichType("Vector2", Vector2.Zero(), 5);
var RichTypeVector3 = new RichType("Vector3", Vector3.Zero(), 1);
var RichTypeVector4 = new RichType("Vector4", Vector4.Zero());
var RichTypeMatrix = new RichType("Matrix", Matrix.Identity(), 3);
var RichTypeMatrix2D = new RichType("Matrix2D", new FlowGraphMatrix2D());
var RichTypeMatrix3D = new RichType("Matrix3D", new FlowGraphMatrix3D());
var RichTypeColor3 = new RichType("Color3", Color3.Black(), 4);
var RichTypeColor4 = new RichType("Color4", new Color4(0, 0, 0, 0), 7);
var RichTypeQuaternion = new RichType("Quaternion", Quaternion.Identity(), 2);
RichTypeQuaternion.typeTransformer = (value) => {
  if (value.getClassName && value.getClassName() === "Vector4") {
    return Quaternion.FromArray(value.asArray());
  } else if (value.getClassName && value.getClassName() === "Vector3") {
    return Quaternion.FromEulerVector(value);
  } else if (value.getClassName && value.getClassName() === "Matrix") {
    return Quaternion.FromRotationMatrix(value);
  }
  return value;
};
var RichTypeFlowGraphInteger = new RichType("FlowGraphInteger", new FlowGraphInteger(0), 0);
function getRichTypeFromValue(value) {
  const anyValue = value;
  switch (typeof value) {
    case "string":
      return RichTypeString;
    case "number":
      return RichTypeNumber;
    case "boolean":
      return RichTypeBoolean;
    case "object":
      if (anyValue.getClassName) {
        switch (anyValue.getClassName()) {
          case "Vector2":
            return RichTypeVector2;
          case "Vector3":
            return RichTypeVector3;
          case "Vector4":
            return RichTypeVector4;
          case "Matrix":
            return RichTypeMatrix;
          case "Color3":
            return RichTypeColor3;
          case "Color4":
            return RichTypeColor4;
          case "Quaternion":
            return RichTypeQuaternion;
          case "FlowGraphInteger":
            return RichTypeFlowGraphInteger;
          case "Matrix2D":
            return RichTypeMatrix2D;
          case "Matrix3D":
            return RichTypeMatrix3D;
        }
      }
      return RichTypeAny;
    default:
      return RichTypeAny;
  }
}
function getRichTypeByFlowGraphType(flowGraphType) {
  switch (flowGraphType) {
    case "string":
      return RichTypeString;
    case "number":
      return RichTypeNumber;
    case "boolean":
      return RichTypeBoolean;
    case "Vector2":
      return RichTypeVector2;
    case "Vector3":
      return RichTypeVector3;
    case "Vector4":
      return RichTypeVector4;
    case "Matrix":
      return RichTypeMatrix;
    case "Color3":
      return RichTypeColor3;
    case "Color4":
      return RichTypeColor4;
    case "Quaternion":
      return RichTypeQuaternion;
    case "FlowGraphInteger":
      return RichTypeFlowGraphInteger;
    case "Matrix2D":
      return RichTypeMatrix2D;
    case "Matrix3D":
      return RichTypeMatrix3D;
    default:
      return RichTypeAny;
  }
}
function getAnimationTypeByFlowGraphType(flowGraphType) {
  switch (flowGraphType) {
    case "number":
      return 0;
    case "Vector2":
      return 5;
    case "Vector3":
      return 1;
    case "Matrix":
      return 3;
    case "Color3":
      return 4;
    case "Color4":
      return 7;
    case "Quaternion":
      return 2;
    default:
      return 0;
  }
}
function getRichTypeByAnimationType(animationType) {
  switch (animationType) {
    case 0:
      return RichTypeNumber;
    case 5:
      return RichTypeVector2;
    case 1:
      return RichTypeVector3;
    case 3:
      return RichTypeMatrix;
    case 4:
      return RichTypeColor3;
    case 7:
      return RichTypeColor4;
    case 2:
      return RichTypeQuaternion;
    default:
      return RichTypeAny;
  }
}

// node_modules/@babylonjs/core/FlowGraph/serialization.js
function isMeshClassName(className) {
  return className === "Mesh" || className === "AbstractMesh" || className === "GroundMesh" || className === "InstanceMesh" || className === "LinesMesh" || className === "GoldbergMesh" || className === "GreasedLineMesh" || className === "TrailMesh";
}
function isVectorClassName(className) {
  return className === "Vector2" || className === "Vector3" || className === "Vector4" || className === "Quaternion" || className === "Color3" || className === "Color4";
}
function isMatrixClassName(className) {
  return className === "Matrix" || className === "Matrix2D" || className === "Matrix3D";
}
function isAnimationGroupClassName(className) {
  return className === "AnimationGroup";
}
function parseVector(className, value, flipHandedness = false) {
  if (className === "Vector2") {
    return Vector2.FromArray(value);
  } else if (className === "Vector3") {
    if (flipHandedness) {
      value[2] *= -1;
    }
    return Vector3.FromArray(value);
  } else if (className === "Vector4") {
    return Vector4.FromArray(value);
  } else if (className === "Quaternion") {
    if (flipHandedness) {
      value[2] *= -1;
      value[3] *= -1;
    }
    return Quaternion.FromArray(value);
  } else if (className === "Color3") {
    return new Color3(value[0], value[1], value[2]);
  } else if (className === "Color4") {
    return new Color4(value[0], value[1], value[2], value[3]);
  } else {
    throw new Error(`Unknown vector class name ${className}`);
  }
}
function defaultValueSerializationFunction(key, value, serializationObject) {
  var _a;
  const className = ((_a = value == null ? void 0 : value.getClassName) == null ? void 0 : _a.call(value)) ?? "";
  if (isVectorClassName(className) || isMatrixClassName(className)) {
    serializationObject[key] = {
      value: value.asArray(),
      className
    };
  } else if (className === "FlowGraphInteger") {
    serializationObject[key] = {
      value: value.value,
      className
    };
  } else {
    if (className && (value.id || value.name)) {
      serializationObject[key] = {
        id: value.id,
        name: value.name,
        className
      };
    } else {
      if (typeof value !== "object") {
        serializationObject[key] = value;
      } else {
        throw new Error(`Could not serialize value ${value}`);
      }
    }
  }
}
function defaultValueParseFunction(key, serializationObject, assetsContainer, scene) {
  const intermediateValue = serializationObject[key];
  let finalValue;
  const className = (intermediateValue == null ? void 0 : intermediateValue.type) ?? (intermediateValue == null ? void 0 : intermediateValue.className);
  if (isMeshClassName(className)) {
    let nodes = scene.meshes.filter((m) => intermediateValue.id ? m.id === intermediateValue.id : m.name === intermediateValue.name);
    if (nodes.length === 0) {
      nodes = scene.transformNodes.filter((m) => intermediateValue.id ? m.id === intermediateValue.id : m.name === intermediateValue.name);
    }
    finalValue = intermediateValue.uniqueId ? nodes.find((m) => m.uniqueId === intermediateValue.uniqueId) : nodes[0];
  } else if (isVectorClassName(className)) {
    finalValue = parseVector(className, intermediateValue.value);
  } else if (isAnimationGroupClassName(className)) {
    const ags = scene.animationGroups.filter((ag) => ag.name === intermediateValue.name);
    finalValue = ags.length === 1 ? ags[0] : ags.find((ag) => ag.uniqueId === intermediateValue.uniqueId);
  } else if (className === "Matrix") {
    finalValue = Matrix.FromArray(intermediateValue.value);
  } else if (className === "Matrix2D") {
    finalValue = new FlowGraphMatrix2D(intermediateValue.value);
  } else if (className === "Matrix3D") {
    finalValue = new FlowGraphMatrix3D(intermediateValue.value);
  } else if (className === "FlowGraphInteger") {
    finalValue = FlowGraphInteger.FromValue(intermediateValue.value);
  } else if (className === "number" || className === "string" || className === "boolean") {
    finalValue = intermediateValue.value[0];
  } else if (intermediateValue && intermediateValue.value !== void 0) {
    finalValue = intermediateValue.value;
  } else {
    if (Array.isArray(intermediateValue)) {
      finalValue = intermediateValue.reduce((acc, val) => {
        if (!val.eventData) {
          return acc;
        }
        acc[val.id] = {
          type: getRichTypeByFlowGraphType(val.type)
        };
        if (typeof val.value !== "undefined") {
          acc[val.id].value = defaultValueParseFunction("value", val, assetsContainer, scene);
        }
        return acc;
      }, {});
    } else {
      finalValue = intermediateValue;
    }
  }
  return finalValue;
}
function needsPathConverter(className) {
  return className === "FlowGraphJsonPointerParserBlock";
}

// node_modules/@babylonjs/core/FlowGraph/flowGraphConnection.js
var FlowGraphConnectionType;
(function(FlowGraphConnectionType2) {
  FlowGraphConnectionType2[FlowGraphConnectionType2["Input"] = 0] = "Input";
  FlowGraphConnectionType2[FlowGraphConnectionType2["Output"] = 1] = "Output";
})(FlowGraphConnectionType || (FlowGraphConnectionType = {}));
var FlowGraphConnection = class {
  constructor(name, _connectionType, _ownerBlock) {
    this._ownerBlock = _ownerBlock;
    this._connectedPoint = [];
    this.uniqueId = RandomGUID();
    this.connectedPointIds = [];
    this.name = name;
    this._connectionType = _connectionType;
  }
  /**
   * The type of the connection
   */
  get connectionType() {
    return this._connectionType;
  }
  /**
   * @internal
   * Override this to indicate if a point can connect to more than one point.
   */
  _isSingularConnection() {
    return true;
  }
  /**
   * Returns if a point is connected to any other point.
   * @returns boolean indicating if the point is connected.
   */
  isConnected() {
    return this._connectedPoint.length > 0;
  }
  /**
   * Connects two connections together.
   * @param point the connection to connect to.
   */
  connectTo(point) {
    if (this._connectionType === point._connectionType) {
      throw new Error(`Cannot connect two points of type ${this.connectionType}`);
    }
    if (this._isSingularConnection() && this._connectedPoint.length > 0 || point._isSingularConnection() && point._connectedPoint.length > 0) {
      throw new Error("Max number of connections for point reached");
    }
    this._connectedPoint.push(point);
    point._connectedPoint.push(this);
  }
  /**
   * Disconnects two connections.
   * @param point the connection to disconnect from.
   * @param removeFromLocal if true, the connection will be removed from the local connection list.
   */
  disconnectFrom(point, removeFromLocal = true) {
    const indexLocal = this._connectedPoint.indexOf(point);
    const indexConnected = point._connectedPoint.indexOf(this);
    if (indexLocal === -1 || indexConnected === -1) {
      return;
    }
    if (removeFromLocal) {
      this._connectedPoint.splice(indexLocal, 1);
    }
    point._connectedPoint.splice(indexConnected, 1);
  }
  /**
   * Disconnects all connected points.
   */
  disconnectFromAll() {
    for (const point of this._connectedPoint) {
      this.disconnectFrom(point, false);
    }
    this._connectedPoint.length = 0;
  }
  dispose() {
    for (const point of this._connectedPoint) {
      this.disconnectFrom(point);
    }
  }
  /**
   * Saves the connection to a JSON object.
   * @param serializationObject the object to serialize to.
   */
  serialize(serializationObject = {}) {
    serializationObject.uniqueId = this.uniqueId;
    serializationObject.name = this.name;
    serializationObject._connectionType = this._connectionType;
    serializationObject.connectedPointIds = [];
    serializationObject.className = this.getClassName();
    for (const point of this._connectedPoint) {
      serializationObject.connectedPointIds.push(point.uniqueId);
    }
  }
  /**
   * @returns class name of the connection.
   */
  getClassName() {
    return "FGConnection";
  }
  /**
   * Deserialize from a object into this
   * @param serializationObject the object to deserialize from.
   */
  deserialize(serializationObject) {
    this.uniqueId = serializationObject.uniqueId;
    this.name = serializationObject.name;
    this._connectionType = serializationObject._connectionType;
    this.connectedPointIds = serializationObject.connectedPointIds;
  }
};

// node_modules/@babylonjs/core/FlowGraph/flowGraphDataConnection.js
var FlowGraphDataConnection = class extends FlowGraphConnection {
  /**
   * Create a new data connection point.
   * @param name the name of the connection
   * @param connectionType the type of the connection
   * @param ownerBlock the block that owns this connection
   * @param richType the type of the data in this block
   * @param _defaultValue the default value of the connection
   * @param _optional if the connection is optional
   */
  constructor(name, connectionType, ownerBlock, richType, _defaultValue = richType.defaultValue, _optional = false) {
    super(name, connectionType, ownerBlock);
    this.richType = richType;
    this._defaultValue = _defaultValue;
    this._optional = _optional;
    this._isDisabled = false;
    this._lastValue = null;
    this.dataTransformer = null;
    this.onValueChangedObservable = new Observable();
  }
  /**
   * Whether or not the connection is optional.
   * Currently only used for UI control.
   */
  get optional() {
    return this._optional;
  }
  /**
   * is this connection disabled
   * If the connection is disabled you will not be able to connect anything to it.
   */
  get isDisabled() {
    return this._isDisabled;
  }
  set isDisabled(value) {
    if (this._isDisabled === value) {
      return;
    }
    this._isDisabled = value;
    if (this._isDisabled) {
      this.disconnectFromAll();
    }
  }
  /**
   * An output data block can connect to multiple input data blocks,
   * but an input data block can only connect to one output data block.
   * @returns true if the connection is singular
   */
  _isSingularConnection() {
    return this.connectionType === 0;
  }
  /**
   * Set the value of the connection in a specific context.
   * @param value the value to set
   * @param context the context to which the value is set
   */
  setValue(value, context) {
    if (context._getConnectionValue(this) === value) {
      return;
    }
    context._setConnectionValue(this, value);
    this.onValueChangedObservable.notifyObservers(value);
  }
  /**
   * Reset the value of the connection to the default value.
   * @param context the context in which the value is reset
   */
  resetToDefaultValue(context) {
    context._setConnectionValue(this, this._defaultValue);
  }
  /**
   * Connect this point to another point.
   * @param point the point to connect to.
   */
  connectTo(point) {
    if (this._isDisabled) {
      return;
    }
    super.connectTo(point);
  }
  _getValueOrDefault(context) {
    const val = context._getConnectionValue(this) ?? this._defaultValue;
    return this.dataTransformer ? this.dataTransformer(val) : val;
  }
  /**
   * Gets the value of the connection in a specific context.
   * @param context the context from which the value is retrieved
   * @returns the value of the connection
   */
  getValue(context) {
    if (this.connectionType === 1) {
      context._notifyExecuteNode(this._ownerBlock);
      this._ownerBlock._updateOutputs(context);
      const value2 = this._getValueOrDefault(context);
      this._lastValue = value2;
      return this.richType.typeTransformer ? this.richType.typeTransformer(value2) : value2;
    }
    const value = !this.isConnected() ? this._getValueOrDefault(context) : this._connectedPoint[0].getValue(context);
    this._lastValue = value;
    return this.richType.typeTransformer ? this.richType.typeTransformer(value) : value;
  }
  /**
   * @internal
   */
  _getLastValue() {
    return this._lastValue;
  }
  /**
   * @returns class name of the object.
   */
  getClassName() {
    return "FlowGraphDataConnection";
  }
  /**
   * Serializes this object.
   * @param serializationObject the object to serialize to
   */
  serialize(serializationObject = {}) {
    super.serialize(serializationObject);
    serializationObject.richType = {};
    this.richType.serialize(serializationObject.richType);
    serializationObject.optional = this._optional;
    defaultValueSerializationFunction("defaultValue", this._defaultValue, serializationObject);
  }
};
RegisterClass("FlowGraphDataConnection", FlowGraphDataConnection);

// node_modules/@babylonjs/core/FlowGraph/flowGraphBlock.js
var FlowGraphBlock = class {
  /** Constructor is protected so only subclasses can be instantiated
   * @param config optional configuration for this block
   * @internal - do not use directly. Extend this class instead.
   */
  constructor(config) {
    var _a;
    this.config = config;
    this.uniqueId = RandomGUID();
    this.name = ((_a = this.config) == null ? void 0 : _a.name) ?? this.getClassName();
    this.dataInputs = [];
    this.dataOutputs = [];
  }
  /**
   * @internal
   * This function is called when the block needs to update its output flows.
   * @param _context the context in which it is running
   */
  _updateOutputs(_context) {
  }
  /**
   * Registers a data input on the block.
   * @param name the name of the input
   * @param richType the type of the input
   * @param defaultValue optional default value of the input. If not set, the rich type's default value will be used.
   * @returns the created connection
   */
  registerDataInput(name, richType, defaultValue) {
    const input = new FlowGraphDataConnection(name, 0, this, richType, defaultValue);
    this.dataInputs.push(input);
    return input;
  }
  /**
   * Registers a data output on the block.
   * @param name the name of the input
   * @param richType the type of the input
   * @param defaultValue optional default value of the input. If not set, the rich type's default value will be used.
   * @returns the created connection
   */
  registerDataOutput(name, richType, defaultValue) {
    const output = new FlowGraphDataConnection(name, 1, this, richType, defaultValue);
    this.dataOutputs.push(output);
    return output;
  }
  /**
   * Given the name of a data input, returns the connection if it exists
   * @param name the name of the input
   * @returns the connection if it exists, undefined otherwise
   */
  getDataInput(name) {
    return this.dataInputs.find((i) => i.name === name);
  }
  /**
   * Given the name of a data output, returns the connection if it exists
   * @param name the name of the output
   * @returns the connection if it exists, undefined otherwise
   */
  getDataOutput(name) {
    return this.dataOutputs.find((i) => i.name === name);
  }
  /**
   * Serializes this block
   * @param serializationObject the object to serialize to
   * @param _valueSerializeFunction a function that serializes a specific value
   */
  serialize(serializationObject = {}, _valueSerializeFunction = defaultValueSerializationFunction) {
    serializationObject.uniqueId = this.uniqueId;
    serializationObject.config = {};
    if (this.config) {
      const config = this.config;
      Object.keys(this.config).forEach((key) => {
        _valueSerializeFunction(key, config[key], serializationObject.config);
      });
    }
    serializationObject.dataInputs = [];
    serializationObject.dataOutputs = [];
    serializationObject.className = this.getClassName();
    for (const input of this.dataInputs) {
      const serializedInput = {};
      input.serialize(serializedInput);
      serializationObject.dataInputs.push(serializedInput);
    }
    for (const output of this.dataOutputs) {
      const serializedOutput = {};
      output.serialize(serializedOutput);
      serializationObject.dataOutputs.push(serializedOutput);
    }
  }
  /**
   * Deserializes this block
   * @param _serializationObject the object to deserialize from
   */
  deserialize(_serializationObject) {
  }
  _log(context, action, payload) {
    var _a;
    (_a = context.logger) == null ? void 0 : _a.addLogItem({
      action,
      payload,
      className: this.getClassName(),
      uniqueId: this.uniqueId
    });
  }
  /**
   * Gets the class name of this block
   * @returns the class name
   */
  getClassName() {
    return "FlowGraphBlock";
  }
};

export {
  FlowGraphInteger,
  FlowGraphMatrix2D,
  FlowGraphMatrix3D,
  FlowGraphTypes,
  RichType,
  RichTypeAny,
  RichTypeString,
  RichTypeNumber,
  RichTypeBoolean,
  RichTypeVector2,
  RichTypeVector3,
  RichTypeVector4,
  RichTypeMatrix,
  RichTypeMatrix2D,
  RichTypeMatrix3D,
  RichTypeColor3,
  RichTypeColor4,
  RichTypeQuaternion,
  RichTypeFlowGraphInteger,
  getRichTypeFromValue,
  getRichTypeByFlowGraphType,
  getAnimationTypeByFlowGraphType,
  getRichTypeByAnimationType,
  defaultValueSerializationFunction,
  defaultValueParseFunction,
  needsPathConverter,
  FlowGraphConnectionType,
  FlowGraphConnection,
  FlowGraphDataConnection,
  FlowGraphBlock
};
//# sourceMappingURL=chunk-PQRK4BIZ.js.map
