import {
  Observable
} from "./chunk-GWFZRJMO.js";
import {
  Logger
} from "./chunk-OJJXGLTO.js";

// node_modules/@babylonjs/core/AudioV2/abstractAudio/abstractAudioNode.js
var AudioNodeType;
(function(AudioNodeType2) {
  AudioNodeType2[AudioNodeType2["HAS_INPUTS"] = 1] = "HAS_INPUTS";
  AudioNodeType2[AudioNodeType2["HAS_OUTPUTS"] = 2] = "HAS_OUTPUTS";
  AudioNodeType2[AudioNodeType2["HAS_INPUTS_AND_OUTPUTS"] = 3] = "HAS_INPUTS_AND_OUTPUTS";
})(AudioNodeType || (AudioNodeType = {}));
var AbstractAudioNode = class {
  constructor(engine, nodeType) {
    this.onDisposeObservable = new Observable();
    this.engine = engine;
    if (nodeType & 1) {
      this._upstreamNodes = /* @__PURE__ */ new Set();
    }
    if (nodeType & 2) {
      this._downstreamNodes = /* @__PURE__ */ new Set();
    }
  }
  /**
   * Releases associated resources.
   * - Triggers `onDisposeObservable`.
   * @see {@link onDisposeObservable}
   */
  dispose() {
    if (this._downstreamNodes) {
      for (const node of Array.from(this._downstreamNodes)) {
        if (!this._disconnect(node)) {
          throw new Error("Disconnect failed");
        }
      }
      this._downstreamNodes.clear();
    }
    if (this._upstreamNodes) {
      for (const node of Array.from(this._upstreamNodes)) {
        if (!node._disconnect(this)) {
          throw new Error("Disconnect failed");
        }
      }
      this._upstreamNodes.clear();
    }
    this.onDisposeObservable.notifyObservers(this);
    this.onDisposeObservable.clear();
  }
  /**
   * Connect to a downstream audio input node.
   * @param node - The downstream audio input node to connect
   * @returns `true` if the node is successfully connected; otherwise `false`
   */
  _connect(node) {
    if (!this._downstreamNodes) {
      return false;
    }
    if (this._downstreamNodes.has(node)) {
      return false;
    }
    if (!node._onConnect(this)) {
      return false;
    }
    this._downstreamNodes.add(node);
    return true;
  }
  /**
   * Disconnects a downstream audio input node.
   * @param node - The downstream audio input node to disconnect
   * @returns `true` if the node is successfully disconnected; otherwise `false`
   */
  _disconnect(node) {
    if (!this._downstreamNodes) {
      return false;
    }
    if (!this._downstreamNodes.delete(node)) {
      return false;
    }
    return node._onDisconnect(this);
  }
  /**
   * Called when an upstream audio output node is connecting.
   * @param node - The connecting upstream audio node
   * @returns `true` if the node is successfully connected; otherwise `false`
   */
  _onConnect(node) {
    if (!this._upstreamNodes) {
      return false;
    }
    if (this._upstreamNodes.has(node)) {
      return false;
    }
    this._upstreamNodes.add(node);
    return true;
  }
  /**
   * Called when an upstream audio output node disconnects.
   * @param node - The disconnecting upstream audio node
   * @returns `true` if node is sucessfully disconnected; otherwise `false`
   */
  _onDisconnect(node) {
    var _a;
    return ((_a = this._upstreamNodes) == null ? void 0 : _a.delete(node)) ?? false;
  }
};
var AbstractNamedAudioNode = class extends AbstractAudioNode {
  constructor(name, engine, nodeType) {
    super(engine, nodeType);
    this.onNameChangedObservable = new Observable();
    this._name = name;
  }
  /**
   * The name of the audio node.
   * - Triggers `onNameChangedObservable` when changed.
   * @see {@link onNameChangedObservable}
   */
  get name() {
    return this._name;
  }
  set name(newName) {
    if (this._name === newName) {
      return;
    }
    const oldName = this._name;
    this._name = newName;
    this.onNameChangedObservable.notifyObservers({ newName, oldName, node: this });
  }
  dispose() {
    super.dispose();
    this.onNameChangedObservable.clear();
  }
};

// node_modules/@babylonjs/core/AudioV2/abstractAudio/subProperties/abstractAudioAnalyzer.js
var _AudioAnalyzerDefaults = {
  fftSize: 2048,
  minDecibels: -100,
  maxDecibels: -30,
  smoothing: 0.8
};
function _HasAudioAnalyzerOptions(options) {
  return options.analyzerEnabled || options.analyzerFFTSize !== void 0 || options.analyzerMinDecibels !== void 0 || options.analyzerMaxDecibels !== void 0 || options.analyzerSmoothing !== void 0;
}
var AbstractAudioAnalyzer = class {
  /**
   * The number of data values that will be returned when calling getByteFrequencyData() or getFloatFrequencyData(). This is always half the `fftSize`.
   */
  get frequencyBinCount() {
    return this.fftSize / 2;
  }
};

// node_modules/@babylonjs/core/AudioV2/abstractAudio/subNodes/abstractAudioSubGraph.js
var _AbstractAudioSubGraph = class {
  constructor() {
    this._createSubNodePromises = {};
    this._isDisposed = false;
    this._subNodes = {};
    this._onSubNodeDisposed = (node) => {
      const subNode = node;
      delete this._subNodes[subNode.name];
      this._onSubNodesChanged();
    };
  }
  /**
   * Executes the given callback with the named sub node, creating the sub node if needed.
   *
   * @param name The name of the sub node
   * @param callback The function to call with the named sub node
   *
   * @internal
   */
  callOnSubNode(name, callback) {
    const node = this.getSubNode(name);
    if (node) {
      callback(node);
      return;
    }
    this._createSubNodePromisesResolved().then(() => {
      const node2 = this.getSubNode(name);
      if (node2) {
        callback(node2);
        return;
      }
      this.createAndAddSubNode(name).then((node3) => {
        callback(node3);
      });
    });
  }
  /**
   * Creates the named subnode and adds it to the sub graph.
   *
   * @param name The name of the sub node.
   * @returns A promise that resolves to the created sub node.
   *
   * @internal
   */
  createAndAddSubNode(name) {
    var _a;
    (_a = this._createSubNodePromises)[name] || (_a[name] = this._createSubNode(name).then((node) => {
      this._addSubNode(node);
      return node;
    }));
    return this._createSubNodePromises[name];
  }
  /**
   * Releases associated resources.
   *
   * @internal
   */
  dispose() {
    this._isDisposed = true;
    const subNodes = Object.values(this._subNodes);
    for (const subNode of subNodes) {
      subNode.dispose();
    }
    this._subNodes = {};
    this._createSubNodePromises = {};
  }
  /**
   * Gets a previously created sub node.
   *
   * @param name - The name of the sub node
   * @returns The named sub node, or `null` if it has not been created, yet
   *
   * @internal
   * */
  getSubNode(name) {
    return this._subNodes[name] ?? null;
  }
  /**
   * Removes a sub node from the sub graph.
   *
   * @param subNode - The sub node to remove
   * @returns A promise that resolves when the sub node is removed
   *
   * @internal
   */
  async removeSubNode(subNode) {
    await this._createSubNodePromisesResolved();
    const name = subNode.name;
    if (this._subNodes[name]) {
      delete this._subNodes[name];
    }
    delete this._createSubNodePromises[name];
    this._onSubNodesChanged();
  }
  _createSubNodePromisesResolved() {
    return Promise.all(Object.values(this._createSubNodePromises));
  }
  _addSubNode(node) {
    if (this._isDisposed) {
      node.dispose();
      return;
    }
    this._subNodes[node.name] = node;
    node.onDisposeObservable.addOnce(this._onSubNodeDisposed);
    this._onSubNodesChanged();
  }
};

// node_modules/@babylonjs/core/AudioV2/abstractAudio/subNodes/abstractAudioSubNode.js
var _AbstractAudioSubNode = class extends AbstractNamedAudioNode {
  /** @internal */
  constructor(name, engine) {
    super(
      name,
      engine,
      3
      /* AudioNodeType.HAS_INPUTS_AND_OUTPUTS */
    );
  }
  /** @internal */
  connect(node) {
    if (!this._connect(node)) {
      throw new Error("Connect failed");
    }
  }
  /** @internal */
  disconnect(node) {
    if (!this._disconnect(node)) {
      throw new Error("Disconnect failed");
    }
  }
  /** @internal */
  disconnectAll() {
    if (!this._downstreamNodes) {
      throw new Error("Disconnect failed");
    }
    const it = this._downstreamNodes.values();
    for (let next = it.next(); !next.done; next = it.next()) {
      if (!this._disconnect(next.value)) {
        throw new Error("Disconnect failed");
      }
    }
  }
};

// node_modules/@babylonjs/core/AudioV2/abstractAudio/subNodes/audioAnalyzerSubNode.js
var _AudioAnalyzerSubNode = class extends _AbstractAudioSubNode {
  constructor(engine) {
    super("Analyzer", engine);
  }
  /** @internal */
  setOptions(options) {
    this.fftSize = options.analyzerFFTSize ?? _AudioAnalyzerDefaults.fftSize;
    this.minDecibels = options.analyzerMinDecibels ?? _AudioAnalyzerDefaults.minDecibels;
    this.maxDecibels = options.analyzerMaxDecibels ?? _AudioAnalyzerDefaults.maxDecibels;
    this.smoothing = options.analyzerSmoothing ?? _AudioAnalyzerDefaults.smoothing;
  }
};
function _GetAudioAnalyzerSubNode(subGraph) {
  return subGraph.getSubNode(
    "Analyzer"
    /* AudioSubNode.ANALYZER */
  );
}
function _GetAudioAnalyzerProperty(subGraph, property) {
  var _a;
  return ((_a = _GetAudioAnalyzerSubNode(subGraph)) == null ? void 0 : _a[property]) ?? _AudioAnalyzerDefaults[property];
}
function _SetAudioAnalyzerProperty(subGraph, property, value) {
  subGraph.callOnSubNode("Analyzer", (node) => {
    node[property] = value;
  });
}

// node_modules/@babylonjs/core/AudioV2/abstractAudio/subNodes/volumeAudioSubNode.js
var _VolumeAudioDefaults = {
  volume: 1
};
var _VolumeAudioSubNode = class extends _AbstractAudioSubNode {
  constructor(engine) {
    super("Volume", engine);
  }
  /** @internal */
  setOptions(options) {
    this.volume = options.volume ?? _VolumeAudioDefaults.volume;
  }
};
function _GetVolumeAudioSubNode(subGraph) {
  return subGraph.getSubNode(
    "Volume"
    /* AudioSubNode.VOLUME */
  );
}
function _GetVolumeAudioProperty(subGraph, property) {
  var _a;
  return ((_a = _GetVolumeAudioSubNode(subGraph)) == null ? void 0 : _a[property]) ?? _VolumeAudioDefaults[property];
}

// node_modules/@babylonjs/core/AudioV2/webAudio/subNodes/volumeWebAudioSubNode.js
async function _CreateVolumeAudioSubNodeAsync(engine) {
  return new _VolumeWebAudioSubNode(engine);
}
var _VolumeWebAudioSubNode = class extends _VolumeAudioSubNode {
  /** @internal */
  constructor(engine) {
    super(engine);
    this._volume = 1;
    this.node = new GainNode(engine._audioContext);
  }
  /** @internal */
  get volume() {
    return this._volume;
  }
  /** @internal */
  set volume(value) {
    this._volume = value;
    this.engine._setAudioParam(this.node.gain, value);
  }
  /** @internal */
  get _inNode() {
    return this.node;
  }
  /** @internal */
  get _outNode() {
    return this.node;
  }
  _connect(node) {
    const connected = super._connect(node);
    if (!connected) {
      return false;
    }
    if (node._inNode) {
      this.node.connect(node._inNode);
    }
    return true;
  }
  _disconnect(node) {
    const disconnected = super._disconnect(node);
    if (!disconnected) {
      return false;
    }
    if (node._inNode) {
      this.node.disconnect(node._inNode);
    }
    return true;
  }
  /** @internal */
  getClassName() {
    return "_VolumeWebAudioSubNode";
  }
};

// node_modules/@babylonjs/core/AudioV2/abstractAudio/subProperties/audioAnalyzer.js
var _emptyByteFrequencyData = null;
var _emptyFloatFrequencyData = null;
function _GetEmptyByteFrequencyData() {
  if (!_emptyByteFrequencyData) {
    _emptyByteFrequencyData = new Uint8Array();
  }
  return _emptyByteFrequencyData;
}
function _GetEmptyFloatFrequencyData() {
  if (!_emptyFloatFrequencyData) {
    _emptyFloatFrequencyData = new Float32Array();
  }
  return _emptyFloatFrequencyData;
}
var _AudioAnalyzer = class extends AbstractAudioAnalyzer {
  /** @internal */
  constructor(subGraph) {
    super();
    this._subGraph = subGraph;
  }
  /** @internal */
  get fftSize() {
    return _GetAudioAnalyzerProperty(this._subGraph, "fftSize");
  }
  set fftSize(value) {
    _SetAudioAnalyzerProperty(this._subGraph, "fftSize", value);
  }
  /** @internal */
  get isEnabled() {
    return _GetAudioAnalyzerSubNode(this._subGraph) !== null;
  }
  /** @internal */
  get minDecibels() {
    return _GetAudioAnalyzerProperty(this._subGraph, "minDecibels");
  }
  set minDecibels(value) {
    _SetAudioAnalyzerProperty(this._subGraph, "minDecibels", value);
  }
  /** @internal */
  get maxDecibels() {
    return _GetAudioAnalyzerProperty(this._subGraph, "maxDecibels");
  }
  set maxDecibels(value) {
    _SetAudioAnalyzerProperty(this._subGraph, "maxDecibels", value);
  }
  /** @internal */
  get smoothing() {
    return _GetAudioAnalyzerProperty(this._subGraph, "smoothing");
  }
  set smoothing(value) {
    _SetAudioAnalyzerProperty(this._subGraph, "smoothing", value);
  }
  /** @internal */
  dispose() {
    const subNode = _GetAudioAnalyzerSubNode(this._subGraph);
    if (subNode) {
      this._subGraph.removeSubNode(subNode);
      subNode.dispose();
    }
  }
  /** @internal */
  async enableAsync() {
    const subNode = _GetAudioAnalyzerSubNode(this._subGraph);
    if (!subNode) {
      await this._subGraph.createAndAddSubNode(
        "Analyzer"
        /* AudioSubNode.ANALYZER */
      );
    }
    return Promise.resolve();
  }
  /** @internal */
  getByteFrequencyData() {
    const subNode = _GetAudioAnalyzerSubNode(this._subGraph);
    if (!subNode) {
      Logger.Warn("AudioAnalyzer not enabled");
      this.enableAsync();
      return _GetEmptyByteFrequencyData();
    }
    return subNode.getByteFrequencyData();
  }
  /** @internal */
  getFloatFrequencyData() {
    const subNode = _GetAudioAnalyzerSubNode(this._subGraph);
    if (!subNode) {
      Logger.Warn("AudioAnalyzer not enabled");
      this.enableAsync();
      return _GetEmptyFloatFrequencyData();
    }
    return subNode.getFloatFrequencyData();
  }
};

// node_modules/@babylonjs/core/AudioV2/webAudio/subNodes/webAudioAnalyzerSubNode.js
async function _CreateAudioAnalyzerSubNodeAsync(engine) {
  return new _WebAudioAnalyzerSubNode(engine);
}
var _WebAudioAnalyzerSubNode = class extends _AudioAnalyzerSubNode {
  /** @internal */
  constructor(engine) {
    super(engine);
    this._byteFrequencyData = null;
    this._floatFrequencyData = null;
    this._analyzerNode = new AnalyserNode(engine._audioContext);
  }
  /** @internal */
  get fftSize() {
    return this._analyzerNode.fftSize;
  }
  set fftSize(value) {
    if (value === this._analyzerNode.fftSize) {
      return;
    }
    this._analyzerNode.fftSize = value;
    this._clearArrays();
  }
  /** @internal */
  get _inNode() {
    return this._analyzerNode;
  }
  /** @internal */
  get minDecibels() {
    return this._analyzerNode.minDecibels;
  }
  set minDecibels(value) {
    this._analyzerNode.minDecibels = value;
  }
  /** @internal */
  get maxDecibels() {
    return this._analyzerNode.maxDecibels;
  }
  set maxDecibels(value) {
    this._analyzerNode.maxDecibels = value;
  }
  /** @internal */
  get smoothing() {
    return this._analyzerNode.smoothingTimeConstant;
  }
  set smoothing(value) {
    this._analyzerNode.smoothingTimeConstant = value;
  }
  /** @internal */
  dispose() {
    super.dispose();
    this._clearArrays();
    this._byteFrequencyData = null;
    this._floatFrequencyData = null;
    this._analyzerNode.disconnect();
  }
  /** @internal */
  getClassName() {
    return "_WebAudioAnalyzerSubNode";
  }
  /** @internal */
  getByteFrequencyData() {
    if (!this._byteFrequencyData || this._byteFrequencyData.length === 0) {
      this._byteFrequencyData = new Uint8Array(this._analyzerNode.frequencyBinCount);
    }
    this._analyzerNode.getByteFrequencyData(this._byteFrequencyData);
    return this._byteFrequencyData;
  }
  /** @internal */
  getFloatFrequencyData() {
    if (!this._floatFrequencyData || this._floatFrequencyData.length === 0) {
      this._floatFrequencyData = new Float32Array(this._analyzerNode.frequencyBinCount);
    }
    this._analyzerNode.getFloatFrequencyData(this._floatFrequencyData);
    return this._floatFrequencyData;
  }
  _clearArrays() {
    var _a, _b;
    (_a = this._byteFrequencyData) == null ? void 0 : _a.set(_GetEmptyByteFrequencyData());
    (_b = this._floatFrequencyData) == null ? void 0 : _b.set(_GetEmptyFloatFrequencyData());
  }
};

// node_modules/@babylonjs/core/AudioV2/webAudio/subNodes/webAudioBaseSubGraph.js
var _WebAudioBaseSubGraph = class extends _AbstractAudioSubGraph {
  /** @internal */
  constructor(owner) {
    super();
    this._outputNode = null;
    this._owner = owner;
  }
  /** @internal */
  async init(options) {
    const hasAnalyzerOptions = _HasAudioAnalyzerOptions(options);
    if (hasAnalyzerOptions) {
      await this.createAndAddSubNode(
        "Analyzer"
        /* AudioSubNode.ANALYZER */
      );
    }
    await this.createAndAddSubNode(
      "Volume"
      /* AudioSubNode.VOLUME */
    );
    await this._createSubNodePromisesResolved();
    if (hasAnalyzerOptions) {
      const analyzerNode = _GetAudioAnalyzerSubNode(this);
      if (!analyzerNode) {
        throw new Error("No analyzer subnode.");
      }
      analyzerNode.setOptions(options);
    }
    const volumeNode = _GetVolumeAudioSubNode(this);
    if (!volumeNode) {
      throw new Error("No volume subnode.");
    }
    volumeNode.setOptions(options);
    if (volumeNode.getClassName() !== "_VolumeWebAudioSubNode") {
      throw new Error("Not a WebAudio subnode.");
    }
    this._outputNode = volumeNode.node;
    if (this._outputNode && this._downstreamNodes) {
      const it = this._downstreamNodes.values();
      for (let next = it.next(); !next.done; next = it.next()) {
        const inNode = next.value._inNode;
        if (inNode) {
          this._outputNode.connect(inNode);
        }
      }
    }
  }
  /** @internal */
  get _inNode() {
    return this._outputNode;
  }
  /** @internal */
  get _outNode() {
    return this._outputNode;
  }
  _createSubNode(name) {
    switch (name) {
      case "Analyzer":
        return _CreateAudioAnalyzerSubNodeAsync(this._owner.engine);
      case "Volume":
        return _CreateVolumeAudioSubNodeAsync(this._owner.engine);
      default:
        throw new Error(`Unknown subnode name: ${name}`);
    }
  }
  _onSubNodesChanged() {
    const analyzerNode = _GetAudioAnalyzerSubNode(this);
    const volumeNode = _GetVolumeAudioSubNode(this);
    if (analyzerNode && volumeNode) {
      volumeNode.connect(analyzerNode);
    }
  }
};

export {
  AudioNodeType,
  AbstractAudioNode,
  AbstractNamedAudioNode,
  _AbstractAudioSubNode,
  _GetVolumeAudioSubNode,
  _GetVolumeAudioProperty,
  _AudioAnalyzerDefaults,
  _HasAudioAnalyzerOptions,
  AbstractAudioAnalyzer,
  _AudioAnalyzer,
  _WebAudioBaseSubGraph
};
//# sourceMappingURL=chunk-PUTQWIL7.js.map
