import {
  GetFlowGraphAssetWithType
} from "./chunk-2TY2RX26.js";
import {
  _isADescendantOf
} from "./chunk-2EXF6GXX.js";
import {
  FlowGraphEventBlock
} from "./chunk-NG44AFPO.js";
import {
  FlowGraphExecutionBlock
} from "./chunk-O24ALDLE.js";
import {
  defaultValueSerializationFunction
} from "./chunk-QU5NJF7N.js";
import {
  PointerEventTypes
} from "./chunk-CEMZORTM.js";
import {
  __decorate,
  serialize
} from "./chunk-3FJRTHLS.js";
import {
  Tools
} from "./chunk-6RU4CQCA.js";
import {
  RandomGUID
} from "./chunk-IW7YW5OA.js";
import {
  RegisterClass
} from "./chunk-LMH7SWDS.js";
import {
  Logger
} from "./chunk-OJJXGLTO.js";
import {
  Observable
} from "./chunk-GWFZRJMO.js";

// node_modules/@babylonjs/core/FlowGraph/flowGraphLogger.js
var FlowGraphAction;
(function(FlowGraphAction2) {
  FlowGraphAction2["ExecuteBlock"] = "ExecuteBlock";
  FlowGraphAction2["ExecuteEvent"] = "ExecuteEvent";
  FlowGraphAction2["TriggerConnection"] = "TriggerConnection";
  FlowGraphAction2["ContextVariableSet"] = "ContextVariableSet";
  FlowGraphAction2["GlobalVariableSet"] = "GlobalVariableSet";
  FlowGraphAction2["GlobalVariableDelete"] = "GlobalVariableDelete";
  FlowGraphAction2["GlobalVariableGet"] = "GlobalVariableGet";
  FlowGraphAction2["AddConnection"] = "AddConnection";
  FlowGraphAction2["GetConnectionValue"] = "GetConnectionValue";
  FlowGraphAction2["SetConnectionValue"] = "SetConnectionValue";
  FlowGraphAction2["ActivateSignal"] = "ActivateSignal";
  FlowGraphAction2["ContextVariableGet"] = "ContextVariableGet";
})(FlowGraphAction || (FlowGraphAction = {}));
var FlowGraphLogger = class {
  constructor() {
    this.logToConsole = false;
    this.log = [];
  }
  addLogItem(item) {
    var _a;
    if (!item.time) {
      item.time = Date.now();
    }
    this.log.push(item);
    if (this.logToConsole) {
      const value = (_a = item.payload) == null ? void 0 : _a.value;
      if (typeof value === "object" && value.getClassName) {
        Logger.Log(`[FGLog] ${item.className}:${item.uniqueId.split("-")[0]} ${item.action} - ${JSON.stringify(value.getClassName())}: ${value.toString()}`);
      } else {
        Logger.Log(`[FGLog] ${item.className}:${item.uniqueId.split("-")[0]} ${item.action} - ${JSON.stringify(item.payload)}`);
      }
    }
  }
  getItemsOfType(action) {
    return this.log.filter((i) => i.action === action);
  }
};

// node_modules/@babylonjs/core/FlowGraph/flowGraphContext.js
var FlowGraphContext = class {
  /**
   * Enable logging on this context
   */
  get enableLogging() {
    return this._enableLogging;
  }
  set enableLogging(value) {
    if (this._enableLogging === value) {
      return;
    }
    this._enableLogging = value;
    if (this._enableLogging) {
      this.logger = new FlowGraphLogger();
      this.logger.logToConsole = true;
    } else {
      this.logger = null;
    }
  }
  constructor(params) {
    this.uniqueId = RandomGUID();
    this._userVariables = {};
    this._executionVariables = {};
    this._globalContextVariables = {};
    this._connectionValues = {};
    this._pendingBlocks = [];
    this._executionId = 0;
    this.onNodeExecutedObservable = new Observable();
    this.treatDataAsRightHanded = false;
    this._enableLogging = false;
    this._configuration = params;
    this.assetsContext = params.assetsContext ?? params.scene;
  }
  /**
   * Check if a user-defined variable is defined.
   * @param name the name of the variable
   * @returns true if the variable is defined
   */
  hasVariable(name) {
    return name in this._userVariables;
  }
  /**
   * Set a user-defined variable.
   * @param name the name of the variable
   * @param value the value of the variable
   */
  setVariable(name, value) {
    var _a;
    this._userVariables[name] = value;
    (_a = this.logger) == null ? void 0 : _a.addLogItem({
      time: Date.now(),
      className: this.getClassName(),
      uniqueId: this.uniqueId,
      action: "ContextVariableSet",
      payload: {
        name,
        value
      }
    });
  }
  /**
   * Get an assets from the assets context based on its type and index in the array
   * @param type The type of the asset
   * @param index The index of the asset
   * @returns The asset or null if not found
   */
  getAsset(type, index) {
    return GetFlowGraphAssetWithType(this.assetsContext, type, index);
  }
  /**
   * Get a user-defined variable.
   * @param name the name of the variable
   * @returns the value of the variable
   */
  getVariable(name) {
    var _a;
    (_a = this.logger) == null ? void 0 : _a.addLogItem({
      time: Date.now(),
      className: this.getClassName(),
      uniqueId: this.uniqueId,
      action: "ContextVariableGet",
      payload: {
        name,
        value: this._userVariables[name]
      }
    });
    return this._userVariables[name];
  }
  /**
   * Gets all user variables map
   */
  get userVariables() {
    return this._userVariables;
  }
  /**
   * Get the scene that the context belongs to.
   * @returns the scene
   */
  getScene() {
    return this._configuration.scene;
  }
  _getUniqueIdPrefixedName(obj, name) {
    return `${obj.uniqueId}_${name}`;
  }
  /**
   * @internal
   * @param name name of the variable
   * @param defaultValue default value to return if the variable is not defined
   * @returns the variable value or the default value if the variable is not defined
   */
  _getGlobalContextVariable(name, defaultValue) {
    var _a;
    (_a = this.logger) == null ? void 0 : _a.addLogItem({
      time: Date.now(),
      className: this.getClassName(),
      uniqueId: this.uniqueId,
      action: "GlobalVariableGet",
      payload: {
        name,
        defaultValue,
        possibleValue: this._globalContextVariables[name]
      }
    });
    if (this._hasGlobalContextVariable(name)) {
      return this._globalContextVariables[name];
    } else {
      return defaultValue;
    }
  }
  /**
   * Set a global context variable
   * @internal
   * @param name the name of the variable
   * @param value the value of the variable
   */
  _setGlobalContextVariable(name, value) {
    var _a;
    (_a = this.logger) == null ? void 0 : _a.addLogItem({
      time: Date.now(),
      className: this.getClassName(),
      uniqueId: this.uniqueId,
      action: "GlobalVariableSet",
      payload: { name, value }
    });
    this._globalContextVariables[name] = value;
  }
  /**
   * Delete a global context variable
   * @internal
   * @param name the name of the variable
   */
  _deleteGlobalContextVariable(name) {
    var _a;
    (_a = this.logger) == null ? void 0 : _a.addLogItem({
      time: Date.now(),
      className: this.getClassName(),
      uniqueId: this.uniqueId,
      action: "GlobalVariableDelete",
      payload: { name }
    });
    delete this._globalContextVariables[name];
  }
  /**
   * Check if a global context variable is defined
   * @internal
   * @param name the name of the variable
   * @returns true if the variable is defined
   */
  _hasGlobalContextVariable(name) {
    return name in this._globalContextVariables;
  }
  /**
   * Set an internal execution variable
   * @internal
   * @param name
   * @param value
   */
  _setExecutionVariable(block, name, value) {
    this._executionVariables[this._getUniqueIdPrefixedName(block, name)] = value;
  }
  /**
   * Get an internal execution variable
   * @internal
   * @param name
   * @returns
   */
  _getExecutionVariable(block, name, defaultValue) {
    if (this._hasExecutionVariable(block, name)) {
      return this._executionVariables[this._getUniqueIdPrefixedName(block, name)];
    } else {
      return defaultValue;
    }
  }
  /**
   * Delete an internal execution variable
   * @internal
   * @param block
   * @param name
   */
  _deleteExecutionVariable(block, name) {
    delete this._executionVariables[this._getUniqueIdPrefixedName(block, name)];
  }
  /**
   * Check if an internal execution variable is defined
   * @internal
   * @param block
   * @param name
   * @returns
   */
  _hasExecutionVariable(block, name) {
    return this._getUniqueIdPrefixedName(block, name) in this._executionVariables;
  }
  /**
   * Check if a connection value is defined
   * @internal
   * @param connectionPoint
   * @returns
   */
  _hasConnectionValue(connectionPoint) {
    return connectionPoint.uniqueId in this._connectionValues;
  }
  /**
   * Set a connection value
   * @internal
   * @param connectionPoint
   * @param value
   */
  _setConnectionValue(connectionPoint, value) {
    var _a;
    this._connectionValues[connectionPoint.uniqueId] = value;
    (_a = this.logger) == null ? void 0 : _a.addLogItem({
      time: Date.now(),
      className: this.getClassName(),
      uniqueId: this.uniqueId,
      action: "SetConnectionValue",
      payload: {
        connectionPointId: connectionPoint.uniqueId,
        value
      }
    });
  }
  /**
   * Set a connection value by key
   * @internal
   * @param key the key of the connection value
   * @param value the value of the connection
   */
  _setConnectionValueByKey(key, value) {
    this._connectionValues[key] = value;
  }
  /**
   * Get a connection value
   * @internal
   * @param connectionPoint
   * @returns
   */
  _getConnectionValue(connectionPoint) {
    var _a;
    (_a = this.logger) == null ? void 0 : _a.addLogItem({
      time: Date.now(),
      className: this.getClassName(),
      uniqueId: this.uniqueId,
      action: "GetConnectionValue",
      payload: {
        connectionPointId: connectionPoint.uniqueId,
        value: this._connectionValues[connectionPoint.uniqueId]
      }
    });
    return this._connectionValues[connectionPoint.uniqueId];
  }
  /**
   * Get the configuration
   * @internal
   * @param name
   * @param value
   */
  get configuration() {
    return this._configuration;
  }
  /**
   * Check if there are any pending blocks in this context
   * @returns true if there are pending blocks
   */
  get hasPendingBlocks() {
    return this._pendingBlocks.length > 0;
  }
  /**
   * Add a block to the list of blocks that have pending tasks.
   * @internal
   * @param block
   */
  _addPendingBlock(block) {
    if (this._pendingBlocks.includes(block)) {
      return;
    }
    this._pendingBlocks.push(block);
    this._pendingBlocks.sort((a, b) => a.priority - b.priority);
  }
  /**
   * Remove a block from the list of blocks that have pending tasks.
   * @internal
   * @param block
   */
  _removePendingBlock(block) {
    const index = this._pendingBlocks.indexOf(block);
    if (index !== -1) {
      this._pendingBlocks.splice(index, 1);
    }
  }
  /**
   * Clear all pending blocks.
   * @internal
   */
  _clearPendingBlocks() {
    for (const block of this._pendingBlocks) {
      block._cancelPendingTasks(this);
    }
    this._pendingBlocks.length = 0;
  }
  /**
   * @internal
   * Function that notifies the node executed observable
   * @param node
   */
  _notifyExecuteNode(node) {
    var _a;
    this.onNodeExecutedObservable.notifyObservers(node);
    (_a = this.logger) == null ? void 0 : _a.addLogItem({
      time: Date.now(),
      className: node.getClassName(),
      uniqueId: node.uniqueId,
      action: "ExecuteBlock"
    });
  }
  _notifyOnTick(framePayload) {
    var _a;
    this._setGlobalContextVariable("timeSinceStart", framePayload.timeSinceStart);
    this._setGlobalContextVariable("deltaTime", framePayload.deltaTime);
    for (const block of this._pendingBlocks) {
      (_a = block._executeOnTick) == null ? void 0 : _a.call(block, this);
    }
  }
  /**
   * @internal
   */
  _increaseExecutionId() {
    this._executionId++;
  }
  /**
   * A monotonically increasing ID for each execution.
   * Incremented for every block executed.
   */
  get executionId() {
    return this._executionId;
  }
  /**
   * Serializes a context
   * @param serializationObject the object to write the values in
   * @param valueSerializationFunction a function to serialize complex values
   */
  serialize(serializationObject = {}, valueSerializationFunction = defaultValueSerializationFunction) {
    var _a;
    serializationObject.uniqueId = this.uniqueId;
    serializationObject._userVariables = {};
    for (const key in this._userVariables) {
      valueSerializationFunction(key, this._userVariables[key], serializationObject._userVariables);
    }
    serializationObject._connectionValues = {};
    for (const key in this._connectionValues) {
      valueSerializationFunction(key, this._connectionValues[key], serializationObject._connectionValues);
    }
    if (this.assetsContext !== this.getScene()) {
      serializationObject._assetsContext = {
        meshes: this.assetsContext.meshes.map((m) => m.id),
        materials: this.assetsContext.materials.map((m) => m.id),
        textures: this.assetsContext.textures.map((m) => m.name),
        animations: this.assetsContext.animations.map((m) => m.name),
        lights: this.assetsContext.lights.map((m) => m.id),
        cameras: this.assetsContext.cameras.map((m) => m.id),
        sounds: (_a = this.assetsContext.sounds) == null ? void 0 : _a.map((m) => m.name),
        skeletons: this.assetsContext.skeletons.map((m) => m.id),
        particleSystems: this.assetsContext.particleSystems.map((m) => m.name),
        geometries: this.assetsContext.geometries.map((m) => m.id),
        multiMaterials: this.assetsContext.multiMaterials.map((m) => m.id),
        transformNodes: this.assetsContext.transformNodes.map((m) => m.id)
      };
    }
  }
  /**
   * @returns the class name of the object.
   */
  getClassName() {
    return "FlowGraphContext";
  }
};
__decorate([
  serialize()
], FlowGraphContext.prototype, "uniqueId", void 0);

// node_modules/@babylonjs/core/FlowGraph/flowGraphSceneEventCoordinator.js
var FlowGraphSceneEventCoordinator = class {
  constructor(scene) {
    this.onEventTriggeredObservable = new Observable();
    this.sceneReadyTriggered = false;
    this._pointerUnderMeshState = {};
    this._startingTime = 0;
    this._scene = scene;
    this._initialize();
  }
  _initialize() {
    this._sceneReadyObserver = this._scene.onReadyObservable.add(() => {
      if (!this.sceneReadyTriggered) {
        this.onEventTriggeredObservable.notifyObservers({
          type: "SceneReady"
          /* FlowGraphEventType.SceneReady */
        });
        this.sceneReadyTriggered = true;
      }
    });
    this._sceneDisposeObserver = this._scene.onDisposeObservable.add(() => {
      this.onEventTriggeredObservable.notifyObservers({
        type: "SceneDispose"
        /* FlowGraphEventType.SceneDispose */
      });
    });
    this._sceneOnBeforeRenderObserver = this._scene.onBeforeRenderObservable.add(() => {
      const deltaTime = this._scene.getEngine().getDeltaTime() / 1e3;
      this.onEventTriggeredObservable.notifyObservers({
        type: "SceneBeforeRender",
        payload: {
          timeSinceStart: this._startingTime,
          deltaTime
        }
      });
      this._startingTime += deltaTime;
    });
    this._meshPickedObserver = this._scene.onPointerObservable.add((pointerInfo) => {
      this.onEventTriggeredObservable.notifyObservers({ type: "MeshPick", payload: pointerInfo });
    }, PointerEventTypes.POINTERPICK);
    this._meshUnderPointerObserver = this._scene.onMeshUnderPointerUpdatedObservable.add((data) => {
      const pointerId = data.pointerId;
      const mesh = data.mesh;
      const previousState = this._pointerUnderMeshState[pointerId];
      if (!previousState && mesh) {
        this.onEventTriggeredObservable.notifyObservers({ type: "PointerOver", payload: { pointerId, mesh } });
      } else if (previousState && !mesh) {
        this.onEventTriggeredObservable.notifyObservers({ type: "PointerOut", payload: { pointerId, mesh: previousState } });
      } else if (previousState && mesh && previousState !== mesh) {
        this.onEventTriggeredObservable.notifyObservers({ type: "PointerOut", payload: { pointerId, mesh: previousState, over: mesh } });
        this.onEventTriggeredObservable.notifyObservers({ type: "PointerOver", payload: { pointerId, mesh, out: previousState } });
      }
      this._pointerUnderMeshState[pointerId] = mesh;
    }, PointerEventTypes.POINTERMOVE);
  }
  dispose() {
    var _a, _b, _c, _d, _e;
    (_a = this._sceneDisposeObserver) == null ? void 0 : _a.remove();
    (_b = this._sceneReadyObserver) == null ? void 0 : _b.remove();
    (_c = this._sceneOnBeforeRenderObserver) == null ? void 0 : _c.remove();
    (_d = this._meshPickedObserver) == null ? void 0 : _d.remove();
    (_e = this._meshUnderPointerObserver) == null ? void 0 : _e.remove();
    this.onEventTriggeredObservable.clear();
  }
};

// node_modules/@babylonjs/core/FlowGraph/flowGraph.js
var FlowGraphState;
(function(FlowGraphState2) {
  FlowGraphState2[FlowGraphState2["Stopped"] = 0] = "Stopped";
  FlowGraphState2[FlowGraphState2["Started"] = 1] = "Started";
})(FlowGraphState || (FlowGraphState = {}));
var FlowGraph = class {
  /**
   * The state of the graph
   */
  get state() {
    return this._state;
  }
  /**
   * The state of the graph
   */
  set state(value) {
    this._state = value;
    this.onStateChangedObservable.notifyObservers(value);
  }
  /**
   * Construct a Flow Graph
   * @param params construction parameters. currently only the scene
   */
  constructor(params) {
    this.onStateChangedObservable = new Observable();
    this._eventBlocks = {
      [
        "SceneReady"
        /* FlowGraphEventType.SceneReady */
      ]: [],
      [
        "SceneDispose"
        /* FlowGraphEventType.SceneDispose */
      ]: [],
      [
        "SceneBeforeRender"
        /* FlowGraphEventType.SceneBeforeRender */
      ]: [],
      [
        "MeshPick"
        /* FlowGraphEventType.MeshPick */
      ]: [],
      [
        "PointerDown"
        /* FlowGraphEventType.PointerDown */
      ]: [],
      [
        "PointerUp"
        /* FlowGraphEventType.PointerUp */
      ]: [],
      [
        "PointerMove"
        /* FlowGraphEventType.PointerMove */
      ]: [],
      [
        "PointerOver"
        /* FlowGraphEventType.PointerOver */
      ]: [],
      [
        "PointerOut"
        /* FlowGraphEventType.PointerOut */
      ]: [],
      [
        "SceneAfterRender"
        /* FlowGraphEventType.SceneAfterRender */
      ]: [],
      [
        "NoTrigger"
        /* FlowGraphEventType.NoTrigger */
      ]: []
    };
    this._executionContexts = [];
    this._state = 0;
    this._scene = params.scene;
    this._sceneEventCoordinator = new FlowGraphSceneEventCoordinator(this._scene);
    this._coordinator = params.coordinator;
    this._eventObserver = this._sceneEventCoordinator.onEventTriggeredObservable.add((event) => {
      for (const context of this._executionContexts) {
        const order = this._getContextualOrder(event.type, context);
        for (const block of order) {
          if (!block._executeEvent(context, event.payload)) {
            break;
          }
        }
      }
      switch (event.type) {
        case "SceneReady":
          this._sceneEventCoordinator.sceneReadyTriggered = true;
          break;
        case "SceneBeforeRender":
          for (const context of this._executionContexts) {
            context._notifyOnTick(event.payload);
          }
          break;
        case "SceneDispose":
          this.dispose();
          break;
      }
    });
  }
  /**
   * Create a context. A context represents one self contained execution for the graph, with its own variables.
   * @returns the context, where you can get and set variables
   */
  createContext() {
    const context = new FlowGraphContext({ scene: this._scene, coordinator: this._coordinator });
    this._executionContexts.push(context);
    return context;
  }
  /**
   * Returns the execution context at a given index
   * @param index the index of the context
   * @returns the execution context at that index
   */
  getContext(index) {
    return this._executionContexts[index];
  }
  /**
   * Add an event block. When the graph is started, it will start listening to events
   * from the block and execute the graph when they are triggered.
   * @param block the event block to be added
   */
  addEventBlock(block) {
    if (block.type === "PointerOver" || block.type === "PointerOut") {
      this._scene.constantlyUpdateMeshUnderPointer = true;
    }
    if (block.type !== "NoTrigger") {
      this._eventBlocks[block.type].push(block);
    }
    if (this.state === 1) {
      for (const context of this._executionContexts) {
        block._startPendingTasks(context);
      }
    } else {
      this.onStateChangedObservable.addOnce((state) => {
        if (state === 1) {
          for (const context of this._executionContexts) {
            block._startPendingTasks(context);
          }
        }
      });
    }
  }
  /**
   * Starts the flow graph. Initializes the event blocks and starts listening to events.
   */
  start() {
    if (this.state === 1) {
      return;
    }
    if (this._executionContexts.length === 0) {
      this.createContext();
    }
    this.onStateChangedObservable.add((state) => {
      if (state === 1) {
        this._startPendingEvents();
        if (this._scene.isReady(true)) {
          this._sceneEventCoordinator.onEventTriggeredObservable.notifyObservers({
            type: "SceneReady"
            /* FlowGraphEventType.SceneReady */
          });
        }
      }
    });
    this.state = 1;
  }
  _startPendingEvents() {
    for (const context of this._executionContexts) {
      for (const type in this._eventBlocks) {
        const order = this._getContextualOrder(type, context);
        for (const block of order) {
          block._startPendingTasks(context);
        }
      }
    }
  }
  _getContextualOrder(type, context) {
    const order = this._eventBlocks[type].sort((a, b) => b.initPriority - a.initPriority);
    if (type === "MeshPick") {
      const meshPickOrder = [];
      for (const block1 of order) {
        const mesh1 = block1.asset.getValue(context);
        let i = 0;
        for (; i < order.length; i++) {
          const block2 = order[i];
          const mesh2 = block2.asset.getValue(context);
          if (mesh1 && mesh2 && _isADescendantOf(mesh1, mesh2)) {
            break;
          }
        }
        meshPickOrder.splice(i, 0, block1);
      }
      return meshPickOrder;
    }
    return order;
  }
  /**
   * Disposes of the flow graph. Cancels any pending tasks and removes all event listeners.
   */
  dispose() {
    var _a;
    if (this.state === 0) {
      return;
    }
    this.state = 0;
    for (const context of this._executionContexts) {
      context._clearPendingBlocks();
    }
    this._executionContexts.length = 0;
    for (const type in this._eventBlocks) {
      this._eventBlocks[type].length = 0;
    }
    (_a = this._eventObserver) == null ? void 0 : _a.remove();
    this._sceneEventCoordinator.dispose();
  }
  /**
   * Executes a function in all blocks of a flow graph, starting with the event blocks.
   * @param visitor the function to execute.
   */
  visitAllBlocks(visitor) {
    const visitList = [];
    const idsAddedToVisitList = /* @__PURE__ */ new Set();
    for (const type in this._eventBlocks) {
      for (const block of this._eventBlocks[type]) {
        visitList.push(block);
        idsAddedToVisitList.add(block.uniqueId);
      }
    }
    while (visitList.length > 0) {
      const block = visitList.pop();
      visitor(block);
      for (const dataIn of block.dataInputs) {
        for (const connection of dataIn._connectedPoint) {
          if (!idsAddedToVisitList.has(connection._ownerBlock.uniqueId)) {
            visitList.push(connection._ownerBlock);
            idsAddedToVisitList.add(connection._ownerBlock.uniqueId);
          }
        }
      }
      if (block instanceof FlowGraphExecutionBlock) {
        for (const signalOut of block.signalOutputs) {
          for (const connection of signalOut._connectedPoint) {
            if (!idsAddedToVisitList.has(connection._ownerBlock.uniqueId)) {
              visitList.push(connection._ownerBlock);
              idsAddedToVisitList.add(connection._ownerBlock.uniqueId);
            }
          }
        }
      }
    }
  }
  /**
   * Serializes a graph
   * @param serializationObject the object to write the values in
   * @param valueSerializeFunction a function to serialize complex values
   */
  serialize(serializationObject = {}, valueSerializeFunction) {
    serializationObject.allBlocks = [];
    this.visitAllBlocks((block) => {
      const serializedBlock = {};
      block.serialize(serializedBlock);
      serializationObject.allBlocks.push(serializedBlock);
    });
    serializationObject.executionContexts = [];
    for (const context of this._executionContexts) {
      const serializedContext = {};
      context.serialize(serializedContext, valueSerializeFunction);
      serializationObject.executionContexts.push(serializedContext);
    }
  }
};

// node_modules/@babylonjs/core/FlowGraph/flowGraphCoordinator.js
var FlowGraphCoordinator = class _FlowGraphCoordinator {
  constructor(config) {
    this.config = config;
    this.dispatchEventsSynchronously = true;
    this._flowGraphs = [];
    this._customEventsMap = /* @__PURE__ */ new Map();
    this._eventExecutionCounter = /* @__PURE__ */ new Map();
    this._executeOnNextFrame = [];
    this._disposeObserver = this.config.scene.onDisposeObservable.add(() => {
      this.dispose();
    });
    this._onBeforeRenderObserver = this.config.scene.onBeforeRenderObservable.add(() => {
      this._eventExecutionCounter.clear();
      if (this._executeOnNextFrame.length) {
        this._executeOnNextFrame.forEach((event) => {
          this.notifyCustomEvent(event.id, event.data, false);
        });
        this._executeOnNextFrame.length = 0;
      }
    });
    const coordinators = _FlowGraphCoordinator.SceneCoordinators.get(this.config.scene) ?? [];
    coordinators.push(this);
  }
  /**
   * Creates a new flow graph and adds it to the list of existing flow graphs
   * @returns a new flow graph
   */
  createGraph() {
    const graph = new FlowGraph({ scene: this.config.scene, coordinator: this });
    this._flowGraphs.push(graph);
    return graph;
  }
  /**
   * Removes a flow graph from the list of existing flow graphs and disposes it
   * @param graph the graph to remove
   */
  removeGraph(graph) {
    const index = this._flowGraphs.indexOf(graph);
    if (index !== -1) {
      graph.dispose();
      this._flowGraphs.splice(index, 1);
    }
  }
  /**
   * Starts all graphs
   */
  start() {
    this._flowGraphs.forEach((graph) => graph.start());
  }
  /**
   * Disposes all graphs
   */
  dispose() {
    var _a, _b;
    this._flowGraphs.forEach((graph) => graph.dispose());
    this._flowGraphs.length = 0;
    (_a = this._disposeObserver) == null ? void 0 : _a.remove();
    (_b = this._onBeforeRenderObserver) == null ? void 0 : _b.remove();
    const coordinators = _FlowGraphCoordinator.SceneCoordinators.get(this.config.scene) ?? [];
    const index = coordinators.indexOf(this);
    if (index !== -1) {
      coordinators.splice(index, 1);
    }
  }
  /**
   * Serializes this coordinator to a JSON object.
   * @param serializationObject the object to serialize to
   * @param valueSerializeFunction the function to use to serialize the value
   */
  serialize(serializationObject, valueSerializeFunction) {
    serializationObject._flowGraphs = [];
    this._flowGraphs.forEach((graph) => {
      const serializedGraph = {};
      graph.serialize(serializedGraph, valueSerializeFunction);
      serializationObject._flowGraphs.push(serializedGraph);
    });
    serializationObject.dispatchEventsSynchronously = this.dispatchEventsSynchronously;
  }
  /**
   * Gets the list of flow graphs
   */
  get flowGraphs() {
    return this._flowGraphs;
  }
  /**
   * Get an observable that will be notified when the event with the given id is fired.
   * @param id the id of the event
   * @returns the observable for the event
   */
  getCustomEventObservable(id) {
    let observable = this._customEventsMap.get(id);
    if (!observable) {
      observable = new Observable(
        /*undefined, true*/
      );
      this._customEventsMap.set(id, observable);
    }
    return observable;
  }
  /**
   * Notifies the observable for the given event id with the given data.
   * @param id the id of the event
   * @param data the data to send with the event
   * @param async if true, the event will be dispatched asynchronously
   */
  notifyCustomEvent(id, data, async = !this.dispatchEventsSynchronously) {
    if (async) {
      this._executeOnNextFrame.push({ id, data });
      return;
    }
    if (this._eventExecutionCounter.has(id)) {
      const count = this._eventExecutionCounter.get(id);
      this._eventExecutionCounter.set(id, count + 1);
      if (count >= _FlowGraphCoordinator.MaxEventTypeExecutionPerFrame) {
        count === _FlowGraphCoordinator.MaxEventTypeExecutionPerFrame && Logger.Warn(`FlowGraphCoordinator: Too many executions of event "${id}".`);
        return;
      }
    } else {
      this._eventExecutionCounter.set(id, 1);
    }
    const observable = this._customEventsMap.get(id);
    if (observable) {
      observable.notifyObservers(data);
    }
  }
};
FlowGraphCoordinator.MaxEventsPerType = 30;
FlowGraphCoordinator.MaxEventTypeExecutionPerFrame = 30;
FlowGraphCoordinator.SceneCoordinators = /* @__PURE__ */ new Map();

// node_modules/@babylonjs/core/FlowGraph/Blocks/Event/flowGraphReceiveCustomEventBlock.js
var FlowGraphReceiveCustomEventBlock = class extends FlowGraphEventBlock {
  constructor(config) {
    super(config);
    this.config = config;
    this.initPriority = 1;
    for (const key in this.config.eventData) {
      this.registerDataOutput(key, this.config.eventData[key].type);
    }
  }
  _preparePendingTasks(context) {
    const observable = context.configuration.coordinator.getCustomEventObservable(this.config.eventId);
    if (observable && observable.hasObservers() && observable.observers.length > FlowGraphCoordinator.MaxEventsPerType) {
      this._reportError(context, `FlowGraphReceiveCustomEventBlock: Too many observers for event ${this.config.eventId}. Max is ${FlowGraphCoordinator.MaxEventsPerType}.`);
      return;
    }
    const eventObserver = observable.add((eventData) => {
      Object.keys(eventData).forEach((key) => {
        var _a;
        (_a = this.getDataOutput(key)) == null ? void 0 : _a.setValue(eventData[key], context);
      });
      this._execute(context);
    });
    context._setExecutionVariable(this, "_eventObserver", eventObserver);
  }
  _cancelPendingTasks(context) {
    const observable = context.configuration.coordinator.getCustomEventObservable(this.config.eventId);
    if (observable) {
      const eventObserver = context._getExecutionVariable(this, "_eventObserver", null);
      observable.remove(eventObserver);
    } else {
      Tools.Warn(`FlowGraphReceiveCustomEventBlock: Missing observable for event ${this.config.eventId}`);
    }
  }
  _executeEvent(_context, _payload) {
    return true;
  }
  /**
   * @returns class name of the block.
   */
  getClassName() {
    return "FlowGraphReceiveCustomEventBlock";
  }
};
RegisterClass("FlowGraphReceiveCustomEventBlock", FlowGraphReceiveCustomEventBlock);

export {
  FlowGraphAction,
  FlowGraphLogger,
  FlowGraphContext,
  FlowGraphState,
  FlowGraph,
  FlowGraphCoordinator,
  FlowGraphReceiveCustomEventBlock
};
//# sourceMappingURL=chunk-QS7UI66K.js.map
