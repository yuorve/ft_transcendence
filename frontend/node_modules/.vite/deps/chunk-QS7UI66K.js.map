{
  "version": 3,
  "sources": ["../../../dev/core/src/FlowGraph/flowGraphLogger.ts", "../../../dev/core/src/FlowGraph/flowGraphContext.ts", "../../../dev/core/src/FlowGraph/flowGraphSceneEventCoordinator.ts", "../../../dev/core/src/FlowGraph/flowGraph.ts", "../../../dev/core/src/FlowGraph/flowGraphCoordinator.ts", "../../../dev/core/src/FlowGraph/Blocks/Event/flowGraphReceiveCustomEventBlock.ts"],
  "sourcesContent": ["import { Logger } from \"core/Misc/logger\";\n\nexport const enum FlowGraphAction {\n    ExecuteBlock = \"ExecuteBlock\",\n    ExecuteEvent = \"ExecuteEvent\",\n    TriggerConnection = \"TriggerConnection\",\n    ContextVariableSet = \"ContextVariableSet\",\n    GlobalVariableSet = \"GlobalVariableSet\",\n    GlobalVariableDelete = \"GlobalVariableDelete\",\n    GlobalVariableGet = \"GlobalVariableGet\",\n    AddConnection = \"AddConnection\",\n    GetConnectionValue = \"GetConnectionValue\",\n    SetConnectionValue = \"SetConnectionValue\",\n    ActivateSignal = \"ActivateSignal\",\n    ContextVariableGet = \"ContextVariableGet\",\n}\n\n/**\n * An item in the flow graph log.\n */\nexport interface IFlowGraphLogItem {\n    /**\n     * The time of the log item.\n     */\n    time?: number;\n    /**\n     * The class that triggered the log.\n     */\n    className: string;\n    /**\n     * The unique id of the block/module that triggered the log.\n     */\n    uniqueId: string;\n    /**\n     * The action that was logged.\n     */\n    action: FlowGraphAction;\n    /**\n     * The payload of the log\n     * This can be any data that is relevant to the action.\n     * For example, the value of a connection, the value of a variable, etc.\n     * This is optional.\n     */\n    payload?: any;\n}\n\n/**\n * This class will be responsible of logging the flow graph activity.\n * Note that using this class might reduce performance, as it will log every action, according to the configuration.\n * It attaches to a flow graph and uses meta-programming to replace the methods of the flow graph to add logging abilities.\n */\nexport class FlowGraphLogger {\n    /**\n     * Whether to log to the console.\n     */\n    public logToConsole: boolean = false;\n\n    /**\n     * The log cache of the flow graph.\n     * Each item is a logged item, in order of execution.\n     */\n    public log: IFlowGraphLogItem[] = [];\n\n    public addLogItem(item: IFlowGraphLogItem) {\n        if (!item.time) {\n            item.time = Date.now();\n        }\n        this.log.push(item);\n        if (this.logToConsole) {\n            const value = item.payload?.value;\n            if (typeof value === \"object\" && value.getClassName) {\n                Logger.Log(`[FGLog] ${item.className}:${item.uniqueId.split(\"-\")[0]} ${item.action} - ${JSON.stringify(value.getClassName())}: ${value.toString()}`);\n            } else {\n                Logger.Log(`[FGLog] ${item.className}:${item.uniqueId.split(\"-\")[0]} ${item.action} - ${JSON.stringify(item.payload)}`);\n            }\n        }\n    }\n\n    public getItemsOfType(action: FlowGraphAction): IFlowGraphLogItem[] {\n        return this.log.filter((i) => i.action === action);\n    }\n}\n", "import { serialize } from \"../Misc/decorators\";\r\nimport { RandomGUID } from \"../Misc/guid\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { FlowGraphAsyncExecutionBlock } from \"./flowGraphAsyncExecutionBlock\";\r\nimport type { FlowGraphBlock } from \"./flowGraphBlock\";\r\nimport type { FlowGraphDataConnection } from \"./flowGraphDataConnection\";\r\nimport type { FlowGraph } from \"./flowGraph\";\r\nimport { defaultValueSerializationFunction } from \"./serialization\";\r\nimport type { FlowGraphCoordinator } from \"./flowGraphCoordinator\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { AssetType, FlowGraphAssetType } from \"./flowGraphAssetsContext\";\r\nimport { GetFlowGraphAssetWithType } from \"./flowGraphAssetsContext\";\r\nimport type { IAssetContainer } from \"core/IAssetContainer\";\r\nimport type { Nullable } from \"core/types\";\r\nimport { FlowGraphAction, FlowGraphLogger } from \"./flowGraphLogger\";\r\nimport type { IFlowGraphOnTickEventPayload } from \"./Blocks/Event/flowGraphSceneTickEventBlock\";\r\n\r\n/**\r\n * Construction parameters for the context.\r\n */\r\nexport interface IFlowGraphContextConfiguration {\r\n    /**\r\n     * The scene that the flow graph context belongs to.\r\n     */\r\n    readonly scene: Scene;\r\n    /**\r\n     * The event coordinator used by the flow graph context.\r\n     */\r\n    readonly coordinator: FlowGraphCoordinator;\r\n\r\n    /**\r\n     * The assets context used by the flow graph context.\r\n     * If none is provided, a default one will be created.\r\n     */\r\n    readonly assetsContext?: IAssetContainer;\r\n}\r\n\r\n/**\r\n * Options for parsing a context.\r\n */\r\nexport interface IFlowGraphContextParseOptions {\r\n    /**\r\n     * A function that parses a value from a serialization object.\r\n     * @param key the key of the value\r\n     * @param serializationObject the object containing the value\r\n     * @param scene the current scene\r\n     * @returns\r\n     */\r\n    readonly valueParseFunction?: (key: string, serializationObject: any, assetsContainer: IAssetContainer, scene: Scene) => any;\r\n    /**\r\n     * The graph that the context is being parsed in.\r\n     */\r\n    readonly graph: FlowGraph;\r\n}\r\n/**\r\n * The context represents the current state and execution of the flow graph.\r\n * It contains both user-defined variables, which are derived from\r\n * a more general variable definition, and execution variables that\r\n * are set by the blocks.\r\n */\r\nexport class FlowGraphContext {\r\n    /**\r\n     * A randomly generated GUID for each context.\r\n     */\r\n    @serialize()\r\n    public uniqueId = RandomGUID();\r\n    /**\r\n     * These are the variables defined by a user.\r\n     */\r\n    private _userVariables: { [key: string]: any } = {};\r\n    /**\r\n     * These are the variables set by the blocks.\r\n     */\r\n    private _executionVariables: { [key: string]: any } = {};\r\n\r\n    /**\r\n     * A context-specific global variables, available to all blocks in the context.\r\n     */\r\n    private _globalContextVariables: { [key: string]: any } = {};\r\n    /**\r\n     * These are the values for the data connection points\r\n     */\r\n    private _connectionValues: { [key: string]: any } = {};\r\n    /**\r\n     * These are the variables set by the graph.\r\n     */\r\n    private readonly _configuration: IFlowGraphContextConfiguration;\r\n    /**\r\n     * These are blocks that have currently pending tasks/listeners that need to be cleaned up.\r\n     */\r\n    private _pendingBlocks: FlowGraphAsyncExecutionBlock[] = [];\r\n    /**\r\n     * A monotonically increasing ID for each execution.\r\n     * Incremented for every block executed.\r\n     */\r\n    private _executionId = 0;\r\n    /**\r\n     * Observable that is triggered when a node is executed.\r\n     */\r\n    public onNodeExecutedObservable: Observable<FlowGraphBlock> = new Observable<FlowGraphBlock>();\r\n\r\n    /**\r\n     * The assets context used by the flow graph context.\r\n     * Note that it can be shared between flow graph contexts.\r\n     */\r\n    public assetsContext: IAssetContainer;\r\n\r\n    /**\r\n     * Whether to treat data as right-handed.\r\n     * This is used when serializing data from a right-handed system, while running the context in a left-handed system, for example in glTF parsing.\r\n     * Default is false.\r\n     */\r\n    public treatDataAsRightHanded = false;\r\n\r\n    private _enableLogging = false;\r\n\r\n    /**\r\n     * The logger used by the context to log actions.\r\n     */\r\n    public logger: Nullable<FlowGraphLogger>;\r\n\r\n    /**\r\n     * Enable logging on this context\r\n     */\r\n    public get enableLogging() {\r\n        return this._enableLogging;\r\n    }\r\n\r\n    public set enableLogging(value: boolean) {\r\n        if (this._enableLogging === value) {\r\n            return;\r\n        }\r\n        this._enableLogging = value;\r\n        if (this._enableLogging) {\r\n            this.logger = new FlowGraphLogger();\r\n            this.logger.logToConsole = true;\r\n        } else {\r\n            this.logger = null;\r\n        }\r\n    }\r\n\r\n    constructor(params: IFlowGraphContextConfiguration) {\r\n        this._configuration = params;\r\n        this.assetsContext = params.assetsContext ?? params.scene;\r\n    }\r\n\r\n    /**\r\n     * Check if a user-defined variable is defined.\r\n     * @param name the name of the variable\r\n     * @returns true if the variable is defined\r\n     */\r\n    public hasVariable(name: string) {\r\n        return name in this._userVariables;\r\n    }\r\n\r\n    /**\r\n     * Set a user-defined variable.\r\n     * @param name the name of the variable\r\n     * @param value the value of the variable\r\n     */\r\n    public setVariable(name: string, value: any) {\r\n        this._userVariables[name] = value;\r\n        this.logger?.addLogItem({\r\n            time: Date.now(),\r\n            className: this.getClassName(),\r\n            uniqueId: this.uniqueId,\r\n            action: FlowGraphAction.ContextVariableSet,\r\n            payload: {\r\n                name,\r\n                value,\r\n            },\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Get an assets from the assets context based on its type and index in the array\r\n     * @param type The type of the asset\r\n     * @param index The index of the asset\r\n     * @returns The asset or null if not found\r\n     */\r\n    public getAsset<T extends FlowGraphAssetType>(type: T, index: number): Nullable<AssetType<T>> {\r\n        return GetFlowGraphAssetWithType(this.assetsContext, type, index);\r\n    }\r\n\r\n    /**\r\n     * Get a user-defined variable.\r\n     * @param name the name of the variable\r\n     * @returns the value of the variable\r\n     */\r\n    public getVariable(name: string): any {\r\n        this.logger?.addLogItem({\r\n            time: Date.now(),\r\n            className: this.getClassName(),\r\n            uniqueId: this.uniqueId,\r\n            action: FlowGraphAction.ContextVariableGet,\r\n            payload: {\r\n                name,\r\n                value: this._userVariables[name],\r\n            },\r\n        });\r\n        return this._userVariables[name];\r\n    }\r\n\r\n    /**\r\n     * Gets all user variables map\r\n     */\r\n    public get userVariables() {\r\n        return this._userVariables;\r\n    }\r\n\r\n    /**\r\n     * Get the scene that the context belongs to.\r\n     * @returns the scene\r\n     */\r\n    public getScene() {\r\n        return this._configuration.scene;\r\n    }\r\n\r\n    private _getUniqueIdPrefixedName(obj: FlowGraphBlock, name: string): string {\r\n        return `${obj.uniqueId}_${name}`;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * @param name name of the variable\r\n     * @param defaultValue default value to return if the variable is not defined\r\n     * @returns the variable value or the default value if the variable is not defined\r\n     */\r\n    public _getGlobalContextVariable<T>(name: string, defaultValue: T): T {\r\n        this.logger?.addLogItem({\r\n            time: Date.now(),\r\n            className: this.getClassName(),\r\n            uniqueId: this.uniqueId,\r\n            action: FlowGraphAction.GlobalVariableGet,\r\n            payload: {\r\n                name,\r\n                defaultValue,\r\n                possibleValue: this._globalContextVariables[name],\r\n            },\r\n        });\r\n        if (this._hasGlobalContextVariable(name)) {\r\n            return this._globalContextVariables[name];\r\n        } else {\r\n            return defaultValue;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set a global context variable\r\n     * @internal\r\n     * @param name the name of the variable\r\n     * @param value the value of the variable\r\n     */\r\n    public _setGlobalContextVariable<T>(name: string, value: T) {\r\n        this.logger?.addLogItem({\r\n            time: Date.now(),\r\n            className: this.getClassName(),\r\n            uniqueId: this.uniqueId,\r\n            action: FlowGraphAction.GlobalVariableSet,\r\n            payload: { name, value },\r\n        });\r\n        this._globalContextVariables[name] = value;\r\n    }\r\n\r\n    /**\r\n     * Delete a global context variable\r\n     * @internal\r\n     * @param name the name of the variable\r\n     */\r\n    public _deleteGlobalContextVariable(name: string) {\r\n        this.logger?.addLogItem({\r\n            time: Date.now(),\r\n            className: this.getClassName(),\r\n            uniqueId: this.uniqueId,\r\n            action: FlowGraphAction.GlobalVariableDelete,\r\n            payload: { name },\r\n        });\r\n        delete this._globalContextVariables[name];\r\n    }\r\n\r\n    /**\r\n     * Check if a global context variable is defined\r\n     * @internal\r\n     * @param name the name of the variable\r\n     * @returns true if the variable is defined\r\n     */\r\n    public _hasGlobalContextVariable(name: string) {\r\n        return name in this._globalContextVariables;\r\n    }\r\n\r\n    /**\r\n     * Set an internal execution variable\r\n     * @internal\r\n     * @param name\r\n     * @param value\r\n     */\r\n    public _setExecutionVariable(block: FlowGraphBlock, name: string, value: any) {\r\n        this._executionVariables[this._getUniqueIdPrefixedName(block, name)] = value;\r\n    }\r\n\r\n    /**\r\n     * Get an internal execution variable\r\n     * @internal\r\n     * @param name\r\n     * @returns\r\n     */\r\n    public _getExecutionVariable<T>(block: FlowGraphBlock, name: string, defaultValue: T): T {\r\n        if (this._hasExecutionVariable(block, name)) {\r\n            return this._executionVariables[this._getUniqueIdPrefixedName(block, name)];\r\n        } else {\r\n            return defaultValue;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Delete an internal execution variable\r\n     * @internal\r\n     * @param block\r\n     * @param name\r\n     */\r\n    public _deleteExecutionVariable(block: FlowGraphBlock, name: string) {\r\n        delete this._executionVariables[this._getUniqueIdPrefixedName(block, name)];\r\n    }\r\n\r\n    /**\r\n     * Check if an internal execution variable is defined\r\n     * @internal\r\n     * @param block\r\n     * @param name\r\n     * @returns\r\n     */\r\n    public _hasExecutionVariable(block: FlowGraphBlock, name: string) {\r\n        return this._getUniqueIdPrefixedName(block, name) in this._executionVariables;\r\n    }\r\n\r\n    /**\r\n     * Check if a connection value is defined\r\n     * @internal\r\n     * @param connectionPoint\r\n     * @returns\r\n     */\r\n    public _hasConnectionValue(connectionPoint: FlowGraphDataConnection<any>) {\r\n        return connectionPoint.uniqueId in this._connectionValues;\r\n    }\r\n\r\n    /**\r\n     * Set a connection value\r\n     * @internal\r\n     * @param connectionPoint\r\n     * @param value\r\n     */\r\n    public _setConnectionValue<T>(connectionPoint: FlowGraphDataConnection<T>, value: T) {\r\n        this._connectionValues[connectionPoint.uniqueId] = value;\r\n        this.logger?.addLogItem({\r\n            time: Date.now(),\r\n            className: this.getClassName(),\r\n            uniqueId: this.uniqueId,\r\n            action: FlowGraphAction.SetConnectionValue,\r\n            payload: {\r\n                connectionPointId: connectionPoint.uniqueId,\r\n                value,\r\n            },\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Set a connection value by key\r\n     * @internal\r\n     * @param key the key of the connection value\r\n     * @param value the value of the connection\r\n     */\r\n    public _setConnectionValueByKey<T>(key: string, value: T) {\r\n        this._connectionValues[key] = value;\r\n    }\r\n\r\n    /**\r\n     * Get a connection value\r\n     * @internal\r\n     * @param connectionPoint\r\n     * @returns\r\n     */\r\n    public _getConnectionValue<T>(connectionPoint: FlowGraphDataConnection<T>): T {\r\n        this.logger?.addLogItem({\r\n            time: Date.now(),\r\n            className: this.getClassName(),\r\n            uniqueId: this.uniqueId,\r\n            action: FlowGraphAction.GetConnectionValue,\r\n            payload: {\r\n                connectionPointId: connectionPoint.uniqueId,\r\n                value: this._connectionValues[connectionPoint.uniqueId],\r\n            },\r\n        });\r\n        return this._connectionValues[connectionPoint.uniqueId];\r\n    }\r\n\r\n    /**\r\n     * Get the configuration\r\n     * @internal\r\n     * @param name\r\n     * @param value\r\n     */\r\n    public get configuration() {\r\n        return this._configuration;\r\n    }\r\n\r\n    /**\r\n     * Check if there are any pending blocks in this context\r\n     * @returns true if there are pending blocks\r\n     */\r\n    public get hasPendingBlocks() {\r\n        return this._pendingBlocks.length > 0;\r\n    }\r\n\r\n    /**\r\n     * Add a block to the list of blocks that have pending tasks.\r\n     * @internal\r\n     * @param block\r\n     */\r\n    public _addPendingBlock(block: FlowGraphAsyncExecutionBlock) {\r\n        // check if block is already in the array\r\n        if (this._pendingBlocks.includes(block)) {\r\n            return;\r\n        }\r\n        this._pendingBlocks.push(block);\r\n        // sort pending blocks by priority\r\n        this._pendingBlocks.sort((a, b) => a.priority - b.priority);\r\n    }\r\n\r\n    /**\r\n     * Remove a block from the list of blocks that have pending tasks.\r\n     * @internal\r\n     * @param block\r\n     */\r\n    public _removePendingBlock(block: FlowGraphAsyncExecutionBlock) {\r\n        const index = this._pendingBlocks.indexOf(block);\r\n        if (index !== -1) {\r\n            this._pendingBlocks.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clear all pending blocks.\r\n     * @internal\r\n     */\r\n    public _clearPendingBlocks() {\r\n        for (const block of this._pendingBlocks) {\r\n            block._cancelPendingTasks(this);\r\n        }\r\n        this._pendingBlocks.length = 0;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Function that notifies the node executed observable\r\n     * @param node\r\n     */\r\n    public _notifyExecuteNode(node: FlowGraphBlock) {\r\n        this.onNodeExecutedObservable.notifyObservers(node);\r\n        this.logger?.addLogItem({\r\n            time: Date.now(),\r\n            className: node.getClassName(),\r\n            uniqueId: node.uniqueId,\r\n            action: FlowGraphAction.ExecuteBlock,\r\n        });\r\n    }\r\n\r\n    public _notifyOnTick(framePayload: IFlowGraphOnTickEventPayload) {\r\n        // set the values as global variables\r\n        this._setGlobalContextVariable(\"timeSinceStart\", framePayload.timeSinceStart);\r\n        this._setGlobalContextVariable(\"deltaTime\", framePayload.deltaTime);\r\n        // iterate the pending blocks and run each one's onFrame function\r\n        for (const block of this._pendingBlocks) {\r\n            block._executeOnTick?.(this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _increaseExecutionId() {\r\n        this._executionId++;\r\n    }\r\n    /**\r\n     * A monotonically increasing ID for each execution.\r\n     * Incremented for every block executed.\r\n     */\r\n    public get executionId() {\r\n        return this._executionId;\r\n    }\r\n\r\n    /**\r\n     * Serializes a context\r\n     * @param serializationObject the object to write the values in\r\n     * @param valueSerializationFunction a function to serialize complex values\r\n     */\r\n    public serialize(serializationObject: any = {}, valueSerializationFunction: (key: string, value: any, serializationObject: any) => void = defaultValueSerializationFunction) {\r\n        serializationObject.uniqueId = this.uniqueId;\r\n        serializationObject._userVariables = {};\r\n        for (const key in this._userVariables) {\r\n            valueSerializationFunction(key, this._userVariables[key], serializationObject._userVariables);\r\n        }\r\n        serializationObject._connectionValues = {};\r\n        for (const key in this._connectionValues) {\r\n            valueSerializationFunction(key, this._connectionValues[key], serializationObject._connectionValues);\r\n        }\r\n        // serialize assets context, if not scene\r\n        if (this.assetsContext !== this.getScene()) {\r\n            serializationObject._assetsContext = {\r\n                meshes: this.assetsContext.meshes.map((m) => m.id),\r\n                materials: this.assetsContext.materials.map((m) => m.id),\r\n                textures: this.assetsContext.textures.map((m) => m.name),\r\n                animations: this.assetsContext.animations.map((m) => m.name),\r\n                lights: this.assetsContext.lights.map((m) => m.id),\r\n                cameras: this.assetsContext.cameras.map((m) => m.id),\r\n                sounds: this.assetsContext.sounds?.map((m) => m.name),\r\n                skeletons: this.assetsContext.skeletons.map((m) => m.id),\r\n                particleSystems: this.assetsContext.particleSystems.map((m) => m.name),\r\n                geometries: this.assetsContext.geometries.map((m) => m.id),\r\n                multiMaterials: this.assetsContext.multiMaterials.map((m) => m.id),\r\n                transformNodes: this.assetsContext.transformNodes.map((m) => m.id),\r\n            };\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @returns the class name of the object.\r\n     */\r\n    public getClassName() {\r\n        return \"FlowGraphContext\";\r\n    }\r\n}\r\n", "import type { PointerInfo } from \"core/Events/pointerEvents\";\nimport { PointerEventTypes } from \"core/Events/pointerEvents\";\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\nimport type { Observer } from \"core/Misc/observable\";\nimport { Observable } from \"core/Misc/observable\";\nimport type { Scene } from \"core/scene\";\nimport type { Nullable } from \"core/types\";\nimport { FlowGraphEventType } from \"./flowGraphEventType\";\n\n/**\n * the interface of the object the scene event coordinator will trigger.\n */\nexport interface IFlowGraphEventTrigger {\n    /**\n     * The type of the event\n     */\n    type: FlowGraphEventType;\n    /**\n     * The data of the event\n     */\n    payload?: any;\n}\n\n/**\n * This class is responsible for coordinating the events that are triggered in the scene.\n * It registers all observers needed to track certain events and triggers the blocks that are listening to them.\n * Abstracting the events from the class will allow us to easily change the events that are being listened to, and trigger them in any order.\n */\nexport class FlowGraphSceneEventCoordinator {\n    /**\n     * @internal\n     */\n    public readonly _scene: Scene;\n\n    /**\n     * register to this observable to get flow graph event notifications.\n     */\n    public onEventTriggeredObservable: Observable<IFlowGraphEventTrigger> = new Observable();\n\n    /**\n     * Was scene-ready already triggered?\n     */\n    public sceneReadyTriggered: boolean = false;\n\n    private _sceneDisposeObserver: Nullable<Observer<Scene>>;\n    private _sceneReadyObserver: Nullable<Observer<Scene>>;\n    private _sceneOnBeforeRenderObserver: Nullable<Observer<Scene>>;\n    private _meshPickedObserver: Nullable<Observer<PointerInfo>>;\n    private _meshUnderPointerObserver: Nullable<Observer<{ mesh: Nullable<AbstractMesh>; pointerId: number }>>;\n    private _pointerUnderMeshState: { [pointerId: number]: Nullable<AbstractMesh> } = {};\n\n    private _startingTime: number = 0;\n\n    constructor(scene: Scene) {\n        this._scene = scene;\n        this._initialize();\n    }\n\n    private _initialize() {\n        this._sceneReadyObserver = this._scene.onReadyObservable.add(() => {\n            if (!this.sceneReadyTriggered) {\n                this.onEventTriggeredObservable.notifyObservers({ type: FlowGraphEventType.SceneReady });\n                this.sceneReadyTriggered = true;\n            }\n        });\n\n        this._sceneDisposeObserver = this._scene.onDisposeObservable.add(() => {\n            this.onEventTriggeredObservable.notifyObservers({ type: FlowGraphEventType.SceneDispose });\n        });\n        this._sceneOnBeforeRenderObserver = this._scene.onBeforeRenderObservable.add(() => {\n            const deltaTime = this._scene.getEngine().getDeltaTime() / 1000; // set in seconds\n            this.onEventTriggeredObservable.notifyObservers({\n                type: FlowGraphEventType.SceneBeforeRender,\n                payload: {\n                    timeSinceStart: this._startingTime,\n                    deltaTime,\n                },\n            });\n            this._startingTime += deltaTime;\n        });\n\n        this._meshPickedObserver = this._scene.onPointerObservable.add((pointerInfo) => {\n            this.onEventTriggeredObservable.notifyObservers({ type: FlowGraphEventType.MeshPick, payload: pointerInfo });\n        }, PointerEventTypes.POINTERPICK); // should it be pointerdown?\n\n        this._meshUnderPointerObserver = this._scene.onMeshUnderPointerUpdatedObservable.add((data) => {\n            // check if the data has changed. Check the state of the last change and see if it is a mesh or null.\n            // if it is a mesh and the previous state was null, trigger over event. If it is null and the previous state was a mesh, trigger out event.\n            // if it is a mesh and the previous state was a mesh, trigger out from the old mesh and over the new mesh\n            // if it is null and the previous state was null, do nothing.\n            const pointerId = data.pointerId;\n            const mesh = data.mesh;\n            const previousState = this._pointerUnderMeshState[pointerId];\n            if (!previousState && mesh) {\n                this.onEventTriggeredObservable.notifyObservers({ type: FlowGraphEventType.PointerOver, payload: { pointerId, mesh } });\n            } else if (previousState && !mesh) {\n                this.onEventTriggeredObservable.notifyObservers({ type: FlowGraphEventType.PointerOut, payload: { pointerId, mesh: previousState } });\n            } else if (previousState && mesh && previousState !== mesh) {\n                this.onEventTriggeredObservable.notifyObservers({ type: FlowGraphEventType.PointerOut, payload: { pointerId, mesh: previousState, over: mesh } });\n                this.onEventTriggeredObservable.notifyObservers({ type: FlowGraphEventType.PointerOver, payload: { pointerId, mesh, out: previousState } });\n            }\n            this._pointerUnderMeshState[pointerId] = mesh;\n        }, PointerEventTypes.POINTERMOVE);\n    }\n\n    public dispose() {\n        this._sceneDisposeObserver?.remove();\n        this._sceneReadyObserver?.remove();\n        this._sceneOnBeforeRenderObserver?.remove();\n        this._meshPickedObserver?.remove();\n        this._meshUnderPointerObserver?.remove();\n        this.onEventTriggeredObservable.clear();\n    }\n}\n", "import type { Observer } from \"../Misc/observable\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { FlowGraphEventBlock } from \"./flowGraphEventBlock\";\r\nimport { FlowGraphContext } from \"./flowGraphContext\";\r\nimport type { FlowGraphBlock } from \"./flowGraphBlock\";\r\nimport { FlowGraphExecutionBlock } from \"./flowGraphExecutionBlock\";\r\nimport type { FlowGraphCoordinator } from \"./flowGraphCoordinator\";\r\nimport type { IObjectAccessor } from \"./typeDefinitions\";\r\nimport type { IPathToObjectConverter } from \"../ObjectModel/objectModelInterfaces\";\r\nimport type { IAssetContainer } from \"core/IAssetContainer\";\r\nimport { FlowGraphEventType } from \"./flowGraphEventType\";\r\nimport type { IFlowGraphEventTrigger } from \"./flowGraphSceneEventCoordinator\";\r\nimport { FlowGraphSceneEventCoordinator } from \"./flowGraphSceneEventCoordinator\";\r\nimport type { FlowGraphMeshPickEventBlock } from \"./Blocks/Event/flowGraphMeshPickEventBlock\";\r\nimport { _isADescendantOf } from \"./utils\";\r\n\r\nexport const enum FlowGraphState {\r\n    /**\r\n     * The graph is stopped\r\n     */\r\n    Stopped,\r\n    /**\r\n     * The graph is running\r\n     */\r\n    Started,\r\n}\r\n\r\n/**\r\n * Parameters used to create a flow graph.\r\n */\r\nexport interface IFlowGraphParams {\r\n    /**\r\n     * The scene that the flow graph belongs to.\r\n     */\r\n    scene: Scene;\r\n    /**\r\n     * The event coordinator used by the flow graph.\r\n     */\r\n    coordinator: FlowGraphCoordinator;\r\n}\r\n\r\n/**\r\n * Options for parsing a flow graph.\r\n */\r\nexport interface IFlowGraphParseOptions {\r\n    /**\r\n     * A function that parses complex values in a scene.\r\n     * @param key the key of the value\r\n     * @param serializationObject the object to read the value from\r\n     * @param scene the scene to read the value from\r\n     */\r\n    valueParseFunction?: (key: string, serializationObject: any, assetsContainer: IAssetContainer, scene: Scene) => any;\r\n    /**\r\n     * The flow graph coordinator.\r\n     */\r\n    coordinator: FlowGraphCoordinator;\r\n    /**\r\n     * A function that converts a path to an object accessor.\r\n     */\r\n    pathConverter?: IPathToObjectConverter<IObjectAccessor>;\r\n}\r\n/**\r\n * Class used to represent a flow graph.\r\n * A flow graph is a graph of blocks that can be used to create complex logic.\r\n * Blocks can be added to the graph and connected to each other.\r\n * The graph can then be started, which will init and start all of its event blocks.\r\n *\r\n * @experimental FlowGraph is still in development and is subject to change.\r\n */\r\nexport class FlowGraph {\r\n    /**\r\n     * An observable that is triggered when the state of the graph changes.\r\n     */\r\n    public onStateChangedObservable: Observable<FlowGraphState> = new Observable();\r\n    /** @internal */\r\n    public _eventBlocks: { [keyof in FlowGraphEventType]: FlowGraphEventBlock[] } = {\r\n        [FlowGraphEventType.SceneReady]: [],\r\n        [FlowGraphEventType.SceneDispose]: [],\r\n        [FlowGraphEventType.SceneBeforeRender]: [],\r\n        [FlowGraphEventType.MeshPick]: [],\r\n        [FlowGraphEventType.PointerDown]: [],\r\n        [FlowGraphEventType.PointerUp]: [],\r\n        [FlowGraphEventType.PointerMove]: [],\r\n        [FlowGraphEventType.PointerOver]: [],\r\n        [FlowGraphEventType.PointerOut]: [],\r\n        [FlowGraphEventType.SceneAfterRender]: [],\r\n        [FlowGraphEventType.NoTrigger]: [],\r\n    };\r\n    /**\r\n     * @internal\r\n     */\r\n    public readonly _scene: Scene;\r\n    private _coordinator: FlowGraphCoordinator;\r\n    private _executionContexts: FlowGraphContext[] = [];\r\n    private _sceneEventCoordinator: FlowGraphSceneEventCoordinator;\r\n    private _eventObserver: Nullable<Observer<IFlowGraphEventTrigger>>;\r\n\r\n    /**\r\n     * The state of the graph\r\n     */\r\n    private _state: FlowGraphState = FlowGraphState.Stopped;\r\n\r\n    /**\r\n     * The state of the graph\r\n     */\r\n    public get state() {\r\n        return this._state;\r\n    }\r\n\r\n    /**\r\n     * The state of the graph\r\n     */\r\n    public set state(value: FlowGraphState) {\r\n        this._state = value;\r\n        this.onStateChangedObservable.notifyObservers(value);\r\n    }\r\n\r\n    /**\r\n     * Construct a Flow Graph\r\n     * @param params construction parameters. currently only the scene\r\n     */\r\n    public constructor(params: IFlowGraphParams) {\r\n        this._scene = params.scene;\r\n        this._sceneEventCoordinator = new FlowGraphSceneEventCoordinator(this._scene);\r\n        this._coordinator = params.coordinator;\r\n\r\n        this._eventObserver = this._sceneEventCoordinator.onEventTriggeredObservable.add((event) => {\r\n            for (const context of this._executionContexts) {\r\n                const order = this._getContextualOrder(event.type, context);\r\n                for (const block of order) {\r\n                    // iterate contexts\r\n                    if (!block._executeEvent(context, event.payload)) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            // custom behavior(s) of specific events\r\n            switch (event.type) {\r\n                case FlowGraphEventType.SceneReady:\r\n                    this._sceneEventCoordinator.sceneReadyTriggered = true;\r\n                    break;\r\n                case FlowGraphEventType.SceneBeforeRender:\r\n                    for (const context of this._executionContexts) {\r\n                        context._notifyOnTick(event.payload);\r\n                    }\r\n                    break;\r\n                case FlowGraphEventType.SceneDispose:\r\n                    this.dispose();\r\n                    break;\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Create a context. A context represents one self contained execution for the graph, with its own variables.\r\n     * @returns the context, where you can get and set variables\r\n     */\r\n    public createContext() {\r\n        const context = new FlowGraphContext({ scene: this._scene, coordinator: this._coordinator });\r\n        this._executionContexts.push(context);\r\n        return context;\r\n    }\r\n\r\n    /**\r\n     * Returns the execution context at a given index\r\n     * @param index the index of the context\r\n     * @returns the execution context at that index\r\n     */\r\n    public getContext(index: number) {\r\n        return this._executionContexts[index];\r\n    }\r\n\r\n    /**\r\n     * Add an event block. When the graph is started, it will start listening to events\r\n     * from the block and execute the graph when they are triggered.\r\n     * @param block the event block to be added\r\n     */\r\n    public addEventBlock(block: FlowGraphEventBlock): void {\r\n        if (block.type === FlowGraphEventType.PointerOver || block.type === FlowGraphEventType.PointerOut) {\r\n            this._scene.constantlyUpdateMeshUnderPointer = true;\r\n        }\r\n\r\n        // don't add if NoTrigger, but still start the pending tasks\r\n        if (block.type !== FlowGraphEventType.NoTrigger) {\r\n            this._eventBlocks[block.type].push(block);\r\n        }\r\n        // if already started, sort and add to the pending\r\n        if (this.state === FlowGraphState.Started) {\r\n            for (const context of this._executionContexts) {\r\n                block._startPendingTasks(context);\r\n            }\r\n        } else {\r\n            this.onStateChangedObservable.addOnce((state) => {\r\n                if (state === FlowGraphState.Started) {\r\n                    for (const context of this._executionContexts) {\r\n                        block._startPendingTasks(context);\r\n                    }\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Starts the flow graph. Initializes the event blocks and starts listening to events.\r\n     */\r\n    public start() {\r\n        if (this.state === FlowGraphState.Started) {\r\n            return;\r\n        }\r\n        if (this._executionContexts.length === 0) {\r\n            this.createContext();\r\n        }\r\n        this.onStateChangedObservable.add((state) => {\r\n            if (state === FlowGraphState.Started) {\r\n                this._startPendingEvents();\r\n                // the only event we need to check is the scene ready event. If the scene is already ready when the graph starts, we should start the pending tasks.\r\n                if (this._scene.isReady(true)) {\r\n                    this._sceneEventCoordinator.onEventTriggeredObservable.notifyObservers({ type: FlowGraphEventType.SceneReady });\r\n                }\r\n            }\r\n        });\r\n        this.state = FlowGraphState.Started;\r\n    }\r\n\r\n    private _startPendingEvents() {\r\n        for (const context of this._executionContexts) {\r\n            for (const type in this._eventBlocks) {\r\n                const order = this._getContextualOrder(type as FlowGraphEventType, context);\r\n                for (const block of order) {\r\n                    block._startPendingTasks(context);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private _getContextualOrder(type: FlowGraphEventType, context: FlowGraphContext): FlowGraphEventBlock[] {\r\n        const order = this._eventBlocks[type].sort((a, b) => b.initPriority - a.initPriority);\r\n\r\n        if (type === FlowGraphEventType.MeshPick) {\r\n            const meshPickOrder = [] as FlowGraphEventBlock[];\r\n            for (const block1 of order) {\r\n                // If the block is a mesh pick, guarantee that picks of children meshes come before picks of parent meshes\r\n                const mesh1 = (block1 as FlowGraphMeshPickEventBlock).asset.getValue(context);\r\n                let i = 0;\r\n                for (; i < order.length; i++) {\r\n                    const block2 = order[i];\r\n                    const mesh2 = (block2 as FlowGraphMeshPickEventBlock).asset.getValue(context);\r\n                    if (mesh1 && mesh2 && _isADescendantOf(mesh1, mesh2)) {\r\n                        break;\r\n                    }\r\n                }\r\n                meshPickOrder.splice(i, 0, block1);\r\n            }\r\n            return meshPickOrder;\r\n        }\r\n        return order;\r\n    }\r\n\r\n    /**\r\n     * Disposes of the flow graph. Cancels any pending tasks and removes all event listeners.\r\n     */\r\n    public dispose() {\r\n        if (this.state === FlowGraphState.Stopped) {\r\n            return;\r\n        }\r\n        this.state = FlowGraphState.Stopped;\r\n        for (const context of this._executionContexts) {\r\n            context._clearPendingBlocks();\r\n        }\r\n        this._executionContexts.length = 0;\r\n        for (const type in this._eventBlocks) {\r\n            this._eventBlocks[type as FlowGraphEventType].length = 0;\r\n        }\r\n        this._eventObserver?.remove();\r\n        this._sceneEventCoordinator.dispose();\r\n    }\r\n\r\n    /**\r\n     * Executes a function in all blocks of a flow graph, starting with the event blocks.\r\n     * @param visitor the function to execute.\r\n     */\r\n    public visitAllBlocks(visitor: (block: FlowGraphBlock) => void) {\r\n        const visitList: FlowGraphBlock[] = [];\r\n        const idsAddedToVisitList = new Set<string>();\r\n        for (const type in this._eventBlocks) {\r\n            for (const block of this._eventBlocks[type as FlowGraphEventType]) {\r\n                visitList.push(block);\r\n                idsAddedToVisitList.add(block.uniqueId);\r\n            }\r\n        }\r\n\r\n        while (visitList.length > 0) {\r\n            const block = visitList.pop()!;\r\n            visitor(block);\r\n\r\n            for (const dataIn of block.dataInputs) {\r\n                for (const connection of dataIn._connectedPoint) {\r\n                    if (!idsAddedToVisitList.has(connection._ownerBlock.uniqueId)) {\r\n                        visitList.push(connection._ownerBlock);\r\n                        idsAddedToVisitList.add(connection._ownerBlock.uniqueId);\r\n                    }\r\n                }\r\n            }\r\n            if (block instanceof FlowGraphExecutionBlock) {\r\n                for (const signalOut of block.signalOutputs) {\r\n                    for (const connection of signalOut._connectedPoint) {\r\n                        if (!idsAddedToVisitList.has(connection._ownerBlock.uniqueId)) {\r\n                            visitList.push(connection._ownerBlock);\r\n                            idsAddedToVisitList.add(connection._ownerBlock.uniqueId);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Serializes a graph\r\n     * @param serializationObject the object to write the values in\r\n     * @param valueSerializeFunction a function to serialize complex values\r\n     */\r\n    public serialize(serializationObject: any = {}, valueSerializeFunction?: (key: string, value: any, serializationObject: any) => void) {\r\n        serializationObject.allBlocks = [];\r\n        this.visitAllBlocks((block) => {\r\n            const serializedBlock: any = {};\r\n            block.serialize(serializedBlock);\r\n            serializationObject.allBlocks.push(serializedBlock);\r\n        });\r\n        serializationObject.executionContexts = [];\r\n        for (const context of this._executionContexts) {\r\n            const serializedContext: any = {};\r\n            context.serialize(serializedContext, valueSerializeFunction);\r\n            serializationObject.executionContexts.push(serializedContext);\r\n        }\r\n    }\r\n}\r\n", "import type { Observer } from \"core/Misc/observable\";\r\nimport { Observable } from \"core/Misc/observable\";\r\nimport type { Scene } from \"../scene\";\r\nimport { FlowGraph } from \"./flowGraph\";\r\nimport type { IPathToObjectConverter } from \"../ObjectModel/objectModelInterfaces\";\r\nimport type { IObjectAccessor } from \"./typeDefinitions\";\r\nimport type { IAssetContainer } from \"core/IAssetContainer\";\r\nimport { Logger } from \"core/Misc/logger\";\r\n\r\n/**\r\n * Parameters used to create a flow graph engine.\r\n */\r\nexport interface IFlowGraphCoordinatorConfiguration {\r\n    /**\r\n     * The scene that the flow graph engine belongs to.\r\n     */\r\n    scene: Scene;\r\n}\r\n\r\n/**\r\n * Parameters used to parse a flow graph coordinator.\r\n */\r\nexport interface FlowGraphCoordinatorParseOptions {\r\n    /**\r\n     * A function that will be called to parse the value of a property.\r\n     * @param key the key of the property\r\n     * @param serializationObject the serialization object where the property is located\r\n     * @param scene the scene that the block is being parsed in\r\n     */\r\n    valueParseFunction?: (key: string, serializationObject: any, assetsContainer: IAssetContainer, scene: Scene) => any;\r\n    /**\r\n     * The path converter to use to convert the path to an object accessor.\r\n     */\r\n    pathConverter: IPathToObjectConverter<IObjectAccessor>;\r\n    /**\r\n     * The scene that the flow graph coordinator belongs to.\r\n     */\r\n    scene: Scene;\r\n}\r\n/**\r\n * This class holds all of the existing flow graphs and is responsible for creating new ones.\r\n * It also handles starting/stopping multiple graphs and communication between them through an Event Coordinator\r\n * This is the entry point for the flow graph system.\r\n * @experimental This class is still in development and is subject to change.\r\n */\r\nexport class FlowGraphCoordinator {\r\n    /**\r\n     * The maximum number of events per type.\r\n     * This is used to limit the number of events that can be created in a single scene.\r\n     * This is to prevent infinite loops.\r\n     */\r\n    public static MaxEventsPerType: number = 30;\r\n\r\n    /**\r\n     * The maximum number of execution of a specific event in a single frame.\r\n     */\r\n    public static MaxEventTypeExecutionPerFrame: number = 30;\r\n    /**\r\n     * @internal\r\n     * A list of all the coordinators per scene. Will be used by the inspector\r\n     */\r\n    public static readonly SceneCoordinators: Map<Scene, FlowGraphCoordinator[]> = new Map();\r\n\r\n    /**\r\n     * When set to true (default) custom events will be dispatched synchronously.\r\n     * This means that the events will be dispatched immediately when they are triggered.\r\n     */\r\n    public dispatchEventsSynchronously: boolean = true;\r\n\r\n    private readonly _flowGraphs: FlowGraph[] = [];\r\n\r\n    private _customEventsMap: Map<string, Observable<any>> = new Map();\r\n\r\n    private _eventExecutionCounter: Map<string, number> = new Map();\r\n\r\n    private _disposeObserver: Observer<Scene>;\r\n    private _onBeforeRenderObserver: Observer<Scene>;\r\n    private _executeOnNextFrame: { id: string; data?: any }[] = [];\r\n\r\n    public constructor(\r\n        /**\r\n         * the configuration of the block\r\n         */\r\n        public config: IFlowGraphCoordinatorConfiguration\r\n    ) {\r\n        // When the scene is disposed, dispose all graphs currently running on it.\r\n        this._disposeObserver = this.config.scene.onDisposeObservable.add(() => {\r\n            this.dispose();\r\n        });\r\n\r\n        this._onBeforeRenderObserver = this.config.scene.onBeforeRenderObservable.add(() => {\r\n            // Reset the event execution counter at the beginning of each frame.\r\n            this._eventExecutionCounter.clear();\r\n            if (this._executeOnNextFrame.length) {\r\n                // Execute the events that were triggered on the next frame.\r\n                this._executeOnNextFrame.forEach((event) => {\r\n                    this.notifyCustomEvent(event.id, event.data, false);\r\n                });\r\n                this._executeOnNextFrame.length = 0;\r\n            }\r\n        });\r\n\r\n        // Add itself to the SceneCoordinators list for the Inspector.\r\n        const coordinators = FlowGraphCoordinator.SceneCoordinators.get(this.config.scene) ?? [];\r\n        coordinators.push(this);\r\n    }\r\n\r\n    /**\r\n     * Creates a new flow graph and adds it to the list of existing flow graphs\r\n     * @returns a new flow graph\r\n     */\r\n    public createGraph(): FlowGraph {\r\n        const graph = new FlowGraph({ scene: this.config.scene, coordinator: this });\r\n        this._flowGraphs.push(graph);\r\n        return graph;\r\n    }\r\n\r\n    /**\r\n     * Removes a flow graph from the list of existing flow graphs and disposes it\r\n     * @param graph the graph to remove\r\n     */\r\n    public removeGraph(graph: FlowGraph) {\r\n        const index = this._flowGraphs.indexOf(graph);\r\n        if (index !== -1) {\r\n            graph.dispose();\r\n            this._flowGraphs.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Starts all graphs\r\n     */\r\n    public start() {\r\n        this._flowGraphs.forEach((graph) => graph.start());\r\n    }\r\n\r\n    /**\r\n     * Disposes all graphs\r\n     */\r\n    public dispose() {\r\n        this._flowGraphs.forEach((graph) => graph.dispose());\r\n        this._flowGraphs.length = 0;\r\n        this._disposeObserver?.remove();\r\n        this._onBeforeRenderObserver?.remove();\r\n\r\n        // Remove itself from the SceneCoordinators list for the Inspector.\r\n        const coordinators = FlowGraphCoordinator.SceneCoordinators.get(this.config.scene) ?? [];\r\n        const index = coordinators.indexOf(this);\r\n        if (index !== -1) {\r\n            coordinators.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Serializes this coordinator to a JSON object.\r\n     * @param serializationObject the object to serialize to\r\n     * @param valueSerializeFunction the function to use to serialize the value\r\n     */\r\n    public serialize(serializationObject: any, valueSerializeFunction?: (key: string, value: any, serializationObject: any) => void) {\r\n        serializationObject._flowGraphs = [];\r\n        this._flowGraphs.forEach((graph) => {\r\n            const serializedGraph = {};\r\n            graph.serialize(serializedGraph, valueSerializeFunction);\r\n            serializationObject._flowGraphs.push(serializedGraph);\r\n        });\r\n        serializationObject.dispatchEventsSynchronously = this.dispatchEventsSynchronously;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of flow graphs\r\n     */\r\n    public get flowGraphs() {\r\n        return this._flowGraphs;\r\n    }\r\n\r\n    /**\r\n     * Get an observable that will be notified when the event with the given id is fired.\r\n     * @param id the id of the event\r\n     * @returns the observable for the event\r\n     */\r\n    public getCustomEventObservable(id: string): Observable<any> {\r\n        let observable = this._customEventsMap.get(id);\r\n        if (!observable) {\r\n            // receive event is initialized before scene start, so no need to notify if triggered. but possible!\r\n            observable = new Observable<any>(/*undefined, true*/);\r\n            this._customEventsMap.set(id, observable);\r\n        }\r\n        return observable;\r\n    }\r\n\r\n    /**\r\n     * Notifies the observable for the given event id with the given data.\r\n     * @param id the id of the event\r\n     * @param data the data to send with the event\r\n     * @param async if true, the event will be dispatched asynchronously\r\n     */\r\n    public notifyCustomEvent(id: string, data: any, async: boolean = !this.dispatchEventsSynchronously) {\r\n        if (async) {\r\n            this._executeOnNextFrame.push({ id, data });\r\n            return;\r\n        }\r\n        // check if we are not exceeding the max number of events\r\n        if (this._eventExecutionCounter.has(id)) {\r\n            const count = this._eventExecutionCounter.get(id)!;\r\n            this._eventExecutionCounter.set(id, count + 1);\r\n            if (count >= FlowGraphCoordinator.MaxEventTypeExecutionPerFrame) {\r\n                count === FlowGraphCoordinator.MaxEventTypeExecutionPerFrame && Logger.Warn(`FlowGraphCoordinator: Too many executions of event \"${id}\".`);\r\n                return;\r\n            }\r\n        } else {\r\n            this._eventExecutionCounter.set(id, 1);\r\n        }\r\n        const observable = this._customEventsMap.get(id);\r\n        if (observable) {\r\n            observable.notifyObservers(data);\r\n        }\r\n    }\r\n}\r\n", "import type { Observer } from \"../../../Misc/observable\";\r\nimport type { FlowGraphContext } from \"../../flowGraphContext\";\r\nimport { FlowGraphEventBlock } from \"../../flowGraphEventBlock\";\r\nimport type { Nullable } from \"../../../types\";\r\nimport { Tools } from \"../../../Misc/tools\";\r\nimport type { RichType } from \"../../flowGraphRichTypes\";\r\nimport type { IFlowGraphBlockConfiguration } from \"../../flowGraphBlock\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport { FlowGraphBlockNames } from \"../flowGraphBlockNames\";\r\nimport { FlowGraphCoordinator } from \"core/FlowGraph/flowGraphCoordinator\";\r\n/**\r\n * Parameters used to create a FlowGraphReceiveCustomEventBlock.\r\n */\r\nexport interface IFlowGraphReceiveCustomEventBlockConfiguration extends IFlowGraphBlockConfiguration {\r\n    /**\r\n     * The id of the event to receive.\r\n     * This event id is unique to the environment (not the context).\r\n     */\r\n    eventId: string;\r\n    /**\r\n     * The names of the data outputs for that event. Should be in the same order as the event data in\r\n     * SendCustomEvent\r\n     */\r\n    eventData: { [key: string]: { type: RichType<any> } };\r\n}\r\n\r\n/**\r\n * A block that receives a custom event.\r\n * It saves the event data in the data outputs, based on the provided eventData in the configuration. For example, if the event data is\r\n * `{ x: { type: RichTypeNumber }, y: { type: RichTypeNumber } }`, the block will have two data outputs: x and y.\r\n */\r\nexport class FlowGraphReceiveCustomEventBlock extends FlowGraphEventBlock {\r\n    public override initPriority: number = 1;\r\n\r\n    constructor(\r\n        /**\r\n         * the configuration of the block\r\n         */\r\n        public override config: IFlowGraphReceiveCustomEventBlockConfiguration\r\n    ) {\r\n        super(config);\r\n        // use event data to register data outputs\r\n        for (const key in this.config.eventData) {\r\n            this.registerDataOutput(key, this.config.eventData[key].type);\r\n        }\r\n    }\r\n\r\n    public _preparePendingTasks(context: FlowGraphContext): void {\r\n        const observable = context.configuration.coordinator.getCustomEventObservable(this.config.eventId);\r\n        // check if we are not exceeding the max number of events\r\n        if (observable && observable.hasObservers() && observable.observers.length > FlowGraphCoordinator.MaxEventsPerType) {\r\n            this._reportError(context, `FlowGraphReceiveCustomEventBlock: Too many observers for event ${this.config.eventId}. Max is ${FlowGraphCoordinator.MaxEventsPerType}.`);\r\n            return;\r\n        }\r\n\r\n        const eventObserver = observable.add((eventData: { [key: string]: any }) => {\r\n            Object.keys(eventData).forEach((key) => {\r\n                this.getDataOutput(key)?.setValue(eventData[key], context);\r\n            });\r\n            this._execute(context);\r\n        });\r\n        context._setExecutionVariable(this, \"_eventObserver\", eventObserver);\r\n    }\r\n    public _cancelPendingTasks(context: FlowGraphContext): void {\r\n        const observable = context.configuration.coordinator.getCustomEventObservable(this.config.eventId);\r\n        if (observable) {\r\n            const eventObserver = context._getExecutionVariable<Nullable<Observer<any[]>>>(this, \"_eventObserver\", null);\r\n            observable.remove(eventObserver);\r\n        } else {\r\n            Tools.Warn(`FlowGraphReceiveCustomEventBlock: Missing observable for event ${this.config.eventId}`);\r\n        }\r\n    }\r\n\r\n    public override _executeEvent(_context: FlowGraphContext, _payload: any): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @returns class name of the block.\r\n     */\r\n    public override getClassName(): string {\r\n        return FlowGraphBlockNames.ReceiveCustomEvent;\r\n    }\r\n}\r\nRegisterClass(FlowGraphBlockNames.ReceiveCustomEvent, FlowGraphReceiveCustomEventBlock);\r\n"],
  "mappings": "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",
  "names": ["FlowGraphAction", "FlowGraphState"]
}
