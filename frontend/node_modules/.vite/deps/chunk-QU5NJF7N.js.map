{
  "version": 3,
  "sources": ["../../../dev/core/src/FlowGraph/CustomTypes/flowGraphInteger.ts", "../../../dev/core/src/FlowGraph/CustomTypes/flowGraphMatrix.ts", "../../../dev/core/src/FlowGraph/flowGraphRichTypes.ts", "../../../dev/core/src/FlowGraph/serialization.ts", "../../../dev/core/src/FlowGraph/flowGraphConnection.ts", "../../../dev/core/src/FlowGraph/flowGraphDataConnection.ts", "../../../dev/core/src/FlowGraph/flowGraphBlock.ts"],
  "sourcesContent": ["import { RegisterClass } from \"../../Misc/typeStore\";\r\n\r\n/**\r\n * Class that represents an integer value.\r\n */\r\nexport class FlowGraphInteger {\r\n    /**\r\n     * The value of the integer. Its type\r\n     * is a javascript number. Shouldn't be\r\n     * directly modified - it is populated by\r\n     * the constructor.\r\n     */\r\n    readonly value: number;\r\n\r\n    constructor(value: number) {\r\n        this.value = this._toInt(value);\r\n    }\r\n\r\n    /**\r\n     * Converts a float to an integer.\r\n     * @param n the float to convert\r\n     * @returns the result of n | 0 - converting it to a int\r\n     */\r\n    private _toInt(n: number): number {\r\n        return n | 0;\r\n    }\r\n\r\n    /**\r\n     * Adds two integers together.\r\n     * @param other the other integer to add\r\n     * @returns a FlowGraphInteger with the result of the addition\r\n     */\r\n    public add(other: FlowGraphInteger): FlowGraphInteger {\r\n        return new FlowGraphInteger(this.value + other.value);\r\n    }\r\n\r\n    /**\r\n     * Subtracts two integers.\r\n     * @param other the other integer to subtract\r\n     * @returns a FlowGraphInteger with the result of the subtraction\r\n     */\r\n    public subtract(other: FlowGraphInteger): FlowGraphInteger {\r\n        return new FlowGraphInteger(this.value - other.value);\r\n    }\r\n\r\n    /**\r\n     * Multiplies two integers.\r\n     * @param other the other integer to multiply\r\n     * @returns a FlowGraphInteger with the result of the multiplication\r\n     */\r\n    public multiply(other: FlowGraphInteger): FlowGraphInteger {\r\n        return new FlowGraphInteger(Math.imul(this.value, other.value));\r\n    }\r\n\r\n    /**\r\n     * Divides two integers.\r\n     * @param other the other integer to divide\r\n     * @returns a FlowGraphInteger with the result of the division\r\n     */\r\n    public divide(other: FlowGraphInteger): FlowGraphInteger {\r\n        return new FlowGraphInteger(this.value / other.value);\r\n    }\r\n\r\n    /**\r\n     * The class name of this type.\r\n     * @returns\r\n     */\r\n    public getClassName() {\r\n        return FlowGraphInteger.ClassName;\r\n    }\r\n\r\n    /**\r\n     * Compares two integers for equality.\r\n     * @param other the other integer to compare\r\n     * @returns\r\n     */\r\n    public equals(other: FlowGraphInteger): boolean {\r\n        return this.value === other.value;\r\n    }\r\n\r\n    public static ClassName = \"FlowGraphInteger\";\r\n\r\n    /**\r\n     * Parses a FlowGraphInteger from a serialization object.\r\n     * @param value te number to parse\r\n     * @returns\r\n     */\r\n    public static FromValue(value: number): FlowGraphInteger {\r\n        return new FlowGraphInteger(value);\r\n    }\r\n\r\n    public toString(): string {\r\n        return this.value.toString();\r\n    }\r\n}\r\nRegisterClass(\"FlowGraphInteger\", FlowGraphInteger);\r\n", "import { Vector3, Vector2 } from \"core/Maths/math.vector\";\n\n/**\n * Interface representing a generic flow graph matrix.\n */\nexport interface IFlowGraphMatrix<VectorType> {\n    /**\n     * The matrix elements stored in a row-major order.\n     */\n    m: number[];\n\n    /**\n     * Transforms a vector using this matrix.\n     *\n     * @param v - The vector to transform.\n     * @returns The transformed vector.\n     */\n    transformVector(v: VectorType): VectorType;\n\n    /**\n     * Transforms a vector using this matrix and stores the result in a reference vector.\n     *\n     * @param v - The vector to transform.\n     * @param result - The vector to store the result.\n     * @returns The transformed vector.\n     */\n    transformVectorToRef(v: VectorType, result: VectorType): VectorType;\n\n    /**\n     * Returns the matrix elements as an array.\n     *\n     * @returns The matrix elements as an array.\n     */\n    asArray(): number[];\n\n    /**\n     * Copies the matrix elements to an array.\n     *\n     * @param emptyArray - The array to copy the elements to.\n     * @returns The array with the matrix elements.\n     */\n    toArray(emptyArray: number[]): number[];\n\n    /**\n     * Sets the matrix elements from an array.\n     *\n     * @param array - The array containing the matrix elements.\n     * @returns The updated matrix.\n     */\n    fromArray(array: number[]): IFlowGraphMatrix<VectorType>;\n\n    /**\n     * Multiplies this matrix with another matrix and stores the result in a reference matrix.\n     *\n     * @param other - The matrix to multiply with.\n     * @param result - The matrix to store the result.\n     * @returns The result matrix.\n     */\n    multiplyToRef(other: IFlowGraphMatrix<VectorType>, result: IFlowGraphMatrix<VectorType>): IFlowGraphMatrix<VectorType>;\n\n    /**\n     * Multiplies this matrix with another matrix.\n     * To staz conform with the Matrix class, this does B * A\n     *\n     * @param other - The matrix to multiply with.\n     * @returns The result matrix.\n     */\n    multiply(other: IFlowGraphMatrix<VectorType>): IFlowGraphMatrix<VectorType>;\n\n    /**\n     * Divides this matrix by another matrix and stores the result in a reference matrix.\n     *\n     * @param other - The matrix to divide by.\n     * @param result - The matrix to store the result.\n     * @returns The result matrix.\n     */\n    divideToRef(other: IFlowGraphMatrix<VectorType>, result: IFlowGraphMatrix<VectorType>): IFlowGraphMatrix<VectorType>;\n\n    /**\n     * Divides this matrix by another matrix.\n     *\n     * @param other - The matrix to divide by.\n     * @returns The result matrix.\n     */\n    divide(other: IFlowGraphMatrix<VectorType>): IFlowGraphMatrix<VectorType>;\n\n    /**\n     * Adds another matrix to this matrix and stores the result in a reference matrix.\n     *\n     * @param other - The matrix to add.\n     * @param result - The matrix to store the result.\n     * @returns The result matrix.\n     */\n    addToRef(other: IFlowGraphMatrix<VectorType>, result: IFlowGraphMatrix<VectorType>): IFlowGraphMatrix<VectorType>;\n\n    /**\n     * Adds another matrix to this matrix.\n     *\n     * @param other - The matrix to add.\n     * @returns The result matrix.\n     */\n    add(other: IFlowGraphMatrix<VectorType>): IFlowGraphMatrix<VectorType>;\n\n    /**\n     * Subtracts another matrix from this matrix and stores the result in a reference matrix.\n     *\n     * @param other - The matrix to subtract.\n     * @param result - The matrix to store the result.\n     * @returns The result matrix.\n     */\n    subtractToRef(other: IFlowGraphMatrix<VectorType>, result: IFlowGraphMatrix<VectorType>): IFlowGraphMatrix<VectorType>;\n\n    /**\n     * Subtracts another matrix from this matrix.\n     *\n     * @param other - The matrix to subtract.\n     * @returns The result matrix.\n     */\n    subtract(other: IFlowGraphMatrix<VectorType>): IFlowGraphMatrix<VectorType>;\n\n    /**\n     * Transposes this matrix.\n     *\n     * @returns The transposed matrix.\n     */\n    transpose(): IFlowGraphMatrix<VectorType>;\n\n    /**\n     * Computes the determinant of this matrix.\n     *\n     * @returns The determinant of the matrix.\n     */\n    determinant(): number;\n\n    /**\n     * Computes the inverse of this matrix.\n     *\n     * @returns The inverse of the matrix.\n     * @throws Error if the matrix is not invertible.\n     */\n    inverse(): IFlowGraphMatrix<VectorType>;\n\n    /**\n     * Gets the class name of this matrix.\n     *\n     * @returns The class name.\n     */\n    getClassName(): string;\n\n    /**\n     * Checks if this matrix is equal to another matrix within an optional epsilon.\n     *\n     * @param other - The matrix to compare with.\n     * @param epsilon - The optional epsilon for comparison.\n     * @returns True if the matrices are equal, false otherwise.\n     */\n    equals(other: IFlowGraphMatrix<VectorType>, epsilon?: number): boolean;\n}\n\n// Note - the matrix classes are basically column-major, and work similarly to Babylon.js' Matrix class.\n\n/**\n * A 2x2 matrix.\n */\nexport class FlowGraphMatrix2D implements IFlowGraphMatrix<Vector2> {\n    /**\n     * @internal\n     */\n    public _m: number[];\n\n    constructor(m: number[] = [1, 0, 0, 1]) {\n        this._m = m;\n    }\n\n    public get m(): number[] {\n        return this._m;\n    }\n\n    public transformVector(v: Vector2): Vector2 {\n        return this.transformVectorToRef(v, new Vector2());\n    }\n\n    public transformVectorToRef(v: Vector2, result: Vector2): Vector2 {\n        result.x = v.x * this._m[0] + v.y * this._m[1];\n        result.y = v.x * this._m[2] + v.y * this._m[3];\n        return result;\n    }\n\n    public asArray(): number[] {\n        return this.toArray();\n    }\n\n    public toArray(emptyArray: number[] = []): number[] {\n        for (let i = 0; i < 4; i++) {\n            emptyArray[i] = this._m[i];\n        }\n        return emptyArray;\n    }\n\n    public fromArray(array: number[]): FlowGraphMatrix2D {\n        for (let i = 0; i < 4; i++) {\n            this._m[i] = array[i];\n        }\n        return this;\n    }\n\n    public multiplyToRef(other: FlowGraphMatrix2D, result: FlowGraphMatrix2D): FlowGraphMatrix2D {\n        const otherMatrix = other._m;\n        const thisMatrix = this._m;\n        const r = result._m;\n        // other * this\n        r[0] = otherMatrix[0] * thisMatrix[0] + otherMatrix[1] * thisMatrix[2];\n        r[1] = otherMatrix[0] * thisMatrix[1] + otherMatrix[1] * thisMatrix[3];\n        r[2] = otherMatrix[2] * thisMatrix[0] + otherMatrix[3] * thisMatrix[2];\n        r[3] = otherMatrix[2] * thisMatrix[1] + otherMatrix[3] * thisMatrix[3];\n\n        return result;\n    }\n\n    public multiply(other: FlowGraphMatrix2D): FlowGraphMatrix2D {\n        return this.multiplyToRef(other, new FlowGraphMatrix2D());\n    }\n\n    public divideToRef(other: FlowGraphMatrix2D, result: FlowGraphMatrix2D): FlowGraphMatrix2D {\n        const m = this._m;\n        const o = other._m;\n        const r = result._m;\n\n        r[0] = m[0] / o[0];\n        r[1] = m[1] / o[1];\n        r[2] = m[2] / o[2];\n        r[3] = m[3] / o[3];\n\n        return result;\n    }\n\n    public divide(other: FlowGraphMatrix2D): FlowGraphMatrix2D {\n        return this.divideToRef(other, new FlowGraphMatrix2D());\n    }\n\n    public addToRef(other: FlowGraphMatrix2D, result: FlowGraphMatrix2D): FlowGraphMatrix2D {\n        const m = this._m;\n        const o = other.m;\n        const r = result.m;\n\n        r[0] = m[0] + o[0];\n        r[1] = m[1] + o[1];\n        r[2] = m[2] + o[2];\n        r[3] = m[3] + o[3];\n\n        return result;\n    }\n\n    public add(other: FlowGraphMatrix2D): FlowGraphMatrix2D {\n        return this.addToRef(other, new FlowGraphMatrix2D());\n    }\n\n    public subtractToRef(other: FlowGraphMatrix2D, result: FlowGraphMatrix2D): FlowGraphMatrix2D {\n        const m = this._m;\n        const o = other.m;\n        const r = result.m;\n\n        r[0] = m[0] - o[0];\n        r[1] = m[1] - o[1];\n        r[2] = m[2] - o[2];\n        r[3] = m[3] - o[3];\n\n        return result;\n    }\n\n    public subtract(other: FlowGraphMatrix2D): FlowGraphMatrix2D {\n        return this.subtractToRef(other, new FlowGraphMatrix2D());\n    }\n\n    public transpose(): FlowGraphMatrix2D {\n        const m = this._m;\n        return new FlowGraphMatrix2D([m[0], m[2], m[1], m[3]]);\n    }\n\n    public determinant(): number {\n        const m = this._m;\n        return m[0] * m[3] - m[1] * m[2];\n    }\n\n    public inverse(): FlowGraphMatrix2D {\n        const det = this.determinant();\n        if (det === 0) {\n            throw new Error(\"Matrix is not invertible\");\n        }\n        const m = this._m;\n        const invDet = 1 / det;\n        return new FlowGraphMatrix2D([m[3] * invDet, -m[1] * invDet, -m[2] * invDet, m[0] * invDet]);\n    }\n\n    public equals(other: IFlowGraphMatrix<Vector2>, epsilon: number = 0): boolean {\n        const m = this._m;\n        const o = other.m;\n        if (epsilon === 0) {\n            return m[0] === o[0] && m[1] === o[1] && m[2] === o[2] && m[3] === o[3];\n        }\n        return Math.abs(m[0] - o[0]) < epsilon && Math.abs(m[1] - o[1]) < epsilon && Math.abs(m[2] - o[2]) < epsilon && Math.abs(m[3] - o[3]) < epsilon;\n    }\n\n    public getClassName(): string {\n        return \"FlowGraphMatrix2D\";\n    }\n\n    public toString(): string {\n        return `FlowGraphMatrix2D(${this._m.join(\", \")})`;\n    }\n}\n\n/**\n * A 3x3 matrix.\n */\nexport class FlowGraphMatrix3D implements IFlowGraphMatrix<Vector3> {\n    /**\n     * @internal\n     */\n    public _m: number[];\n\n    constructor(array: number[] = [1, 0, 0, 0, 1, 0, 0, 0, 1]) {\n        this._m = array;\n    }\n\n    public get m(): number[] {\n        return this._m;\n    }\n\n    public transformVector(v: Vector3): Vector3 {\n        return this.transformVectorToRef(v, new Vector3());\n    }\n\n    public transformVectorToRef(v: Vector3, result: Vector3): Vector3 {\n        const m = this._m;\n        result.x = v.x * m[0] + v.y * m[1] + v.z * m[2];\n        result.y = v.x * m[3] + v.y * m[4] + v.z * m[5];\n        result.z = v.x * m[6] + v.y * m[7] + v.z * m[8];\n        return result;\n    }\n\n    public multiplyToRef(other: FlowGraphMatrix3D, result: FlowGraphMatrix3D): FlowGraphMatrix3D {\n        const otherMatrix = other._m;\n        const thisMatrix = this._m;\n        const r = result.m;\n\n        r[0] = otherMatrix[0] * thisMatrix[0] + otherMatrix[1] * thisMatrix[3] + otherMatrix[2] * thisMatrix[6];\n        r[1] = otherMatrix[0] * thisMatrix[1] + otherMatrix[1] * thisMatrix[4] + otherMatrix[2] * thisMatrix[7];\n        r[2] = otherMatrix[0] * thisMatrix[2] + otherMatrix[1] * thisMatrix[5] + otherMatrix[2] * thisMatrix[8];\n\n        r[3] = otherMatrix[3] * thisMatrix[0] + otherMatrix[4] * thisMatrix[3] + otherMatrix[5] * thisMatrix[6];\n        r[4] = otherMatrix[3] * thisMatrix[1] + otherMatrix[4] * thisMatrix[4] + otherMatrix[5] * thisMatrix[7];\n        r[5] = otherMatrix[3] * thisMatrix[2] + otherMatrix[4] * thisMatrix[5] + otherMatrix[5] * thisMatrix[8];\n\n        r[6] = otherMatrix[6] * thisMatrix[0] + otherMatrix[7] * thisMatrix[3] + otherMatrix[8] * thisMatrix[6];\n        r[7] = otherMatrix[6] * thisMatrix[1] + otherMatrix[7] * thisMatrix[4] + otherMatrix[8] * thisMatrix[7];\n        r[8] = otherMatrix[6] * thisMatrix[2] + otherMatrix[7] * thisMatrix[5] + otherMatrix[8] * thisMatrix[8];\n\n        return result;\n    }\n\n    public multiply(other: FlowGraphMatrix3D): FlowGraphMatrix3D {\n        return this.multiplyToRef(other, new FlowGraphMatrix3D());\n    }\n\n    public divideToRef(other: FlowGraphMatrix3D, result: FlowGraphMatrix3D): FlowGraphMatrix3D {\n        const m = this._m;\n        const o = other.m;\n        const r = result.m;\n\n        r[0] = m[0] / o[0];\n        r[1] = m[1] / o[1];\n        r[2] = m[2] / o[2];\n        r[3] = m[3] / o[3];\n        r[4] = m[4] / o[4];\n        r[5] = m[5] / o[5];\n        r[6] = m[6] / o[6];\n        r[7] = m[7] / o[7];\n        r[8] = m[8] / o[8];\n\n        return result;\n    }\n\n    public divide(other: FlowGraphMatrix3D): FlowGraphMatrix3D {\n        return this.divideToRef(other, new FlowGraphMatrix3D());\n    }\n\n    public addToRef(other: FlowGraphMatrix3D, result: FlowGraphMatrix3D): FlowGraphMatrix3D {\n        const m = this._m;\n        const o = other.m;\n        const r = result.m;\n\n        r[0] = m[0] + o[0];\n        r[1] = m[1] + o[1];\n        r[2] = m[2] + o[2];\n        r[3] = m[3] + o[3];\n        r[4] = m[4] + o[4];\n        r[5] = m[5] + o[5];\n        r[6] = m[6] + o[6];\n        r[7] = m[7] + o[7];\n        r[8] = m[8] + o[8];\n\n        return result;\n    }\n\n    public add(other: FlowGraphMatrix3D): FlowGraphMatrix3D {\n        return this.addToRef(other, new FlowGraphMatrix3D());\n    }\n\n    public subtractToRef(other: FlowGraphMatrix3D, result: FlowGraphMatrix3D): FlowGraphMatrix3D {\n        const m = this._m;\n        const o = other.m;\n        const r = result.m;\n\n        r[0] = m[0] - o[0];\n        r[1] = m[1] - o[1];\n        r[2] = m[2] - o[2];\n        r[3] = m[3] - o[3];\n        r[4] = m[4] - o[4];\n        r[5] = m[5] - o[5];\n        r[6] = m[6] - o[6];\n        r[7] = m[7] - o[7];\n        r[8] = m[8] - o[8];\n\n        return result;\n    }\n\n    public subtract(other: FlowGraphMatrix3D): FlowGraphMatrix3D {\n        return this.subtractToRef(other, new FlowGraphMatrix3D());\n    }\n\n    public toArray(emptyArray: number[] = []): number[] {\n        for (let i = 0; i < 9; i++) {\n            emptyArray[i] = this._m[i];\n        }\n        return emptyArray;\n    }\n\n    public asArray(): number[] {\n        return this.toArray();\n    }\n\n    public fromArray(array: number[]): FlowGraphMatrix3D {\n        for (let i = 0; i < 9; i++) {\n            this._m[i] = array[i];\n        }\n        return this;\n    }\n\n    public transpose(): FlowGraphMatrix3D {\n        const m = this._m;\n        return new FlowGraphMatrix3D([m[0], m[3], m[6], m[1], m[4], m[7], m[2], m[5], m[8]]);\n    }\n\n    public determinant(): number {\n        const m = this._m;\n        return m[0] * (m[4] * m[8] - m[5] * m[7]) - m[1] * (m[3] * m[8] - m[5] * m[6]) + m[2] * (m[3] * m[7] - m[4] * m[6]);\n    }\n\n    public inverse(): FlowGraphMatrix3D {\n        const det = this.determinant();\n        if (det === 0) {\n            throw new Error(\"Matrix is not invertible\");\n        }\n        const m = this._m;\n        const invDet = 1 / det;\n        return new FlowGraphMatrix3D([\n            (m[4] * m[8] - m[5] * m[7]) * invDet,\n            (m[2] * m[7] - m[1] * m[8]) * invDet,\n            (m[1] * m[5] - m[2] * m[4]) * invDet,\n            (m[5] * m[6] - m[3] * m[8]) * invDet,\n            (m[0] * m[8] - m[2] * m[6]) * invDet,\n            (m[2] * m[3] - m[0] * m[5]) * invDet,\n            (m[3] * m[7] - m[4] * m[6]) * invDet,\n            (m[1] * m[6] - m[0] * m[7]) * invDet,\n            (m[0] * m[4] - m[1] * m[3]) * invDet,\n        ]);\n    }\n\n    public equals(other: IFlowGraphMatrix<Vector3>, epsilon: number = 0): boolean {\n        const m = this._m;\n        const o = other.m;\n        // performance shortcut\n        if (epsilon === 0) {\n            return m[0] === o[0] && m[1] === o[1] && m[2] === o[2] && m[3] === o[3] && m[4] === o[4] && m[5] === o[5] && m[6] === o[6] && m[7] === o[7] && m[8] === o[8];\n        }\n        return (\n            Math.abs(m[0] - o[0]) < epsilon &&\n            Math.abs(m[1] - o[1]) < epsilon &&\n            Math.abs(m[2] - o[2]) < epsilon &&\n            Math.abs(m[3] - o[3]) < epsilon &&\n            Math.abs(m[4] - o[4]) < epsilon &&\n            Math.abs(m[5] - o[5]) < epsilon &&\n            Math.abs(m[6] - o[6]) < epsilon &&\n            Math.abs(m[7] - o[7]) < epsilon &&\n            Math.abs(m[8] - o[8]) < epsilon\n        );\n    }\n\n    public getClassName(): string {\n        return \"FlowGraphMatrix3D\";\n    }\n\n    public toString(): string {\n        return `FlowGraphMatrix3D(${this._m.join(\", \")})`;\n    }\n}\n", "import { Vector2, Vector3, Vector4, Matrix, Quaternion } from \"../Maths/math.vector\";\r\nimport { Color3, Color4 } from \"../Maths/math.color\";\r\nimport { FlowGraphInteger } from \"./CustomTypes/flowGraphInteger\";\r\nimport { Constants } from \"core/Engines/constants\";\r\nimport { FlowGraphMatrix2D, FlowGraphMatrix3D } from \"./CustomTypes/flowGraphMatrix\";\r\n\r\n/**\r\n * The types supported by the flow graph.\r\n */\r\nexport const enum FlowGraphTypes {\r\n    Any = \"any\",\r\n    String = \"string\",\r\n    Number = \"number\",\r\n    Boolean = \"boolean\",\r\n    Object = \"object\",\r\n    Integer = \"FlowGraphInteger\",\r\n    Vector2 = \"Vector2\",\r\n    Vector3 = \"Vector3\",\r\n    Vector4 = \"Vector4\",\r\n    Quaternion = \"Quaternion\",\r\n    Matrix = \"Matrix\",\r\n    Matrix2D = \"Matrix2D\",\r\n    Matrix3D = \"Matrix3D\",\r\n    Color3 = \"Color3\",\r\n    Color4 = \"Color4\",\r\n}\r\n\r\n/**\r\n * A rich type represents extra information about a type,\r\n * such as its name and a default value constructor.\r\n */\r\nexport class RichType<T> {\r\n    /**\r\n     * A function that can be used to transform a value of any type into a value of this rich type.\r\n     * This can be used, for example, between vector4 and quaternion.\r\n     */\r\n    public typeTransformer: (value: any) => T;\r\n\r\n    constructor(\r\n        /**\r\n         * The name given to the type.\r\n         */\r\n        public typeName: string,\r\n        /**\r\n         * The default value of the type.\r\n         */\r\n        public defaultValue: T,\r\n\r\n        /**\r\n         * [-1] The ANIMATIONTYPE of the type, if available\r\n         */\r\n        public animationType: number = -1\r\n    ) {}\r\n\r\n    /**\r\n     * Serializes this rich type into a serialization object.\r\n     * @param serializationObject the object to serialize to\r\n     */\r\n    serialize(serializationObject: any) {\r\n        serializationObject.typeName = this.typeName;\r\n        serializationObject.defaultValue = this.defaultValue;\r\n    }\r\n}\r\n\r\nexport const RichTypeAny: RichType<any> = new RichType(FlowGraphTypes.Any, undefined);\r\n\r\nexport const RichTypeString: RichType<string> = new RichType(FlowGraphTypes.String, \"\");\r\n\r\nexport const RichTypeNumber: RichType<number> = new RichType(FlowGraphTypes.Number, 0, Constants.ANIMATIONTYPE_FLOAT);\r\n\r\nexport const RichTypeBoolean: RichType<boolean> = new RichType(FlowGraphTypes.Boolean, false);\r\n\r\nexport const RichTypeVector2: RichType<Vector2> = new RichType(FlowGraphTypes.Vector2, Vector2.Zero(), Constants.ANIMATIONTYPE_VECTOR2);\r\n\r\nexport const RichTypeVector3: RichType<Vector3> = new RichType(FlowGraphTypes.Vector3, Vector3.Zero(), Constants.ANIMATIONTYPE_VECTOR3);\r\n\r\nexport const RichTypeVector4: RichType<Vector4> = new RichType(FlowGraphTypes.Vector4, Vector4.Zero());\r\n\r\nexport const RichTypeMatrix: RichType<Matrix> = new RichType(FlowGraphTypes.Matrix, Matrix.Identity(), Constants.ANIMATIONTYPE_MATRIX);\r\n\r\nexport const RichTypeMatrix2D: RichType<FlowGraphMatrix2D> = new RichType(FlowGraphTypes.Matrix2D, new FlowGraphMatrix2D());\r\n\r\nexport const RichTypeMatrix3D: RichType<FlowGraphMatrix3D> = new RichType(FlowGraphTypes.Matrix3D, new FlowGraphMatrix3D());\r\n\r\nexport const RichTypeColor3: RichType<Color3> = new RichType(FlowGraphTypes.Color3, Color3.Black(), Constants.ANIMATIONTYPE_COLOR3);\r\n\r\nexport const RichTypeColor4: RichType<Color4> = new RichType(FlowGraphTypes.Color4, new Color4(0, 0, 0, 0), Constants.ANIMATIONTYPE_COLOR4);\r\n\r\nexport const RichTypeQuaternion: RichType<Quaternion> = new RichType(FlowGraphTypes.Quaternion, Quaternion.Identity(), Constants.ANIMATIONTYPE_QUATERNION);\r\nRichTypeQuaternion.typeTransformer = (value: any) => {\r\n    if (value.getClassName && value.getClassName() === FlowGraphTypes.Vector4) {\r\n        return Quaternion.FromArray(value.asArray());\r\n    } else if (value.getClassName && value.getClassName() === FlowGraphTypes.Vector3) {\r\n        return Quaternion.FromEulerVector(value);\r\n    } else if (value.getClassName && value.getClassName() === FlowGraphTypes.Matrix) {\r\n        return Quaternion.FromRotationMatrix(value);\r\n    }\r\n    return value;\r\n};\r\nexport const RichTypeFlowGraphInteger: RichType<FlowGraphInteger> = new RichType(FlowGraphTypes.Integer, new FlowGraphInteger(0), Constants.ANIMATIONTYPE_FLOAT);\r\n\r\n/**\r\n * Given a value, try to deduce its rich type.\r\n * @param value the value to deduce the rich type from\r\n * @returns the value's rich type, or RichTypeAny if the type could not be deduced.\r\n */\r\nexport function getRichTypeFromValue<T>(value: T): RichType<T> {\r\n    const anyValue = value as any;\r\n    switch (typeof value) {\r\n        case FlowGraphTypes.String:\r\n            return RichTypeString as RichType<T>;\r\n        case FlowGraphTypes.Number:\r\n            return RichTypeNumber as RichType<T>;\r\n        case FlowGraphTypes.Boolean:\r\n            return RichTypeBoolean as RichType<T>;\r\n        case FlowGraphTypes.Object:\r\n            if (anyValue.getClassName) {\r\n                switch (anyValue.getClassName() as string) {\r\n                    case FlowGraphTypes.Vector2:\r\n                        return RichTypeVector2 as RichType<T>;\r\n                    case FlowGraphTypes.Vector3:\r\n                        return RichTypeVector3 as RichType<T>;\r\n                    case FlowGraphTypes.Vector4:\r\n                        return RichTypeVector4 as RichType<T>;\r\n                    case FlowGraphTypes.Matrix:\r\n                        return RichTypeMatrix as RichType<T>;\r\n                    case FlowGraphTypes.Color3:\r\n                        return RichTypeColor3 as RichType<T>;\r\n                    case FlowGraphTypes.Color4:\r\n                        return RichTypeColor4 as RichType<T>;\r\n                    case FlowGraphTypes.Quaternion:\r\n                        return RichTypeQuaternion as RichType<T>;\r\n                    case FlowGraphTypes.Integer:\r\n                        return RichTypeFlowGraphInteger as RichType<T>;\r\n                    case FlowGraphTypes.Matrix2D:\r\n                        return RichTypeMatrix2D as RichType<T>;\r\n                    case FlowGraphTypes.Matrix3D:\r\n                        return RichTypeMatrix3D as RichType<T>;\r\n                }\r\n            }\r\n            return RichTypeAny as RichType<T>;\r\n        default:\r\n            return RichTypeAny as RichType<T>;\r\n    }\r\n}\r\n\r\n/**\r\n * Given a flow graph type, return the rich type that corresponds to it.\r\n * @param flowGraphType the flow graph type\r\n * @returns the rich type that corresponds to the flow graph type\r\n */\r\nexport function getRichTypeByFlowGraphType(flowGraphType?: string): RichType<any> {\r\n    switch (flowGraphType) {\r\n        case FlowGraphTypes.String:\r\n            return RichTypeString;\r\n        case FlowGraphTypes.Number:\r\n            return RichTypeNumber;\r\n        case FlowGraphTypes.Boolean:\r\n            return RichTypeBoolean;\r\n        case FlowGraphTypes.Vector2:\r\n            return RichTypeVector2;\r\n        case FlowGraphTypes.Vector3:\r\n            return RichTypeVector3;\r\n        case FlowGraphTypes.Vector4:\r\n            return RichTypeVector4;\r\n        case FlowGraphTypes.Matrix:\r\n            return RichTypeMatrix;\r\n        case FlowGraphTypes.Color3:\r\n            return RichTypeColor3;\r\n        case FlowGraphTypes.Color4:\r\n            return RichTypeColor4;\r\n        case FlowGraphTypes.Quaternion:\r\n            return RichTypeQuaternion;\r\n        case FlowGraphTypes.Integer:\r\n            return RichTypeFlowGraphInteger;\r\n        case FlowGraphTypes.Matrix2D:\r\n            return RichTypeMatrix2D;\r\n        case FlowGraphTypes.Matrix3D:\r\n            return RichTypeMatrix3D;\r\n        default:\r\n            return RichTypeAny;\r\n    }\r\n}\r\n\r\n/**\r\n * get the animation type for a given flow graph type\r\n * @param flowGraphType the flow graph type\r\n * @returns the animation type for this flow graph type\r\n */\r\nexport function getAnimationTypeByFlowGraphType(flowGraphType: FlowGraphTypes): number {\r\n    switch (flowGraphType) {\r\n        case FlowGraphTypes.Number:\r\n            return Constants.ANIMATIONTYPE_FLOAT;\r\n        case FlowGraphTypes.Vector2:\r\n            return Constants.ANIMATIONTYPE_VECTOR2;\r\n        case FlowGraphTypes.Vector3:\r\n            return Constants.ANIMATIONTYPE_VECTOR3;\r\n        case FlowGraphTypes.Matrix:\r\n            return Constants.ANIMATIONTYPE_MATRIX;\r\n        case FlowGraphTypes.Color3:\r\n            return Constants.ANIMATIONTYPE_COLOR3;\r\n        case FlowGraphTypes.Color4:\r\n            return Constants.ANIMATIONTYPE_COLOR4;\r\n        case FlowGraphTypes.Quaternion:\r\n            return Constants.ANIMATIONTYPE_QUATERNION;\r\n        default:\r\n            return Constants.ANIMATIONTYPE_FLOAT;\r\n    }\r\n}\r\n\r\n/**\r\n * Given an animation type, return the rich type that corresponds to it.\r\n * @param animationType the animation type\r\n * @returns the rich type that corresponds to the animation type\r\n */\r\nexport function getRichTypeByAnimationType(animationType: number): RichType<any> {\r\n    switch (animationType) {\r\n        case Constants.ANIMATIONTYPE_FLOAT:\r\n            return RichTypeNumber;\r\n        case Constants.ANIMATIONTYPE_VECTOR2:\r\n            return RichTypeVector2;\r\n        case Constants.ANIMATIONTYPE_VECTOR3:\r\n            return RichTypeVector3;\r\n        case Constants.ANIMATIONTYPE_MATRIX:\r\n            return RichTypeMatrix;\r\n        case Constants.ANIMATIONTYPE_COLOR3:\r\n            return RichTypeColor3;\r\n        case Constants.ANIMATIONTYPE_COLOR4:\r\n            return RichTypeColor4;\r\n        case Constants.ANIMATIONTYPE_QUATERNION:\r\n            return RichTypeQuaternion;\r\n        default:\r\n            return RichTypeAny;\r\n    }\r\n}\r\n", "import type { IAssetContainer } from \"core/IAssetContainer\";\r\nimport { Color3, Color4 } from \"../Maths/math.color\";\r\nimport { Matrix, Quaternion, Vector2, Vector3, Vector4 } from \"../Maths/math.vector\";\r\nimport type { Scene } from \"../scene\";\r\nimport { FlowGraphBlockNames } from \"./Blocks/flowGraphBlockNames\";\r\nimport { FlowGraphInteger } from \"./CustomTypes/flowGraphInteger\";\r\nimport { FlowGraphTypes, getRichTypeByFlowGraphType } from \"./flowGraphRichTypes\";\r\nimport type { TransformNode } from \"core/Meshes/transformNode\";\r\nimport { FlowGraphMatrix2D, FlowGraphMatrix3D } from \"./CustomTypes/flowGraphMatrix\";\r\n\r\nfunction isMeshClassName(className: string) {\r\n    return (\r\n        className === \"Mesh\" ||\r\n        className === \"AbstractMesh\" ||\r\n        className === \"GroundMesh\" ||\r\n        className === \"InstanceMesh\" ||\r\n        className === \"LinesMesh\" ||\r\n        className === \"GoldbergMesh\" ||\r\n        className === \"GreasedLineMesh\" ||\r\n        className === \"TrailMesh\"\r\n    );\r\n}\r\n\r\nfunction isVectorClassName(className: string) {\r\n    return (\r\n        className === FlowGraphTypes.Vector2 ||\r\n        className === FlowGraphTypes.Vector3 ||\r\n        className === FlowGraphTypes.Vector4 ||\r\n        className === FlowGraphTypes.Quaternion ||\r\n        className === FlowGraphTypes.Color3 ||\r\n        className === FlowGraphTypes.Color4\r\n    );\r\n}\r\n\r\nfunction isMatrixClassName(className: string) {\r\n    return className === FlowGraphTypes.Matrix || className === FlowGraphTypes.Matrix2D || className === FlowGraphTypes.Matrix3D;\r\n}\r\n\r\nfunction isAnimationGroupClassName(className: string) {\r\n    return className === \"AnimationGroup\";\r\n}\r\n\r\nfunction parseVector(className: string, value: Array<number>, flipHandedness = false) {\r\n    if (className === FlowGraphTypes.Vector2) {\r\n        return Vector2.FromArray(value);\r\n    } else if (className === FlowGraphTypes.Vector3) {\r\n        if (flipHandedness) {\r\n            value[2] *= -1;\r\n        }\r\n        return Vector3.FromArray(value);\r\n    } else if (className === FlowGraphTypes.Vector4) {\r\n        return Vector4.FromArray(value);\r\n    } else if (className === FlowGraphTypes.Quaternion) {\r\n        if (flipHandedness) {\r\n            value[2] *= -1;\r\n            value[3] *= -1;\r\n        }\r\n        return Quaternion.FromArray(value);\r\n    } else if (className === FlowGraphTypes.Color3) {\r\n        return new Color3(value[0], value[1], value[2]);\r\n    } else if (className === FlowGraphTypes.Color4) {\r\n        return new Color4(value[0], value[1], value[2], value[3]);\r\n    } else {\r\n        throw new Error(`Unknown vector class name ${className}`);\r\n    }\r\n}\r\n\r\n/**\r\n * The default function that serializes values in a context object to a serialization object\r\n * @param key the key where the value should be stored in the serialization object\r\n * @param value the value to store\r\n * @param serializationObject the object where the value will be stored\r\n */\r\nexport function defaultValueSerializationFunction(key: string, value: any, serializationObject: any) {\r\n    const className = value?.getClassName?.() ?? \"\";\r\n    if (isVectorClassName(className) || isMatrixClassName(className)) {\r\n        serializationObject[key] = {\r\n            value: value.asArray(),\r\n            className,\r\n        };\r\n    } else if (className === FlowGraphTypes.Integer) {\r\n        serializationObject[key] = {\r\n            value: value.value,\r\n            className,\r\n        };\r\n    } else {\r\n        if (className && (value.id || value.name)) {\r\n            serializationObject[key] = {\r\n                id: value.id,\r\n                name: value.name,\r\n                className,\r\n            };\r\n        } else {\r\n            // only if it is not an object\r\n            if (typeof value !== \"object\") {\r\n                serializationObject[key] = value;\r\n            } else {\r\n                throw new Error(`Could not serialize value ${value}`);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * The default function that parses values stored in a serialization object\r\n * @param key the key to the value that will be parsed\r\n * @param serializationObject the object that will be parsed\r\n * @param assetsContainer the assets container that will be used to find the objects\r\n * @param scene\r\n * @returns\r\n */\r\nexport function defaultValueParseFunction(key: string, serializationObject: any, assetsContainer: IAssetContainer, scene: Scene) {\r\n    const intermediateValue = serializationObject[key];\r\n    let finalValue;\r\n    const className = intermediateValue?.type ?? intermediateValue?.className;\r\n    if (isMeshClassName(className)) {\r\n        let nodes: TransformNode[] = scene.meshes.filter((m) => (intermediateValue.id ? m.id === intermediateValue.id : m.name === intermediateValue.name));\r\n        if (nodes.length === 0) {\r\n            nodes = scene.transformNodes.filter((m) => (intermediateValue.id ? m.id === intermediateValue.id : m.name === intermediateValue.name));\r\n        }\r\n        finalValue = intermediateValue.uniqueId ? nodes.find((m) => m.uniqueId === intermediateValue.uniqueId) : nodes[0];\r\n    } else if (isVectorClassName(className)) {\r\n        finalValue = parseVector(className, intermediateValue.value);\r\n    } else if (isAnimationGroupClassName(className)) {\r\n        // do not use the scene.getAnimationGroupByName because it is possible that two AGs will have the same name\r\n        const ags = scene.animationGroups.filter((ag) => ag.name === intermediateValue.name);\r\n        // uniqueId changes on each load. this is used for the glTF loader, that uses serialization after the scene was loaded.\r\n        finalValue = ags.length === 1 ? ags[0] : ags.find((ag) => ag.uniqueId === intermediateValue.uniqueId);\r\n    } else if (className === FlowGraphTypes.Matrix) {\r\n        finalValue = Matrix.FromArray(intermediateValue.value);\r\n    } else if (className === FlowGraphTypes.Matrix2D) {\r\n        finalValue = new FlowGraphMatrix2D(intermediateValue.value);\r\n    } else if (className === FlowGraphTypes.Matrix3D) {\r\n        finalValue = new FlowGraphMatrix3D(intermediateValue.value);\r\n    } else if (className === FlowGraphTypes.Integer) {\r\n        finalValue = FlowGraphInteger.FromValue(intermediateValue.value);\r\n    } else if (className === FlowGraphTypes.Number || className === FlowGraphTypes.String || className === FlowGraphTypes.Boolean) {\r\n        finalValue = intermediateValue.value[0];\r\n    } else if (intermediateValue && intermediateValue.value !== undefined) {\r\n        finalValue = intermediateValue.value;\r\n    } else {\r\n        if (Array.isArray(intermediateValue)) {\r\n            // configuration data of an event\r\n            finalValue = intermediateValue.reduce((acc, val) => {\r\n                if (!val.eventData) {\r\n                    return acc;\r\n                }\r\n                acc[val.id] = {\r\n                    type: getRichTypeByFlowGraphType(val.type),\r\n                };\r\n                if (typeof val.value !== \"undefined\") {\r\n                    acc[val.id].value = defaultValueParseFunction(\"value\", val, assetsContainer, scene);\r\n                }\r\n                return acc;\r\n            }, {});\r\n        } else {\r\n            finalValue = intermediateValue;\r\n        }\r\n    }\r\n    return finalValue;\r\n}\r\n\r\n/**\r\n * Given a name of a flow graph block class, return if this\r\n * class needs to be created with a path converter. Used in\r\n * parsing.\r\n * @param className the name of the flow graph block class\r\n * @returns a boolean indicating if the class needs a path converter\r\n */\r\nexport function needsPathConverter(className: string) {\r\n    // I am not using the ClassName property here because it was causing a circular dependency\r\n    // that jest didn't like!\r\n    return className === FlowGraphBlockNames.JsonPointerParser;\r\n}\r\n", "import { RandomGUID } from \"../Misc/guid\";\r\n\r\n/**\r\n * The type of a connection point - input or output.\r\n */\r\nexport const enum FlowGraphConnectionType {\r\n    Input,\r\n    Output,\r\n}\r\n\r\n/**\r\n * An interface for a connectable point in the flow graph.\r\n */\r\nexport interface IConnectable {\r\n    /**\r\n     * A uniquely identifying string for the connection.\r\n     */\r\n    uniqueId: string;\r\n    /**\r\n     * An array of the points that this point is connected to.\r\n     */\r\n    _connectedPoint: Array<IConnectable>;\r\n    /**\r\n     * Returns if the connection can only be connected to one other point.\r\n     */\r\n    _isSingularConnection(): boolean;\r\n    /**\r\n     * The type of the connection\r\n     */\r\n    _connectionType: FlowGraphConnectionType;\r\n    /**\r\n     * Connect this point to another point.\r\n     * @param point the point to connect to.\r\n     */\r\n    connectTo(point: IConnectable): void;\r\n}\r\n\r\n/**\r\n * The base connection class.\r\n */\r\nexport class FlowGraphConnection<BlockT, ConnectedToT extends IConnectable> implements IConnectable {\r\n    /** @internal */\r\n    public _connectedPoint: Array<ConnectedToT> = [];\r\n    /**\r\n     * A uniquely identifying string for the connection.\r\n     */\r\n    public uniqueId = RandomGUID();\r\n\r\n    /**\r\n     * The name of the connection.\r\n     */\r\n    public name: string;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _connectionType: FlowGraphConnectionType;\r\n\r\n    /**\r\n     * Used for parsing connections.\r\n     * @internal\r\n     */\r\n    // disable warning as this is used for parsing\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public connectedPointIds: any[] = [];\r\n\r\n    public constructor(\r\n        name: string,\r\n        _connectionType: FlowGraphConnectionType,\r\n        /* @internal */ public _ownerBlock: BlockT\r\n    ) {\r\n        this.name = name;\r\n        this._connectionType = _connectionType;\r\n    }\r\n\r\n    /**\r\n     * The type of the connection\r\n     */\r\n    public get connectionType() {\r\n        return this._connectionType;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Override this to indicate if a point can connect to more than one point.\r\n     */\r\n    public _isSingularConnection(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Returns if a point is connected to any other point.\r\n     * @returns boolean indicating if the point is connected.\r\n     */\r\n    public isConnected(): boolean {\r\n        return this._connectedPoint.length > 0;\r\n    }\r\n\r\n    /**\r\n     * Connects two connections together.\r\n     * @param point the connection to connect to.\r\n     */\r\n    public connectTo(point: ConnectedToT): void {\r\n        if (this._connectionType === point._connectionType) {\r\n            throw new Error(`Cannot connect two points of type ${this.connectionType}`);\r\n        }\r\n        if ((this._isSingularConnection() && this._connectedPoint.length > 0) || (point._isSingularConnection() && point._connectedPoint.length > 0)) {\r\n            throw new Error(\"Max number of connections for point reached\");\r\n        }\r\n        this._connectedPoint.push(point);\r\n        point._connectedPoint.push(this);\r\n    }\r\n\r\n    /**\r\n     * Disconnects two connections.\r\n     * @param point the connection to disconnect from.\r\n     * @param removeFromLocal if true, the connection will be removed from the local connection list.\r\n     */\r\n    public disconnectFrom(point: ConnectedToT, removeFromLocal = true): void {\r\n        const indexLocal = this._connectedPoint.indexOf(point);\r\n        const indexConnected = point._connectedPoint.indexOf(this);\r\n        if (indexLocal === -1 || indexConnected === -1) {\r\n            return;\r\n        }\r\n        if (removeFromLocal) {\r\n            this._connectedPoint.splice(indexLocal, 1);\r\n        }\r\n        point._connectedPoint.splice(indexConnected, 1);\r\n    }\r\n\r\n    /**\r\n     * Disconnects all connected points.\r\n     */\r\n    public disconnectFromAll() {\r\n        for (const point of this._connectedPoint) {\r\n            this.disconnectFrom(point, false);\r\n        }\r\n        this._connectedPoint.length = 0;\r\n    }\r\n\r\n    public dispose() {\r\n        for (const point of this._connectedPoint) {\r\n            this.disconnectFrom(point);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Saves the connection to a JSON object.\r\n     * @param serializationObject the object to serialize to.\r\n     */\r\n    public serialize(serializationObject: any = {}) {\r\n        serializationObject.uniqueId = this.uniqueId;\r\n        serializationObject.name = this.name;\r\n        serializationObject._connectionType = this._connectionType;\r\n        serializationObject.connectedPointIds = [];\r\n        serializationObject.className = this.getClassName();\r\n        for (const point of this._connectedPoint) {\r\n            serializationObject.connectedPointIds.push(point.uniqueId);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @returns class name of the connection.\r\n     */\r\n    public getClassName(): string {\r\n        return \"FGConnection\";\r\n    }\r\n\r\n    /**\r\n     * Deserialize from a object into this\r\n     * @param serializationObject the object to deserialize from.\r\n     */\r\n    deserialize(serializationObject: any) {\r\n        this.uniqueId = serializationObject.uniqueId;\r\n        this.name = serializationObject.name;\r\n        this._connectionType = serializationObject._connectionType;\r\n        this.connectedPointIds = serializationObject.connectedPointIds;\r\n    }\r\n}\r\n", "import type { Nullable } from \"core/types\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\nimport type { FlowGraphBlock } from \"./flowGraphBlock\";\r\nimport { FlowGraphConnection, FlowGraphConnectionType } from \"./flowGraphConnection\";\r\nimport type { FlowGraphContext } from \"./flowGraphContext\";\r\nimport type { RichType } from \"./flowGraphRichTypes\";\r\nimport { Observable } from \"core/Misc/observable\";\r\nimport { defaultValueSerializationFunction } from \"./serialization\";\r\n/**\r\n * Represents a connection point for data.\r\n * An unconnected input point can have a default value.\r\n * An output point will only have a value if it is connected to an input point. Furthermore,\r\n * if the point belongs to a \"function\" node, the node will run its function to update the value.\r\n */\r\nexport class FlowGraphDataConnection<T> extends FlowGraphConnection<FlowGraphBlock, FlowGraphDataConnection<T>> {\r\n    private _isDisabled: boolean = false;\r\n    /**\r\n     * This is used for debugging purposes! It is the last value that was set to this connection with ANY context.\r\n     * Do not use this value for anything else, as it might be wrong if used in a different context.\r\n     */\r\n    private _lastValue: Nullable<T> = null;\r\n\r\n    /**\r\n     * a data transformer function, if needed.\r\n     * This can be used, for example, to force seconds into milliseconds output, if it makes sense in your case.\r\n     */\r\n    public dataTransformer: Nullable<(value: T) => T> = null;\r\n\r\n    /**\r\n     * An observable that is triggered when the value of the connection changes.\r\n     */\r\n    public onValueChangedObservable = new Observable<T>();\r\n    /**\r\n     * Create a new data connection point.\r\n     * @param name the name of the connection\r\n     * @param connectionType the type of the connection\r\n     * @param ownerBlock the block that owns this connection\r\n     * @param richType the type of the data in this block\r\n     * @param _defaultValue the default value of the connection\r\n     * @param _optional if the connection is optional\r\n     */\r\n    public constructor(\r\n        name: string,\r\n        connectionType: FlowGraphConnectionType,\r\n        ownerBlock: FlowGraphBlock,\r\n        /**\r\n         * the type of the data in this block\r\n         */\r\n        public richType: RichType<T>,\r\n        /**\r\n         * [any] the default value of the connection\r\n         */\r\n        private _defaultValue: T = richType.defaultValue,\r\n        /**\r\n         * [false] if the connection is optional\r\n         */\r\n        private _optional: boolean = false\r\n    ) {\r\n        super(name, connectionType, ownerBlock);\r\n    }\r\n\r\n    /**\r\n     * Whether or not the connection is optional.\r\n     * Currently only used for UI control.\r\n     */\r\n    public get optional(): boolean {\r\n        return this._optional;\r\n    }\r\n\r\n    /**\r\n     * is this connection disabled\r\n     * If the connection is disabled you will not be able to connect anything to it.\r\n     */\r\n    public get isDisabled(): boolean {\r\n        return this._isDisabled;\r\n    }\r\n\r\n    public set isDisabled(value: boolean) {\r\n        if (this._isDisabled === value) {\r\n            return;\r\n        }\r\n        this._isDisabled = value;\r\n        if (this._isDisabled) {\r\n            this.disconnectFromAll();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * An output data block can connect to multiple input data blocks,\r\n     * but an input data block can only connect to one output data block.\r\n     * @returns true if the connection is singular\r\n     */\r\n    public override _isSingularConnection(): boolean {\r\n        return this.connectionType === FlowGraphConnectionType.Input;\r\n    }\r\n\r\n    /**\r\n     * Set the value of the connection in a specific context.\r\n     * @param value the value to set\r\n     * @param context the context to which the value is set\r\n     */\r\n    public setValue(value: T, context: FlowGraphContext): void {\r\n        // check if the value is different\r\n        if (context._getConnectionValue(this) === value) {\r\n            return;\r\n        }\r\n        context._setConnectionValue(this, value);\r\n        this.onValueChangedObservable.notifyObservers(value);\r\n    }\r\n\r\n    /**\r\n     * Reset the value of the connection to the default value.\r\n     * @param context the context in which the value is reset\r\n     */\r\n    public resetToDefaultValue(context: FlowGraphContext): void {\r\n        context._setConnectionValue(this, this._defaultValue);\r\n    }\r\n\r\n    /**\r\n     * Connect this point to another point.\r\n     * @param point the point to connect to.\r\n     */\r\n    public override connectTo(point: FlowGraphDataConnection<T>): void {\r\n        if (this._isDisabled) {\r\n            return;\r\n        }\r\n        super.connectTo(point);\r\n    }\r\n\r\n    private _getValueOrDefault(context: FlowGraphContext): T {\r\n        const val = context._getConnectionValue(this) ?? this._defaultValue;\r\n        return this.dataTransformer ? this.dataTransformer(val) : val;\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the connection in a specific context.\r\n     * @param context the context from which the value is retrieved\r\n     * @returns the value of the connection\r\n     */\r\n    public getValue(context: FlowGraphContext): T {\r\n        if (this.connectionType === FlowGraphConnectionType.Output) {\r\n            context._notifyExecuteNode(this._ownerBlock);\r\n            this._ownerBlock._updateOutputs(context);\r\n            const value = this._getValueOrDefault(context);\r\n            this._lastValue = value;\r\n            return this.richType.typeTransformer ? this.richType.typeTransformer(value) : value;\r\n        }\r\n        const value = !this.isConnected() ? this._getValueOrDefault(context) : this._connectedPoint[0].getValue(context);\r\n        this._lastValue = value;\r\n        return this.richType.typeTransformer ? this.richType.typeTransformer(value) : value;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getLastValue(): Nullable<T> {\r\n        return this._lastValue;\r\n    }\r\n\r\n    /**\r\n     * @returns class name of the object.\r\n     */\r\n    public override getClassName(): string {\r\n        return \"FlowGraphDataConnection\";\r\n    }\r\n\r\n    /**\r\n     * Serializes this object.\r\n     * @param serializationObject the object to serialize to\r\n     */\r\n    public override serialize(serializationObject: any = {}) {\r\n        super.serialize(serializationObject);\r\n        serializationObject.richType = {};\r\n        this.richType.serialize(serializationObject.richType);\r\n        serializationObject.optional = this._optional;\r\n        defaultValueSerializationFunction(\"defaultValue\", this._defaultValue, serializationObject);\r\n    }\r\n}\r\n\r\nRegisterClass(\"FlowGraphDataConnection\", FlowGraphDataConnection);\r\n", "import { RandomGUID } from \"../Misc/guid\";\r\nimport { FlowGraphConnectionType } from \"./flowGraphConnection\";\r\nimport type { FlowGraphContext } from \"./flowGraphContext\";\r\nimport { FlowGraphDataConnection } from \"./flowGraphDataConnection\";\r\nimport type { RichType } from \"./flowGraphRichTypes\";\r\nimport type { ISerializedFlowGraphBlock, IObjectAccessor } from \"./typeDefinitions\";\r\nimport { defaultValueSerializationFunction } from \"./serialization\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { IPathToObjectConverter } from \"../ObjectModel/objectModelInterfaces\";\r\nimport type { IAssetContainer } from \"core/IAssetContainer\";\r\nimport type { FlowGraphAction } from \"./flowGraphLogger\";\r\n\r\n/**\r\n * Options for parsing a block.\r\n */\r\nexport interface IFlowGraphBlockParseOptions {\r\n    /**\r\n     * A function that parses a value from a serialization object.\r\n     * @param key the key of the property\r\n     * @param serializationObject the serialization object where the property is located\r\n     * @param scene the scene that the block is being parsed in\r\n     * @returns the parsed value\r\n     */\r\n    valueParseFunction?: (key: string, serializationObject: any, assetsContainer: IAssetContainer, scene: Scene) => any;\r\n    /**\r\n     * The assets container to use when loading assets.\r\n     */\r\n    assetsContainer?: IAssetContainer;\r\n    /**\r\n     * The scene that the block is being parsed in.\r\n     */\r\n    scene: Scene;\r\n    /**\r\n     * The path converter to use to convert the path to an object accessor.\r\n     */\r\n    pathConverter?: IPathToObjectConverter<IObjectAccessor>;\r\n}\r\n\r\n/**\r\n * Configuration for a block.\r\n */\r\nexport interface IFlowGraphBlockConfiguration {\r\n    /**\r\n     * The name of the block.\r\n     */\r\n    name?: string;\r\n    [extraPropertyKey: string]: any;\r\n}\r\n\r\n/**\r\n * A block in a flow graph. The most basic form\r\n * of a block has inputs and outputs that contain\r\n * data.\r\n */\r\nexport class FlowGraphBlock {\r\n    /**\r\n     * A randomly generated GUID for each block.\r\n     */\r\n    public uniqueId = RandomGUID();\r\n    /**\r\n     * The name of the block.\r\n     */\r\n    public name: string;\r\n    /**\r\n     * The data inputs of the block.\r\n     */\r\n    public dataInputs: FlowGraphDataConnection<any>[];\r\n    /**\r\n     * The data outputs of the block.\r\n     */\r\n    public dataOutputs: FlowGraphDataConnection<any>[];\r\n\r\n    /**\r\n     * Metadata that can be used by the block.\r\n     */\r\n    public metadata: any;\r\n\r\n    /** Constructor is protected so only subclasses can be instantiated\r\n     * @param config optional configuration for this block\r\n     * @internal - do not use directly. Extend this class instead.\r\n     */\r\n    constructor(\r\n        /**\r\n         * the configuration of the block\r\n         */\r\n        public config?: IFlowGraphBlockConfiguration\r\n    ) {\r\n        this.name = this.config?.name ?? this.getClassName();\r\n        this.dataInputs = [];\r\n        this.dataOutputs = [];\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * This function is called when the block needs to update its output flows.\r\n     * @param _context the context in which it is running\r\n     */\r\n    public _updateOutputs(_context: FlowGraphContext): void {\r\n        // empty by default, overridden in data blocks\r\n    }\r\n\r\n    /**\r\n     * Registers a data input on the block.\r\n     * @param name the name of the input\r\n     * @param richType the type of the input\r\n     * @param defaultValue optional default value of the input. If not set, the rich type's default value will be used.\r\n     * @returns the created connection\r\n     */\r\n    public registerDataInput<T>(name: string, richType: RichType<T>, defaultValue?: T): FlowGraphDataConnection<T> {\r\n        const input = new FlowGraphDataConnection(name, FlowGraphConnectionType.Input, this, richType, defaultValue);\r\n        this.dataInputs.push(input);\r\n        return input;\r\n    }\r\n\r\n    /**\r\n     * Registers a data output on the block.\r\n     * @param name the name of the input\r\n     * @param richType the type of the input\r\n     * @param defaultValue optional default value of the input. If not set, the rich type's default value will be used.\r\n     * @returns the created connection\r\n     */\r\n    public registerDataOutput<T>(name: string, richType: RichType<T>, defaultValue?: T): FlowGraphDataConnection<T> {\r\n        const output = new FlowGraphDataConnection(name, FlowGraphConnectionType.Output, this, richType, defaultValue);\r\n        this.dataOutputs.push(output);\r\n        return output;\r\n    }\r\n\r\n    /**\r\n     * Given the name of a data input, returns the connection if it exists\r\n     * @param name the name of the input\r\n     * @returns the connection if it exists, undefined otherwise\r\n     */\r\n    public getDataInput(name: string): FlowGraphDataConnection<any> | undefined {\r\n        return this.dataInputs.find((i) => i.name === name);\r\n    }\r\n\r\n    /**\r\n     * Given the name of a data output, returns the connection if it exists\r\n     * @param name the name of the output\r\n     * @returns the connection if it exists, undefined otherwise\r\n     */\r\n    public getDataOutput(name: string): FlowGraphDataConnection<any> | undefined {\r\n        return this.dataOutputs.find((i) => i.name === name);\r\n    }\r\n\r\n    /**\r\n     * Serializes this block\r\n     * @param serializationObject the object to serialize to\r\n     * @param _valueSerializeFunction a function that serializes a specific value\r\n     */\r\n    public serialize(serializationObject: any = {}, _valueSerializeFunction: (key: string, value: any, serializationObject: any) => any = defaultValueSerializationFunction) {\r\n        serializationObject.uniqueId = this.uniqueId;\r\n        serializationObject.config = {};\r\n        if (this.config) {\r\n            const config = this.config;\r\n            Object.keys(this.config).forEach((key) => {\r\n                _valueSerializeFunction(key, config[key], serializationObject.config);\r\n            });\r\n        }\r\n        serializationObject.dataInputs = [];\r\n        serializationObject.dataOutputs = [];\r\n        serializationObject.className = this.getClassName();\r\n        for (const input of this.dataInputs) {\r\n            const serializedInput: any = {};\r\n            input.serialize(serializedInput);\r\n            serializationObject.dataInputs.push(serializedInput);\r\n        }\r\n        for (const output of this.dataOutputs) {\r\n            const serializedOutput: any = {};\r\n            output.serialize(serializedOutput);\r\n            serializationObject.dataOutputs.push(serializedOutput);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Deserializes this block\r\n     * @param _serializationObject the object to deserialize from\r\n     */\r\n    public deserialize(_serializationObject: ISerializedFlowGraphBlock) {\r\n        // no-op by default\r\n    }\r\n\r\n    protected _log(context: FlowGraphContext, action: FlowGraphAction, payload?: any) {\r\n        context.logger?.addLogItem({\r\n            action,\r\n            payload,\r\n            className: this.getClassName(),\r\n            uniqueId: this.uniqueId,\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of this block\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"FlowGraphBlock\";\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": ["FlowGraphTypes", "FlowGraphConnectionType", "value"]
}
