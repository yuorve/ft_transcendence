{
  "version": 3,
  "sources": ["../../../dev/core/src/Misc/basisWorker.ts", "../../../dev/core/src/Misc/basis.ts", "../../../dev/core/src/Materials/Textures/Loaders/basisTextureLoader.ts"],
  "sourcesContent": ["/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"core/types\";\r\nimport { Tools } from \"./tools\";\r\nimport type { BasisFileInfo, BasisTranscodeConfiguration } from \"./basis\";\r\n\r\n// WorkerGlobalScope\r\ndeclare function importScripts(...urls: string[]): void;\r\ndeclare function postMessage(message: any, transfer?: any[]): void;\r\ndeclare let BASIS: any;\r\n/**\r\n * The worker function that gets converted to a blob url to pass into a worker.\r\n * To be used if a developer wants to create their own worker instance and inject it instead of using the default worker.\r\n */\r\nexport function workerFunction(): void {\r\n    const _BASIS_FORMAT = {\r\n        cTFETC1: 0,\r\n        cTFETC2: 1,\r\n        cTFBC1: 2,\r\n        cTFBC3: 3,\r\n        cTFBC4: 4,\r\n        cTFBC5: 5,\r\n        cTFBC7: 6,\r\n        cTFPVRTC1_4_RGB: 8,\r\n        cTFPVRTC1_4_RGBA: 9,\r\n        cTFASTC_4x4: 10,\r\n        cTFATC_RGB: 11,\r\n        cTFATC_RGBA_INTERPOLATED_ALPHA: 12,\r\n        cTFRGBA32: 13,\r\n        cTFRGB565: 14,\r\n        cTFBGR565: 15,\r\n        cTFRGBA4444: 16,\r\n        cTFFXT1_RGB: 17,\r\n        cTFPVRTC2_4_RGB: 18,\r\n        cTFPVRTC2_4_RGBA: 19,\r\n        cTFETC2_EAC_R11: 20,\r\n        cTFETC2_EAC_RG11: 21,\r\n    };\r\n    let transcoderModulePromise: Nullable<PromiseLike<any>> = null;\r\n    onmessage = (event) => {\r\n        if (event.data.action === \"init\") {\r\n            // Load the transcoder if it hasn't been yet\r\n            if (event.data.url) {\r\n                // make sure we loaded the script correctly\r\n                try {\r\n                    importScripts(event.data.url);\r\n                } catch (e) {\r\n                    postMessage({ action: \"error\", error: e });\r\n                }\r\n            }\r\n            if (!transcoderModulePromise) {\r\n                transcoderModulePromise = BASIS({\r\n                    // Override wasm binary\r\n                    wasmBinary: event.data.wasmBinary,\r\n                });\r\n            }\r\n            if (transcoderModulePromise !== null) {\r\n                transcoderModulePromise.then((m) => {\r\n                    BASIS = m;\r\n                    m.initializeBasis();\r\n                    postMessage({ action: \"init\" });\r\n                });\r\n            }\r\n        } else if (event.data.action === \"transcode\") {\r\n            // Transcode the basis image and return the resulting pixels\r\n            const config: BasisTranscodeConfiguration = event.data.config;\r\n            const imgData = event.data.imageData;\r\n            const loadedFile = new BASIS.BasisFile(imgData);\r\n            const fileInfo = GetFileInfo(loadedFile);\r\n            let format = event.data.ignoreSupportedFormats ? null : GetSupportedTranscodeFormat(event.data.config, fileInfo);\r\n\r\n            let needsConversion = false;\r\n            if (format === null) {\r\n                needsConversion = true;\r\n                format = fileInfo.hasAlpha ? _BASIS_FORMAT.cTFBC3 : _BASIS_FORMAT.cTFBC1;\r\n            }\r\n\r\n            // Begin transcode\r\n            let success = true;\r\n            if (!loadedFile.startTranscoding()) {\r\n                success = false;\r\n            }\r\n\r\n            const buffers: Array<any> = [];\r\n            for (let imageIndex = 0; imageIndex < fileInfo.images.length; imageIndex++) {\r\n                if (!success) {\r\n                    break;\r\n                }\r\n                const image = fileInfo.images[imageIndex];\r\n                if (config.loadSingleImage === undefined || config.loadSingleImage === imageIndex) {\r\n                    let mipCount = image.levels.length;\r\n                    if (config.loadMipmapLevels === false) {\r\n                        mipCount = 1;\r\n                    }\r\n                    for (let levelIndex = 0; levelIndex < mipCount; levelIndex++) {\r\n                        const levelInfo = image.levels[levelIndex];\r\n\r\n                        const pixels = TranscodeLevel(loadedFile, imageIndex, levelIndex, format!, needsConversion);\r\n                        if (!pixels) {\r\n                            success = false;\r\n                            break;\r\n                        }\r\n                        levelInfo.transcodedPixels = pixels;\r\n                        buffers.push(levelInfo.transcodedPixels.buffer);\r\n                    }\r\n                }\r\n            }\r\n            // Close file\r\n            loadedFile.close();\r\n            loadedFile.delete();\r\n\r\n            if (needsConversion) {\r\n                format = -1;\r\n            }\r\n            if (!success) {\r\n                postMessage({ action: \"transcode\", success: success, id: event.data.id });\r\n            } else {\r\n                postMessage({ action: \"transcode\", success: success, id: event.data.id, fileInfo: fileInfo, format: format }, buffers);\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Detects the supported transcode format for the file\r\n     * @param config transcode config\r\n     * @param fileInfo info about the file\r\n     * @returns the chosed format or null if none are supported\r\n     */\r\n    function GetSupportedTranscodeFormat(config: BasisTranscodeConfiguration, fileInfo: BasisFileInfo): Nullable<number> {\r\n        let format = null;\r\n        if (config.supportedCompressionFormats) {\r\n            if (config.supportedCompressionFormats.astc) {\r\n                format = _BASIS_FORMAT.cTFASTC_4x4;\r\n            } else if (config.supportedCompressionFormats.bc7) {\r\n                format = _BASIS_FORMAT.cTFBC7;\r\n            } else if (config.supportedCompressionFormats.s3tc) {\r\n                format = fileInfo.hasAlpha ? _BASIS_FORMAT.cTFBC3 : _BASIS_FORMAT.cTFBC1;\r\n            } else if (config.supportedCompressionFormats.pvrtc) {\r\n                format = fileInfo.hasAlpha ? _BASIS_FORMAT.cTFPVRTC1_4_RGBA : _BASIS_FORMAT.cTFPVRTC1_4_RGB;\r\n            } else if (config.supportedCompressionFormats.etc2) {\r\n                format = _BASIS_FORMAT.cTFETC2;\r\n            } else if (config.supportedCompressionFormats.etc1) {\r\n                format = _BASIS_FORMAT.cTFETC1;\r\n            } else {\r\n                format = _BASIS_FORMAT.cTFRGB565;\r\n            }\r\n        }\r\n        return format;\r\n    }\r\n\r\n    /**\r\n     * Retrieves information about the basis file eg. dimensions\r\n     * @param basisFile the basis file to get the info from\r\n     * @returns information about the basis file\r\n     */\r\n    function GetFileInfo(basisFile: any): BasisFileInfo {\r\n        const hasAlpha = basisFile.getHasAlpha();\r\n        const imageCount = basisFile.getNumImages();\r\n        const images = [];\r\n        for (let i = 0; i < imageCount; i++) {\r\n            const imageInfo = {\r\n                levels: [] as Array<any>,\r\n            };\r\n            const levelCount = basisFile.getNumLevels(i);\r\n            for (let level = 0; level < levelCount; level++) {\r\n                const levelInfo = {\r\n                    width: basisFile.getImageWidth(i, level),\r\n                    height: basisFile.getImageHeight(i, level),\r\n                };\r\n                imageInfo.levels.push(levelInfo);\r\n            }\r\n            images.push(imageInfo);\r\n        }\r\n        const info = { hasAlpha, images };\r\n        return info;\r\n    }\r\n\r\n    function TranscodeLevel(loadedFile: any, imageIndex: number, levelIndex: number, format: number, convertToRgb565: boolean): Nullable<Uint8Array | Uint16Array> {\r\n        const dstSize = loadedFile.getImageTranscodedSizeInBytes(imageIndex, levelIndex, format);\r\n        let dst: Uint8Array | Uint16Array = new Uint8Array(dstSize);\r\n        if (!loadedFile.transcodeImage(dst, imageIndex, levelIndex, format, 1, 0)) {\r\n            return null;\r\n        }\r\n        // If no supported format is found, load as dxt and convert to rgb565\r\n        if (convertToRgb565) {\r\n            const alignedWidth = (loadedFile.getImageWidth(imageIndex, levelIndex) + 3) & ~3;\r\n            const alignedHeight = (loadedFile.getImageHeight(imageIndex, levelIndex) + 3) & ~3;\r\n            dst = ConvertDxtToRgb565(dst, 0, alignedWidth, alignedHeight);\r\n        }\r\n        return dst;\r\n    }\r\n\r\n    /**\r\n     * From https://github.com/BinomialLLC/basis_universal/blob/master/webgl/texture/dxt-to-rgb565.js\r\n     * An unoptimized version of dxtToRgb565.  Also, the floating\r\n     * point math used to compute the colors actually results in\r\n     * slightly different colors compared to hardware DXT decoders.\r\n     * @param src dxt src pixels\r\n     * @param srcByteOffset offset for the start of src\r\n     * @param  width aligned width of the image\r\n     * @param  height aligned height of the image\r\n     * @returns the converted pixels\r\n     */\r\n    function ConvertDxtToRgb565(src: Uint8Array, srcByteOffset: number, width: number, height: number): Uint16Array {\r\n        const c = new Uint16Array(4);\r\n        const dst = new Uint16Array(width * height);\r\n\r\n        const blockWidth = width / 4;\r\n        const blockHeight = height / 4;\r\n        for (let blockY = 0; blockY < blockHeight; blockY++) {\r\n            for (let blockX = 0; blockX < blockWidth; blockX++) {\r\n                const i = srcByteOffset + 8 * (blockY * blockWidth + blockX);\r\n                c[0] = src[i] | (src[i + 1] << 8);\r\n                c[1] = src[i + 2] | (src[i + 3] << 8);\r\n                c[2] =\r\n                    ((2 * (c[0] & 0x1f) + 1 * (c[1] & 0x1f)) / 3) |\r\n                    (((2 * (c[0] & 0x7e0) + 1 * (c[1] & 0x7e0)) / 3) & 0x7e0) |\r\n                    (((2 * (c[0] & 0xf800) + 1 * (c[1] & 0xf800)) / 3) & 0xf800);\r\n                c[3] =\r\n                    ((2 * (c[1] & 0x1f) + 1 * (c[0] & 0x1f)) / 3) |\r\n                    (((2 * (c[1] & 0x7e0) + 1 * (c[0] & 0x7e0)) / 3) & 0x7e0) |\r\n                    (((2 * (c[1] & 0xf800) + 1 * (c[0] & 0xf800)) / 3) & 0xf800);\r\n                for (let row = 0; row < 4; row++) {\r\n                    const m = src[i + 4 + row];\r\n                    let dstI = (blockY * 4 + row) * width + blockX * 4;\r\n                    dst[dstI++] = c[m & 0x3];\r\n                    dst[dstI++] = c[(m >> 2) & 0x3];\r\n                    dst[dstI++] = c[(m >> 4) & 0x3];\r\n                    dst[dstI++] = c[(m >> 6) & 0x3];\r\n                }\r\n            }\r\n        }\r\n        return dst;\r\n    }\r\n}\r\n\r\n/**\r\n * Initialize a web worker with the basis transcoder\r\n * @param worker the worker to initialize\r\n * @param wasmBinary the wasm binary to load into the worker\r\n * @param moduleUrl the url to the basis transcoder module\r\n * @returns a promise that resolves when the worker is initialized\r\n */\r\nexport function initializeWebWorker(worker: Worker, wasmBinary: ArrayBuffer, moduleUrl?: string) {\r\n    return new Promise<Worker>((res, reject) => {\r\n        const initHandler = (msg: any) => {\r\n            if (msg.data.action === \"init\") {\r\n                worker!.removeEventListener(\"message\", initHandler);\r\n                res(worker!);\r\n            } else if (msg.data.action === \"error\") {\r\n                reject(msg.data.error || \"error initializing worker\");\r\n            }\r\n        };\r\n        worker.addEventListener(\"message\", initHandler);\r\n        // we can use transferable objects here because the worker will own the ArrayBuffer\r\n        worker.postMessage({ action: \"init\", url: moduleUrl ? Tools.GetBabylonScriptURL(moduleUrl) : undefined, wasmBinary }, [wasmBinary]);\r\n    });\r\n}\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"../types\";\r\nimport { Tools } from \"./tools\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { InternalTexture, InternalTextureSource } from \"../Materials/Textures/internalTexture\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { initializeWebWorker, workerFunction } from \"./basisWorker\";\r\nimport type { AbstractEngine } from \"core/Engines/abstractEngine\";\r\nimport type { Engine } from \"core/Engines/engine\";\r\n\r\n/**\r\n * Info about the .basis files\r\n */\r\nexport class BasisFileInfo {\r\n    /**\r\n     * If the file has alpha\r\n     */\r\n    public hasAlpha: boolean;\r\n    /**\r\n     * Info about each image of the basis file\r\n     */\r\n    public images: Array<{ levels: Array<{ width: number; height: number; transcodedPixels: ArrayBufferView }> }>;\r\n}\r\n\r\n/**\r\n * Result of transcoding a basis file\r\n */\r\nclass TranscodeResult {\r\n    /**\r\n     * Info about the .basis file\r\n     */\r\n    public fileInfo: BasisFileInfo;\r\n    /**\r\n     * Format to use when loading the file\r\n     */\r\n    public format: number;\r\n}\r\n\r\n/**\r\n * Configuration options for the Basis transcoder\r\n */\r\nexport class BasisTranscodeConfiguration {\r\n    /**\r\n     * Supported compression formats used to determine the supported output format of the transcoder\r\n     */\r\n    supportedCompressionFormats?: {\r\n        /**\r\n         * etc1 compression format\r\n         */\r\n        etc1?: boolean;\r\n        /**\r\n         * s3tc compression format\r\n         */\r\n        s3tc?: boolean;\r\n        /**\r\n         * pvrtc compression format\r\n         */\r\n        pvrtc?: boolean;\r\n        /**\r\n         * etc2 compression format\r\n         */\r\n        etc2?: boolean;\r\n        /**\r\n         * astc compression format\r\n         */\r\n        astc?: boolean;\r\n        /**\r\n         * bc7 compression format\r\n         */\r\n        bc7?: boolean;\r\n    };\r\n    /**\r\n     * If mipmap levels should be loaded for transcoded images (Default: true)\r\n     */\r\n    loadMipmapLevels?: boolean;\r\n    /**\r\n     * Index of a single image to load (Default: all images)\r\n     */\r\n    loadSingleImage?: number;\r\n}\r\n\r\n/**\r\n * @internal\r\n * Enum of basis transcoder formats\r\n */\r\nenum BASIS_FORMATS {\r\n    cTFETC1 = 0,\r\n    cTFETC2 = 1,\r\n    cTFBC1 = 2,\r\n    cTFBC3 = 3,\r\n    cTFBC4 = 4,\r\n    cTFBC5 = 5,\r\n    cTFBC7 = 6,\r\n    cTFPVRTC1_4_RGB = 8,\r\n    cTFPVRTC1_4_RGBA = 9,\r\n    cTFASTC_4x4 = 10,\r\n    cTFATC_RGB = 11,\r\n    cTFATC_RGBA_INTERPOLATED_ALPHA = 12,\r\n    cTFRGBA32 = 13,\r\n    cTFRGB565 = 14,\r\n    cTFBGR565 = 15,\r\n    cTFRGBA4444 = 16,\r\n    cTFFXT1_RGB = 17,\r\n    cTFPVRTC2_4_RGB = 18,\r\n    cTFPVRTC2_4_RGBA = 19,\r\n    cTFETC2_EAC_R11 = 20,\r\n    cTFETC2_EAC_RG11 = 21,\r\n}\r\n\r\n/**\r\n * Used to load .Basis files\r\n * See https://github.com/BinomialLLC/basis_universal/tree/master/webgl\r\n */\r\nexport const BasisToolsOptions = {\r\n    /**\r\n     * URL to use when loading the basis transcoder\r\n     */\r\n    JSModuleURL: `${Tools._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,\r\n    /**\r\n     * URL to use when loading the wasm module for the transcoder\r\n     */\r\n    WasmModuleURL: `${Tools._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`,\r\n};\r\n\r\n/**\r\n * Get the internal format to be passed to texImage2D corresponding to the .basis format value\r\n * @param basisFormat format chosen from GetSupportedTranscodeFormat\r\n * @param engine\r\n * @returns internal format corresponding to the Basis format\r\n */\r\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\r\nexport const GetInternalFormatFromBasisFormat = (basisFormat: number, engine: AbstractEngine) => {\r\n    let format;\r\n    switch (basisFormat) {\r\n        case BASIS_FORMATS.cTFETC1:\r\n            format = Constants.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL;\r\n            break;\r\n        case BASIS_FORMATS.cTFBC1:\r\n            format = Constants.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1;\r\n            break;\r\n        case BASIS_FORMATS.cTFBC4:\r\n            format = Constants.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5;\r\n            break;\r\n        case BASIS_FORMATS.cTFASTC_4x4:\r\n            format = Constants.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4;\r\n            break;\r\n        case BASIS_FORMATS.cTFETC2:\r\n            format = Constants.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC;\r\n            break;\r\n        case BASIS_FORMATS.cTFBC7:\r\n            format = Constants.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM;\r\n            break;\r\n    }\r\n\r\n    if (format === undefined) {\r\n        // eslint-disable-next-line no-throw-literal\r\n        throw \"The chosen Basis transcoder format is not currently supported\";\r\n    }\r\n\r\n    return format;\r\n};\r\n\r\nlet _WorkerPromise: Nullable<Promise<Worker>> = null;\r\nlet _Worker: Nullable<Worker> = null;\r\nlet _actionId = 0;\r\nconst _IgnoreSupportedFormats = false;\r\nconst _CreateWorkerAsync = () => {\r\n    if (!_WorkerPromise) {\r\n        _WorkerPromise = new Promise((res, reject) => {\r\n            if (_Worker) {\r\n                res(_Worker);\r\n            } else {\r\n                Tools.LoadFileAsync(Tools.GetBabylonScriptURL(BasisToolsOptions.WasmModuleURL))\r\n                    .then((wasmBinary) => {\r\n                        if (typeof URL !== \"function\") {\r\n                            return reject(\"Basis transcoder requires an environment with a URL constructor\");\r\n                        }\r\n                        const workerBlobUrl = URL.createObjectURL(new Blob([`(${workerFunction})()`], { type: \"application/javascript\" }));\r\n                        _Worker = new Worker(workerBlobUrl);\r\n                        initializeWebWorker(_Worker, wasmBinary, BasisToolsOptions.JSModuleURL).then(res, reject);\r\n                    })\r\n                    .catch(reject);\r\n            }\r\n        });\r\n    }\r\n    return _WorkerPromise;\r\n};\r\n\r\n/**\r\n * Set the worker to use for transcoding\r\n * @param worker The worker that will be used for transcoding\r\n */\r\nexport const SetBasisTranscoderWorker = (worker: Worker) => {\r\n    _Worker = worker;\r\n};\r\n\r\n/**\r\n * Transcodes a loaded image file to compressed pixel data\r\n * @param data image data to transcode\r\n * @param config configuration options for the transcoding\r\n * @returns a promise resulting in the transcoded image\r\n */\r\nexport const TranscodeAsync = (data: ArrayBuffer | ArrayBufferView, config: BasisTranscodeConfiguration): Promise<TranscodeResult> => {\r\n    const dataView = data instanceof ArrayBuffer ? new Uint8Array(data) : data;\r\n\r\n    return new Promise((res, rej) => {\r\n        _CreateWorkerAsync().then(\r\n            () => {\r\n                const actionId = _actionId++;\r\n                const messageHandler = (msg: any) => {\r\n                    if (msg.data.action === \"transcode\" && msg.data.id === actionId) {\r\n                        _Worker!.removeEventListener(\"message\", messageHandler);\r\n                        if (!msg.data.success) {\r\n                            rej(\"Transcode is not supported on this device\");\r\n                        } else {\r\n                            res(msg.data);\r\n                        }\r\n                    }\r\n                };\r\n                _Worker!.addEventListener(\"message\", messageHandler);\r\n\r\n                const dataViewCopy = new Uint8Array(dataView.byteLength);\r\n                dataViewCopy.set(new Uint8Array(dataView.buffer, dataView.byteOffset, dataView.byteLength));\r\n                _Worker!.postMessage({ action: \"transcode\", id: actionId, imageData: dataViewCopy, config: config, ignoreSupportedFormats: _IgnoreSupportedFormats }, [\r\n                    dataViewCopy.buffer,\r\n                ]);\r\n            },\r\n            (error) => {\r\n                rej(error);\r\n            }\r\n        );\r\n    });\r\n};\r\n\r\n/**\r\n * Binds a texture according to its underlying target.\r\n * @param texture texture to bind\r\n * @param engine the engine to bind the texture in\r\n */\r\nconst BindTexture = (texture: InternalTexture, engine: Engine): void => {\r\n    let target: GLenum = engine._gl?.TEXTURE_2D;\r\n    if (texture.isCube) {\r\n        target = engine._gl?.TEXTURE_CUBE_MAP;\r\n    }\r\n\r\n    engine._bindTextureDirectly(target, texture, true);\r\n};\r\n\r\n/**\r\n * Loads a texture from the transcode result\r\n * @param texture texture load to\r\n * @param transcodeResult the result of transcoding the basis file to load from\r\n */\r\nexport const LoadTextureFromTranscodeResult = (texture: InternalTexture, transcodeResult: TranscodeResult) => {\r\n    const engine = texture.getEngine() as Engine;\r\n    for (let i = 0; i < transcodeResult.fileInfo.images.length; i++) {\r\n        const rootImage = transcodeResult.fileInfo.images[i].levels[0];\r\n        texture._invertVScale = texture.invertY;\r\n        if (transcodeResult.format === -1 || transcodeResult.format === BASIS_FORMATS.cTFRGB565) {\r\n            // No compatable compressed format found, fallback to RGB\r\n            texture.type = Constants.TEXTURETYPE_UNSIGNED_SHORT_5_6_5;\r\n            texture.format = Constants.TEXTUREFORMAT_RGB;\r\n\r\n            if (engine._features.basisNeedsPOT && (Math.log2(rootImage.width) % 1 !== 0 || Math.log2(rootImage.height) % 1 !== 0)) {\r\n                // Create non power of two texture\r\n                const source = new InternalTexture(engine, InternalTextureSource.Temp);\r\n\r\n                texture._invertVScale = texture.invertY;\r\n                source.type = Constants.TEXTURETYPE_UNSIGNED_SHORT_5_6_5;\r\n                source.format = Constants.TEXTUREFORMAT_RGB;\r\n                // Fallback requires aligned width/height\r\n                source.width = (rootImage.width + 3) & ~3;\r\n                source.height = (rootImage.height + 3) & ~3;\r\n                BindTexture(source, engine);\r\n                engine._uploadDataToTextureDirectly(source, new Uint16Array(rootImage.transcodedPixels.buffer), i, 0, Constants.TEXTUREFORMAT_RGB, true);\r\n\r\n                // Resize to power of two\r\n                engine._rescaleTexture(source, texture, engine.scenes[0], engine._getInternalFormat(Constants.TEXTUREFORMAT_RGB), () => {\r\n                    engine._releaseTexture(source);\r\n                    BindTexture(texture, engine);\r\n                });\r\n            } else {\r\n                // Fallback is already inverted\r\n                texture._invertVScale = !texture.invertY;\r\n\r\n                // Upload directly\r\n                texture.width = (rootImage.width + 3) & ~3;\r\n                texture.height = (rootImage.height + 3) & ~3;\r\n                texture.samplingMode = Constants.TEXTURE_LINEAR_LINEAR;\r\n                BindTexture(texture, engine);\r\n                engine._uploadDataToTextureDirectly(texture, new Uint16Array(rootImage.transcodedPixels.buffer), i, 0, Constants.TEXTUREFORMAT_RGB, true);\r\n            }\r\n        } else {\r\n            texture.width = rootImage.width;\r\n            texture.height = rootImage.height;\r\n            texture.generateMipMaps = transcodeResult.fileInfo.images[i].levels.length > 1;\r\n\r\n            const format = BasisTools.GetInternalFormatFromBasisFormat(transcodeResult.format!, engine);\r\n            texture.format = format;\r\n\r\n            BindTexture(texture, engine);\r\n\r\n            // Upload all mip levels in the file\r\n            transcodeResult.fileInfo.images[i].levels.forEach((level: any, index: number) => {\r\n                engine._uploadCompressedDataToTextureDirectly(texture, format, level.width, level.height, level.transcodedPixels, i, index);\r\n            });\r\n\r\n            if (engine._features.basisNeedsPOT && (Math.log2(texture.width) % 1 !== 0 || Math.log2(texture.height) % 1 !== 0)) {\r\n                Tools.Warn(\r\n                    \"Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1.\"\r\n                );\r\n                texture._cachedWrapU = Texture.CLAMP_ADDRESSMODE;\r\n                texture._cachedWrapV = Texture.CLAMP_ADDRESSMODE;\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Used to load .Basis files\r\n * See https://github.com/BinomialLLC/basis_universal/tree/master/webgl\r\n */\r\nexport const BasisTools = {\r\n    /**\r\n     * URL to use when loading the basis transcoder\r\n     */\r\n    JSModuleURL: BasisToolsOptions.JSModuleURL,\r\n    /**\r\n     * URL to use when loading the wasm module for the transcoder\r\n     */\r\n    WasmModuleURL: BasisToolsOptions.WasmModuleURL,\r\n\r\n    /**\r\n     * Get the internal format to be passed to texImage2D corresponding to the .basis format value\r\n     * @param basisFormat format chosen from GetSupportedTranscodeFormat\r\n     * @returns internal format corresponding to the Basis format\r\n     */\r\n    GetInternalFormatFromBasisFormat,\r\n\r\n    /**\r\n     * Transcodes a loaded image file to compressed pixel data\r\n     * @param data image data to transcode\r\n     * @param config configuration options for the transcoding\r\n     * @returns a promise resulting in the transcoded image\r\n     */\r\n    TranscodeAsync,\r\n\r\n    /**\r\n     * Loads a texture from the transcode result\r\n     * @param texture texture load to\r\n     * @param transcodeResult the result of transcoding the basis file to load from\r\n     */\r\n    LoadTextureFromTranscodeResult,\r\n};\r\n\r\nObject.defineProperty(BasisTools, \"JSModuleURL\", {\r\n    get: function (this: null) {\r\n        return BasisToolsOptions.JSModuleURL;\r\n    },\r\n    set: function (this: null, value: string) {\r\n        BasisToolsOptions.JSModuleURL = value;\r\n    },\r\n});\r\n\r\nObject.defineProperty(BasisTools, \"WasmModuleURL\", {\r\n    get: function (this: null) {\r\n        return BasisToolsOptions.WasmModuleURL;\r\n    },\r\n    set: function (this: null, value: string) {\r\n        BasisToolsOptions.WasmModuleURL = value;\r\n    },\r\n});\r\n", "import type { Nullable } from \"../../../types\";\r\nimport type { InternalTexture } from \"../../../Materials/Textures/internalTexture\";\r\nimport type { IInternalTextureLoader } from \"./internalTextureLoader\";\r\nimport { LoadTextureFromTranscodeResult, TranscodeAsync } from \"../../../Misc/basis\";\r\nimport { Tools } from \"../../../Misc/tools\";\r\n\r\n/**\r\n * Loader for .basis file format\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class _BasisTextureLoader implements IInternalTextureLoader {\r\n    /**\r\n     * Defines whether the loader supports cascade loading the different faces.\r\n     */\r\n    public readonly supportCascades = false;\r\n\r\n    /**\r\n     * Uploads the cube texture data to the WebGL texture. It has already been bound.\r\n     * @param data contains the texture data\r\n     * @param texture defines the BabylonJS internal texture\r\n     * @param createPolynomials will be true if polynomials have been requested\r\n     * @param onLoad defines the callback to trigger once the texture is ready\r\n     * @param onError defines the callback to trigger in case of error\r\n     */\r\n    public loadCubeData(\r\n        data: ArrayBufferView | ArrayBufferView[],\r\n        texture: InternalTexture,\r\n        createPolynomials: boolean,\r\n        onLoad: Nullable<(data?: any) => void>,\r\n        onError: Nullable<(message?: string, exception?: any) => void>\r\n    ): void {\r\n        if (Array.isArray(data)) {\r\n            return;\r\n        }\r\n        const caps = texture.getEngine().getCaps();\r\n        const transcodeConfig = {\r\n            supportedCompressionFormats: {\r\n                etc1: caps.etc1 ? true : false,\r\n                s3tc: caps.s3tc ? true : false,\r\n                pvrtc: caps.pvrtc ? true : false,\r\n                etc2: caps.etc2 ? true : false,\r\n                astc: caps.astc ? true : false,\r\n                bc7: caps.bptc ? true : false,\r\n            },\r\n        };\r\n        TranscodeAsync(data, transcodeConfig)\r\n            .then((result) => {\r\n                const hasMipmap = result.fileInfo.images[0].levels.length > 1 && texture.generateMipMaps;\r\n                LoadTextureFromTranscodeResult(texture, result);\r\n                texture.getEngine()._setCubeMapTextureParams(texture, hasMipmap);\r\n                texture.isReady = true;\r\n                texture.onLoadedObservable.notifyObservers(texture);\r\n                texture.onLoadedObservable.clear();\r\n                if (onLoad) {\r\n                    onLoad();\r\n                }\r\n            })\r\n            .catch((err) => {\r\n                const errorMessage = \"Failed to transcode Basis file, transcoding may not be supported on this device\";\r\n                Tools.Warn(errorMessage);\r\n                texture.isReady = true;\r\n                if (onError) {\r\n                    onError(err);\r\n                }\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Uploads the 2D texture data to the WebGL texture. It has already been bound once in the callback.\r\n     * @param data contains the texture data\r\n     * @param texture defines the BabylonJS internal texture\r\n     * @param callback defines the method to call once ready to upload\r\n     */\r\n    public loadData(\r\n        data: ArrayBufferView,\r\n        texture: InternalTexture,\r\n        callback: (width: number, height: number, loadMipmap: boolean, isCompressed: boolean, done: () => void, failedLoading?: boolean) => void\r\n    ): void {\r\n        const caps = texture.getEngine().getCaps();\r\n        const transcodeConfig = {\r\n            supportedCompressionFormats: {\r\n                etc1: caps.etc1 ? true : false,\r\n                s3tc: caps.s3tc ? true : false,\r\n                pvrtc: caps.pvrtc ? true : false,\r\n                etc2: caps.etc2 ? true : false,\r\n                astc: caps.astc ? true : false,\r\n                bc7: caps.bptc ? true : false,\r\n            },\r\n        };\r\n        TranscodeAsync(data, transcodeConfig)\r\n            .then((result) => {\r\n                const rootImage = result.fileInfo.images[0].levels[0];\r\n                const hasMipmap = result.fileInfo.images[0].levels.length > 1 && texture.generateMipMaps;\r\n                callback(rootImage.width, rootImage.height, hasMipmap, result.format !== -1, () => {\r\n                    LoadTextureFromTranscodeResult(texture, result);\r\n                });\r\n            })\r\n            .catch((err) => {\r\n                Tools.Warn(\"Failed to transcode Basis file, transcoding may not be supported on this device\");\r\n                Tools.Warn(`Failed to transcode Basis file: ${err}`);\r\n                callback(0, 0, false, false, () => {}, true);\r\n            });\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": ["BASIS_FORMATS"]
}
