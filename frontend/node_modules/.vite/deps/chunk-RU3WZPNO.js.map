{
  "version": 3,
  "sources": ["../../../dev/core/src/Materials/Textures/Loaders/EXR/exrLoader.interfaces.ts", "../../../dev/core/src/Materials/Textures/Loaders/EXR/exrLoader.core.ts", "../../../dev/core/src/Materials/Textures/Loaders/EXR/exrLoader.header.ts", "../../../dev/core/src/Materials/Textures/Loaders/EXR/exrLoader.compression.huf.ts", "../../../dev/core/src/Materials/Textures/Loaders/EXR/exrLoader.compression.rle.ts", "../../../dev/core/src/Materials/Textures/Loaders/EXR/exrLoader.compression.ts", "../../../dev/core/src/Materials/Textures/Loaders/EXR/exrLoader.configuration.ts", "../../../dev/core/src/Materials/Textures/Loaders/EXR/exrLoader.decoder.ts", "../../../dev/core/src/Materials/Textures/Loaders/exrTextureLoader.ts"],
  "sourcesContent": ["/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"core/types\";\r\nimport type { DataCursor } from \"./exrLoader.core\";\r\n\r\nexport const INT32_SIZE = 4;\r\nexport const FLOAT32_SIZE = 4;\r\nexport const INT8_SIZE = 1;\r\nexport const INT16_SIZE = 2;\r\nexport const ULONG_SIZE = 8;\r\nexport const USHORT_RANGE = 1 << 16;\r\nexport const BITMAP_SIZE = USHORT_RANGE >> 3;\r\nexport const HUF_ENCBITS = 16;\r\nexport const HUF_DECBITS = 14;\r\nexport const HUF_ENCSIZE = (1 << HUF_ENCBITS) + 1;\r\nexport const HUF_DECSIZE = 1 << HUF_DECBITS;\r\nexport const HUF_DECMASK = HUF_DECSIZE - 1;\r\nexport const SHORT_ZEROCODE_RUN = 59;\r\nexport const LONG_ZEROCODE_RUN = 63;\r\nexport const SHORTEST_LONG_RUN = 2 + LONG_ZEROCODE_RUN - SHORT_ZEROCODE_RUN;\r\n\r\nexport interface IEXRCHannel {\r\n    name: string;\r\n    pixelType: number;\r\n}\r\n\r\nexport interface IDecodeChannel {\r\n    [name: string]: number;\r\n}\r\n\r\n/**\r\n * Interface used to define the EXR header\r\n */\r\nexport interface IEXRHeader {\r\n    /** Version */\r\n    version: number;\r\n    /** Specifications */\r\n    spec: {\r\n        singleTile: boolean;\r\n        longName: boolean;\r\n        deepFormat: boolean;\r\n        multiPart: boolean;\r\n    };\r\n    /** Data window */\r\n    dataWindow: {\r\n        xMin: number;\r\n        xMax: number;\r\n        yMin: number;\r\n        yMax: number;\r\n    };\r\n    /** Channels */\r\n    channels: IEXRCHannel[];\r\n    /** Extra data */\r\n    [name: string]: any;\r\n}\r\n\r\nexport interface IEXRDecoder {\r\n    size: number;\r\n    viewer: DataView;\r\n    array: Uint8Array;\r\n    byteArray: Nullable<Float32Array | Uint16Array>;\r\n    offset: DataCursor;\r\n    width: number;\r\n    height: number;\r\n    channels: number;\r\n    channelLineOffsets: IDecodeChannel;\r\n    scanOrder: (value: number) => number;\r\n    bytesPerLine: number;\r\n    outLineWidth: number;\r\n    lines: number;\r\n    scanlineBlockSize: number;\r\n    inputSize: Nullable<number>;\r\n    type: number;\r\n    uncompress: Nullable<(decoder: IEXRDecoder) => DataView>;\r\n    getter: (dataView: DataView, offset: DataCursor) => number;\r\n    format: number;\r\n    outputChannels: number;\r\n    decodeChannels: IDecodeChannel;\r\n    blockCount: Nullable<number>;\r\n    linearSpace: boolean;\r\n    textureType: number;\r\n}\r\n", "import { Clamp } from \"core/Maths/math.scalar.functions\";\r\nimport { FLOAT32_SIZE, INT16_SIZE, INT32_SIZE, INT8_SIZE, ULONG_SIZE } from \"./exrLoader.interfaces\";\r\n\r\n/**\r\n * Inspired by https://github.com/sciecode/three.js/blob/dev/examples/jsm/loaders/EXRLoader.js\r\n * Referred to the original Industrial Light & Magic OpenEXR implementation and the TinyEXR / Syoyo Fujita\r\n * implementation.\r\n */\r\n\r\n// /*\r\n// Copyright (c) 2014 - 2017, Syoyo Fujita\r\n// All rights reserved.\r\n\r\n// Redistribution and use in source and binary forms, with or without\r\n// modification, are permitted provided that the following conditions are met:\r\n//     * Redistributions of source code must retain the above copyright\r\n//       notice, this list of conditions and the following disclaimer.\r\n//     * Redistributions in binary form must reproduce the above copyright\r\n//       notice, this list of conditions and the following disclaimer in the\r\n//       documentation and/or other materials provided with the distribution.\r\n//     * Neither the name of the Syoyo Fujita nor the\r\n//       names of its contributors may be used to endorse or promote products\r\n//       derived from this software without specific prior written permission.\r\n\r\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\r\n// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n// DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\r\n// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\r\n// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\r\n// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\r\n// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\r\n// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n// */\r\n\r\n// // TinyEXR contains some OpenEXR code, which is licensed under ------------\r\n\r\n// ///////////////////////////////////////////////////////////////////////////\r\n// //\r\n// // Copyright (c) 2002, Industrial Light & Magic, a division of Lucas\r\n// // Digital Ltd. LLC\r\n// //\r\n// // All rights reserved.\r\n// //\r\n// // Redistribution and use in source and binary forms, with or without\r\n// // modification, are permitted provided that the following conditions are\r\n// // met:\r\n// // *       Redistributions of source code must retain the above copyright\r\n// // notice, this list of conditions and the following disclaimer.\r\n// // *       Redistributions in binary form must reproduce the above\r\n// // copyright notice, this list of conditions and the following disclaimer\r\n// // in the documentation and/or other materials provided with the\r\n// // distribution.\r\n// // *       Neither the name of Industrial Light & Magic nor the names of\r\n// // its contributors may be used to endorse or promote products derived\r\n// // from this software without specific prior written permission.\r\n// //\r\n// // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\r\n// // \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\r\n// // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\r\n// // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\r\n// // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n// // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\r\n// // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\r\n// // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\r\n// // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n// // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\r\n// // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n// //\r\n// ///////////////////////////////////////////////////////////////////////////\r\n\r\n// // End of OpenEXR license -------------------------------------------------\r\n\r\nexport enum CompressionCodes {\r\n    NO_COMPRESSION,\r\n    RLE_COMPRESSION,\r\n    ZIPS_COMPRESSION,\r\n    ZIP_COMPRESSION,\r\n    PIZ_COMPRESSION,\r\n    PXR24_COMPRESSION,\r\n}\r\n\r\nenum LineOrders {\r\n    INCREASING_Y,\r\n    DECREASING_Y,\r\n}\r\n\r\n/**\r\n * Interface used to define the cursor position in the data\r\n */\r\nexport interface DataCursor {\r\n    /** Curosr position */\r\n    value: number;\r\n}\r\n\r\nconst _tables = _GenerateTables();\r\n\r\n// Fast Half Float Conversions, http://www.fox-toolkit.org/ftp/fasthalffloatconversion.pdf\r\nfunction _GenerateTables() {\r\n    // float32 to float16 helpers\r\n\r\n    const buffer = new ArrayBuffer(4);\r\n    const floatView = new Float32Array(buffer);\r\n    const uint32View = new Uint32Array(buffer);\r\n\r\n    const baseTable = new Uint32Array(512);\r\n    const shiftTable = new Uint32Array(512);\r\n\r\n    for (let i = 0; i < 256; ++i) {\r\n        const e = i - 127;\r\n\r\n        // very small number (0, -0)\r\n\r\n        if (e < -27) {\r\n            baseTable[i] = 0x0000;\r\n            baseTable[i | 0x100] = 0x8000;\r\n            shiftTable[i] = 24;\r\n            shiftTable[i | 0x100] = 24;\r\n\r\n            // small number (denorm)\r\n        } else if (e < -14) {\r\n            baseTable[i] = 0x0400 >> (-e - 14);\r\n            baseTable[i | 0x100] = (0x0400 >> (-e - 14)) | 0x8000;\r\n            shiftTable[i] = -e - 1;\r\n            shiftTable[i | 0x100] = -e - 1;\r\n\r\n            // normal number\r\n        } else if (e <= 15) {\r\n            baseTable[i] = (e + 15) << 10;\r\n            baseTable[i | 0x100] = ((e + 15) << 10) | 0x8000;\r\n            shiftTable[i] = 13;\r\n            shiftTable[i | 0x100] = 13;\r\n\r\n            // large number (Infinity, -Infinity)\r\n        } else if (e < 128) {\r\n            baseTable[i] = 0x7c00;\r\n            baseTable[i | 0x100] = 0xfc00;\r\n            shiftTable[i] = 24;\r\n            shiftTable[i | 0x100] = 24;\r\n\r\n            // stay (NaN, Infinity, -Infinity)\r\n        } else {\r\n            baseTable[i] = 0x7c00;\r\n            baseTable[i | 0x100] = 0xfc00;\r\n            shiftTable[i] = 13;\r\n            shiftTable[i | 0x100] = 13;\r\n        }\r\n    }\r\n\r\n    // float16 to float32 helpers\r\n    const mantissaTable = new Uint32Array(2048);\r\n    const exponentTable = new Uint32Array(64);\r\n    const offsetTable = new Uint32Array(64);\r\n\r\n    for (let i = 1; i < 1024; ++i) {\r\n        let m = i << 13; // zero pad mantissa bits\r\n        let e = 0; // zero exponent\r\n\r\n        // normalized\r\n        while ((m & 0x00800000) === 0) {\r\n            m <<= 1;\r\n            e -= 0x00800000; // decrement exponent\r\n        }\r\n\r\n        m &= ~0x00800000; // clear leading 1 bit\r\n        e += 0x38800000; // adjust bias\r\n\r\n        mantissaTable[i] = m | e;\r\n    }\r\n\r\n    for (let i = 1024; i < 2048; ++i) {\r\n        mantissaTable[i] = 0x38000000 + ((i - 1024) << 13);\r\n    }\r\n\r\n    for (let i = 1; i < 31; ++i) {\r\n        exponentTable[i] = i << 23;\r\n    }\r\n\r\n    exponentTable[31] = 0x47800000;\r\n    exponentTable[32] = 0x80000000;\r\n\r\n    for (let i = 33; i < 63; ++i) {\r\n        exponentTable[i] = 0x80000000 + ((i - 32) << 23);\r\n    }\r\n\r\n    exponentTable[63] = 0xc7800000;\r\n\r\n    for (let i = 1; i < 64; ++i) {\r\n        if (i !== 32) {\r\n            offsetTable[i] = 1024;\r\n        }\r\n    }\r\n\r\n    return {\r\n        floatView: floatView,\r\n        uint32View: uint32View,\r\n        baseTable: baseTable,\r\n        shiftTable: shiftTable,\r\n        mantissaTable: mantissaTable,\r\n        exponentTable: exponentTable,\r\n        offsetTable: offsetTable,\r\n    };\r\n}\r\n\r\n/**\r\n * Parse a null terminated string from the buffer\r\n * @param buffer buffer to read from\r\n * @param offset current offset in the buffer\r\n * @returns a string\r\n */\r\nexport function ParseNullTerminatedString(buffer: ArrayBuffer, offset: DataCursor) {\r\n    const uintBuffer = new Uint8Array(buffer);\r\n    let endOffset = 0;\r\n\r\n    while (uintBuffer[offset.value + endOffset] != 0) {\r\n        endOffset += 1;\r\n    }\r\n\r\n    const stringValue = new TextDecoder().decode(uintBuffer.slice(offset.value, offset.value + endOffset));\r\n\r\n    offset.value = offset.value + endOffset + 1;\r\n\r\n    return stringValue;\r\n}\r\n\r\n/**\r\n * Parse an int32 from the buffer\r\n * @param dataView dataview on the data\r\n * @param offset current offset in the data view\r\n * @returns an int32\r\n */\r\nexport function ParseInt32(dataView: DataView, offset: DataCursor) {\r\n    const value = dataView.getInt32(offset.value, true);\r\n\r\n    offset.value += INT32_SIZE;\r\n\r\n    return value;\r\n}\r\n\r\n/**\r\n * Parse an uint32 from the buffer\r\n * @param dataView data view to read from\r\n * @param offset offset in the data view\r\n * @returns an uint32\r\n */\r\nexport function ParseUint32(dataView: DataView, offset: DataCursor) {\r\n    const value = dataView.getUint32(offset.value, true);\r\n\r\n    offset.value += INT32_SIZE;\r\n\r\n    return value;\r\n}\r\n\r\n/**\r\n * Parse an uint8 from the buffer\r\n * @param dataView dataview on the data\r\n * @param offset current offset in the data view\r\n * @returns an uint8\r\n */\r\nexport function ParseUint8(dataView: DataView, offset: DataCursor) {\r\n    const value = dataView.getUint8(offset.value);\r\n\r\n    offset.value += INT8_SIZE;\r\n\r\n    return value;\r\n}\r\n\r\n/**\r\n * Parse an uint16 from the buffer\r\n * @param dataView dataview on the data\r\n * @param offset current offset in the data view\r\n * @returns an uint16\r\n */\r\nexport function ParseUint16(dataView: DataView, offset: DataCursor) {\r\n    const value = dataView.getUint16(offset.value, true);\r\n\r\n    offset.value += INT16_SIZE;\r\n\r\n    return value;\r\n}\r\n\r\n/**\r\n * Parse an uint8 from an array buffer\r\n * @param array array buffer\r\n * @param offset current offset in the data view\r\n * @returns an uint16\r\n */\r\nexport function ParseUint8Array(array: Uint8Array, offset: DataCursor) {\r\n    const value = array[offset.value];\r\n\r\n    offset.value += INT8_SIZE;\r\n\r\n    return value;\r\n}\r\n\r\n/**\r\n * Parse an int64 from the buffer\r\n * @param dataView dataview on the data\r\n * @param offset current offset in the data view\r\n * @returns an int64\r\n */\r\nexport function ParseInt64(dataView: DataView, offset: DataCursor) {\r\n    let int;\r\n\r\n    if (\"getBigInt64\" in DataView.prototype) {\r\n        int = Number(dataView.getBigInt64(offset.value, true));\r\n    } else {\r\n        int = dataView.getUint32(offset.value + 4, true) + Number(dataView.getUint32(offset.value, true) << 32);\r\n    }\r\n\r\n    offset.value += ULONG_SIZE;\r\n\r\n    return int;\r\n}\r\n\r\n/**\r\n * Parse a float32 from the buffer\r\n * @param dataView dataview on the data\r\n * @param offset current offset in the data view\r\n * @returns a float32\r\n */\r\nexport function ParseFloat32(dataView: DataView, offset: DataCursor) {\r\n    const value = dataView.getFloat32(offset.value, true);\r\n\r\n    offset.value += FLOAT32_SIZE;\r\n\r\n    return value;\r\n}\r\n\r\n/**\r\n * Parse a float16 from the buffer\r\n * @param dataView dataview on the data\r\n * @param offset current offset in the data view\r\n * @returns a float16\r\n */\r\nexport function ParseFloat16(dataView: DataView, offset: DataCursor) {\r\n    return DecodeFloat16(ParseUint16(dataView, offset));\r\n}\r\n\r\nfunction DecodeFloat16(binary: number) {\r\n    const exponent = (binary & 0x7c00) >> 10;\r\n    const fraction = binary & 0x03ff;\r\n\r\n    return (\r\n        (binary >> 15 ? -1 : 1) *\r\n        (exponent ? (exponent === 0x1f ? (fraction ? NaN : Infinity) : Math.pow(2, exponent - 15) * (1 + fraction / 0x400)) : 6.103515625e-5 * (fraction / 0x400))\r\n    );\r\n}\r\n\r\nfunction ToHalfFloat(value: number) {\r\n    if (Math.abs(value) > 65504) {\r\n        throw new Error(\"Value out of range.Consider using float instead of half-float.\");\r\n    }\r\n\r\n    value = Clamp(value, -65504, 65504);\r\n\r\n    _tables.floatView[0] = value;\r\n    const f = _tables.uint32View[0];\r\n    const e = (f >> 23) & 0x1ff;\r\n    return _tables.baseTable[e] + ((f & 0x007fffff) >> _tables.shiftTable[e]);\r\n}\r\n\r\n/**\r\n * Decode a float32 from the buffer\r\n * @param dataView dataview on the data\r\n * @param offset current offset in the data view\r\n * @returns a float32\r\n */\r\nexport function DecodeFloat32(dataView: DataView, offset: DataCursor) {\r\n    return ToHalfFloat(ParseFloat32(dataView, offset));\r\n}\r\n\r\nfunction ParseFixedLengthString(buffer: ArrayBuffer, offset: DataCursor, size: number) {\r\n    const stringValue = new TextDecoder().decode(new Uint8Array(buffer).slice(offset.value, offset.value + size));\r\n\r\n    offset.value = offset.value + size;\r\n\r\n    return stringValue;\r\n}\r\n\r\nfunction ParseRational(dataView: DataView, offset: DataCursor) {\r\n    const x = ParseInt32(dataView, offset);\r\n    const y = ParseUint32(dataView, offset);\r\n\r\n    return [x, y];\r\n}\r\n\r\nfunction ParseTimecode(dataView: DataView, offset: DataCursor) {\r\n    const x = ParseUint32(dataView, offset);\r\n    const y = ParseUint32(dataView, offset);\r\n\r\n    return [x, y];\r\n}\r\n\r\nfunction ParseV2f(dataView: DataView, offset: DataCursor) {\r\n    const x = ParseFloat32(dataView, offset);\r\n    const y = ParseFloat32(dataView, offset);\r\n\r\n    return [x, y];\r\n}\r\n\r\nfunction ParseV3f(dataView: DataView, offset: DataCursor) {\r\n    const x = ParseFloat32(dataView, offset);\r\n    const y = ParseFloat32(dataView, offset);\r\n    const z = ParseFloat32(dataView, offset);\r\n\r\n    return [x, y, z];\r\n}\r\n\r\nfunction ParseChlist(dataView: DataView, offset: DataCursor, size: number) {\r\n    const startOffset = offset.value;\r\n    const channels = [];\r\n\r\n    while (offset.value < startOffset + size - 1) {\r\n        const name = ParseNullTerminatedString(dataView.buffer, offset);\r\n        const pixelType = ParseInt32(dataView, offset);\r\n        const pLinear = ParseUint8(dataView, offset);\r\n        offset.value += 3; // reserved, three chars\r\n        const xSampling = ParseInt32(dataView, offset);\r\n        const ySampling = ParseInt32(dataView, offset);\r\n\r\n        channels.push({\r\n            name: name,\r\n            pixelType: pixelType,\r\n            pLinear: pLinear,\r\n            xSampling: xSampling,\r\n            ySampling: ySampling,\r\n        });\r\n    }\r\n\r\n    offset.value += 1;\r\n\r\n    return channels;\r\n}\r\n\r\nfunction ParseChromaticities(dataView: DataView, offset: DataCursor) {\r\n    const redX = ParseFloat32(dataView, offset);\r\n    const redY = ParseFloat32(dataView, offset);\r\n    const greenX = ParseFloat32(dataView, offset);\r\n    const greenY = ParseFloat32(dataView, offset);\r\n    const blueX = ParseFloat32(dataView, offset);\r\n    const blueY = ParseFloat32(dataView, offset);\r\n    const whiteX = ParseFloat32(dataView, offset);\r\n    const whiteY = ParseFloat32(dataView, offset);\r\n\r\n    return { redX: redX, redY: redY, greenX: greenX, greenY: greenY, blueX: blueX, blueY: blueY, whiteX: whiteX, whiteY: whiteY };\r\n}\r\n\r\nfunction ParseCompression(dataView: DataView, offset: DataCursor) {\r\n    return ParseUint8(dataView, offset);\r\n}\r\n\r\nfunction ParseBox2i(dataView: DataView, offset: DataCursor) {\r\n    const xMin = ParseInt32(dataView, offset);\r\n    const yMin = ParseInt32(dataView, offset);\r\n    const xMax = ParseInt32(dataView, offset);\r\n    const yMax = ParseInt32(dataView, offset);\r\n\r\n    return { xMin: xMin, yMin: yMin, xMax: xMax, yMax: yMax };\r\n}\r\n\r\nfunction ParseLineOrder(dataView: DataView, offset: DataCursor) {\r\n    const lineOrder = ParseUint8(dataView, offset);\r\n\r\n    return LineOrders[lineOrder];\r\n}\r\n\r\n/**\r\n * Parse a value from the data view\r\n * @param dataView defines the data view to read from\r\n * @param offset defines the current offset in the data view\r\n * @param type defines the type of the value to read\r\n * @param size defines the size of the value to read\r\n * @returns the parsed value\r\n */\r\nexport function ParseValue(dataView: DataView, offset: DataCursor, type: string, size: number) {\r\n    switch (type) {\r\n        case \"string\":\r\n        case \"stringvector\":\r\n        case \"iccProfile\":\r\n            return ParseFixedLengthString(dataView.buffer, offset, size);\r\n        case \"chlist\":\r\n            return ParseChlist(dataView, offset, size);\r\n        case \"chromaticities\":\r\n            return ParseChromaticities(dataView, offset);\r\n        case \"compression\":\r\n            return ParseCompression(dataView, offset);\r\n        case \"box2i\":\r\n            return ParseBox2i(dataView, offset);\r\n        case \"lineOrder\":\r\n            return ParseLineOrder(dataView, offset);\r\n        case \"float\":\r\n            return ParseFloat32(dataView, offset);\r\n        case \"v2f\":\r\n            return ParseV2f(dataView, offset);\r\n        case \"v3f\":\r\n            return ParseV3f(dataView, offset);\r\n        case \"int\":\r\n            return ParseInt32(dataView, offset);\r\n        case \"rational\":\r\n            return ParseRational(dataView, offset);\r\n        case \"timecode\":\r\n            return ParseTimecode(dataView, offset);\r\n        case \"preview\":\r\n            offset.value += size;\r\n            return \"skipped\";\r\n        default:\r\n            offset.value += size;\r\n            return undefined;\r\n    }\r\n}\r\n\r\n/**\r\n * Revert the endianness of the data\r\n * @param source defines the source\r\n */\r\nexport function Predictor(source: Uint8Array) {\r\n    for (let t = 1; t < source.length; t++) {\r\n        const d = source[t - 1] + source[t] - 128;\r\n        source[t] = d;\r\n    }\r\n}\r\n\r\n/**\r\n * Interleave pixels\r\n * @param source defines the data source\r\n * @param out defines the output\r\n */\r\nexport function InterleaveScalar(source: Uint8Array, out: Uint8Array) {\r\n    let t1 = 0;\r\n    let t2 = Math.floor((source.length + 1) / 2);\r\n    let s = 0;\r\n    const stop = source.length - 1;\r\n\r\n    // eslint-disable-next-line no-constant-condition\r\n    while (true) {\r\n        if (s > stop) {\r\n            break;\r\n        }\r\n        out[s++] = source[t1++];\r\n\r\n        if (s > stop) {\r\n            break;\r\n        }\r\n        out[s++] = source[t2++];\r\n    }\r\n}\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport { Logger } from \"core/Misc/logger\";\r\nimport type { DataCursor } from \"./exrLoader.core\";\r\nimport { ParseNullTerminatedString, ParseUint32, ParseValue } from \"./exrLoader.core\";\r\nimport type { IEXRHeader } from \"./exrLoader.interfaces\";\r\n\r\n/**\r\n * Inspired by https://github.com/sciecode/three.js/blob/dev/examples/jsm/loaders/EXRLoader.js\r\n * Referred to the original Industrial Light & Magic OpenEXR implementation and the TinyEXR / Syoyo Fujita\r\n * implementation.\r\n */\r\n\r\n// /*\r\n// Copyright (c) 2014 - 2017, Syoyo Fujita\r\n// All rights reserved.\r\n\r\n// Redistribution and use in source and binary forms, with or without\r\n// modification, are permitted provided that the following conditions are met:\r\n//     * Redistributions of source code must retain the above copyright\r\n//       notice, this list of conditions and the following disclaimer.\r\n//     * Redistributions in binary form must reproduce the above copyright\r\n//       notice, this list of conditions and the following disclaimer in the\r\n//       documentation and/or other materials provided with the distribution.\r\n//     * Neither the name of the Syoyo Fujita nor the\r\n//       names of its contributors may be used to endorse or promote products\r\n//       derived from this software without specific prior written permission.\r\n\r\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\r\n// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n// DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\r\n// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\r\n// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\r\n// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\r\n// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\r\n// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n// */\r\n\r\n// // TinyEXR contains some OpenEXR code, which is licensed under ------------\r\n\r\n// ///////////////////////////////////////////////////////////////////////////\r\n// //\r\n// // Copyright (c) 2002, Industrial Light & Magic, a division of Lucas\r\n// // Digital Ltd. LLC\r\n// //\r\n// // All rights reserved.\r\n// //\r\n// // Redistribution and use in source and binary forms, with or without\r\n// // modification, are permitted provided that the following conditions are\r\n// // met:\r\n// // *       Redistributions of source code must retain the above copyright\r\n// // notice, this list of conditions and the following disclaimer.\r\n// // *       Redistributions in binary form must reproduce the above\r\n// // copyright notice, this list of conditions and the following disclaimer\r\n// // in the documentation and/or other materials provided with the\r\n// // distribution.\r\n// // *       Neither the name of Industrial Light & Magic nor the names of\r\n// // its contributors may be used to endorse or promote products derived\r\n// // from this software without specific prior written permission.\r\n// //\r\n// // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\r\n// // \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\r\n// // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\r\n// // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\r\n// // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n// // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\r\n// // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\r\n// // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\r\n// // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n// // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\r\n// // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n// //\r\n// ///////////////////////////////////////////////////////////////////////////\r\n\r\n// // End of OpenEXR license -------------------------------------------------\r\n\r\nconst EXR_MAGIC = 20000630;\r\n\r\n/**\r\n * Gets the EXR header\r\n * @param dataView defines the data view to read from\r\n * @param offset defines the offset to start reading from\r\n * @returns the header\r\n */\r\nexport function GetExrHeader(dataView: DataView, offset: DataCursor): IEXRHeader {\r\n    if (dataView.getUint32(0, true) != EXR_MAGIC) {\r\n        throw new Error(\"Incorrect OpenEXR format\");\r\n    }\r\n\r\n    const version = dataView.getUint8(4);\r\n\r\n    const specData = dataView.getUint8(5); // fullMask\r\n    const spec = {\r\n        singleTile: !!(specData & 2),\r\n        longName: !!(specData & 4),\r\n        deepFormat: !!(specData & 8),\r\n        multiPart: !!(specData & 16),\r\n    };\r\n\r\n    offset.value = 8;\r\n\r\n    const headerData: any = {};\r\n\r\n    let keepReading = true;\r\n\r\n    while (keepReading) {\r\n        const attributeName = ParseNullTerminatedString(dataView.buffer, offset);\r\n\r\n        if (!attributeName) {\r\n            keepReading = false;\r\n        } else {\r\n            const attributeType = ParseNullTerminatedString(dataView.buffer, offset);\r\n            const attributeSize = ParseUint32(dataView, offset);\r\n            const attributeValue = ParseValue(dataView, offset, attributeType, attributeSize);\r\n\r\n            if (attributeValue === undefined) {\r\n                Logger.Warn(`Unknown header attribute type ${attributeType}'.`);\r\n            } else {\r\n                headerData[attributeName] = attributeValue;\r\n            }\r\n        }\r\n    }\r\n\r\n    if ((specData & ~0x04) != 0) {\r\n        throw new Error(\"Unsupported file format\");\r\n    }\r\n\r\n    return { version: version, spec: spec, ...headerData };\r\n}\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"core/types\";\r\nimport type { DataCursor } from \"./exrLoader.core\";\r\nimport { ParseUint32, ParseUint8Array } from \"./exrLoader.core\";\r\nimport { HUF_DECBITS, HUF_DECMASK, HUF_DECSIZE, HUF_ENCSIZE, LONG_ZEROCODE_RUN, SHORT_ZEROCODE_RUN, SHORTEST_LONG_RUN, USHORT_RANGE } from \"./exrLoader.interfaces\";\r\n\r\n/**\r\n * Inspired by https://github.com/sciecode/three.js/blob/dev/examples/jsm/loaders/EXRLoader.js\r\n * Referred to the original Industrial Light & Magic OpenEXR implementation and the TinyEXR / Syoyo Fujita\r\n * implementation.\r\n */\r\n\r\n// /*\r\n// Copyright (c) 2014 - 2017, Syoyo Fujita\r\n// All rights reserved.\r\n\r\n// Redistribution and use in source and binary forms, with or without\r\n// modification, are permitted provided that the following conditions are met:\r\n//     * Redistributions of source code must retain the above copyright\r\n//       notice, this list of conditions and the following disclaimer.\r\n//     * Redistributions in binary form must reproduce the above copyright\r\n//       notice, this list of conditions and the following disclaimer in the\r\n//       documentation and/or other materials provided with the distribution.\r\n//     * Neither the name of the Syoyo Fujita nor the\r\n//       names of its contributors may be used to endorse or promote products\r\n//       derived from this software without specific prior written permission.\r\n\r\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\r\n// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n// DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\r\n// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\r\n// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\r\n// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\r\n// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\r\n// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n// */\r\n\r\n// // TinyEXR contains some OpenEXR code, which is licensed under ------------\r\n\r\n// ///////////////////////////////////////////////////////////////////////////\r\n// //\r\n// // Copyright (c) 2002, Industrial Light & Magic, a division of Lucas\r\n// // Digital Ltd. LLC\r\n// //\r\n// // All rights reserved.\r\n// //\r\n// // Redistribution and use in source and binary forms, with or without\r\n// // modification, are permitted provided that the following conditions are\r\n// // met:\r\n// // *       Redistributions of source code must retain the above copyright\r\n// // notice, this list of conditions and the following disclaimer.\r\n// // *       Redistributions in binary form must reproduce the above\r\n// // copyright notice, this list of conditions and the following disclaimer\r\n// // in the documentation and/or other materials provided with the\r\n// // distribution.\r\n// // *       Neither the name of Industrial Light & Magic nor the names of\r\n// // its contributors may be used to endorse or promote products derived\r\n// // from this software without specific prior written permission.\r\n// //\r\n// // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\r\n// // \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\r\n// // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\r\n// // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\r\n// // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n// // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\r\n// // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\r\n// // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\r\n// // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n// // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\r\n// // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n// //\r\n// ///////////////////////////////////////////////////////////////////////////\r\n\r\n// // End of OpenEXR license -------------------------------------------------\r\n\r\nconst NBITS = 16;\r\nconst A_OFFSET = 1 << (NBITS - 1);\r\nconst MOD_MASK = (1 << NBITS) - 1;\r\n\r\ninterface IGetBits {\r\n    l: number;\r\n    c: number;\r\n    lc: number;\r\n}\r\n\r\ninterface IGetChar {\r\n    c: number;\r\n    lc: number;\r\n}\r\n\r\n/** @internal */\r\nexport function ReverseLutFromBitmap(bitmap: Uint8Array, lut: Uint16Array) {\r\n    let k = 0;\r\n\r\n    for (let i = 0; i < USHORT_RANGE; ++i) {\r\n        if (i == 0 || bitmap[i >> 3] & (1 << (i & 7))) {\r\n            lut[k++] = i;\r\n        }\r\n    }\r\n\r\n    const n = k - 1;\r\n\r\n    while (k < USHORT_RANGE) lut[k++] = 0;\r\n\r\n    return n;\r\n}\r\n\r\nfunction HufClearDecTable(hdec: Array<any>) {\r\n    for (let i = 0; i < HUF_DECSIZE; i++) {\r\n        hdec[i] = {};\r\n        hdec[i].len = 0;\r\n        hdec[i].lit = 0;\r\n        hdec[i].p = null;\r\n    }\r\n}\r\n\r\nfunction GetBits(nBits: number, c: number, lc: number, array: Uint8Array, offset: DataCursor): IGetBits {\r\n    while (lc < nBits) {\r\n        c = (c << 8) | ParseUint8Array(array, offset);\r\n        lc += 8;\r\n    }\r\n\r\n    lc -= nBits;\r\n\r\n    return {\r\n        l: (c >> lc) & ((1 << nBits) - 1),\r\n        c,\r\n        lc,\r\n    };\r\n}\r\n\r\nfunction GetChar(c: number, lc: number, array: Uint8Array, offset: DataCursor): IGetChar {\r\n    c = (c << 8) | ParseUint8Array(array, offset);\r\n    lc += 8;\r\n\r\n    return {\r\n        c,\r\n        lc,\r\n    };\r\n}\r\n\r\nfunction GetCode(\r\n    po: number,\r\n    rlc: number,\r\n    c: number,\r\n    lc: number,\r\n    array: Uint8Array,\r\n    offset: DataCursor,\r\n    outBuffer: Uint16Array,\r\n    outBufferOffset: DataCursor,\r\n    outBufferEndOffset: number\r\n): Nullable<IGetChar> {\r\n    if (po == rlc) {\r\n        if (lc < 8) {\r\n            const gc = GetChar(c, lc, array, offset);\r\n            c = gc.c;\r\n            lc = gc.lc;\r\n        }\r\n\r\n        lc -= 8;\r\n\r\n        let cs = c >> lc;\r\n        cs = new Uint8Array([cs])[0];\r\n\r\n        if (outBufferOffset.value + cs > outBufferEndOffset) {\r\n            return null;\r\n        }\r\n\r\n        const s = outBuffer[outBufferOffset.value - 1];\r\n\r\n        while (cs-- > 0) {\r\n            outBuffer[outBufferOffset.value++] = s;\r\n        }\r\n    } else if (outBufferOffset.value < outBufferEndOffset) {\r\n        outBuffer[outBufferOffset.value++] = po;\r\n    } else {\r\n        return null;\r\n    }\r\n\r\n    return { c, lc };\r\n}\r\n\r\nconst HufTableBuffer = new Array(59);\r\n\r\nfunction HufCanonicalCodeTable(hcode: Array<any>) {\r\n    for (let i = 0; i <= 58; ++i) HufTableBuffer[i] = 0;\r\n    for (let i = 0; i < HUF_ENCSIZE; ++i) HufTableBuffer[hcode[i]] += 1;\r\n\r\n    let c = 0;\r\n\r\n    for (let i = 58; i > 0; --i) {\r\n        const nc = (c + HufTableBuffer[i]) >> 1;\r\n        HufTableBuffer[i] = c;\r\n        c = nc;\r\n    }\r\n\r\n    for (let i = 0; i < HUF_ENCSIZE; ++i) {\r\n        const l = hcode[i];\r\n        if (l > 0) hcode[i] = l | (HufTableBuffer[l]++ << 6);\r\n    }\r\n}\r\n\r\nfunction HufUnpackEncTable(array: Uint8Array, offset: DataCursor, ni: number, im: number, iM: number, hcode: Array<any>) {\r\n    const p = offset;\r\n    let c = 0;\r\n    let lc = 0;\r\n\r\n    for (; im <= iM; im++) {\r\n        if (p.value - offset.value > ni) {\r\n            return;\r\n        }\r\n\r\n        let gb = GetBits(6, c, lc, array, p);\r\n\r\n        const l = gb.l;\r\n        c = gb.c;\r\n        lc = gb.lc;\r\n\r\n        hcode[im] = l;\r\n\r\n        if (l == LONG_ZEROCODE_RUN) {\r\n            if (p.value - offset.value > ni) {\r\n                throw new Error(\"Error in HufUnpackEncTable\");\r\n            }\r\n\r\n            gb = GetBits(8, c, lc, array, p);\r\n\r\n            let zerun = gb.l + SHORTEST_LONG_RUN;\r\n            c = gb.c;\r\n            lc = gb.lc;\r\n\r\n            if (im + zerun > iM + 1) {\r\n                throw new Error(\"Error in HufUnpackEncTable\");\r\n            }\r\n\r\n            while (zerun--) hcode[im++] = 0;\r\n\r\n            im--;\r\n        } else if (l >= SHORT_ZEROCODE_RUN) {\r\n            let zerun = l - SHORT_ZEROCODE_RUN + 2;\r\n\r\n            if (im + zerun > iM + 1) {\r\n                throw new Error(\"Error in HufUnpackEncTable\");\r\n            }\r\n\r\n            while (zerun--) hcode[im++] = 0;\r\n\r\n            im--;\r\n        }\r\n    }\r\n\r\n    HufCanonicalCodeTable(hcode);\r\n}\r\n\r\nfunction HufLength(code: number) {\r\n    return code & 63;\r\n}\r\n\r\nfunction HufCode(code: number) {\r\n    return code >> 6;\r\n}\r\n\r\nfunction HufBuildDecTable(hcode: Array<any>, im: number, iM: number, hdecod: Array<any>) {\r\n    for (; im <= iM; im++) {\r\n        const c = HufCode(hcode[im]);\r\n        const l = HufLength(hcode[im]);\r\n\r\n        if (c >> l) {\r\n            throw new Error(\"Invalid table entry\");\r\n        }\r\n\r\n        if (l > HUF_DECBITS) {\r\n            const pl = hdecod[c >> (l - HUF_DECBITS)];\r\n\r\n            if (pl.len) {\r\n                throw new Error(\"Invalid table entry\");\r\n            }\r\n\r\n            pl.lit++;\r\n\r\n            if (pl.p) {\r\n                const p = pl.p;\r\n                pl.p = new Array(pl.lit);\r\n\r\n                for (let i = 0; i < pl.lit - 1; ++i) {\r\n                    pl.p[i] = p[i];\r\n                }\r\n            } else {\r\n                pl.p = new Array(1);\r\n            }\r\n\r\n            pl.p[pl.lit - 1] = im;\r\n        } else if (l) {\r\n            let plOffset = 0;\r\n\r\n            for (let i = 1 << (HUF_DECBITS - l); i > 0; i--) {\r\n                const pl = hdecod[(c << (HUF_DECBITS - l)) + plOffset];\r\n\r\n                if (pl.len || pl.p) {\r\n                    throw new Error(\"Invalid table entry\");\r\n                }\r\n\r\n                pl.len = l;\r\n                pl.lit = im;\r\n\r\n                plOffset++;\r\n            }\r\n        }\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\nfunction HufDecode(\r\n    encodingTable: Array<any>,\r\n    decodingTable: Array<any>,\r\n    array: Uint8Array,\r\n    offset: DataCursor,\r\n    ni: number,\r\n    rlc: number,\r\n    no: number,\r\n    outBuffer: Uint16Array,\r\n    outOffset: DataCursor\r\n) {\r\n    let c = 0;\r\n    let lc = 0;\r\n    const outBufferEndOffset = no;\r\n    const inOffsetEnd = Math.trunc(offset.value + (ni + 7) / 8);\r\n\r\n    while (offset.value < inOffsetEnd) {\r\n        let gc = GetChar(c, lc, array, offset);\r\n\r\n        c = gc.c;\r\n        lc = gc.lc;\r\n\r\n        while (lc >= HUF_DECBITS) {\r\n            const index = (c >> (lc - HUF_DECBITS)) & HUF_DECMASK;\r\n            const pl = decodingTable[index];\r\n\r\n            if (pl.len) {\r\n                lc -= pl.len;\r\n\r\n                const gCode = GetCode(pl.lit, rlc, c, lc, array, offset, outBuffer, outOffset, outBufferEndOffset);\r\n                if (gCode) {\r\n                    c = gCode.c;\r\n                    lc = gCode.lc;\r\n                }\r\n            } else {\r\n                if (!pl.p) {\r\n                    throw new Error(\"hufDecode issues\");\r\n                }\r\n\r\n                let j;\r\n\r\n                for (j = 0; j < pl.lit; j++) {\r\n                    const l = HufLength(encodingTable[pl.p[j]]);\r\n\r\n                    while (lc < l && offset.value < inOffsetEnd) {\r\n                        gc = GetChar(c, lc, array, offset);\r\n\r\n                        c = gc.c;\r\n                        lc = gc.lc;\r\n                    }\r\n\r\n                    if (lc >= l) {\r\n                        if (HufCode(encodingTable[pl.p[j]]) == ((c >> (lc - l)) & ((1 << l) - 1))) {\r\n                            lc -= l;\r\n\r\n                            const gCode = GetCode(pl.p[j], rlc, c, lc, array, offset, outBuffer, outOffset, outBufferEndOffset);\r\n\r\n                            if (gCode) {\r\n                                c = gCode.c;\r\n                                lc = gCode.lc;\r\n                            }\r\n\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (j == pl.lit) {\r\n                    throw new Error(\"HufDecode issues\");\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    const i = (8 - ni) & 7;\r\n\r\n    c >>= i;\r\n    lc -= i;\r\n\r\n    while (lc > 0) {\r\n        const pl = decodingTable[(c << (HUF_DECBITS - lc)) & HUF_DECMASK];\r\n\r\n        if (pl.len) {\r\n            lc -= pl.len;\r\n\r\n            const gCode = GetCode(pl.lit, rlc, c, lc, array, offset, outBuffer, outOffset, outBufferEndOffset);\r\n            if (gCode) {\r\n                c = gCode.c;\r\n                lc = gCode.lc;\r\n            }\r\n        } else {\r\n            throw new Error(\"HufDecode issues\");\r\n        }\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n/** @internal */\r\nexport function HufUncompress(array: Uint8Array, dataView: DataView, offset: DataCursor, nCompressed: number, outBuffer: Uint16Array, nRaw: number) {\r\n    const outOffset: DataCursor = { value: 0 };\r\n    const initialInOffset = offset.value;\r\n\r\n    const im = ParseUint32(dataView, offset);\r\n    const iM = ParseUint32(dataView, offset);\r\n\r\n    offset.value += 4;\r\n\r\n    const nBits = ParseUint32(dataView, offset);\r\n\r\n    offset.value += 4;\r\n\r\n    if (im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE) {\r\n        throw new Error(\"Wrong HUF_ENCSIZE\");\r\n    }\r\n\r\n    const freq = new Array(HUF_ENCSIZE);\r\n    const hdec = new Array(HUF_DECSIZE);\r\n\r\n    HufClearDecTable(hdec);\r\n\r\n    const ni = nCompressed - (offset.value - initialInOffset);\r\n\r\n    HufUnpackEncTable(array, offset, ni, im, iM, freq);\r\n\r\n    if (nBits > 8 * (nCompressed - (offset.value - initialInOffset))) {\r\n        throw new Error(\"Wrong hufUncompress\");\r\n    }\r\n\r\n    HufBuildDecTable(freq, im, iM, hdec);\r\n\r\n    HufDecode(freq, hdec, array, offset, nBits, iM, nRaw, outBuffer, outOffset);\r\n}\r\n\r\nfunction UInt16(value: number) {\r\n    return value & 0xffff;\r\n}\r\n\r\nfunction Int16(value: number) {\r\n    const ref = UInt16(value);\r\n    return ref > 0x7fff ? ref - 0x10000 : ref;\r\n}\r\n\r\nfunction Wdec14(l: number, h: number) {\r\n    const ls = Int16(l);\r\n    const hs = Int16(h);\r\n\r\n    const hi = hs;\r\n    const ai = ls + (hi & 1) + (hi >> 1);\r\n\r\n    const as = ai;\r\n    const bs = ai - hi;\r\n\r\n    return { a: as, b: bs };\r\n}\r\n\r\nfunction Wdec16(l: number, h: number) {\r\n    const m = UInt16(l);\r\n    const d = UInt16(h);\r\n\r\n    const bb = (m - (d >> 1)) & MOD_MASK;\r\n    const aa = (d + bb - A_OFFSET) & MOD_MASK;\r\n\r\n    return { a: aa, b: bb };\r\n}\r\n\r\n/** @internal */\r\nexport function Wav2Decode(buffer: Uint16Array, j: number, nx: number, ox: number, ny: number, oy: number, mx: number) {\r\n    const w14 = mx < 1 << 14;\r\n    const n = nx > ny ? ny : nx;\r\n    let p = 1;\r\n    let p2;\r\n    let py;\r\n\r\n    while (p <= n) p <<= 1;\r\n\r\n    p >>= 1;\r\n    p2 = p;\r\n    p >>= 1;\r\n\r\n    while (p >= 1) {\r\n        py = 0;\r\n        const ey = py + oy * (ny - p2);\r\n        const oy1 = oy * p;\r\n        const oy2 = oy * p2;\r\n        const ox1 = ox * p;\r\n        const ox2 = ox * p2;\r\n        let i00, i01, i10, i11;\r\n\r\n        for (; py <= ey; py += oy2) {\r\n            let px = py;\r\n            const ex = py + ox * (nx - p2);\r\n\r\n            for (; px <= ex; px += ox2) {\r\n                const p01 = px + ox1;\r\n                const p10 = px + oy1;\r\n                const p11 = p10 + ox1;\r\n\r\n                if (w14) {\r\n                    let result = Wdec14(buffer[px + j], buffer[p10 + j]);\r\n\r\n                    i00 = result.a;\r\n                    i10 = result.b;\r\n\r\n                    result = Wdec14(buffer[p01 + j], buffer[p11 + j]);\r\n\r\n                    i01 = result.a;\r\n                    i11 = result.b;\r\n\r\n                    result = Wdec14(i00, i01);\r\n\r\n                    buffer[px + j] = result.a;\r\n                    buffer[p01 + j] = result.b;\r\n\r\n                    result = Wdec14(i10, i11);\r\n\r\n                    buffer[p10 + j] = result.a;\r\n                    buffer[p11 + j] = result.b;\r\n                } else {\r\n                    let result = Wdec16(buffer[px + j], buffer[p10 + j]);\r\n\r\n                    i00 = result.a;\r\n                    i10 = result.b;\r\n\r\n                    result = Wdec16(buffer[p01 + j], buffer[p11 + j]);\r\n\r\n                    i01 = result.a;\r\n                    i11 = result.b;\r\n\r\n                    result = Wdec16(i00, i01);\r\n\r\n                    buffer[px + j] = result.a;\r\n                    buffer[p01 + j] = result.b;\r\n\r\n                    result = Wdec16(i10, i11);\r\n\r\n                    buffer[p10 + j] = result.a;\r\n                    buffer[p11 + j] = result.b;\r\n                }\r\n            }\r\n\r\n            if (nx & p) {\r\n                const p10 = px + oy1;\r\n                let result;\r\n                if (w14) {\r\n                    result = Wdec14(buffer[px + j], buffer[p10 + j]);\r\n                } else {\r\n                    result = Wdec16(buffer[px + j], buffer[p10 + j]);\r\n                }\r\n\r\n                i00 = result.a;\r\n                buffer[p10 + j] = result.b;\r\n\r\n                buffer[px + j] = i00;\r\n            }\r\n        }\r\n\r\n        if (ny & p) {\r\n            let px = py;\r\n            const ex = py + ox * (nx - p2);\r\n\r\n            for (; px <= ex; px += ox2) {\r\n                const p01 = px + ox1;\r\n                let result;\r\n\r\n                if (w14) {\r\n                    result = Wdec14(buffer[px + j], buffer[p01 + j]);\r\n                } else {\r\n                    result = Wdec16(buffer[px + j], buffer[p01 + j]);\r\n                }\r\n\r\n                i00 = result.a;\r\n                buffer[p01 + j] = result.b;\r\n\r\n                buffer[px + j] = i00;\r\n            }\r\n        }\r\n\r\n        p2 = p;\r\n        p >>= 1;\r\n    }\r\n\r\n    return py;\r\n}\r\n\r\n/** @internal */\r\nexport function ApplyLut(lut: Uint16Array, data: Uint16Array, nData: number) {\r\n    for (let i = 0; i < nData; ++i) {\r\n        data[i] = lut[data[i]];\r\n    }\r\n}\r\n", "/**\r\n * Inspired by https://github.com/sciecode/three.js/blob/dev/examples/jsm/loaders/EXRLoader.js\r\n * Referred to the original Industrial Light & Magic OpenEXR implementation and the TinyEXR / Syoyo Fujita\r\n * implementation.\r\n */\r\n\r\n// /*\r\n// Copyright (c) 2014 - 2017, Syoyo Fujita\r\n// All rights reserved.\r\n\r\n// Redistribution and use in source and binary forms, with or without\r\n// modification, are permitted provided that the following conditions are met:\r\n//     * Redistributions of source code must retain the above copyright\r\n//       notice, this list of conditions and the following disclaimer.\r\n//     * Redistributions in binary form must reproduce the above copyright\r\n//       notice, this list of conditions and the following disclaimer in the\r\n//       documentation and/or other materials provided with the distribution.\r\n//     * Neither the name of the Syoyo Fujita nor the\r\n//       names of its contributors may be used to endorse or promote products\r\n//       derived from this software without specific prior written permission.\r\n\r\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\r\n// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n// DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\r\n// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\r\n// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\r\n// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\r\n// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\r\n// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n// */\r\n\r\n// // TinyEXR contains some OpenEXR code, which is licensed under ------------\r\n\r\n// ///////////////////////////////////////////////////////////////////////////\r\n// //\r\n// // Copyright (c) 2002, Industrial Light & Magic, a division of Lucas\r\n// // Digital Ltd. LLC\r\n// //\r\n// // All rights reserved.\r\n// //\r\n// // Redistribution and use in source and binary forms, with or without\r\n// // modification, are permitted provided that the following conditions are\r\n// // met:\r\n// // *       Redistributions of source code must retain the above copyright\r\n// // notice, this list of conditions and the following disclaimer.\r\n// // *       Redistributions in binary form must reproduce the above\r\n// // copyright notice, this list of conditions and the following disclaimer\r\n// // in the documentation and/or other materials provided with the\r\n// // distribution.\r\n// // *       Neither the name of Industrial Light & Magic nor the names of\r\n// // its contributors may be used to endorse or promote products derived\r\n// // from this software without specific prior written permission.\r\n// //\r\n// // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\r\n// // \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\r\n// // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\r\n// // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\r\n// // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n// // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\r\n// // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\r\n// // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\r\n// // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n// // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\r\n// // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n// //\r\n// ///////////////////////////////////////////////////////////////////////////\r\n\r\n// // End of OpenEXR license -------------------------------------------------\r\n\r\n/** @internal */\r\nexport function DecodeRunLength(source: ArrayBuffer) {\r\n    let size = source.byteLength;\r\n    const out = new Array();\r\n    let p = 0;\r\n\r\n    const reader = new DataView(source);\r\n\r\n    while (size > 0) {\r\n        const l = reader.getInt8(p++);\r\n\r\n        if (l < 0) {\r\n            const count = -l;\r\n            size -= count + 1;\r\n\r\n            for (let i = 0; i < count; i++) {\r\n                out.push(reader.getUint8(p++));\r\n            }\r\n        } else {\r\n            const count = l;\r\n            size -= 2;\r\n\r\n            const value = reader.getUint8(p++);\r\n\r\n            for (let i = 0; i < count + 1; i++) {\r\n                out.push(value);\r\n            }\r\n        }\r\n    }\r\n\r\n    return out;\r\n}\r\n", "import { ApplyLut, HufUncompress, ReverseLutFromBitmap, Wav2Decode } from \"./exrLoader.compression.huf\";\r\nimport { DecodeRunLength } from \"./exrLoader.compression.rle\";\r\nimport { InterleaveScalar, ParseUint16, ParseUint32, ParseUint8, Predictor } from \"./exrLoader.core\";\r\nimport { BITMAP_SIZE, INT16_SIZE, USHORT_RANGE, type IEXRDecoder } from \"./exrLoader.interfaces\";\r\n\r\n/**\r\n * Inspired by https://github.com/sciecode/three.js/blob/dev/examples/jsm/loaders/EXRLoader.js\r\n * Referred to the original Industrial Light & Magic OpenEXR implementation and the TinyEXR / Syoyo Fujita\r\n * implementation.\r\n */\r\n\r\n// /*\r\n// Copyright (c) 2014 - 2017, Syoyo Fujita\r\n// All rights reserved.\r\n\r\n// Redistribution and use in source and binary forms, with or without\r\n// modification, are permitted provided that the following conditions are met:\r\n//     * Redistributions of source code must retain the above copyright\r\n//       notice, this list of conditions and the following disclaimer.\r\n//     * Redistributions in binary form must reproduce the above copyright\r\n//       notice, this list of conditions and the following disclaimer in the\r\n//       documentation and/or other materials provided with the distribution.\r\n//     * Neither the name of the Syoyo Fujita nor the\r\n//       names of its contributors may be used to endorse or promote products\r\n//       derived from this software without specific prior written permission.\r\n\r\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\r\n// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n// DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\r\n// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\r\n// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\r\n// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\r\n// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\r\n// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n// */\r\n\r\n// // TinyEXR contains some OpenEXR code, which is licensed under ------------\r\n\r\n// ///////////////////////////////////////////////////////////////////////////\r\n// //\r\n// // Copyright (c) 2002, Industrial Light & Magic, a division of Lucas\r\n// // Digital Ltd. LLC\r\n// //\r\n// // All rights reserved.\r\n// //\r\n// // Redistribution and use in source and binary forms, with or without\r\n// // modification, are permitted provided that the following conditions are\r\n// // met:\r\n// // *       Redistributions of source code must retain the above copyright\r\n// // notice, this list of conditions and the following disclaimer.\r\n// // *       Redistributions in binary form must reproduce the above\r\n// // copyright notice, this list of conditions and the following disclaimer\r\n// // in the documentation and/or other materials provided with the\r\n// // distribution.\r\n// // *       Neither the name of Industrial Light & Magic nor the names of\r\n// // its contributors may be used to endorse or promote products derived\r\n// // from this software without specific prior written permission.\r\n// //\r\n// // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\r\n// // \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\r\n// // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\r\n// // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\r\n// // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n// // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\r\n// // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\r\n// // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\r\n// // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n// // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\r\n// // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n// //\r\n// ///////////////////////////////////////////////////////////////////////////\r\n\r\n// // End of OpenEXR license -------------------------------------------------\r\n\r\n// FFlate access\r\ndeclare const fflate: any;\r\n\r\n/**\r\n * No compression\r\n * @param decoder defines the decoder to use\r\n * @returns a decompressed data view\r\n */\r\nexport function UncompressRAW(decoder: IEXRDecoder): DataView {\r\n    return new DataView(decoder.array.buffer, decoder.offset.value, decoder.size);\r\n}\r\n\r\n/**\r\n * RLE compression\r\n * @param decoder defines the decoder to use\r\n * @returns a decompressed data view\r\n */\r\nexport function UncompressRLE(decoder: IEXRDecoder): DataView {\r\n    const compressed = decoder.viewer.buffer.slice(decoder.offset.value, decoder.offset.value + decoder.size);\r\n\r\n    const rawBuffer = new Uint8Array(DecodeRunLength(compressed));\r\n    const tmpBuffer = new Uint8Array(rawBuffer.length);\r\n\r\n    Predictor(rawBuffer);\r\n\r\n    InterleaveScalar(rawBuffer, tmpBuffer);\r\n\r\n    return new DataView(tmpBuffer.buffer);\r\n}\r\n\r\n/**\r\n * Zip compression\r\n * @param decoder defines the decoder to use\r\n * @returns a decompressed data view\r\n */\r\nexport function UncompressZIP(decoder: IEXRDecoder): DataView {\r\n    const compressed = decoder.array.slice(decoder.offset.value, decoder.offset.value + decoder.size);\r\n\r\n    const rawBuffer = fflate.unzlibSync(compressed);\r\n    const tmpBuffer = new Uint8Array(rawBuffer.length);\r\n\r\n    Predictor(rawBuffer);\r\n\r\n    InterleaveScalar(rawBuffer, tmpBuffer);\r\n\r\n    return new DataView(tmpBuffer.buffer);\r\n}\r\n\r\n/**\r\n * PXR compression\r\n * @param decoder defines the decoder to use\r\n * @returns a decompressed data view\r\n */\r\nexport function UncompressPXR(decoder: IEXRDecoder): DataView {\r\n    const compressed = decoder.array.slice(decoder.offset.value, decoder.offset.value + decoder.size);\r\n\r\n    const rawBuffer = fflate.unzlibSync(compressed);\r\n\r\n    const sz = decoder.lines * decoder.channels * decoder.width;\r\n    const tmpBuffer = decoder.type == 1 ? new Uint16Array(sz) : new Uint32Array(sz);\r\n\r\n    let tmpBufferEnd = 0;\r\n    let writePtr = 0;\r\n    const ptr = new Array(4);\r\n\r\n    for (let y = 0; y < decoder.lines; y++) {\r\n        for (let c = 0; c < decoder.channels; c++) {\r\n            let pixel = 0;\r\n\r\n            switch (decoder.type) {\r\n                case 1:\r\n                    ptr[0] = tmpBufferEnd;\r\n                    ptr[1] = ptr[0] + decoder.width;\r\n                    tmpBufferEnd = ptr[1] + decoder.width;\r\n\r\n                    for (let j = 0; j < decoder.width; ++j) {\r\n                        const diff = (rawBuffer[ptr[0]++] << 8) | rawBuffer[ptr[1]++];\r\n\r\n                        pixel += diff;\r\n\r\n                        tmpBuffer[writePtr] = pixel;\r\n                        writePtr++;\r\n                    }\r\n\r\n                    break;\r\n\r\n                case 2:\r\n                    ptr[0] = tmpBufferEnd;\r\n                    ptr[1] = ptr[0] + decoder.width;\r\n                    ptr[2] = ptr[1] + decoder.width;\r\n                    tmpBufferEnd = ptr[2] + decoder.width;\r\n\r\n                    for (let j = 0; j < decoder.width; ++j) {\r\n                        const diff = (rawBuffer[ptr[0]++] << 24) | (rawBuffer[ptr[1]++] << 16) | (rawBuffer[ptr[2]++] << 8);\r\n\r\n                        pixel += diff;\r\n\r\n                        tmpBuffer[writePtr] = pixel;\r\n                        writePtr++;\r\n                    }\r\n\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n\r\n    return new DataView(tmpBuffer.buffer);\r\n}\r\n\r\n/**\r\n * PIZ compression\r\n * @param decoder defines the decoder to use\r\n * @returns a decompressed data view\r\n */\r\nexport function UncompressPIZ(decoder: IEXRDecoder): DataView {\r\n    const inDataView = decoder.viewer;\r\n    const inOffset = { value: decoder.offset.value };\r\n\r\n    const outBuffer = new Uint16Array(decoder.width * decoder.scanlineBlockSize * (decoder.channels * decoder.type));\r\n    const bitmap = new Uint8Array(BITMAP_SIZE);\r\n\r\n    // Setup channel info\r\n    let outBufferEnd = 0;\r\n    const pizChannelData = new Array(decoder.channels);\r\n    for (let i = 0; i < decoder.channels; i++) {\r\n        pizChannelData[i] = {};\r\n        pizChannelData[i][\"start\"] = outBufferEnd;\r\n        pizChannelData[i][\"end\"] = pizChannelData[i][\"start\"];\r\n        pizChannelData[i][\"nx\"] = decoder.width;\r\n        pizChannelData[i][\"ny\"] = decoder.lines;\r\n        pizChannelData[i][\"size\"] = decoder.type;\r\n\r\n        outBufferEnd += pizChannelData[i].nx * pizChannelData[i].ny * pizChannelData[i].size;\r\n    }\r\n\r\n    // Read range compression data\r\n    const minNonZero = ParseUint16(inDataView, inOffset);\r\n    const maxNonZero = ParseUint16(inDataView, inOffset);\r\n\r\n    if (maxNonZero >= BITMAP_SIZE) {\r\n        throw new Error(\"Wrong PIZ_COMPRESSION BITMAP_SIZE\");\r\n    }\r\n\r\n    if (minNonZero <= maxNonZero) {\r\n        for (let i = 0; i < maxNonZero - minNonZero + 1; i++) {\r\n            bitmap[i + minNonZero] = ParseUint8(inDataView, inOffset);\r\n        }\r\n    }\r\n\r\n    // Reverse LUT\r\n    const lut = new Uint16Array(USHORT_RANGE);\r\n    const maxValue = ReverseLutFromBitmap(bitmap, lut);\r\n\r\n    const length = ParseUint32(inDataView, inOffset);\r\n\r\n    // Huffman decoding\r\n    HufUncompress(decoder.array, inDataView, inOffset, length, outBuffer, outBufferEnd);\r\n\r\n    // Wavelet decoding\r\n    for (let i = 0; i < decoder.channels; ++i) {\r\n        const cd = pizChannelData[i];\r\n\r\n        for (let j = 0; j < pizChannelData[i].size; ++j) {\r\n            Wav2Decode(outBuffer, cd.start + j, cd.nx, cd.size, cd.ny, cd.nx * cd.size, maxValue);\r\n        }\r\n    }\r\n\r\n    // Expand the pixel data to their original range\r\n    ApplyLut(lut, outBuffer, outBufferEnd);\r\n\r\n    // Rearrange the pixel data into the format expected by the caller.\r\n    let tmpOffset = 0;\r\n    const tmpBuffer = new Uint8Array(outBuffer.buffer.byteLength);\r\n    for (let y = 0; y < decoder.lines; y++) {\r\n        for (let c = 0; c < decoder.channels; c++) {\r\n            const cd = pizChannelData[c];\r\n\r\n            const n = cd.nx * cd.size;\r\n            const cp = new Uint8Array(outBuffer.buffer, cd.end * INT16_SIZE, n * INT16_SIZE);\r\n\r\n            tmpBuffer.set(cp, tmpOffset);\r\n            tmpOffset += n * INT16_SIZE;\r\n            cd.end += n;\r\n        }\r\n    }\r\n\r\n    return new DataView(tmpBuffer.buffer);\r\n}\r\n", "export enum EXROutputType {\r\n    Float = 0,\r\n    HalfFloat = 1,\r\n}\r\n\r\n/**\r\n * Class used to store configuration of the exr loader\r\n */\r\nexport class ExrLoaderGlobalConfiguration {\r\n    /**\r\n     * Defines the default output type to use (Half float by default)\r\n     */\r\n    public static DefaultOutputType: EXROutputType = EXROutputType.HalfFloat;\r\n    /**\r\n     * Url to use to load the fflate library (for zip decompression)\r\n     */\r\n    public static FFLATEUrl = \"https://unpkg.com/fflate@0.8.2\";\r\n}\r\n", "import type { DataCursor } from \"./exrLoader.core\";\r\nimport { CompressionCodes, DecodeFloat32, ParseFloat16, ParseFloat32, ParseInt32, ParseInt64, ParseUint16, ParseUint32 } from \"./exrLoader.core\";\r\nimport { UncompressPIZ, UncompressPXR, UncompressRAW, UncompressRLE, UncompressZIP } from \"./exrLoader.compression\";\r\nimport { FLOAT32_SIZE, INT16_SIZE, type IEXRDecoder, type IEXRHeader } from \"./exrLoader.interfaces\";\r\nimport { Constants } from \"core/Engines/constants\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport { ExrLoaderGlobalConfiguration, EXROutputType } from \"./exrLoader.configuration\";\r\n\r\n/**\r\n * Inspired by https://github.com/sciecode/three.js/blob/dev/examples/jsm/loaders/EXRLoader.js\r\n * Referred to the original Industrial Light & Magic OpenEXR implementation and the TinyEXR / Syoyo Fujita\r\n * implementation.\r\n */\r\n\r\n// /*\r\n// Copyright (c) 2014 - 2017, Syoyo Fujita\r\n// All rights reserved.\r\n\r\n// Redistribution and use in source and binary forms, with or without\r\n// modification, are permitted provided that the following conditions are met:\r\n//     * Redistributions of source code must retain the above copyright\r\n//       notice, this list of conditions and the following disclaimer.\r\n//     * Redistributions in binary form must reproduce the above copyright\r\n//       notice, this list of conditions and the following disclaimer in the\r\n//       documentation and/or other materials provided with the distribution.\r\n//     * Neither the name of the Syoyo Fujita nor the\r\n//       names of its contributors may be used to endorse or promote products\r\n//       derived from this software without specific prior written permission.\r\n\r\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\r\n// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n// DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\r\n// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\r\n// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\r\n// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\r\n// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\r\n// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n// */\r\n\r\n// // TinyEXR contains some OpenEXR code, which is licensed under ------------\r\n\r\n// ///////////////////////////////////////////////////////////////////////////\r\n// //\r\n// // Copyright (c) 2002, Industrial Light & Magic, a division of Lucas\r\n// // Digital Ltd. LLC\r\n// //\r\n// // All rights reserved.\r\n// //\r\n// // Redistribution and use in source and binary forms, with or without\r\n// // modification, are permitted provided that the following conditions are\r\n// // met:\r\n// // *       Redistributions of source code must retain the above copyright\r\n// // notice, this list of conditions and the following disclaimer.\r\n// // *       Redistributions in binary form must reproduce the above\r\n// // copyright notice, this list of conditions and the following disclaimer\r\n// // in the documentation and/or other materials provided with the\r\n// // distribution.\r\n// // *       Neither the name of Industrial Light & Magic nor the names of\r\n// // its contributors may be used to endorse or promote products derived\r\n// // from this software without specific prior written permission.\r\n// //\r\n// // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\r\n// // \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\r\n// // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\r\n// // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\r\n// // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n// // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\r\n// // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\r\n// // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\r\n// // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n// // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\r\n// // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n// //\r\n// ///////////////////////////////////////////////////////////////////////////\r\n\r\n// // End of OpenEXR license -------------------------------------------------\r\n\r\n/**\r\n * Create a decoder for the exr file\r\n * @param header header of the exr file\r\n * @param dataView dataview of the exr file\r\n * @param offset current offset\r\n * @param outputType expected output type (float or half float)\r\n * @returns a promise that resolves with the decoder\r\n */\r\nexport async function CreateDecoderAsync(header: IEXRHeader, dataView: DataView, offset: DataCursor, outputType: EXROutputType): Promise<IEXRDecoder> {\r\n    const decoder: IEXRDecoder = {\r\n        size: 0,\r\n        viewer: dataView,\r\n        array: new Uint8Array(dataView.buffer),\r\n        offset: offset,\r\n        width: header.dataWindow.xMax - header.dataWindow.xMin + 1,\r\n        height: header.dataWindow.yMax - header.dataWindow.yMin + 1,\r\n        channels: header.channels.length,\r\n        channelLineOffsets: {},\r\n        scanOrder: () => 0,\r\n        bytesPerLine: 0,\r\n        outLineWidth: 0,\r\n        lines: 0,\r\n        scanlineBlockSize: 0,\r\n        inputSize: null,\r\n        type: 0,\r\n        uncompress: null,\r\n        getter: () => 0,\r\n        format: Constants.TEXTUREFORMAT_RGBA,\r\n        outputChannels: 0,\r\n        decodeChannels: {},\r\n        blockCount: null,\r\n        byteArray: null,\r\n        linearSpace: false,\r\n        textureType: 0,\r\n    };\r\n\r\n    switch (header.compression) {\r\n        case CompressionCodes.NO_COMPRESSION:\r\n            decoder.lines = 1;\r\n            decoder.uncompress = UncompressRAW;\r\n            break;\r\n\r\n        case CompressionCodes.RLE_COMPRESSION:\r\n            decoder.lines = 1;\r\n            decoder.uncompress = UncompressRLE;\r\n            break;\r\n\r\n        case CompressionCodes.ZIPS_COMPRESSION:\r\n            decoder.lines = 1;\r\n            decoder.uncompress = UncompressZIP;\r\n            await Tools.LoadScriptAsync(ExrLoaderGlobalConfiguration.FFLATEUrl);\r\n            break;\r\n\r\n        case CompressionCodes.ZIP_COMPRESSION:\r\n            decoder.lines = 16;\r\n            decoder.uncompress = UncompressZIP;\r\n            await Tools.LoadScriptAsync(ExrLoaderGlobalConfiguration.FFLATEUrl);\r\n            break;\r\n\r\n        case CompressionCodes.PIZ_COMPRESSION:\r\n            decoder.lines = 32;\r\n            decoder.uncompress = UncompressPIZ;\r\n            break;\r\n\r\n        case CompressionCodes.PXR24_COMPRESSION:\r\n            decoder.lines = 16;\r\n            decoder.uncompress = UncompressPXR;\r\n            await Tools.LoadScriptAsync(ExrLoaderGlobalConfiguration.FFLATEUrl);\r\n            break;\r\n\r\n        default:\r\n            throw new Error(CompressionCodes[header.compression] + \" is unsupported\");\r\n    }\r\n\r\n    decoder.scanlineBlockSize = decoder.lines;\r\n\r\n    const channels: {\r\n        [key: string]: boolean;\r\n    } = {};\r\n    for (const channel of header.channels) {\r\n        switch (channel.name) {\r\n            case \"Y\":\r\n            case \"R\":\r\n            case \"G\":\r\n            case \"B\":\r\n            case \"A\":\r\n                channels[channel.name] = true;\r\n                decoder.type = channel.pixelType;\r\n        }\r\n    }\r\n\r\n    // RGB images will be converted to RGBA format, preventing software emulation in select devices.\r\n    let fillAlpha = false;\r\n\r\n    if (channels.R && channels.G && channels.B) {\r\n        fillAlpha = !channels.A;\r\n        decoder.outputChannels = 4;\r\n        decoder.decodeChannels = { R: 0, G: 1, B: 2, A: 3 };\r\n    } else if (channels.Y) {\r\n        decoder.outputChannels = 1;\r\n        decoder.decodeChannels = { Y: 0 };\r\n    } else {\r\n        throw new Error(\"EXRLoader.parse: file contains unsupported data channels.\");\r\n    }\r\n\r\n    if (decoder.type === 1) {\r\n        // half\r\n        switch (outputType) {\r\n            case EXROutputType.Float:\r\n                decoder.getter = ParseFloat16;\r\n                decoder.inputSize = INT16_SIZE;\r\n                break;\r\n\r\n            case EXROutputType.HalfFloat:\r\n                decoder.getter = ParseUint16;\r\n                decoder.inputSize = INT16_SIZE;\r\n                break;\r\n        }\r\n    } else if (decoder.type === 2) {\r\n        // float\r\n        switch (outputType) {\r\n            case EXROutputType.Float:\r\n                decoder.getter = ParseFloat32;\r\n                decoder.inputSize = FLOAT32_SIZE;\r\n                break;\r\n\r\n            case EXROutputType.HalfFloat:\r\n                decoder.getter = DecodeFloat32;\r\n                decoder.inputSize = FLOAT32_SIZE;\r\n        }\r\n    } else {\r\n        throw new Error(\"Unsupported pixelType \" + decoder.type + \" for \" + header.compression);\r\n    }\r\n\r\n    decoder.blockCount = decoder.height / decoder.scanlineBlockSize;\r\n\r\n    for (let i = 0; i < decoder.blockCount; i++) {\r\n        ParseInt64(dataView, offset); // scanlineOffset\r\n    }\r\n\r\n    // we should be passed the scanline offset table, ready to start reading pixel data.\r\n    const size = decoder.width * decoder.height * decoder.outputChannels;\r\n\r\n    switch (outputType) {\r\n        case EXROutputType.Float:\r\n            decoder.byteArray = new Float32Array(size);\r\n            decoder.textureType = Constants.TEXTURETYPE_FLOAT;\r\n\r\n            // Fill initially with 1s for the alpha value if the texture is not RGBA, RGB values will be overwritten\r\n            if (fillAlpha) {\r\n                decoder.byteArray.fill(1, 0, size);\r\n            }\r\n\r\n            break;\r\n\r\n        case EXROutputType.HalfFloat:\r\n            decoder.byteArray = new Uint16Array(size);\r\n            decoder.textureType = Constants.TEXTURETYPE_HALF_FLOAT;\r\n\r\n            if (fillAlpha) {\r\n                decoder.byteArray.fill(0x3c00, 0, size); // Uint16Array holds half float data, 0x3C00 is 1\r\n            }\r\n\r\n            break;\r\n\r\n        default:\r\n            throw new Error(\"Unsupported type: \" + outputType);\r\n    }\r\n\r\n    let byteOffset = 0;\r\n    for (const channel of header.channels) {\r\n        if (decoder.decodeChannels[channel.name] !== undefined) {\r\n            decoder.channelLineOffsets[channel.name] = byteOffset * decoder.width;\r\n        }\r\n\r\n        byteOffset += channel.pixelType * 2;\r\n    }\r\n\r\n    decoder.bytesPerLine = decoder.width * byteOffset;\r\n    decoder.outLineWidth = decoder.width * decoder.outputChannels;\r\n\r\n    if (header.lineOrder === \"INCREASING_Y\") {\r\n        decoder.scanOrder = (y) => y;\r\n    } else {\r\n        decoder.scanOrder = (y) => decoder.height - 1 - y;\r\n    }\r\n\r\n    if (decoder.outputChannels == 4) {\r\n        decoder.format = Constants.TEXTUREFORMAT_RGBA;\r\n        decoder.linearSpace = true;\r\n    } else {\r\n        decoder.format = Constants.TEXTUREFORMAT_R;\r\n        decoder.linearSpace = false;\r\n    }\r\n\r\n    return decoder;\r\n}\r\n\r\n/**\r\n * Scan the data of the exr file\r\n * @param decoder decoder to use\r\n * @param header header of the exr file\r\n * @param dataView dataview of the exr file\r\n * @param offset current offset\r\n */\r\nexport function ScanData(decoder: IEXRDecoder, header: IEXRHeader, dataView: DataView, offset: DataCursor): void {\r\n    const tmpOffset = { value: 0 };\r\n\r\n    for (let scanlineBlockIdx = 0; scanlineBlockIdx < decoder.height / decoder.scanlineBlockSize; scanlineBlockIdx++) {\r\n        const line = ParseInt32(dataView, offset) - header.dataWindow.yMin; // line_no\r\n        decoder.size = ParseUint32(dataView, offset); // data_len\r\n        decoder.lines = line + decoder.scanlineBlockSize > decoder.height ? decoder.height - line : decoder.scanlineBlockSize;\r\n\r\n        const isCompressed = decoder.size < decoder.lines * decoder.bytesPerLine;\r\n        const viewer = isCompressed && decoder.uncompress ? decoder.uncompress(decoder) : UncompressRAW(decoder);\r\n\r\n        offset.value += decoder.size;\r\n\r\n        for (let line_y = 0; line_y < decoder.scanlineBlockSize; line_y++) {\r\n            const scan_y = scanlineBlockIdx * decoder.scanlineBlockSize;\r\n            const true_y = line_y + decoder.scanOrder(scan_y);\r\n            if (true_y >= decoder.height) {\r\n                continue;\r\n            }\r\n\r\n            const lineOffset = line_y * decoder.bytesPerLine;\r\n            const outLineOffset = (decoder.height - 1 - true_y) * decoder.outLineWidth;\r\n\r\n            for (let channelID = 0; channelID < decoder.channels; channelID++) {\r\n                const name = header.channels[channelID].name;\r\n                const lOff = decoder.channelLineOffsets[name];\r\n                const cOff = decoder.decodeChannels[name];\r\n\r\n                if (cOff === undefined) {\r\n                    continue;\r\n                }\r\n\r\n                tmpOffset.value = lineOffset + lOff;\r\n\r\n                for (let x = 0; x < decoder.width; x++) {\r\n                    const outIndex = outLineOffset + x * decoder.outputChannels + cOff;\r\n                    if (decoder.byteArray) {\r\n                        decoder.byteArray[outIndex] = decoder.getter(viewer, tmpOffset);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n", "import type { Nullable } from \"core/types\";\r\nimport type { InternalTexture } from \"../internalTexture\";\r\nimport type { IInternalTextureLoader } from \"./internalTextureLoader\";\r\nimport { GetExrHeader } from \"./EXR/exrLoader.header\";\r\nimport { CreateDecoderAsync, ScanData } from \"./EXR/exrLoader.decoder\";\r\nimport { ExrLoaderGlobalConfiguration } from \"./EXR/exrLoader.configuration\";\r\n\r\n/**\r\n * Inspired by https://github.com/sciecode/three.js/blob/dev/examples/jsm/loaders/EXRLoader.js\r\n * Referred to the original Industrial Light & Magic OpenEXR implementation and the TinyEXR / Syoyo Fujita\r\n * implementation.\r\n */\r\n\r\n// /*\r\n// Copyright (c) 2014 - 2017, Syoyo Fujita\r\n// All rights reserved.\r\n\r\n// Redistribution and use in source and binary forms, with or without\r\n// modification, are permitted provided that the following conditions are met:\r\n//     * Redistributions of source code must retain the above copyright\r\n//       notice, this list of conditions and the following disclaimer.\r\n//     * Redistributions in binary form must reproduce the above copyright\r\n//       notice, this list of conditions and the following disclaimer in the\r\n//       documentation and/or other materials provided with the distribution.\r\n//     * Neither the name of the Syoyo Fujita nor the\r\n//       names of its contributors may be used to endorse or promote products\r\n//       derived from this software without specific prior written permission.\r\n\r\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\r\n// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n// DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\r\n// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\r\n// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\r\n// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\r\n// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\r\n// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n// */\r\n\r\n// // TinyEXR contains some OpenEXR code, which is licensed under ------------\r\n\r\n// ///////////////////////////////////////////////////////////////////////////\r\n// //\r\n// // Copyright (c) 2002, Industrial Light & Magic, a division of Lucas\r\n// // Digital Ltd. LLC\r\n// //\r\n// // All rights reserved.\r\n// //\r\n// // Redistribution and use in source and binary forms, with or without\r\n// // modification, are permitted provided that the following conditions are\r\n// // met:\r\n// // *       Redistributions of source code must retain the above copyright\r\n// // notice, this list of conditions and the following disclaimer.\r\n// // *       Redistributions in binary form must reproduce the above\r\n// // copyright notice, this list of conditions and the following disclaimer\r\n// // in the documentation and/or other materials provided with the\r\n// // distribution.\r\n// // *       Neither the name of Industrial Light & Magic nor the names of\r\n// // its contributors may be used to endorse or promote products derived\r\n// // from this software without specific prior written permission.\r\n// //\r\n// // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\r\n// // \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\r\n// // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\r\n// // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\r\n// // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n// // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\r\n// // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\r\n// // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\r\n// // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n// // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\r\n// // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n// //\r\n// ///////////////////////////////////////////////////////////////////////////\r\n\r\n// // End of OpenEXR license -------------------------------------------------\r\n\r\n/**\r\n * Loader for .exr file format\r\n * @see [PIZ compression](https://playground.babylonjs.com/#4RN0VF#151)\r\n * @see [ZIP compression](https://playground.babylonjs.com/#4RN0VF#146)\r\n * @see [RLE compression](https://playground.babylonjs.com/#4RN0VF#149)\r\n * @see [PXR24 compression](https://playground.babylonjs.com/#4RN0VF#150)\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class _ExrTextureLoader implements IInternalTextureLoader {\r\n    /**\r\n     * Defines whether the loader supports cascade loading the different faces.\r\n     */\r\n    public readonly supportCascades = false;\r\n\r\n    /**\r\n     * Uploads the cube texture data to the WebGL texture. It has already been bound.\r\n     * @param _data contains the texture data\r\n     * @param _texture defines the BabylonJS internal texture\r\n     * @param _createPolynomials will be true if polynomials have been requested\r\n     * @param _onLoad defines the callback to trigger once the texture is ready\r\n     * @param _onError defines the callback to trigger in case of error\r\n     * Cube texture are not supported by .exr files\r\n     */\r\n    public loadCubeData(\r\n        _data: ArrayBufferView | ArrayBufferView[],\r\n        _texture: InternalTexture,\r\n        _createPolynomials: boolean,\r\n        _onLoad: Nullable<(data?: any) => void>,\r\n        _onError: Nullable<(message?: string, exception?: any) => void>\r\n    ): void {\r\n        // eslint-disable-next-line no-throw-literal\r\n        throw \".exr not supported in Cube.\";\r\n    }\r\n\r\n    /**\r\n     * Uploads the 2D texture data to the WebGL texture. It has already been bound once in the callback.\r\n     * @param data contains the texture data\r\n     * @param texture defines the BabylonJS internal texture\r\n     * @param callback defines the method to call once ready to upload\r\n     */\r\n    public async loadData(\r\n        data: ArrayBufferView,\r\n        texture: InternalTexture,\r\n        callback: (width: number, height: number, loadMipmap: boolean, isCompressed: boolean, done: () => void, failedLoading?: boolean) => void\r\n    ) {\r\n        const dataView = new DataView(data.buffer);\r\n\r\n        const offset = { value: 0 };\r\n        const header = GetExrHeader(dataView, offset);\r\n        const decoder = await CreateDecoderAsync(header, dataView, offset, ExrLoaderGlobalConfiguration.DefaultOutputType);\r\n\r\n        ScanData(decoder, header, dataView, offset);\r\n\r\n        // Updating texture\r\n        const width = header.dataWindow.xMax - header.dataWindow.xMin + 1;\r\n        const height = header.dataWindow.yMax - header.dataWindow.yMin + 1;\r\n        callback(width, height, texture.generateMipMaps, false, () => {\r\n            const engine = texture.getEngine();\r\n            texture.format = header.format;\r\n            texture.type = decoder.textureType;\r\n            texture.invertY = false;\r\n            texture._gammaSpace = !header.linearSpace;\r\n            if (decoder.byteArray) {\r\n                engine._uploadDataToTextureDirectly(texture, decoder.byteArray, 0, 0, undefined, true);\r\n            }\r\n        });\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": ["CompressionCodes", "LineOrders", "EXROutputType"]
}
