{
  "version": 3,
  "sources": ["../../../dev/core/src/Buffers/bufferUtils.ts", "../../../dev/core/src/Buffers/buffer.ts"],
  "sourcesContent": ["import { Constants } from \"../Engines/constants\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport type { DataArray, FloatArray, IndicesArray, TypedArray, TypedArrayConstructor } from \"../types\";\r\n\r\n/**\r\n * Union of TypedArrays that can be used for vertex data.\r\n */\r\nexport type VertexDataTypedArray = Exclude<TypedArray, Float64Array | BigInt64Array | BigUint64Array>;\r\n\r\nfunction GetFloatValue(dataView: DataView, type: number, byteOffset: number, normalized: boolean): number {\r\n    switch (type) {\r\n        case Constants.BYTE: {\r\n            let value = dataView.getInt8(byteOffset);\r\n            if (normalized) {\r\n                value = Math.max(value / 127, -1);\r\n            }\r\n            return value;\r\n        }\r\n        case Constants.UNSIGNED_BYTE: {\r\n            let value = dataView.getUint8(byteOffset);\r\n            if (normalized) {\r\n                value = value / 255;\r\n            }\r\n            return value;\r\n        }\r\n        case Constants.SHORT: {\r\n            let value = dataView.getInt16(byteOffset, true);\r\n            if (normalized) {\r\n                value = Math.max(value / 32767, -1);\r\n            }\r\n            return value;\r\n        }\r\n        case Constants.UNSIGNED_SHORT: {\r\n            let value = dataView.getUint16(byteOffset, true);\r\n            if (normalized) {\r\n                value = value / 65535;\r\n            }\r\n            return value;\r\n        }\r\n        case Constants.INT: {\r\n            return dataView.getInt32(byteOffset, true);\r\n        }\r\n        case Constants.UNSIGNED_INT: {\r\n            return dataView.getUint32(byteOffset, true);\r\n        }\r\n        case Constants.FLOAT: {\r\n            return dataView.getFloat32(byteOffset, true);\r\n        }\r\n        default: {\r\n            throw new Error(`Invalid component type ${type}`);\r\n        }\r\n    }\r\n}\r\n\r\nfunction SetFloatValue(dataView: DataView, type: number, byteOffset: number, normalized: boolean, value: number): void {\r\n    switch (type) {\r\n        case Constants.BYTE: {\r\n            if (normalized) {\r\n                value = Math.round(value * 127.0);\r\n            }\r\n            dataView.setInt8(byteOffset, value);\r\n            break;\r\n        }\r\n        case Constants.UNSIGNED_BYTE: {\r\n            if (normalized) {\r\n                value = Math.round(value * 255);\r\n            }\r\n            dataView.setUint8(byteOffset, value);\r\n            break;\r\n        }\r\n        case Constants.SHORT: {\r\n            if (normalized) {\r\n                value = Math.round(value * 32767);\r\n            }\r\n            dataView.setInt16(byteOffset, value, true);\r\n            break;\r\n        }\r\n        case Constants.UNSIGNED_SHORT: {\r\n            if (normalized) {\r\n                value = Math.round(value * 65535);\r\n            }\r\n            dataView.setUint16(byteOffset, value, true);\r\n            break;\r\n        }\r\n        case Constants.INT: {\r\n            dataView.setInt32(byteOffset, value, true);\r\n            break;\r\n        }\r\n        case Constants.UNSIGNED_INT: {\r\n            dataView.setUint32(byteOffset, value, true);\r\n            break;\r\n        }\r\n        case Constants.FLOAT: {\r\n            dataView.setFloat32(byteOffset, value, true);\r\n            break;\r\n        }\r\n        default: {\r\n            throw new Error(`Invalid component type ${type}`);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Gets the byte length of the given type.\r\n * @param type the type\r\n * @returns the number of bytes\r\n */\r\nexport function GetTypeByteLength(type: number): number {\r\n    switch (type) {\r\n        case Constants.BYTE:\r\n        case Constants.UNSIGNED_BYTE:\r\n            return 1;\r\n        case Constants.SHORT:\r\n        case Constants.UNSIGNED_SHORT:\r\n            return 2;\r\n        case Constants.INT:\r\n        case Constants.UNSIGNED_INT:\r\n        case Constants.FLOAT:\r\n            return 4;\r\n        default:\r\n            throw new Error(`Invalid type '${type}'`);\r\n    }\r\n}\r\n\r\n/**\r\n * Gets the appropriate TypedArray constructor for the given component type.\r\n * @param componentType the component type\r\n * @returns the constructor object\r\n */\r\nexport function GetTypedArrayConstructor(componentType: number): TypedArrayConstructor<VertexDataTypedArray> {\r\n    switch (componentType) {\r\n        case Constants.BYTE:\r\n            return Int8Array;\r\n        case Constants.UNSIGNED_BYTE:\r\n            return Uint8Array;\r\n        case Constants.SHORT:\r\n            return Int16Array;\r\n        case Constants.UNSIGNED_SHORT:\r\n            return Uint16Array;\r\n        case Constants.INT:\r\n            return Int32Array;\r\n        case Constants.UNSIGNED_INT:\r\n            return Uint32Array;\r\n        case Constants.FLOAT:\r\n            return Float32Array;\r\n        default:\r\n            throw new Error(`Invalid component type '${componentType}'`);\r\n    }\r\n}\r\n\r\n/**\r\n * Enumerates each value of the data array and calls the given callback.\r\n * @param data the data to enumerate\r\n * @param byteOffset the byte offset of the data\r\n * @param byteStride the byte stride of the data\r\n * @param componentCount the number of components per element\r\n * @param componentType the type of the component\r\n * @param count the number of values to enumerate\r\n * @param normalized whether the data is normalized\r\n * @param callback the callback function called for each group of component values\r\n */\r\nexport function EnumerateFloatValues(\r\n    data: DataArray,\r\n    byteOffset: number,\r\n    byteStride: number,\r\n    componentCount: number,\r\n    componentType: number,\r\n    count: number,\r\n    normalized: boolean,\r\n    callback: (values: number[], index: number) => void\r\n): void {\r\n    const oldValues = new Array<number>(componentCount);\r\n    const newValues = new Array<number>(componentCount);\r\n\r\n    if (data instanceof Array) {\r\n        let offset = byteOffset / 4;\r\n        const stride = byteStride / 4;\r\n        for (let index = 0; index < count; index += componentCount) {\r\n            for (let componentIndex = 0; componentIndex < componentCount; componentIndex++) {\r\n                oldValues[componentIndex] = newValues[componentIndex] = data[offset + componentIndex];\r\n            }\r\n\r\n            callback(newValues, index);\r\n\r\n            for (let componentIndex = 0; componentIndex < componentCount; componentIndex++) {\r\n                if (oldValues[componentIndex] !== newValues[componentIndex]) {\r\n                    data[offset + componentIndex] = newValues[componentIndex];\r\n                }\r\n            }\r\n\r\n            offset += stride;\r\n        }\r\n    } else {\r\n        const dataView = !ArrayBuffer.isView(data) ? new DataView(data) : new DataView(data.buffer, data.byteOffset, data.byteLength);\r\n        const componentByteLength = GetTypeByteLength(componentType);\r\n        for (let index = 0; index < count; index += componentCount) {\r\n            for (let componentIndex = 0, componentByteOffset = byteOffset; componentIndex < componentCount; componentIndex++, componentByteOffset += componentByteLength) {\r\n                oldValues[componentIndex] = newValues[componentIndex] = GetFloatValue(dataView, componentType, componentByteOffset, normalized);\r\n            }\r\n\r\n            callback(newValues, index);\r\n\r\n            for (let componentIndex = 0, componentByteOffset = byteOffset; componentIndex < componentCount; componentIndex++, componentByteOffset += componentByteLength) {\r\n                if (oldValues[componentIndex] !== newValues[componentIndex]) {\r\n                    SetFloatValue(dataView, componentType, componentByteOffset, normalized, newValues[componentIndex]);\r\n                }\r\n            }\r\n\r\n            byteOffset += byteStride;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Gets the given data array as a float array. Float data is constructed if the data array cannot be returned directly.\r\n * @param data the input data array\r\n * @param size the number of components\r\n * @param type the component type\r\n * @param byteOffset the byte offset of the data\r\n * @param byteStride the byte stride of the data\r\n * @param normalized whether the data is normalized\r\n * @param totalVertices number of vertices in the buffer to take into account\r\n * @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it\r\n * @returns a float array containing vertex data\r\n */\r\nexport function GetFloatData(\r\n    data: DataArray,\r\n    size: number,\r\n    type: number,\r\n    byteOffset: number,\r\n    byteStride: number,\r\n    normalized: boolean,\r\n    totalVertices: number,\r\n    forceCopy?: boolean\r\n): FloatArray {\r\n    const tightlyPackedByteStride = size * GetTypeByteLength(type);\r\n    const count = totalVertices * size;\r\n\r\n    if (type !== Constants.FLOAT || byteStride !== tightlyPackedByteStride) {\r\n        const copy = new Float32Array(count);\r\n        EnumerateFloatValues(data, byteOffset, byteStride, size, type, count, normalized, (values, index) => {\r\n            for (let i = 0; i < size; i++) {\r\n                copy[index + i] = values[i];\r\n            }\r\n        });\r\n        return copy;\r\n    }\r\n\r\n    if (!(data instanceof Array || data instanceof Float32Array) || byteOffset !== 0 || data.length !== count) {\r\n        if (data instanceof Array) {\r\n            const offset = byteOffset / 4;\r\n            return data.slice(offset, offset + count);\r\n        } else if (data instanceof ArrayBuffer) {\r\n            return new Float32Array(data, byteOffset, count);\r\n        } else {\r\n            const offset = data.byteOffset + byteOffset;\r\n            if ((offset & 3) !== 0) {\r\n                Logger.Warn(\"Float array must be aligned to 4-bytes border\");\r\n                forceCopy = true;\r\n            }\r\n\r\n            if (forceCopy) {\r\n                return new Float32Array(data.buffer.slice(offset, offset + count * Float32Array.BYTES_PER_ELEMENT));\r\n            } else {\r\n                return new Float32Array(data.buffer, offset, count);\r\n            }\r\n        }\r\n    }\r\n\r\n    if (forceCopy) {\r\n        return data.slice();\r\n    }\r\n\r\n    return data;\r\n}\r\n\r\n/**\r\n * Gets the given data array as a typed array that matches the component type. If the data cannot be used directly, a copy is made to support the new typed array.\r\n * If the data is number[], byteOffset and byteStride must be a multiple of 4, as data will be treated like a list of floats.\r\n * @param data the input data array\r\n * @param size the number of components\r\n * @param type the component type\r\n * @param byteOffset the byte offset of the data\r\n * @param byteStride the byte stride of the data\r\n * @param normalized whether the data is normalized\r\n * @param totalVertices number of vertices in the buffer to take into account\r\n * @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it\r\n * @returns a typed array containing vertex data\r\n */\r\nexport function GetTypedArrayData(\r\n    data: DataArray,\r\n    size: number,\r\n    type: number,\r\n    byteOffset: number,\r\n    byteStride: number,\r\n    normalized: boolean,\r\n    totalVertices: number,\r\n    forceCopy?: boolean\r\n): VertexDataTypedArray {\r\n    const typeByteLength = GetTypeByteLength(type);\r\n    const constructor = GetTypedArrayConstructor(type);\r\n    const count = totalVertices * size;\r\n\r\n    // Handle number[]\r\n    if (Array.isArray(data)) {\r\n        if ((byteOffset & 3) !== 0 || (byteStride & 3) !== 0) {\r\n            throw new Error(\"byteOffset and byteStride must be a multiple of 4 for number[] data.\");\r\n        }\r\n\r\n        const offset = byteOffset / 4;\r\n        const stride = byteStride / 4;\r\n\r\n        const lastIndex = offset + (totalVertices - 1) * stride + size;\r\n        if (lastIndex > data.length) {\r\n            throw new Error(\"Last accessed index is out of bounds.\");\r\n        }\r\n\r\n        if (stride < size) {\r\n            throw new Error(\"Data stride cannot be smaller than the component size.\");\r\n        }\r\n        if (stride !== size) {\r\n            const copy = new constructor(count);\r\n            EnumerateFloatValues(data, byteOffset, byteStride, size, type, count, normalized, (values, index) => {\r\n                for (let i = 0; i < size; i++) {\r\n                    copy[index + i] = values[i];\r\n                }\r\n            });\r\n            return copy;\r\n        }\r\n\r\n        return new constructor(data.slice(offset, offset + count));\r\n    }\r\n\r\n    // Handle ArrayBuffer and ArrayBufferView\r\n    let buffer: ArrayBuffer;\r\n    let adjustedByteOffset = byteOffset;\r\n\r\n    if (data instanceof ArrayBuffer) {\r\n        buffer = data;\r\n    } else {\r\n        buffer = data.buffer;\r\n        adjustedByteOffset += data.byteOffset;\r\n    }\r\n\r\n    const lastByteOffset = adjustedByteOffset + (totalVertices - 1) * byteStride + size * typeByteLength;\r\n    if (lastByteOffset > buffer.byteLength) {\r\n        throw new Error(\"Last accessed byte is out of bounds.\");\r\n    }\r\n\r\n    const tightlyPackedByteStride = size * typeByteLength;\r\n    if (byteStride < tightlyPackedByteStride) {\r\n        throw new Error(\"Byte stride cannot be smaller than the component's byte size.\");\r\n    }\r\n    if (byteStride !== tightlyPackedByteStride) {\r\n        const copy = new constructor(count);\r\n        EnumerateFloatValues(buffer, adjustedByteOffset, byteStride, size, type, count, normalized, (values, index) => {\r\n            for (let i = 0; i < size; i++) {\r\n                copy[index + i] = values[i];\r\n            }\r\n        });\r\n        return copy;\r\n    }\r\n\r\n    if (typeByteLength !== 1 && (adjustedByteOffset & (typeByteLength - 1)) !== 0) {\r\n        Logger.Warn(\"Array must be aligned to border of element size. Data will be copied.\");\r\n        forceCopy = true;\r\n    }\r\n\r\n    if (forceCopy) {\r\n        return new constructor(buffer.slice(adjustedByteOffset, adjustedByteOffset + count * typeByteLength));\r\n    }\r\n\r\n    return new constructor(buffer, adjustedByteOffset, count);\r\n}\r\n\r\n/**\r\n * Copies the given data array to the given float array.\r\n * @param input the input data array\r\n * @param size the number of components\r\n * @param type the component type\r\n * @param byteOffset the byte offset of the data\r\n * @param byteStride the byte stride of the data\r\n * @param normalized whether the data is normalized\r\n * @param totalVertices number of vertices in the buffer to take into account\r\n * @param output the output float array\r\n */\r\nexport function CopyFloatData(\r\n    input: DataArray,\r\n    size: number,\r\n    type: number,\r\n    byteOffset: number,\r\n    byteStride: number,\r\n    normalized: boolean,\r\n    totalVertices: number,\r\n    output: Float32Array\r\n): void {\r\n    const tightlyPackedByteStride = size * GetTypeByteLength(type);\r\n    const count = totalVertices * size;\r\n\r\n    if (output.length !== count) {\r\n        throw new Error(\"Output length is not valid\");\r\n    }\r\n\r\n    if (type !== Constants.FLOAT || byteStride !== tightlyPackedByteStride) {\r\n        EnumerateFloatValues(input, byteOffset, byteStride, size, type, count, normalized, (values, index) => {\r\n            for (let i = 0; i < size; i++) {\r\n                output[index + i] = values[i];\r\n            }\r\n        });\r\n        return;\r\n    }\r\n\r\n    if (input instanceof Array) {\r\n        const offset = byteOffset / 4;\r\n        output.set(input, offset);\r\n    } else if (input instanceof ArrayBuffer) {\r\n        const floatData = new Float32Array(input, byteOffset, count);\r\n        output.set(floatData);\r\n    } else {\r\n        const offset = input.byteOffset + byteOffset;\r\n        if ((offset & 3) !== 0) {\r\n            Logger.Warn(\"Float array must be aligned to 4-bytes border\");\r\n            output.set(new Float32Array(input.buffer.slice(offset, offset + count * Float32Array.BYTES_PER_ELEMENT)));\r\n            return;\r\n        }\r\n\r\n        const floatData = new Float32Array(input.buffer, offset, count);\r\n        output.set(floatData);\r\n    }\r\n}\r\n\r\n/**\r\n * Utility function to determine if an IndicesArray is an Uint32Array. If indices is an Array, determines whether at least one index is 32 bits.\r\n * @param indices The IndicesArray to check.\r\n * @param count The number of indices. Only used if indices is an Array.\r\n * @param start The offset to start at (default: 0). Only used if indices is an Array.\r\n * @param offset The offset to substract from the indices before testing (default: 0). Only used if indices is an Array.\r\n * @returns True if the indices use 32 bits\r\n */\r\nexport function AreIndices32Bits(indices: IndicesArray, count: number, start = 0, offset = 0): boolean {\r\n    if (Array.isArray(indices)) {\r\n        for (let index = 0; index < count; index++) {\r\n            if (indices[start + index] - offset > 65535) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    return indices.BYTES_PER_ELEMENT === 4;\r\n}\r\n\r\n/**\r\n * Creates a typed array suitable for GPU buffer operations, as some engines require CPU buffer sizes to be aligned to specific boundaries (e.g., 4 bytes).\r\n * The use of non-aligned arrays still works but may result in a performance penalty.\r\n * @param type The type of the array. For instance, Float32Array or Uint8Array\r\n * @param elementCount The number of elements to store in the array\r\n * @returns The aligned typed array\r\n */\r\nexport function CreateAlignedTypedArray<T extends TypedArray>(type: TypedArrayConstructor<T>, elementCount: number): T {\r\n    let byteSize = elementCount * type.BYTES_PER_ELEMENT;\r\n\r\n    if ((byteSize & 3) === 0) {\r\n        return new type(elementCount);\r\n    }\r\n\r\n    byteSize = (byteSize + 3) & ~3;\r\n\r\n    const backingBuffer = new ArrayBuffer(byteSize);\r\n\r\n    return new type(backingBuffer, 0, elementCount);\r\n}\r\n", "import type { Nullable, DataArray, FloatArray } from \"../types\";\r\nimport type { AbstractEngine } from \"../Engines/abstractEngine\";\r\nimport { DataBuffer } from \"./dataBuffer\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { EnumerateFloatValues, GetFloatData, GetTypeByteLength } from \"./bufferUtils\";\r\n\r\n/**\r\n * Class used to store data that will be store in GPU memory\r\n */\r\nexport class Buffer {\r\n    private _engine: AbstractEngine;\r\n    private _buffer: Nullable<DataBuffer>;\r\n    /** @internal */\r\n    public _data: Nullable<DataArray>;\r\n    private _updatable: boolean;\r\n    private _instanced: boolean;\r\n    private _divisor: number;\r\n    private _isAlreadyOwned = false;\r\n    private _isDisposed = false;\r\n    private _label?: string;\r\n\r\n    /**\r\n     * Gets a boolean indicating if the Buffer is disposed\r\n     */\r\n    public get isDisposed(): boolean {\r\n        return this._isDisposed;\r\n    }\r\n\r\n    /**\r\n     * Gets the byte stride.\r\n     */\r\n    public readonly byteStride: number;\r\n\r\n    /**\r\n     * Constructor\r\n     * @param engine the engine\r\n     * @param data the data to use for this buffer\r\n     * @param updatable whether the data is updatable\r\n     * @param stride the stride (optional)\r\n     * @param postponeInternalCreation whether to postpone creating the internal WebGL buffer (optional)\r\n     * @param instanced whether the buffer is instanced (optional)\r\n     * @param useBytes set to true if the stride in in bytes (optional)\r\n     * @param divisor sets an optional divisor for instances (1 by default)\r\n     * @param label defines the label of the buffer (for debug purpose)\r\n     */\r\n    constructor(\r\n        engine: AbstractEngine,\r\n        data: DataArray | DataBuffer,\r\n        updatable: boolean,\r\n        stride = 0,\r\n        postponeInternalCreation = false,\r\n        instanced = false,\r\n        useBytes = false,\r\n        divisor?: number,\r\n        label?: string\r\n    ) {\r\n        if (engine && (engine as unknown as Mesh).getScene) {\r\n            // old versions of VertexBuffer accepted 'mesh' instead of 'engine'\r\n            this._engine = (engine as unknown as Mesh).getScene().getEngine();\r\n        } else {\r\n            this._engine = engine;\r\n        }\r\n\r\n        this._updatable = updatable;\r\n        this._instanced = instanced;\r\n        this._divisor = divisor || 1;\r\n        this._label = label;\r\n\r\n        if (data instanceof DataBuffer) {\r\n            this._data = null;\r\n            this._buffer = data;\r\n        } else {\r\n            this._data = data;\r\n            this._buffer = null;\r\n        }\r\n\r\n        this.byteStride = useBytes ? stride : stride * Float32Array.BYTES_PER_ELEMENT;\r\n\r\n        if (!postponeInternalCreation) {\r\n            // by default\r\n            this.create();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a new VertexBuffer based on the current buffer\r\n     * @param kind defines the vertex buffer kind (position, normal, etc.)\r\n     * @param offset defines offset in the buffer (0 by default)\r\n     * @param size defines the size in floats of attributes (position is 3 for instance)\r\n     * @param stride defines the stride size in floats in the buffer (the offset to apply to reach next value when data is interleaved)\r\n     * @param instanced defines if the vertex buffer contains indexed data\r\n     * @param useBytes defines if the offset and stride are in bytes     *\r\n     * @param divisor sets an optional divisor for instances (1 by default)\r\n     * @returns the new vertex buffer\r\n     */\r\n    public createVertexBuffer(kind: string, offset: number, size: number, stride?: number, instanced?: boolean, useBytes = false, divisor?: number): VertexBuffer {\r\n        const byteOffset = useBytes ? offset : offset * Float32Array.BYTES_PER_ELEMENT;\r\n        const byteStride = stride ? (useBytes ? stride : stride * Float32Array.BYTES_PER_ELEMENT) : this.byteStride;\r\n\r\n        // a lot of these parameters are ignored as they are overridden by the buffer\r\n        return new VertexBuffer(\r\n            this._engine,\r\n            this,\r\n            kind,\r\n            this._updatable,\r\n            true,\r\n            byteStride,\r\n            instanced === undefined ? this._instanced : instanced,\r\n            byteOffset,\r\n            size,\r\n            undefined,\r\n            undefined,\r\n            true,\r\n            this._divisor || divisor\r\n        );\r\n    }\r\n\r\n    // Properties\r\n\r\n    /**\r\n     * Gets a boolean indicating if the Buffer is updatable?\r\n     * @returns true if the buffer is updatable\r\n     */\r\n    public isUpdatable(): boolean {\r\n        return this._updatable;\r\n    }\r\n\r\n    /**\r\n     * Gets current buffer's data\r\n     * @returns a DataArray or null\r\n     */\r\n    public getData(): Nullable<DataArray> {\r\n        return this._data;\r\n    }\r\n\r\n    /**\r\n     * Gets underlying native buffer\r\n     * @returns underlying native buffer\r\n     */\r\n    public getBuffer(): Nullable<DataBuffer> {\r\n        return this._buffer;\r\n    }\r\n\r\n    /**\r\n     * Gets the stride in float32 units (i.e. byte stride / 4).\r\n     * May not be an integer if the byte stride is not divisible by 4.\r\n     * @returns the stride in float32 units\r\n     * @deprecated Please use byteStride instead.\r\n     */\r\n    public getStrideSize(): number {\r\n        return this.byteStride / Float32Array.BYTES_PER_ELEMENT;\r\n    }\r\n\r\n    // Methods\r\n\r\n    /**\r\n     * Store data into the buffer. Creates the buffer if not used already.\r\n     * If the buffer was already used, it will be updated only if it is updatable, otherwise it will do nothing.\r\n     * @param data defines the data to store\r\n     */\r\n    public create(data: Nullable<DataArray> = null): void {\r\n        if (!data && this._buffer) {\r\n            return; // nothing to do\r\n        }\r\n\r\n        data = data || this._data;\r\n\r\n        if (!data) {\r\n            return;\r\n        }\r\n\r\n        if (!this._buffer) {\r\n            // create buffer\r\n            if (this._updatable) {\r\n                this._buffer = this._engine.createDynamicVertexBuffer(data, this._label);\r\n                this._data = data;\r\n            } else {\r\n                this._buffer = this._engine.createVertexBuffer(data, undefined, this._label);\r\n            }\r\n        } else if (this._updatable) {\r\n            // update buffer\r\n            this._engine.updateDynamicVertexBuffer(this._buffer, data);\r\n            this._data = data;\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _rebuild(): void {\r\n        if (!this._data) {\r\n            if (!this._buffer) {\r\n                // Buffer was not yet created, nothing to do\r\n                return;\r\n            }\r\n            if (this._buffer.capacity > 0) {\r\n                // We can at least recreate the buffer with the right size, even if we don't have the data\r\n                if (this._updatable) {\r\n                    this._buffer = this._engine.createDynamicVertexBuffer(this._buffer.capacity, this._label);\r\n                } else {\r\n                    this._buffer = this._engine.createVertexBuffer(this._buffer.capacity, undefined, this._label);\r\n                }\r\n                return;\r\n            }\r\n            Logger.Warn(`Missing data for buffer \"${this._label}\" ${this._buffer ? \"(uniqueId: \" + this._buffer.uniqueId + \")\" : \"\"}. Buffer reconstruction failed.`);\r\n            this._buffer = null;\r\n        } else {\r\n            this._buffer = null;\r\n            this.create(this._data);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update current buffer data\r\n     * @param data defines the data to store\r\n     */\r\n    public update(data: DataArray): void {\r\n        this.create(data);\r\n    }\r\n\r\n    /**\r\n     * Updates the data directly.\r\n     * @param data the new data\r\n     * @param offset the new offset\r\n     * @param vertexCount the vertex count (optional)\r\n     * @param useBytes set to true if the offset is in bytes\r\n     */\r\n    public updateDirectly(data: DataArray, offset: number, vertexCount?: number, useBytes: boolean = false): void {\r\n        if (!this._buffer) {\r\n            return;\r\n        }\r\n\r\n        if (this._updatable) {\r\n            // update buffer\r\n            this._engine.updateDynamicVertexBuffer(\r\n                this._buffer,\r\n                data,\r\n                useBytes ? offset : offset * Float32Array.BYTES_PER_ELEMENT,\r\n                vertexCount ? vertexCount * this.byteStride : undefined\r\n            );\r\n            if (offset === 0 && vertexCount === undefined) {\r\n                // Keep the data if we easily can\r\n                this._data = data;\r\n            } else {\r\n                this._data = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _increaseReferences() {\r\n        if (!this._buffer) {\r\n            return;\r\n        }\r\n\r\n        if (!this._isAlreadyOwned) {\r\n            this._isAlreadyOwned = true;\r\n            return;\r\n        }\r\n\r\n        this._buffer.references++;\r\n    }\r\n\r\n    /**\r\n     * Release all resources\r\n     */\r\n    public dispose(): void {\r\n        if (!this._buffer) {\r\n            return;\r\n        }\r\n\r\n        // The data buffer has an internal counter as this buffer can be used by several VertexBuffer objects\r\n        // This means that we only flag it as disposed when all references are released (when _releaseBuffer will return true)\r\n        if (this._engine._releaseBuffer(this._buffer)) {\r\n            this._isDisposed = true;\r\n            this._data = null;\r\n            this._buffer = null;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Options to be used when creating a vertex buffer\r\n */\r\nexport interface IVertexBufferOptions {\r\n    /**\r\n     * whether the data is updatable (default: false)\r\n     */\r\n    updatable?: boolean;\r\n    /**\r\n     * whether to postpone creating the internal WebGL buffer (default: false)\r\n     */\r\n    postponeInternalCreation?: boolean;\r\n    /**\r\n     * the stride (will be automatically computed from the kind parameter if not specified)\r\n     */\r\n    stride?: number;\r\n    /**\r\n     * whether the buffer is instanced (default: false)\r\n     */\r\n    instanced?: boolean;\r\n    /**\r\n     * the offset of the data (default: 0)\r\n     */\r\n    offset?: number;\r\n    /**\r\n     * the number of components (will be automatically computed from the kind parameter if not specified)\r\n     */\r\n    size?: number;\r\n    /**\r\n     * the type of the component (will be deduce from the data parameter if not specified)\r\n     */\r\n    type?: number;\r\n    /**\r\n     * whether the data contains normalized data (default: false)\r\n     */\r\n    normalized?: boolean;\r\n    /**\r\n     * set to true if stride and offset are in bytes (default: false)\r\n     */\r\n    useBytes?: boolean;\r\n    /**\r\n     * defines the instance divisor to use (default: 1, only used if instanced is true)\r\n     */\r\n    divisor?: number;\r\n    /**\r\n     * defines if the buffer should be released when the vertex buffer is disposed (default: false)\r\n     */\r\n    takeBufferOwnership?: boolean;\r\n    /**\r\n     * label to use for this vertex buffer (debugging purpose)\r\n     */\r\n    label?: string;\r\n}\r\n\r\n/**\r\n * Specialized buffer used to store vertex data\r\n */\r\nexport class VertexBuffer {\r\n    private static _Counter = 0;\r\n\r\n    /** @internal */\r\n    public _buffer: Buffer;\r\n    /** @internal */\r\n    public _validOffsetRange: boolean; // used internally by the engine\r\n    private _kind: string;\r\n    private _size: number;\r\n    /** @internal */\r\n    public _ownsBuffer: boolean;\r\n    private _instanced: boolean;\r\n    private _instanceDivisor: number;\r\n    /** @internal */\r\n    public _isDisposed = false;\r\n    /** @internal */\r\n    public _label?: string;\r\n\r\n    /**\r\n     * The byte type.\r\n     */\r\n    public static readonly BYTE = Constants.BYTE;\r\n\r\n    /**\r\n     * The unsigned byte type.\r\n     */\r\n    public static readonly UNSIGNED_BYTE = Constants.UNSIGNED_BYTE;\r\n\r\n    /**\r\n     * The short type.\r\n     */\r\n    public static readonly SHORT = Constants.SHORT;\r\n\r\n    /**\r\n     * The unsigned short type.\r\n     */\r\n    public static readonly UNSIGNED_SHORT = Constants.UNSIGNED_SHORT;\r\n\r\n    /**\r\n     * The integer type.\r\n     */\r\n    public static readonly INT = Constants.INT;\r\n\r\n    /**\r\n     * The unsigned integer type.\r\n     */\r\n    public static readonly UNSIGNED_INT = Constants.UNSIGNED_INT;\r\n\r\n    /**\r\n     * The float type.\r\n     */\r\n    public static readonly FLOAT = Constants.FLOAT;\r\n\r\n    /**\r\n     * Gets a boolean indicating if the Buffer is disposed\r\n     */\r\n    public get isDisposed(): boolean {\r\n        return this._isDisposed;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the instance divisor when in instanced mode\r\n     */\r\n    public get instanceDivisor(): number {\r\n        return this._instanceDivisor;\r\n    }\r\n\r\n    public set instanceDivisor(value: number) {\r\n        const isInstanced = value != 0;\r\n        this._instanceDivisor = value;\r\n\r\n        if (isInstanced !== this._instanced) {\r\n            this._instanced = isInstanced;\r\n            this._computeHashCode();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the byte stride.\r\n     */\r\n    public readonly byteStride: number;\r\n\r\n    /**\r\n     * Gets the byte offset.\r\n     */\r\n    public readonly byteOffset: number;\r\n\r\n    /**\r\n     * Gets whether integer data values should be normalized into a certain range when being casted to a float.\r\n     */\r\n    public readonly normalized: boolean;\r\n\r\n    /**\r\n     * Gets the data type of each component in the array.\r\n     */\r\n    public readonly type: number;\r\n\r\n    /**\r\n     * Gets the unique id of this vertex buffer\r\n     */\r\n    public readonly uniqueId: number;\r\n\r\n    /**\r\n     * Gets a hash code representing the format (type, normalized, size, instanced, stride) of this buffer\r\n     * All buffers with the same format will have the same hash code\r\n     */\r\n    public readonly hashCode: number;\r\n\r\n    /**\r\n     * Gets the engine associated with the buffer\r\n     */\r\n    public readonly engine: AbstractEngine;\r\n\r\n    /**\r\n     * Gets the max possible amount of vertices stored within the current vertex buffer.\r\n     * We do not have the end offset or count so this will be too big for concatenated vertex buffers.\r\n     * @internal\r\n     */\r\n    public get _maxVerticesCount() {\r\n        const data = this.getData();\r\n        if (!data) {\r\n            return 0;\r\n        }\r\n\r\n        if (Array.isArray(data)) {\r\n            // data is a regular number[] with float values\r\n            return data.length / (this.byteStride / 4) - this.byteOffset / 4;\r\n        }\r\n\r\n        return (data.byteLength - this.byteOffset) / this.byteStride;\r\n    }\r\n\r\n    /**\r\n     * Constructor\r\n     * @param engine the engine\r\n     * @param data the data to use for this vertex buffer\r\n     * @param kind the vertex buffer kind\r\n     * @param updatable whether the data is updatable\r\n     * @param postponeInternalCreation whether to postpone creating the internal WebGL buffer (optional)\r\n     * @param stride the stride (optional)\r\n     * @param instanced whether the buffer is instanced (optional)\r\n     * @param offset the offset of the data (optional)\r\n     * @param size the number of components (optional)\r\n     * @param type the type of the component (optional)\r\n     * @param normalized whether the data contains normalized data (optional)\r\n     * @param useBytes set to true if stride and offset are in bytes (optional)\r\n     * @param divisor defines the instance divisor to use (1 by default)\r\n     * @param takeBufferOwnership defines if the buffer should be released when the vertex buffer is disposed\r\n     */\r\n    constructor(\r\n        engine: AbstractEngine,\r\n        data: DataArray | Buffer | DataBuffer,\r\n        kind: string,\r\n        updatable: boolean,\r\n        postponeInternalCreation?: boolean,\r\n        stride?: number,\r\n        instanced?: boolean,\r\n        offset?: number,\r\n        size?: number,\r\n        type?: number,\r\n        normalized?: boolean,\r\n        useBytes?: boolean,\r\n        divisor?: number,\r\n        takeBufferOwnership?: boolean\r\n    );\r\n\r\n    /**\r\n     * Constructor\r\n     * @param engine the engine\r\n     * @param data the data to use for this vertex buffer\r\n     * @param kind the vertex buffer kind\r\n     * @param options defines the rest of the options used to create the buffer\r\n     */\r\n    constructor(engine: AbstractEngine, data: DataArray | Buffer | DataBuffer, kind: string, options?: IVertexBufferOptions);\r\n\r\n    /** @internal */\r\n    constructor(\r\n        engine: AbstractEngine,\r\n        data: DataArray | Buffer | DataBuffer,\r\n        kind: string,\r\n        updatableOrOptions?: boolean | IVertexBufferOptions,\r\n        postponeInternalCreation?: boolean,\r\n        stride?: number,\r\n        instanced?: boolean,\r\n        offset?: number,\r\n        size?: number,\r\n        type?: number,\r\n        normalized = false,\r\n        useBytes = false,\r\n        divisor = 1,\r\n        takeBufferOwnership = false\r\n    ) {\r\n        let updatable = false;\r\n\r\n        this.engine = engine;\r\n\r\n        if (typeof updatableOrOptions === \"object\" && updatableOrOptions !== null) {\r\n            updatable = updatableOrOptions.updatable ?? false;\r\n            postponeInternalCreation = updatableOrOptions.postponeInternalCreation;\r\n            stride = updatableOrOptions.stride;\r\n            instanced = updatableOrOptions.instanced;\r\n            offset = updatableOrOptions.offset;\r\n            size = updatableOrOptions.size;\r\n            type = updatableOrOptions.type;\r\n            normalized = updatableOrOptions.normalized ?? false;\r\n            useBytes = updatableOrOptions.useBytes ?? false;\r\n            divisor = updatableOrOptions.divisor ?? 1;\r\n            takeBufferOwnership = updatableOrOptions.takeBufferOwnership ?? false;\r\n            this._label = updatableOrOptions.label;\r\n        } else {\r\n            updatable = !!updatableOrOptions;\r\n        }\r\n\r\n        if (data instanceof Buffer) {\r\n            this._buffer = data;\r\n            this._ownsBuffer = takeBufferOwnership;\r\n        } else {\r\n            this._buffer = new Buffer(engine, data, updatable, stride, postponeInternalCreation, instanced, useBytes, divisor, this._label);\r\n            this._ownsBuffer = true;\r\n        }\r\n\r\n        this.uniqueId = VertexBuffer._Counter++;\r\n        this._kind = kind;\r\n\r\n        if (type === undefined) {\r\n            const vertexData = this.getData();\r\n            this.type = vertexData ? VertexBuffer.GetDataType(vertexData) : VertexBuffer.FLOAT;\r\n        } else {\r\n            this.type = type;\r\n        }\r\n\r\n        const typeByteLength = GetTypeByteLength(this.type);\r\n\r\n        if (useBytes) {\r\n            this._size = size || (stride ? stride / typeByteLength : VertexBuffer.DeduceStride(kind));\r\n            this.byteStride = stride || this._buffer.byteStride || this._size * typeByteLength;\r\n            this.byteOffset = offset || 0;\r\n        } else {\r\n            this._size = size || stride || VertexBuffer.DeduceStride(kind);\r\n            this.byteStride = stride ? stride * typeByteLength : this._buffer.byteStride || this._size * typeByteLength;\r\n            this.byteOffset = (offset || 0) * typeByteLength;\r\n        }\r\n\r\n        this.normalized = normalized;\r\n\r\n        this._instanced = instanced !== undefined ? instanced : false;\r\n        this._instanceDivisor = instanced ? divisor : 0;\r\n\r\n        this._alignBuffer();\r\n        this._computeHashCode();\r\n    }\r\n\r\n    private _computeHashCode(): void {\r\n        // note: cast to any because the property is declared readonly\r\n        (this.hashCode as any) =\r\n            ((this.type - 5120) << 0) +\r\n            ((this.normalized ? 1 : 0) << 3) +\r\n            (this._size << 4) +\r\n            ((this._instanced ? 1 : 0) << 6) +\r\n            /* keep 5 bits free */\r\n            (this.byteStride << 12);\r\n    }\r\n\r\n    /** @internal */\r\n    public _rebuild(): void {\r\n        this._buffer?._rebuild();\r\n    }\r\n\r\n    /**\r\n     * Returns the kind of the VertexBuffer (string)\r\n     * @returns a string\r\n     */\r\n    public getKind(): string {\r\n        return this._kind;\r\n    }\r\n\r\n    // Properties\r\n\r\n    /**\r\n     * Gets a boolean indicating if the VertexBuffer is updatable?\r\n     * @returns true if the buffer is updatable\r\n     */\r\n    public isUpdatable(): boolean {\r\n        return this._buffer.isUpdatable();\r\n    }\r\n\r\n    /**\r\n     * Gets current buffer's data\r\n     * @returns a DataArray or null\r\n     */\r\n    public getData(): Nullable<DataArray> {\r\n        return this._buffer.getData();\r\n    }\r\n\r\n    /**\r\n     * Gets current buffer's data as a float array. Float data is constructed if the vertex buffer data cannot be returned directly.\r\n     * @param totalVertices number of vertices in the buffer to take into account\r\n     * @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it\r\n     * @returns a float array containing vertex data\r\n     */\r\n    public getFloatData(totalVertices: number, forceCopy?: boolean): Nullable<FloatArray> {\r\n        const data = this.getData();\r\n        if (!data) {\r\n            return null;\r\n        }\r\n\r\n        return GetFloatData(data, this._size, this.type, this.byteOffset, this.byteStride, this.normalized, totalVertices, forceCopy);\r\n    }\r\n\r\n    /**\r\n     * Gets underlying native buffer\r\n     * @returns underlying native buffer\r\n     */\r\n    public getBuffer(): Nullable<DataBuffer> {\r\n        return this._buffer.getBuffer();\r\n    }\r\n\r\n    /**\r\n     * Gets the Buffer instance that wraps the native GPU buffer\r\n     * @returns the wrapper buffer\r\n     */\r\n    public getWrapperBuffer(): Buffer {\r\n        return this._buffer;\r\n    }\r\n\r\n    /**\r\n     * Gets the stride in float32 units (i.e. byte stride / 4).\r\n     * May not be an integer if the byte stride is not divisible by 4.\r\n     * @returns the stride in float32 units\r\n     * @deprecated Please use byteStride instead.\r\n     */\r\n    public getStrideSize(): number {\r\n        return this.byteStride / GetTypeByteLength(this.type);\r\n    }\r\n\r\n    /**\r\n     * Returns the offset as a multiple of the type byte length.\r\n     * @returns the offset in bytes\r\n     * @deprecated Please use byteOffset instead.\r\n     */\r\n    public getOffset(): number {\r\n        return this.byteOffset / GetTypeByteLength(this.type);\r\n    }\r\n\r\n    /**\r\n     * Returns the number of components or the byte size per vertex attribute\r\n     * @param sizeInBytes If true, returns the size in bytes or else the size in number of components of the vertex attribute (default: false)\r\n     * @returns the number of components\r\n     */\r\n    public getSize(sizeInBytes = false): number {\r\n        return sizeInBytes ? this._size * GetTypeByteLength(this.type) : this._size;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating is the internal buffer of the VertexBuffer is instanced\r\n     * @returns true if this buffer is instanced\r\n     */\r\n    public getIsInstanced(): boolean {\r\n        return this._instanced;\r\n    }\r\n\r\n    /**\r\n     * Returns the instancing divisor, zero for non-instanced (integer).\r\n     * @returns a number\r\n     */\r\n    public getInstanceDivisor(): number {\r\n        return this._instanceDivisor;\r\n    }\r\n\r\n    // Methods\r\n\r\n    /**\r\n     * Store data into the buffer. If the buffer was already used it will be either recreated or updated depending on isUpdatable property\r\n     * @param data defines the data to store\r\n     */\r\n    public create(data?: DataArray): void {\r\n        this._buffer.create(data);\r\n        this._alignBuffer();\r\n    }\r\n\r\n    /**\r\n     * Updates the underlying buffer according to the passed numeric array or Float32Array.\r\n     * This function will create a new buffer if the current one is not updatable\r\n     * @param data defines the data to store\r\n     */\r\n    public update(data: DataArray): void {\r\n        this._buffer.update(data);\r\n        this._alignBuffer();\r\n    }\r\n\r\n    /**\r\n     * Updates directly the underlying WebGLBuffer according to the passed numeric array or Float32Array.\r\n     * Returns the directly updated WebGLBuffer.\r\n     * @param data the new data\r\n     * @param offset the new offset\r\n     * @param useBytes set to true if the offset is in bytes\r\n     */\r\n    public updateDirectly(data: DataArray, offset: number, useBytes: boolean = false): void {\r\n        this._buffer.updateDirectly(data, offset, undefined, useBytes);\r\n        this._alignBuffer();\r\n    }\r\n\r\n    /**\r\n     * Disposes the VertexBuffer and the underlying WebGLBuffer.\r\n     */\r\n    public dispose(): void {\r\n        if (this._ownsBuffer) {\r\n            this._buffer.dispose();\r\n        }\r\n\r\n        this._isDisposed = true;\r\n    }\r\n\r\n    /**\r\n     * Enumerates each value of this vertex buffer as numbers.\r\n     * @param count the number of values to enumerate\r\n     * @param callback the callback function called for each value\r\n     */\r\n    public forEach(count: number, callback: (value: number, index: number) => void): void {\r\n        EnumerateFloatValues(this._buffer.getData()!, this.byteOffset, this.byteStride, this._size, this.type, count, this.normalized, (values, index) => {\r\n            for (let i = 0; i < this._size; i++) {\r\n                callback(values[i], index + i);\r\n            }\r\n        });\r\n    }\r\n\r\n    /** @internal */\r\n    public _alignBuffer() {}\r\n\r\n    // Enums\r\n    /**\r\n     * Positions\r\n     */\r\n    public static readonly PositionKind = Constants.PositionKind;\r\n    /**\r\n     * Normals\r\n     */\r\n    public static readonly NormalKind = Constants.NormalKind;\r\n    /**\r\n     * Tangents\r\n     */\r\n    public static readonly TangentKind = Constants.TangentKind;\r\n    /**\r\n     * Texture coordinates\r\n     */\r\n    public static readonly UVKind = Constants.UVKind;\r\n    /**\r\n     * Texture coordinates 2\r\n     */\r\n    public static readonly UV2Kind = Constants.UV2Kind;\r\n    /**\r\n     * Texture coordinates 3\r\n     */\r\n    public static readonly UV3Kind = Constants.UV3Kind;\r\n    /**\r\n     * Texture coordinates 4\r\n     */\r\n    public static readonly UV4Kind = Constants.UV4Kind;\r\n    /**\r\n     * Texture coordinates 5\r\n     */\r\n    public static readonly UV5Kind = Constants.UV5Kind;\r\n    /**\r\n     * Texture coordinates 6\r\n     */\r\n    public static readonly UV6Kind = Constants.UV6Kind;\r\n    /**\r\n     * Colors\r\n     */\r\n    public static readonly ColorKind = Constants.ColorKind;\r\n    /**\r\n     * Instance Colors\r\n     */\r\n    public static readonly ColorInstanceKind = Constants.ColorInstanceKind;\r\n    /**\r\n     * Matrix indices (for bones)\r\n     */\r\n    public static readonly MatricesIndicesKind = Constants.MatricesIndicesKind;\r\n    /**\r\n     * Matrix weights (for bones)\r\n     */\r\n    public static readonly MatricesWeightsKind = Constants.MatricesWeightsKind;\r\n    /**\r\n     * Additional matrix indices (for bones)\r\n     */\r\n    public static readonly MatricesIndicesExtraKind = Constants.MatricesIndicesExtraKind;\r\n    /**\r\n     * Additional matrix weights (for bones)\r\n     */\r\n    public static readonly MatricesWeightsExtraKind = Constants.MatricesWeightsExtraKind;\r\n\r\n    /**\r\n     * Deduces the stride given a kind.\r\n     * @param kind The kind string to deduce\r\n     * @returns The deduced stride\r\n     */\r\n    public static DeduceStride(kind: string): number {\r\n        switch (kind) {\r\n            case VertexBuffer.UVKind:\r\n            case VertexBuffer.UV2Kind:\r\n            case VertexBuffer.UV3Kind:\r\n            case VertexBuffer.UV4Kind:\r\n            case VertexBuffer.UV5Kind:\r\n            case VertexBuffer.UV6Kind:\r\n                return 2;\r\n            case VertexBuffer.NormalKind:\r\n            case VertexBuffer.PositionKind:\r\n                return 3;\r\n            case VertexBuffer.ColorKind:\r\n            case VertexBuffer.ColorInstanceKind:\r\n            case VertexBuffer.MatricesIndicesKind:\r\n            case VertexBuffer.MatricesIndicesExtraKind:\r\n            case VertexBuffer.MatricesWeightsKind:\r\n            case VertexBuffer.MatricesWeightsExtraKind:\r\n            case VertexBuffer.TangentKind:\r\n                return 4;\r\n            default:\r\n                throw new Error(\"Invalid kind '\" + kind + \"'\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the vertex buffer type of the given data array.\r\n     * @param data the data array\r\n     * @returns the vertex buffer type\r\n     */\r\n    public static GetDataType(data: DataArray): number {\r\n        if (data instanceof Int8Array) {\r\n            return VertexBuffer.BYTE;\r\n        } else if (data instanceof Uint8Array) {\r\n            return VertexBuffer.UNSIGNED_BYTE;\r\n        } else if (data instanceof Int16Array) {\r\n            return VertexBuffer.SHORT;\r\n        } else if (data instanceof Uint16Array) {\r\n            return VertexBuffer.UNSIGNED_SHORT;\r\n        } else if (data instanceof Int32Array) {\r\n            return VertexBuffer.INT;\r\n        } else if (data instanceof Uint32Array) {\r\n            return VertexBuffer.UNSIGNED_INT;\r\n        } else {\r\n            return VertexBuffer.FLOAT;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the byte length of the given type.\r\n     * @param type the type\r\n     * @returns the number of bytes\r\n     * @deprecated Use `getTypeByteLength` from `bufferUtils` instead\r\n     */\r\n    public static GetTypeByteLength(type: number): number {\r\n        return GetTypeByteLength(type);\r\n    }\r\n\r\n    /**\r\n     * Enumerates each value of the given parameters as numbers.\r\n     * @param data the data to enumerate\r\n     * @param byteOffset the byte offset of the data\r\n     * @param byteStride the byte stride of the data\r\n     * @param componentCount the number of components per element\r\n     * @param componentType the type of the component\r\n     * @param count the number of values to enumerate\r\n     * @param normalized whether the data is normalized\r\n     * @param callback the callback function called for each value\r\n     * @deprecated Use `EnumerateFloatValues` from `bufferUtils` instead\r\n     */\r\n    public static ForEach(\r\n        data: DataArray,\r\n        byteOffset: number,\r\n        byteStride: number,\r\n        componentCount: number,\r\n        componentType: number,\r\n        count: number,\r\n        normalized: boolean,\r\n        callback: (value: number, index: number) => void\r\n    ): void {\r\n        EnumerateFloatValues(data, byteOffset, byteStride, componentCount, componentType, count, normalized, (values, index) => {\r\n            for (let componentIndex = 0; componentIndex < componentCount; componentIndex++) {\r\n                callback(values[componentIndex], index + componentIndex);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Gets the given data array as a float array. Float data is constructed if the data array cannot be returned directly.\r\n     * @param data the input data array\r\n     * @param size the number of components\r\n     * @param type the component type\r\n     * @param byteOffset the byte offset of the data\r\n     * @param byteStride the byte stride of the data\r\n     * @param normalized whether the data is normalized\r\n     * @param totalVertices number of vertices in the buffer to take into account\r\n     * @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it\r\n     * @returns a float array containing vertex data\r\n     * @deprecated Use `GetFloatData` from `bufferUtils` instead\r\n     */\r\n    public static GetFloatData(\r\n        data: DataArray,\r\n        size: number,\r\n        type: number,\r\n        byteOffset: number,\r\n        byteStride: number,\r\n        normalized: boolean,\r\n        totalVertices: number,\r\n        forceCopy?: boolean\r\n    ): FloatArray {\r\n        return GetFloatData(data, size, type, byteOffset, byteStride, normalized, totalVertices, forceCopy);\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": []
}
