{
  "version": 3,
  "sources": ["../../../dev/core/src/Maths/math.scalar.functions.ts"],
  "sourcesContent": ["/**\r\n * Extract int value\r\n * @param value number value\r\n * @returns int value\r\n */\r\nexport function ExtractAsInt(value: number) {\r\n    return parseInt(value.toString().replace(/\\W/g, \"\"));\r\n}\r\n\r\n/**\r\n * Boolean : true if the absolute difference between a and b is lower than epsilon (default = 1.401298E-45)\r\n * @param a number\r\n * @param b number\r\n * @param epsilon (default = 1.401298E-45)\r\n * @returns true if the absolute difference between a and b is lower than epsilon (default = 1.401298E-45)\r\n */\r\nexport function WithinEpsilon(a: number, b: number, epsilon: number = 1.401298e-45): boolean {\r\n    return Math.abs(a - b) <= epsilon;\r\n}\r\n\r\n/**\r\n * Boolean : true if the number is outside a range\r\n * @param num number\r\n * @param min min value\r\n * @param max max value\r\n * @param epsilon (default = Number.EPSILON)\r\n * @returns true if the number is between min and max values\r\n */\r\nexport function OutsideRange(num: number, min: number, max: number, epsilon: number = 1.401298e-45): boolean {\r\n    return num < min - epsilon || num > max + epsilon;\r\n}\r\n\r\n/**\r\n * Returns a random float number between and min and max values\r\n * @param min min value of random\r\n * @param max max value of random\r\n * @returns random value\r\n */\r\nexport function RandomRange(min: number, max: number): number {\r\n    if (min === max) {\r\n        return min;\r\n    }\r\n    return Math.random() * (max - min) + min;\r\n}\r\n\r\n/**\r\n * Creates a new scalar with values linearly interpolated of \"amount\" between the start scalar and the end scalar.\r\n * @param start start value\r\n * @param end target value\r\n * @param amount amount to lerp between\r\n * @returns the lerped value\r\n */\r\nexport function Lerp(start: number, end: number, amount: number): number {\r\n    return start + (end - start) * amount;\r\n}\r\n\r\n/**\r\n * Same as Lerp but makes sure the values interpolate correctly when they wrap around 360 degrees.\r\n * The parameter t is clamped to the range [0, 1]. Variables a and b are assumed to be in degrees.\r\n * @param start start value\r\n * @param end target value\r\n * @param amount amount to lerp between\r\n * @returns the lerped value\r\n */\r\nexport function LerpAngle(start: number, end: number, amount: number): number {\r\n    let num: number = Repeat(end - start, 360.0);\r\n    if (num > 180.0) {\r\n        num -= 360.0;\r\n    }\r\n    return start + num * Clamp(amount);\r\n}\r\n\r\n/**\r\n * Calculates the linear parameter t that produces the interpolant value within the range [a, b].\r\n * @param a start value\r\n * @param b target value\r\n * @param value value between a and b\r\n * @returns the inverseLerp value\r\n */\r\nexport function InverseLerp(a: number, b: number, value: number): number {\r\n    let result: number = 0;\r\n    if (a != b) {\r\n        result = Clamp((value - a) / (b - a));\r\n    } else {\r\n        result = 0.0;\r\n    }\r\n    return result;\r\n}\r\n\r\n/**\r\n * Returns a new scalar located for \"amount\" (float) on the Hermite spline defined by the scalars \"value1\", \"value3\", \"tangent1\", \"tangent2\".\r\n * @see http://mathworld.wolfram.com/HermitePolynomial.html\r\n * @param value1 defines the first control point\r\n * @param tangent1 defines the first tangent\r\n * @param value2 defines the second control point\r\n * @param tangent2 defines the second tangent\r\n * @param amount defines the amount on the interpolation spline (between 0 and 1)\r\n * @returns hermite result\r\n */\r\nexport function Hermite(value1: number, tangent1: number, value2: number, tangent2: number, amount: number): number {\r\n    const squared = amount * amount;\r\n    const cubed = amount * squared;\r\n    const part1 = 2.0 * cubed - 3.0 * squared + 1.0;\r\n    const part2 = -2.0 * cubed + 3.0 * squared;\r\n    const part3 = cubed - 2.0 * squared + amount;\r\n    const part4 = cubed - squared;\r\n\r\n    return value1 * part1 + value2 * part2 + tangent1 * part3 + tangent2 * part4;\r\n}\r\n\r\n/**\r\n * Returns a new scalar which is the 1st derivative of the Hermite spline defined by the scalars \"value1\", \"value2\", \"tangent1\", \"tangent2\".\r\n * @param value1 defines the first control point\r\n * @param tangent1 defines the first tangent\r\n * @param value2 defines the second control point\r\n * @param tangent2 defines the second tangent\r\n * @param time define where the derivative must be done\r\n * @returns 1st derivative\r\n */\r\nexport function Hermite1stDerivative(value1: number, tangent1: number, value2: number, tangent2: number, time: number): number {\r\n    const t2 = time * time;\r\n    return (t2 - time) * 6 * value1 + (3 * t2 - 4 * time + 1) * tangent1 + (-t2 + time) * 6 * value2 + (3 * t2 - 2 * time) * tangent2;\r\n}\r\n\r\n/**\r\n * Returns the value itself if it's between min and max.\r\n * Returns min if the value is lower than min.\r\n * Returns max if the value is greater than max.\r\n * @param value the value to clmap\r\n * @param min the min value to clamp to (default: 0)\r\n * @param max the max value to clamp to (default: 1)\r\n * @returns the clamped value\r\n */\r\nexport function Clamp(value: number, min = 0, max = 1): number {\r\n    return Math.min(max, Math.max(min, value));\r\n}\r\n\r\n/**\r\n * Returns the angle converted to equivalent value between -Math.PI and Math.PI radians.\r\n * @param angle The angle to normalize in radian.\r\n * @returns The converted angle.\r\n */\r\nexport function NormalizeRadians(angle: number): number {\r\n    // More precise but slower version kept for reference.\r\n    // angle = angle % Tools.TwoPi;\r\n    // angle = (angle + Tools.TwoPi) % Tools.TwoPi;\r\n\r\n    //if (angle > Math.PI) {\r\n    //\tangle -= Tools.TwoPi;\r\n    //}\r\n\r\n    angle -= Math.PI * 2 * Math.floor((angle + Math.PI) / (Math.PI * 2));\r\n\r\n    return angle;\r\n}\r\n\r\n/**\r\n * Returns a string : the upper case translation of the number i to hexadecimal.\r\n * @param i number\r\n * @returns the upper case translation of the number i to hexadecimal.\r\n */\r\nexport function ToHex(i: number): string {\r\n    const str = i.toString(16);\r\n\r\n    if (i <= 15) {\r\n        return (\"0\" + str).toUpperCase();\r\n    }\r\n\r\n    return str.toUpperCase();\r\n}\r\n\r\n/**\r\n * the floor part of a log2 value.\r\n * @param value the value to compute log2 of\r\n * @returns the log2 of value.\r\n */\r\nexport function ILog2(value: number): number {\r\n    if (Math.log2) {\r\n        return Math.floor(Math.log2(value));\r\n    }\r\n\r\n    if (value < 0) {\r\n        return NaN;\r\n    } else if (value === 0) {\r\n        return -Infinity;\r\n    }\r\n\r\n    let n = 0;\r\n    if (value < 1) {\r\n        while (value < 1) {\r\n            n++;\r\n            value = value * 2;\r\n        }\r\n        n = -n;\r\n    } else if (value > 1) {\r\n        while (value > 1) {\r\n            n++;\r\n            value = Math.floor(value / 2);\r\n        }\r\n    }\r\n\r\n    return n;\r\n}\r\n\r\n/**\r\n * Loops the value, so that it is never larger than length and never smaller than 0.\r\n *\r\n * This is similar to the modulo operator but it works with floating point numbers.\r\n * For example, using 3.0 for t and 2.5 for length, the result would be 0.5.\r\n * With t = 5 and length = 2.5, the result would be 0.0.\r\n * Note, however, that the behaviour is not defined for negative numbers as it is for the modulo operator\r\n * @param value the value\r\n * @param length the length\r\n * @returns the looped value\r\n */\r\nexport function Repeat(value: number, length: number): number {\r\n    return value - Math.floor(value / length) * length;\r\n}\r\n\r\n/**\r\n * Normalize the value between 0.0 and 1.0 using min and max values\r\n * @param value value to normalize\r\n * @param min max to normalize between\r\n * @param max min to normalize between\r\n * @returns the normalized value\r\n */\r\nexport function Normalize(value: number, min: number, max: number): number {\r\n    return (value - min) / (max - min);\r\n}\r\n\r\n/**\r\n * Denormalize the value from 0.0 and 1.0 using min and max values\r\n * @param normalized value to denormalize\r\n * @param min max to denormalize between\r\n * @param max min to denormalize between\r\n * @returns the denormalized value\r\n */\r\nexport function Denormalize(normalized: number, min: number, max: number): number {\r\n    return normalized * (max - min) + min;\r\n}\r\n\r\n/**\r\n * Calculates the shortest difference between two given angles given in degrees.\r\n * @param current current angle in degrees\r\n * @param target target angle in degrees\r\n * @returns the delta\r\n */\r\nexport function DeltaAngle(current: number, target: number): number {\r\n    let num: number = Repeat(target - current, 360.0);\r\n    if (num > 180.0) {\r\n        num -= 360.0;\r\n    }\r\n    return num;\r\n}\r\n\r\n/**\r\n * PingPongs the value t, so that it is never larger than length and never smaller than 0.\r\n * @param tx value\r\n * @param length length\r\n * @returns The returned value will move back and forth between 0 and length\r\n */\r\nexport function PingPong(tx: number, length: number): number {\r\n    const t: number = Repeat(tx, length * 2.0);\r\n    return length - Math.abs(t - length);\r\n}\r\n\r\n/**\r\n * Interpolates between min and max with smoothing at the limits.\r\n *\r\n * This function interpolates between min and max in a similar way to Lerp. However, the interpolation will gradually speed up\r\n * from the start and slow down toward the end. This is useful for creating natural-looking animation, fading and other transitions.\r\n * @param from from\r\n * @param to to\r\n * @param tx value\r\n * @returns the smooth stepped value\r\n */\r\nexport function SmoothStep(from: number, to: number, tx: number): number {\r\n    let t: number = Clamp(tx);\r\n    t = -2.0 * t * t * t + 3.0 * t * t;\r\n    return to * t + from * (1.0 - t);\r\n}\r\n\r\n/**\r\n * Moves a value current towards target.\r\n *\r\n * This is essentially the same as Mathf.Lerp but instead the function will ensure that the speed never exceeds maxDelta.\r\n * Negative values of maxDelta pushes the value away from target.\r\n * @param current current value\r\n * @param target target value\r\n * @param maxDelta max distance to move\r\n * @returns resulting value\r\n */\r\nexport function MoveTowards(current: number, target: number, maxDelta: number): number {\r\n    let result: number = 0;\r\n    if (Math.abs(target - current) <= maxDelta) {\r\n        result = target;\r\n    } else {\r\n        result = current + Math.sign(target - current) * maxDelta;\r\n    }\r\n    return result;\r\n}\r\n\r\n/**\r\n * Same as MoveTowards but makes sure the values interpolate correctly when they wrap around 360 degrees.\r\n *\r\n * Variables current and target are assumed to be in degrees. For optimization reasons, negative values of maxDelta\r\n *  are not supported and may cause oscillation. To push current away from a target angle, add 180 to that angle instead.\r\n * @param current current value\r\n * @param target target value\r\n * @param maxDelta max distance to move\r\n * @returns resulting angle\r\n */\r\nexport function MoveTowardsAngle(current: number, target: number, maxDelta: number): number {\r\n    const num: number = DeltaAngle(current, target);\r\n    let result: number = 0;\r\n    if (-maxDelta < num && num < maxDelta) {\r\n        result = target;\r\n    } else {\r\n        target = current + num;\r\n        result = MoveTowards(current, target, maxDelta);\r\n    }\r\n    return result;\r\n}\r\n\r\n/**\r\n * This function returns percentage of a number in a given range.\r\n *\r\n * RangeToPercent(40,20,60) will return 0.5 (50%)\r\n * RangeToPercent(34,0,100) will return 0.34 (34%)\r\n * @param number to convert to percentage\r\n * @param min min range\r\n * @param max max range\r\n * @returns the percentage\r\n */\r\nexport function RangeToPercent(number: number, min: number, max: number): number {\r\n    return (number - min) / (max - min);\r\n}\r\n\r\n/**\r\n * This function returns number that corresponds to the percentage in a given range.\r\n *\r\n * PercentToRange(0.34,0,100) will return 34.\r\n * @param percent to convert to number\r\n * @param min min range\r\n * @param max max range\r\n * @returns the number\r\n */\r\nexport function PercentToRange(percent: number, min: number, max: number): number {\r\n    return (max - min) * percent + min;\r\n}\r\n\r\n/**\r\n * Returns the highest common factor of two integers.\r\n * @param a first parameter\r\n * @param b second parameter\r\n * @returns HCF of a and b\r\n */\r\nexport function HighestCommonFactor(a: number, b: number): number {\r\n    const r: number = a % b;\r\n    if (r === 0) {\r\n        return b;\r\n    }\r\n    return HighestCommonFactor(b, r);\r\n}\r\n"],
  "mappings": "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",
  "names": []
}
