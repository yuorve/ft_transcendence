{
  "version": 3,
  "sources": ["../../../dev/core/src/Misc/timer.ts", "../../../dev/core/src/FlowGraph/Blocks/Execution/ControlFlow/flowGraphSetDelayBlock.ts"],
  "sourcesContent": ["import type { Observer } from \"../Misc/observable\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { IDisposable } from \"../scene\";\r\n\r\n/**\r\n * Construction options for a timer\r\n */\r\nexport interface ITimerOptions<T> {\r\n    /**\r\n     * Time-to-end\r\n     */\r\n    timeout: number;\r\n    /**\r\n     * The context observable is used to calculate time deltas and provides the context of the timer's callbacks. Will usually be OnBeforeRenderObservable.\r\n     * Countdown calculation is done ONLY when the observable is notifying its observers, meaning that if\r\n     * you choose an observable that doesn't trigger too often, the wait time might extend further than the requested max time\r\n     */\r\n    contextObservable: Observable<T>;\r\n    /**\r\n     * Optional parameters when adding an observer to the observable\r\n     */\r\n    observableParameters?: {\r\n        mask?: number;\r\n        insertFirst?: boolean;\r\n        scope?: any;\r\n    };\r\n    /**\r\n     * An optional break condition that will stop the times prematurely. In this case onEnded will not be triggered!\r\n     */\r\n    breakCondition?: (data?: ITimerData<T>) => boolean;\r\n    /**\r\n     * Will be triggered when the time condition has met\r\n     */\r\n    onEnded?: (data: ITimerData<any>) => void;\r\n    /**\r\n     * Will be triggered when the break condition has met (prematurely ended)\r\n     */\r\n    onAborted?: (data: ITimerData<any>) => void;\r\n    /**\r\n     * Optional function to execute on each tick (or count)\r\n     */\r\n    onTick?: (data: ITimerData<any>) => void;\r\n}\r\n\r\n/**\r\n * An interface defining the data sent by the timer\r\n */\r\nexport interface ITimerData<T> {\r\n    /**\r\n     * When did it start\r\n     */\r\n    startTime: number;\r\n    /**\r\n     * Time now\r\n     */\r\n    currentTime: number;\r\n    /**\r\n     * Time passed since started\r\n     */\r\n    deltaTime: number;\r\n    /**\r\n     * How much is completed, in [0.0...1.0].\r\n     * Note that this CAN be higher than 1 due to the fact that we don't actually measure time but delta between observable calls\r\n     */\r\n    completeRate: number;\r\n    /**\r\n     * What the registered observable sent in the last count\r\n     */\r\n    payload: T;\r\n}\r\n\r\n/**\r\n * The current state of the timer\r\n */\r\nexport const enum TimerState {\r\n    /**\r\n     * Timer initialized, not yet started\r\n     */\r\n    INIT,\r\n    /**\r\n     * Timer started and counting\r\n     */\r\n    STARTED,\r\n    /**\r\n     * Timer ended (whether aborted or time reached)\r\n     */\r\n    ENDED,\r\n}\r\n\r\n/**\r\n * A simple version of the timer. Will take options and start the timer immediately after calling it\r\n *\r\n * @param options options with which to initialize this timer\r\n * @returns an observer that can be used to stop the timer\r\n */\r\nexport function setAndStartTimer<T = any>(options: ITimerOptions<T>): Nullable<Observer<T>> {\r\n    let timer = 0;\r\n    const startTime = Date.now();\r\n    options.observableParameters = options.observableParameters ?? {};\r\n    const observer = options.contextObservable.add(\r\n        (payload: any) => {\r\n            const now = Date.now();\r\n            timer = now - startTime;\r\n            const data: ITimerData<any> = {\r\n                startTime,\r\n                currentTime: now,\r\n                deltaTime: timer,\r\n                completeRate: timer / options.timeout,\r\n                payload,\r\n            };\r\n            options.onTick && options.onTick(data);\r\n            if (options.breakCondition && options.breakCondition()) {\r\n                options.contextObservable.remove(observer);\r\n                options.onAborted && options.onAborted(data);\r\n            }\r\n            if (timer >= options.timeout) {\r\n                options.contextObservable.remove(observer);\r\n                options.onEnded && options.onEnded(data);\r\n            }\r\n        },\r\n        options.observableParameters.mask,\r\n        options.observableParameters.insertFirst,\r\n        options.observableParameters.scope\r\n    );\r\n    return observer;\r\n}\r\n\r\n/**\r\n * An advanced implementation of a timer class\r\n */\r\nexport class AdvancedTimer<T = any> implements IDisposable {\r\n    /**\r\n     * Will notify each time the timer calculates the remaining time\r\n     */\r\n    public onEachCountObservable: Observable<ITimerData<T>> = new Observable();\r\n    /**\r\n     * Will trigger when the timer was aborted due to the break condition\r\n     */\r\n    public onTimerAbortedObservable: Observable<ITimerData<T>> = new Observable();\r\n    /**\r\n     * Will trigger when the timer ended successfully\r\n     */\r\n    public onTimerEndedObservable: Observable<ITimerData<T>> = new Observable();\r\n    /**\r\n     * Will trigger when the timer state has changed\r\n     */\r\n    public onStateChangedObservable: Observable<TimerState> = new Observable();\r\n\r\n    private _observer: Nullable<Observer<T>> = null;\r\n    private _contextObservable: Observable<T>;\r\n    private _observableParameters: {\r\n        mask?: number;\r\n        insertFirst?: boolean;\r\n        scope?: any;\r\n    };\r\n    private _startTime: number;\r\n    private _timer: number;\r\n    private _state: TimerState;\r\n    private _breakCondition: (data: ITimerData<T>) => boolean;\r\n    private _timeToEnd: number;\r\n    private _breakOnNextTick: boolean = false;\r\n\r\n    /**\r\n     * Will construct a new advanced timer based on the options provided. Timer will not start until start() is called.\r\n     * @param options construction options for this advanced timer\r\n     */\r\n    constructor(options: ITimerOptions<T>) {\r\n        this._setState(TimerState.INIT);\r\n        this._contextObservable = options.contextObservable;\r\n        this._observableParameters = options.observableParameters ?? {};\r\n        this._breakCondition = options.breakCondition ?? (() => false);\r\n        this._timeToEnd = options.timeout;\r\n        if (options.onEnded) {\r\n            this.onTimerEndedObservable.add(options.onEnded);\r\n        }\r\n        if (options.onTick) {\r\n            this.onEachCountObservable.add(options.onTick);\r\n        }\r\n        if (options.onAborted) {\r\n            this.onTimerAbortedObservable.add(options.onAborted);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * set a breaking condition for this timer. Default is to never break during count\r\n     * @param predicate the new break condition. Returns true to break, false otherwise\r\n     */\r\n    public set breakCondition(predicate: (data: ITimerData<T>) => boolean) {\r\n        this._breakCondition = predicate;\r\n    }\r\n\r\n    /**\r\n     * Reset ALL associated observables in this advanced timer\r\n     */\r\n    public clearObservables() {\r\n        this.onEachCountObservable.clear();\r\n        this.onTimerAbortedObservable.clear();\r\n        this.onTimerEndedObservable.clear();\r\n        this.onStateChangedObservable.clear();\r\n    }\r\n\r\n    /**\r\n     * Will start a new iteration of this timer. Only one instance of this timer can run at a time.\r\n     *\r\n     * @param timeToEnd how much time to measure until timer ended\r\n     */\r\n    public start(timeToEnd: number = this._timeToEnd) {\r\n        if (this._state === TimerState.STARTED) {\r\n            throw new Error(\"Timer already started. Please stop it before starting again\");\r\n        }\r\n        this._timeToEnd = timeToEnd;\r\n        this._startTime = Date.now();\r\n        this._timer = 0;\r\n        this._observer = this._contextObservable.add(this._tick, this._observableParameters.mask, this._observableParameters.insertFirst, this._observableParameters.scope);\r\n        this._setState(TimerState.STARTED);\r\n    }\r\n\r\n    /**\r\n     * Will force a stop on the next tick.\r\n     */\r\n    public stop() {\r\n        if (this._state !== TimerState.STARTED) {\r\n            return;\r\n        }\r\n        this._breakOnNextTick = true;\r\n    }\r\n\r\n    /**\r\n     * Dispose this timer, clearing all resources\r\n     */\r\n    public dispose() {\r\n        if (this._observer) {\r\n            this._contextObservable.remove(this._observer);\r\n        }\r\n        this.clearObservables();\r\n    }\r\n\r\n    private _setState(newState: TimerState) {\r\n        this._state = newState;\r\n        this.onStateChangedObservable.notifyObservers(this._state);\r\n    }\r\n\r\n    private _tick = (payload: T) => {\r\n        const now = Date.now();\r\n        this._timer = now - this._startTime;\r\n        const data: ITimerData<T> = {\r\n            startTime: this._startTime,\r\n            currentTime: now,\r\n            deltaTime: this._timer,\r\n            completeRate: this._timer / this._timeToEnd,\r\n            payload,\r\n        };\r\n        const shouldBreak = this._breakOnNextTick || this._breakCondition(data);\r\n        if (shouldBreak || this._timer >= this._timeToEnd) {\r\n            this._stop(data, shouldBreak);\r\n        } else {\r\n            this.onEachCountObservable.notifyObservers(data);\r\n        }\r\n    };\r\n\r\n    private _stop(data: ITimerData<T>, aborted: boolean = false) {\r\n        this._contextObservable.remove(this._observer);\r\n        this._setState(TimerState.ENDED);\r\n        if (aborted) {\r\n            this.onTimerAbortedObservable.notifyObservers(data);\r\n        } else {\r\n            this.onTimerEndedObservable.notifyObservers(data);\r\n        }\r\n    }\r\n}\r\n", "import { FlowGraphAsyncExecutionBlock } from \"../../../flowGraphAsyncExecutionBlock\";\nimport type { IFlowGraphBlockConfiguration } from \"../../../flowGraphBlock\";\nimport type { FlowGraphContext } from \"../../../flowGraphContext\";\nimport type { FlowGraphDataConnection } from \"../../../flowGraphDataConnection\";\nimport { RichTypeNumber } from \"../../../flowGraphRichTypes\";\nimport type { FlowGraphSignalConnection } from \"../../../flowGraphSignalConnection\";\nimport { AdvancedTimer } from \"../../../../Misc/timer\";\nimport { Logger } from \"../../../../Misc/logger\";\nimport { FlowGraphBlockNames } from \"../../flowGraphBlockNames\";\nimport { RegisterClass } from \"core/Misc/typeStore\";\n\n/**\n * Block that sets a delay in seconds before activating the output signal.\n */\nexport class FlowGraphSetDelayBlock extends FlowGraphAsyncExecutionBlock {\n    /**\n     * The maximum number of parallel delays that can be set per node.\n     */\n    public static MaxParallelDelayCount = 100;\n    /**\n     * Input signal: If activated the delayed activations set by this block will be canceled.\n     */\n    public readonly cancel: FlowGraphSignalConnection;\n\n    /**\n     * Input connection: The duration of the delay in seconds.\n     */\n    public readonly duration: FlowGraphDataConnection<number>;\n\n    /**\n     * Output connection: The last delay index that was set.\n     */\n    public readonly lastDelayIndex: FlowGraphDataConnection<number>;\n\n    constructor(config?: IFlowGraphBlockConfiguration) {\n        super(config);\n        this.cancel = this._registerSignalInput(\"cancel\");\n        this.duration = this.registerDataInput(\"duration\", RichTypeNumber);\n        this.lastDelayIndex = this.registerDataOutput(\"lastDelayIndex\", RichTypeNumber, -1);\n    }\n\n    public _preparePendingTasks(context: FlowGraphContext): void {\n        const duration = this.duration.getValue(context);\n        if (duration < 0 || isNaN(duration) || !isFinite(duration)) {\n            return this._reportError(context, \"Invalid duration in SetDelay block\");\n        }\n\n        // active delays are global to the context\n        const activeDelays: number = context._getGlobalContextVariable(\"activeDelays\", 0);\n        if (activeDelays >= FlowGraphSetDelayBlock.MaxParallelDelayCount) {\n            return this._reportError(context, \"Max parallel delays reached\");\n        }\n        // get the last global delay index\n        const lastDelayIndex: number = context._getGlobalContextVariable(\"lastDelayIndex\", -1);\n\n        // these are block-specific and not global\n        const timers = context._getExecutionVariable(this, \"pendingDelays\", [] as AdvancedTimer[]);\n        const scene = context.configuration.scene;\n        const timer: AdvancedTimer = new AdvancedTimer({\n            timeout: duration * 1000, // duration is in seconds\n            contextObservable: scene.onBeforeRenderObservable,\n            onEnded: () => this._onEnded(timer, context),\n        });\n        timer.start();\n        const newIndex = lastDelayIndex + 1;\n        this.lastDelayIndex.setValue(newIndex, context);\n        context._setGlobalContextVariable(\"lastDelayIndex\", newIndex);\n\n        timers[newIndex] = timer;\n        context._setExecutionVariable(this, \"pendingDelays\", timers);\n    }\n\n    public _cancelPendingTasks(context: FlowGraphContext): void {\n        const timers = context._getExecutionVariable(this, \"pendingDelays\", [] as AdvancedTimer[]);\n        for (const timer of timers) {\n            timer?.dispose();\n        }\n        context._deleteExecutionVariable(this, \"pendingDelays\");\n        this.lastDelayIndex.setValue(-1, context);\n    }\n\n    public _execute(context: FlowGraphContext, callingSignal: FlowGraphSignalConnection): void {\n        if (callingSignal === this.cancel) {\n            this._cancelPendingTasks(context);\n            return;\n        } else {\n            this._preparePendingTasks(context);\n            this.out._activateSignal(context);\n        }\n    }\n\n    public override getClassName(): string {\n        return FlowGraphBlockNames.SetDelay;\n    }\n\n    private _onEnded(timer: AdvancedTimer, context: FlowGraphContext) {\n        const timers = context._getExecutionVariable(this, \"pendingDelays\", [] as AdvancedTimer[]);\n        const index = timers.indexOf(timer);\n        if (index !== -1) {\n            timers.splice(index, 1);\n        } else {\n            Logger.Warn(\"FlowGraphTimerBlock: Timer ended but was not found in the running timers list\");\n        }\n        context._removePendingBlock(this);\n        this.done._activateSignal(context);\n    }\n}\n\nRegisterClass(FlowGraphBlockNames.SetDelay, FlowGraphSetDelayBlock);\n"],
  "mappings": "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",
  "names": ["TimerState"]
}
