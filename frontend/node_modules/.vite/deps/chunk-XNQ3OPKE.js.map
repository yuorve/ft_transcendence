{
  "version": 3,
  "sources": ["../../../dev/core/src/Materials/Textures/thinTexture.ts", "../../../dev/core/src/Materials/Textures/baseTexture.ts", "../../../dev/core/src/Misc/copyTools.ts", "../../../dev/core/src/Compat/compatibilityOptions.ts", "../../../dev/core/src/Materials/Textures/texture.ts"],
  "sourcesContent": ["import type { Nullable } from \"../../types\";\r\nimport type { InternalTexture } from \"../../Materials/Textures/internalTexture\";\r\nimport { Constants } from \"../../Engines/constants\";\r\n\r\nimport type { ISize } from \"../../Maths/math.size\";\r\nimport { Size } from \"../../Maths/math.size\";\r\n\r\nimport type { AbstractEngine } from \"../../Engines/abstractEngine\";\r\nimport type { RenderTargetWrapper } from \"core/Engines/renderTargetWrapper\";\r\n\r\n/**\r\n * Base class of all the textures in babylon.\r\n * It groups all the common properties required to work with Thin Engine.\r\n */\r\nexport class ThinTexture {\r\n    protected _wrapU = Constants.TEXTURE_WRAP_ADDRESSMODE;\r\n    /**\r\n     * | Value | Type               | Description |\r\n     * | ----- | ------------------ | ----------- |\r\n     * | 0     | CLAMP_ADDRESSMODE  |             |\r\n     * | 1     | WRAP_ADDRESSMODE   |             |\r\n     * | 2     | MIRROR_ADDRESSMODE |             |\r\n     */\r\n    public get wrapU() {\r\n        return this._wrapU;\r\n    }\r\n\r\n    public set wrapU(value: number) {\r\n        this._wrapU = value;\r\n    }\r\n\r\n    protected _wrapV = Constants.TEXTURE_WRAP_ADDRESSMODE;\r\n    /**\r\n     * | Value | Type               | Description |\r\n     * | ----- | ------------------ | ----------- |\r\n     * | 0     | CLAMP_ADDRESSMODE  |             |\r\n     * | 1     | WRAP_ADDRESSMODE   |             |\r\n     * | 2     | MIRROR_ADDRESSMODE |             |\r\n     */\r\n    public get wrapV() {\r\n        return this._wrapV;\r\n    }\r\n\r\n    public set wrapV(value: number) {\r\n        this._wrapV = value;\r\n    }\r\n\r\n    /**\r\n     * | Value | Type               | Description |\r\n     * | ----- | ------------------ | ----------- |\r\n     * | 0     | CLAMP_ADDRESSMODE  |             |\r\n     * | 1     | WRAP_ADDRESSMODE   |             |\r\n     * | 2     | MIRROR_ADDRESSMODE |             |\r\n     */\r\n    public wrapR = Constants.TEXTURE_WRAP_ADDRESSMODE;\r\n\r\n    /**\r\n     * With compliant hardware and browser (supporting anisotropic filtering)\r\n     * this defines the level of anisotropic filtering in the texture.\r\n     * The higher the better but the slower. This defaults to 4 as it seems to be the best tradeoff.\r\n     */\r\n    public anisotropicFilteringLevel = 4;\r\n\r\n    /**\r\n     * Define the current state of the loading sequence when in delayed load mode.\r\n     */\r\n    public delayLoadState = Constants.DELAYLOADSTATE_NONE;\r\n\r\n    /**\r\n     * How a texture is mapped.\r\n     * Unused in thin texture mode.\r\n     */\r\n    public get coordinatesMode(): number {\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Define if the texture is a cube texture or if false a 2d texture.\r\n     */\r\n    public get isCube(): boolean {\r\n        if (!this._texture) {\r\n            return false;\r\n        }\r\n\r\n        return this._texture.isCube;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    protected set isCube(value: boolean) {\r\n        if (!this._texture) {\r\n            return;\r\n        }\r\n\r\n        this._texture.isCube = value;\r\n    }\r\n\r\n    /**\r\n     * Define if the texture is a 3d texture (webgl 2) or if false a 2d texture.\r\n     */\r\n    public get is3D(): boolean {\r\n        if (!this._texture) {\r\n            return false;\r\n        }\r\n\r\n        return this._texture.is3D;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    protected set is3D(value: boolean) {\r\n        if (!this._texture) {\r\n            return;\r\n        }\r\n\r\n        this._texture.is3D = value;\r\n    }\r\n\r\n    /**\r\n     * Define if the texture is a 2d array texture (webgl 2) or if false a 2d texture.\r\n     */\r\n    public get is2DArray(): boolean {\r\n        if (!this._texture) {\r\n            return false;\r\n        }\r\n\r\n        return this._texture.is2DArray;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    protected set is2DArray(value: boolean) {\r\n        if (!this._texture) {\r\n            return;\r\n        }\r\n\r\n        this._texture.is2DArray = value;\r\n    }\r\n\r\n    /**\r\n     * Get the class name of the texture.\r\n     * @returns \"ThinTexture\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"ThinTexture\";\r\n    }\r\n\r\n    /** @internal */\r\n    public _texture: Nullable<InternalTexture> = null;\r\n\r\n    protected _engine: Nullable<AbstractEngine> = null;\r\n\r\n    private _cachedSize: ISize = Size.Zero();\r\n    private _cachedBaseSize: ISize = Size.Zero();\r\n\r\n    private static _IsRenderTargetWrapper(texture: Nullable<InternalTexture> | Nullable<RenderTargetWrapper>): texture is RenderTargetWrapper {\r\n        return (texture as RenderTargetWrapper)?.shareDepth !== undefined;\r\n    }\r\n\r\n    /**\r\n     * Instantiates a new ThinTexture.\r\n     * Base class of all the textures in babylon.\r\n     * This can be used as an internal texture wrapper in AbstractEngine to benefit from the cache\r\n     * @param internalTexture Define the internalTexture to wrap. You can also pass a RenderTargetWrapper, in which case the texture will be the render target's texture\r\n     */\r\n    constructor(internalTexture: Nullable<InternalTexture | RenderTargetWrapper>) {\r\n        this._texture = ThinTexture._IsRenderTargetWrapper(internalTexture) ? internalTexture.texture : internalTexture;\r\n        if (this._texture) {\r\n            this._engine = this._texture.getEngine();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get if the texture is ready to be used (downloaded, converted, mip mapped...).\r\n     * @returns true if fully ready\r\n     */\r\n    public isReady(): boolean {\r\n        if (this.delayLoadState === Constants.DELAYLOADSTATE_NOTLOADED) {\r\n            this.delayLoad();\r\n            return false;\r\n        }\r\n\r\n        if (this._texture) {\r\n            return this._texture.isReady;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Triggers the load sequence in delayed load mode.\r\n     */\r\n    public delayLoad(): void {}\r\n\r\n    /**\r\n     * Get the underlying lower level texture from Babylon.\r\n     * @returns the internal texture\r\n     */\r\n    public getInternalTexture(): Nullable<InternalTexture> {\r\n        return this._texture;\r\n    }\r\n\r\n    /**\r\n     * Get the size of the texture.\r\n     * @returns the texture size.\r\n     */\r\n    public getSize(): ISize {\r\n        if (this._texture) {\r\n            if (this._texture.width) {\r\n                this._cachedSize.width = this._texture.width;\r\n                this._cachedSize.height = this._texture.height;\r\n                return this._cachedSize;\r\n            }\r\n\r\n            if (this._texture._size) {\r\n                this._cachedSize.width = this._texture._size;\r\n                this._cachedSize.height = this._texture._size;\r\n                return this._cachedSize;\r\n            }\r\n        }\r\n\r\n        return this._cachedSize;\r\n    }\r\n\r\n    /**\r\n     * Get the base size of the texture.\r\n     * It can be different from the size if the texture has been resized for POT for instance\r\n     * @returns the base size\r\n     */\r\n    public getBaseSize(): ISize {\r\n        if (!this.isReady() || !this._texture) {\r\n            this._cachedBaseSize.width = 0;\r\n            this._cachedBaseSize.height = 0;\r\n            return this._cachedBaseSize;\r\n        }\r\n\r\n        if (this._texture._size) {\r\n            this._cachedBaseSize.width = this._texture._size;\r\n            this._cachedBaseSize.height = this._texture._size;\r\n            return this._cachedBaseSize;\r\n        }\r\n\r\n        this._cachedBaseSize.width = this._texture.baseWidth;\r\n        this._cachedBaseSize.height = this._texture.baseHeight;\r\n        return this._cachedBaseSize;\r\n    }\r\n\r\n    /** @internal */\r\n    protected _initialSamplingMode = Constants.TEXTURE_BILINEAR_SAMPLINGMODE;\r\n\r\n    /**\r\n     * Get the current sampling mode associated with the texture.\r\n     */\r\n    public get samplingMode(): number {\r\n        if (!this._texture) {\r\n            return this._initialSamplingMode;\r\n        }\r\n\r\n        return this._texture.samplingMode;\r\n    }\r\n\r\n    /**\r\n     * Update the sampling mode of the texture.\r\n     * Default is Trilinear mode.\r\n     *\r\n     * | Value | Type               | Description |\r\n     * | ----- | ------------------ | ----------- |\r\n     * | 1     | NEAREST_SAMPLINGMODE or NEAREST_NEAREST_MIPLINEAR  | Nearest is: mag = nearest, min = nearest, mip = linear |\r\n     * | 2     | BILINEAR_SAMPLINGMODE or LINEAR_LINEAR_MIPNEAREST | Bilinear is: mag = linear, min = linear, mip = nearest |\r\n     * | 3     | TRILINEAR_SAMPLINGMODE or LINEAR_LINEAR_MIPLINEAR | Trilinear is: mag = linear, min = linear, mip = linear |\r\n     * | 4     | NEAREST_NEAREST_MIPNEAREST |             |\r\n     * | 5    | NEAREST_LINEAR_MIPNEAREST |             |\r\n     * | 6    | NEAREST_LINEAR_MIPLINEAR |             |\r\n     * | 7    | NEAREST_LINEAR |             |\r\n     * | 8    | NEAREST_NEAREST |             |\r\n     * | 9   | LINEAR_NEAREST_MIPNEAREST |             |\r\n     * | 10   | LINEAR_NEAREST_MIPLINEAR |             |\r\n     * | 11   | LINEAR_LINEAR |             |\r\n     * | 12   | LINEAR_NEAREST |             |\r\n     *\r\n     *    > _mag_: magnification filter (close to the viewer)\r\n     *    > _min_: minification filter (far from the viewer)\r\n     *    > _mip_: filter used between mip map levels\r\n     *@param samplingMode Define the new sampling mode of the texture\r\n     */\r\n    public updateSamplingMode(samplingMode: number): void {\r\n        if (this._texture && this._engine) {\r\n            this._engine.updateTextureSamplingMode(samplingMode, this._texture);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Release and destroy the underlying lower level texture aka internalTexture.\r\n     */\r\n    public releaseInternalTexture(): void {\r\n        if (this._texture) {\r\n            this._texture.dispose();\r\n            this._texture = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Dispose the texture and release its associated resources.\r\n     */\r\n    public dispose(): void {\r\n        if (this._texture) {\r\n            this.releaseInternalTexture();\r\n            this._engine = null;\r\n        }\r\n    }\r\n}\r\n", "import { serialize, serializeAsTexture } from \"../../Misc/decorators\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Matrix } from \"../../Maths/math.vector\";\r\nimport { EngineStore } from \"../../Engines/engineStore\";\r\nimport type { InternalTexture } from \"../../Materials/Textures/internalTexture\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport type { IAnimatable } from \"../../Animations/animatable.interface\";\r\nimport { RandomGUID } from \"../../Misc/guid\";\r\n\r\nimport \"../../Misc/fileTools\";\r\nimport type { AbstractEngine } from \"../../Engines/abstractEngine\";\r\nimport { ThinTexture } from \"./thinTexture\";\r\n\r\nimport type { Animation } from \"../../Animations/animation\";\r\nimport { SerializationHelper } from \"../../Misc/decorators.serialization\";\r\nimport type { IAssetContainer } from \"core/IAssetContainer\";\r\n\r\n/**\r\n * Base class of all the textures in babylon.\r\n * It groups all the common properties the materials, post process, lights... might need\r\n * in order to make a correct use of the texture.\r\n */\r\nexport class BaseTexture extends ThinTexture implements IAnimatable {\r\n    /**\r\n     * Default anisotropic filtering level for the application.\r\n     * It is set to 4 as a good tradeoff between perf and quality.\r\n     */\r\n    public static DEFAULT_ANISOTROPIC_FILTERING_LEVEL = 4;\r\n\r\n    /**\r\n     * Gets or sets the unique id of the texture\r\n     */\r\n    @serialize()\r\n    public uniqueId: number;\r\n\r\n    /**\r\n     * Define the name of the texture.\r\n     */\r\n    @serialize()\r\n    public name: string;\r\n\r\n    /**\r\n     * Define the display name of the texture, which is used as tree item name of the dedicated node in the inspector\r\n     */\r\n    @serialize()\r\n    public displayName: string;\r\n\r\n    /**\r\n     * Gets or sets an object used to store user defined information.\r\n     */\r\n    @serialize()\r\n    public metadata: any = null;\r\n\r\n    /** @internal */\r\n    public _internalMetadata: any;\r\n\r\n    /**\r\n     * For internal use only. Please do not use.\r\n     */\r\n    public reservedDataStore: any = null;\r\n\r\n    @serialize(\"hasAlpha\")\r\n    private _hasAlpha = false;\r\n    /**\r\n     * Define if the texture is having a usable alpha value (can be use for transparency or glossiness for instance).\r\n     */\r\n    public set hasAlpha(value: boolean) {\r\n        if (this._hasAlpha === value) {\r\n            return;\r\n        }\r\n        this._hasAlpha = value;\r\n        if (this._scene) {\r\n            this._scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(this);\r\n            });\r\n        }\r\n    }\r\n    public get hasAlpha(): boolean {\r\n        return this._hasAlpha;\r\n    }\r\n\r\n    @serialize(\"getAlphaFromRGB\")\r\n    private _getAlphaFromRGB = false;\r\n    /**\r\n     * Defines if the alpha value should be determined via the rgb values.\r\n     * If true the luminance of the pixel might be used to find the corresponding alpha value.\r\n     */\r\n    public set getAlphaFromRGB(value: boolean) {\r\n        if (this._getAlphaFromRGB === value) {\r\n            return;\r\n        }\r\n        this._getAlphaFromRGB = value;\r\n        if (this._scene) {\r\n            this._scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(this);\r\n            });\r\n        }\r\n    }\r\n    public get getAlphaFromRGB(): boolean {\r\n        return this._getAlphaFromRGB;\r\n    }\r\n\r\n    /**\r\n     * Intensity or strength of the texture.\r\n     * It is commonly used by materials to fine tune the intensity of the texture\r\n     */\r\n    @serialize()\r\n    public level = 1;\r\n\r\n    @serialize(\"coordinatesIndex\")\r\n    protected _coordinatesIndex = 0;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that the texture should try to reduce shader code if there is no UV manipulation.\r\n     * (ie. when texture.getTextureMatrix().isIdentityAs3x2() returns true)\r\n     */\r\n    @serialize()\r\n    public optimizeUVAllocation = true;\r\n\r\n    /**\r\n     * Define the UV channel to use starting from 0 and defaulting to 0.\r\n     * This is part of the texture as textures usually maps to one uv set.\r\n     */\r\n    public set coordinatesIndex(value: number) {\r\n        if (this._coordinatesIndex === value) {\r\n            return;\r\n        }\r\n        this._coordinatesIndex = value;\r\n        if (this._scene) {\r\n            this._scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(this);\r\n            });\r\n        }\r\n    }\r\n    public get coordinatesIndex(): number {\r\n        return this._coordinatesIndex;\r\n    }\r\n\r\n    @serialize(\"coordinatesMode\")\r\n    protected _coordinatesMode = Constants.TEXTURE_EXPLICIT_MODE;\r\n\r\n    /**\r\n     * How a texture is mapped.\r\n     *\r\n     * | Value | Type                                | Description |\r\n     * | ----- | ----------------------------------- | ----------- |\r\n     * | 0     | EXPLICIT_MODE                       |             |\r\n     * | 1     | SPHERICAL_MODE                      |             |\r\n     * | 2     | PLANAR_MODE                         |             |\r\n     * | 3     | CUBIC_MODE                          |             |\r\n     * | 4     | PROJECTION_MODE                     |             |\r\n     * | 5     | SKYBOX_MODE                         |             |\r\n     * | 6     | INVCUBIC_MODE                       |             |\r\n     * | 7     | EQUIRECTANGULAR_MODE                |             |\r\n     * | 8     | FIXED_EQUIRECTANGULAR_MODE          |             |\r\n     * | 9     | FIXED_EQUIRECTANGULAR_MIRRORED_MODE |             |\r\n     */\r\n    public override set coordinatesMode(value: number) {\r\n        if (this._coordinatesMode === value) {\r\n            return;\r\n        }\r\n        this._coordinatesMode = value;\r\n        if (this._scene) {\r\n            this._scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(this);\r\n            });\r\n        }\r\n    }\r\n    public override get coordinatesMode(): number {\r\n        return this._coordinatesMode;\r\n    }\r\n\r\n    /**\r\n     * | Value | Type               | Description |\r\n     * | ----- | ------------------ | ----------- |\r\n     * | 0     | CLAMP_ADDRESSMODE  |             |\r\n     * | 1     | WRAP_ADDRESSMODE   |             |\r\n     * | 2     | MIRROR_ADDRESSMODE |             |\r\n     */\r\n    @serialize()\r\n    public override get wrapU() {\r\n        return this._wrapU;\r\n    }\r\n    public override set wrapU(value: number) {\r\n        this._wrapU = value;\r\n    }\r\n\r\n    /**\r\n     * | Value | Type               | Description |\r\n     * | ----- | ------------------ | ----------- |\r\n     * | 0     | CLAMP_ADDRESSMODE  |             |\r\n     * | 1     | WRAP_ADDRESSMODE   |             |\r\n     * | 2     | MIRROR_ADDRESSMODE |             |\r\n     */\r\n    @serialize()\r\n    public override get wrapV() {\r\n        return this._wrapV;\r\n    }\r\n    public override set wrapV(value: number) {\r\n        this._wrapV = value;\r\n    }\r\n\r\n    /**\r\n     * | Value | Type               | Description |\r\n     * | ----- | ------------------ | ----------- |\r\n     * | 0     | CLAMP_ADDRESSMODE  |             |\r\n     * | 1     | WRAP_ADDRESSMODE   |             |\r\n     * | 2     | MIRROR_ADDRESSMODE |             |\r\n     */\r\n    @serialize()\r\n    public override wrapR = Constants.TEXTURE_WRAP_ADDRESSMODE;\r\n\r\n    /**\r\n     * With compliant hardware and browser (supporting anisotropic filtering)\r\n     * this defines the level of anisotropic filtering in the texture.\r\n     * The higher the better but the slower. This defaults to 4 as it seems to be the best tradeoff.\r\n     */\r\n    @serialize()\r\n    public override anisotropicFilteringLevel = BaseTexture.DEFAULT_ANISOTROPIC_FILTERING_LEVEL;\r\n\r\n    /** @internal */\r\n    public _isCube = false;\r\n    /**\r\n     * Define if the texture is a cube texture or if false a 2d texture.\r\n     */\r\n    @serialize()\r\n    public override get isCube(): boolean {\r\n        if (!this._texture) {\r\n            return this._isCube;\r\n        }\r\n\r\n        return this._texture.isCube;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    protected override set isCube(value: boolean) {\r\n        if (!this._texture) {\r\n            this._isCube = value;\r\n        } else {\r\n            this._texture.isCube = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Define if the texture is a 3d texture (webgl 2) or if false a 2d texture.\r\n     */\r\n    @serialize()\r\n    public override get is3D(): boolean {\r\n        if (!this._texture) {\r\n            return false;\r\n        }\r\n\r\n        return this._texture.is3D;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    protected override set is3D(value: boolean) {\r\n        if (!this._texture) {\r\n            return;\r\n        }\r\n\r\n        this._texture.is3D = value;\r\n    }\r\n\r\n    /**\r\n     * Define if the texture is a 2d array texture (webgl 2) or if false a 2d texture.\r\n     */\r\n    @serialize()\r\n    public override get is2DArray(): boolean {\r\n        if (!this._texture) {\r\n            return false;\r\n        }\r\n\r\n        return this._texture.is2DArray;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    protected override set is2DArray(value: boolean) {\r\n        if (!this._texture) {\r\n            return;\r\n        }\r\n\r\n        this._texture.is2DArray = value;\r\n    }\r\n\r\n    /** @internal */\r\n    protected _gammaSpace = true;\r\n    /**\r\n     * Define if the texture contains data in gamma space (most of the png/jpg aside bump).\r\n     * HDR texture are usually stored in linear space.\r\n     * This only impacts the PBR and Background materials\r\n     */\r\n    @serialize()\r\n    public get gammaSpace(): boolean {\r\n        if (!this._texture) {\r\n            return this._gammaSpace;\r\n        } else {\r\n            if (this._texture._gammaSpace === null) {\r\n                this._texture._gammaSpace = this._gammaSpace;\r\n            }\r\n        }\r\n\r\n        return this._texture._gammaSpace && !this._texture._useSRGBBuffer;\r\n    }\r\n\r\n    public set gammaSpace(gamma: boolean) {\r\n        if (!this._texture) {\r\n            if (this._gammaSpace === gamma) {\r\n                return;\r\n            }\r\n\r\n            this._gammaSpace = gamma;\r\n        } else {\r\n            if (this._texture._gammaSpace === gamma) {\r\n                return;\r\n            }\r\n            this._texture._gammaSpace = gamma;\r\n        }\r\n\r\n        this.getScene()?.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n            return mat.hasTexture(this);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Gets or sets whether or not the texture contains RGBD data.\r\n     */\r\n    public get isRGBD(): boolean {\r\n        return this._texture != null && this._texture._isRGBD;\r\n    }\r\n    public set isRGBD(value: boolean) {\r\n        if (value === this.isRGBD) {\r\n            return;\r\n        }\r\n\r\n        if (this._texture) {\r\n            this._texture._isRGBD = value;\r\n        }\r\n\r\n        this.getScene()?.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n            return mat.hasTexture(this);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Is Z inverted in the texture (useful in a cube texture).\r\n     */\r\n    @serialize()\r\n    public invertZ = false;\r\n\r\n    /**\r\n     * Are mip maps generated for this texture or not.\r\n     */\r\n    public get noMipmap(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    @serialize()\r\n    public lodLevelInAlpha = false;\r\n\r\n    /**\r\n     * With prefiltered texture, defined the offset used during the prefiltering steps.\r\n     */\r\n    @serialize()\r\n    public get lodGenerationOffset(): number {\r\n        if (this._texture) {\r\n            return this._texture._lodGenerationOffset;\r\n        }\r\n\r\n        return 0.0;\r\n    }\r\n    public set lodGenerationOffset(value: number) {\r\n        if (this._texture) {\r\n            this._texture._lodGenerationOffset = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * With prefiltered texture, defined the scale used during the prefiltering steps.\r\n     */\r\n    @serialize()\r\n    public get lodGenerationScale(): number {\r\n        if (this._texture) {\r\n            return this._texture._lodGenerationScale;\r\n        }\r\n\r\n        return 0.0;\r\n    }\r\n    public set lodGenerationScale(value: number) {\r\n        if (this._texture) {\r\n            this._texture._lodGenerationScale = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * With prefiltered texture, defined if the specular generation is based on a linear ramp.\r\n     * By default we are using a log2 of the linear roughness helping to keep a better resolution for\r\n     * average roughness values.\r\n     */\r\n    @serialize()\r\n    public get linearSpecularLOD(): boolean {\r\n        if (this._texture) {\r\n            return this._texture._linearSpecularLOD;\r\n        }\r\n\r\n        return false;\r\n    }\r\n    public set linearSpecularLOD(value: boolean) {\r\n        if (this._texture) {\r\n            this._texture._linearSpecularLOD = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * In case a better definition than spherical harmonics is required for the diffuse part of the environment.\r\n     * You can set the irradiance texture to rely on a texture instead of the spherical approach.\r\n     * This texture need to have the same characteristics than its parent (Cube vs 2d, coordinates mode, Gamma/Linear, RGBD).\r\n     */\r\n    @serializeAsTexture()\r\n    public get irradianceTexture(): Nullable<BaseTexture> {\r\n        if (this._texture) {\r\n            return this._texture._irradianceTexture;\r\n        }\r\n\r\n        return null;\r\n    }\r\n    public set irradianceTexture(value: Nullable<BaseTexture>) {\r\n        if (this._texture) {\r\n            this._texture._irradianceTexture = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Define if the texture is a render target.\r\n     */\r\n    @serialize()\r\n    public isRenderTarget = false;\r\n\r\n    /**\r\n     * Define the unique id of the texture in the scene.\r\n     */\r\n    public get uid(): string {\r\n        if (!this._uid) {\r\n            this._uid = RandomGUID();\r\n        }\r\n        return this._uid;\r\n    }\r\n\r\n    /** @internal */\r\n    public _prefiltered: boolean = false;\r\n    /** @internal */\r\n    public _forceSerialize: boolean = false;\r\n\r\n    /**\r\n     * Return a string representation of the texture.\r\n     * @returns the texture as a string\r\n     */\r\n    public override toString(): string {\r\n        return this.name;\r\n    }\r\n\r\n    /**\r\n     * Get the class name of the texture.\r\n     * @returns \"BaseTexture\"\r\n     */\r\n    public override getClassName(): string {\r\n        return \"BaseTexture\";\r\n    }\r\n\r\n    /**\r\n     * Define the list of animation attached to the texture.\r\n     */\r\n    public animations: Animation[] = [];\r\n\r\n    /**\r\n     * An event triggered when the texture is disposed.\r\n     */\r\n    public onDisposeObservable = new Observable<BaseTexture>();\r\n\r\n    private _onDisposeObserver: Nullable<Observer<BaseTexture>> = null;\r\n    /**\r\n     * Callback triggered when the texture has been disposed.\r\n     * Kept for back compatibility, you can use the onDisposeObservable instead.\r\n     */\r\n    public set onDispose(callback: () => void) {\r\n        if (this._onDisposeObserver) {\r\n            this.onDisposeObservable.remove(this._onDisposeObserver);\r\n        }\r\n        this._onDisposeObserver = this.onDisposeObservable.add(callback);\r\n    }\r\n\r\n    protected _scene: Nullable<Scene> = null;\r\n\r\n    /** @internal */\r\n    private _uid: Nullable<string> = null;\r\n\r\n    /**\r\n     * Define if the texture is preventing a material to render or not.\r\n     * If not and the texture is not ready, the engine will use a default black texture instead.\r\n     */\r\n    public get isBlocking(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /** @internal */\r\n    public _parentContainer: Nullable<IAssetContainer> = null;\r\n\r\n    protected _loadingError: boolean = false;\r\n    protected _errorObject?: {\r\n        message?: string;\r\n        exception?: any;\r\n    };\r\n\r\n    /**\r\n     * Was there any loading error?\r\n     */\r\n    public get loadingError(): boolean {\r\n        return this._loadingError;\r\n    }\r\n\r\n    /**\r\n     * If a loading error occurred this object will be populated with information about the error.\r\n     */\r\n    public get errorObject():\r\n        | {\r\n              message?: string;\r\n              exception?: any;\r\n          }\r\n        | undefined {\r\n        return this._errorObject;\r\n    }\r\n\r\n    /**\r\n     * Instantiates a new BaseTexture.\r\n     * Base class of all the textures in babylon.\r\n     * It groups all the common properties the materials, post process, lights... might need\r\n     * in order to make a correct use of the texture.\r\n     * @param sceneOrEngine Define the scene or engine the texture belongs to\r\n     * @param internalTexture Define the internal texture associated with the texture\r\n     */\r\n    constructor(sceneOrEngine?: Nullable<Scene | AbstractEngine>, internalTexture: Nullable<InternalTexture> = null) {\r\n        super(null);\r\n\r\n        if (sceneOrEngine) {\r\n            if (BaseTexture._IsScene(sceneOrEngine)) {\r\n                this._scene = sceneOrEngine;\r\n            } else {\r\n                this._engine = sceneOrEngine;\r\n            }\r\n        } else {\r\n            this._scene = EngineStore.LastCreatedScene;\r\n        }\r\n\r\n        if (this._scene) {\r\n            this.uniqueId = this._scene.getUniqueId();\r\n            this._scene.addTexture(this);\r\n            this._engine = this._scene.getEngine();\r\n        }\r\n\r\n        this._texture = internalTexture;\r\n\r\n        this._uid = null;\r\n    }\r\n\r\n    /**\r\n     * Get the scene the texture belongs to.\r\n     * @returns the scene or null if undefined\r\n     */\r\n    public getScene(): Nullable<Scene> {\r\n        return this._scene;\r\n    }\r\n\r\n    /** @internal */\r\n    protected _getEngine(): Nullable<AbstractEngine> {\r\n        return this._engine;\r\n    }\r\n\r\n    /**\r\n     * Get the texture transform matrix used to offset tile the texture for instance.\r\n     * @returns the transformation matrix\r\n     */\r\n    public getTextureMatrix(): Matrix {\r\n        return <Matrix>Matrix.IdentityReadOnly;\r\n    }\r\n\r\n    /**\r\n     * Get the texture reflection matrix used to rotate/transform the reflection.\r\n     * @returns the reflection matrix\r\n     */\r\n    public getReflectionTextureMatrix(): Matrix {\r\n        return <Matrix>Matrix.IdentityReadOnly;\r\n    }\r\n\r\n    /**\r\n     * Gets a suitable rotate/transform matrix when the texture is used for refraction.\r\n     * There's a separate function from getReflectionTextureMatrix because refraction requires a special configuration of the matrix in right-handed mode.\r\n     * @returns The refraction matrix\r\n     */\r\n    public getRefractionTextureMatrix(): Matrix {\r\n        return this.getReflectionTextureMatrix();\r\n    }\r\n\r\n    /**\r\n     * Get if the texture is ready to be consumed (either it is ready or it is not blocking)\r\n     * @returns true if ready, not blocking or if there was an error loading the texture\r\n     */\r\n    public isReadyOrNotBlocking(): boolean {\r\n        return !this.isBlocking || this.isReady() || this.loadingError;\r\n    }\r\n\r\n    /**\r\n     * Scales the texture if is `canRescale()`\r\n     * @param ratio the resize factor we want to use to rescale\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public scale(ratio: number): void {}\r\n\r\n    /**\r\n     * Get if the texture can rescale.\r\n     */\r\n    public get canRescale(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getFromCache(url: Nullable<string>, noMipmap: boolean, sampling?: number, invertY?: boolean, useSRGBBuffer?: boolean, isCube?: boolean): Nullable<InternalTexture> {\r\n        const engine = this._getEngine();\r\n        if (!engine) {\r\n            return null;\r\n        }\r\n\r\n        const correctedUseSRGBBuffer = engine._getUseSRGBBuffer(!!useSRGBBuffer, noMipmap);\r\n\r\n        const texturesCache = engine.getLoadedTexturesCache();\r\n        for (let index = 0; index < texturesCache.length; index++) {\r\n            const texturesCacheEntry = texturesCache[index];\r\n\r\n            if (useSRGBBuffer === undefined || correctedUseSRGBBuffer === texturesCacheEntry._useSRGBBuffer) {\r\n                if (invertY === undefined || invertY === texturesCacheEntry.invertY) {\r\n                    if (texturesCacheEntry.url === url && texturesCacheEntry.generateMipMaps === !noMipmap) {\r\n                        if (!sampling || sampling === texturesCacheEntry.samplingMode) {\r\n                            if (isCube === undefined || isCube === texturesCacheEntry.isCube) {\r\n                                texturesCacheEntry.incrementReferences();\r\n                                return texturesCacheEntry;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /** @internal */\r\n    public _rebuild(_fromContextLost = false): void {}\r\n\r\n    /**\r\n     * Clones the texture.\r\n     * @returns the cloned texture\r\n     */\r\n    public clone(): Nullable<BaseTexture> {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Get the texture underlying type (INT, FLOAT...)\r\n     */\r\n    public get textureType(): number {\r\n        if (!this._texture) {\r\n            return Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n        }\r\n\r\n        return this._texture.type !== undefined ? this._texture.type : Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n    }\r\n\r\n    /**\r\n     * Get the texture underlying format (RGB, RGBA...)\r\n     */\r\n    public get textureFormat(): number {\r\n        if (!this._texture) {\r\n            return Constants.TEXTUREFORMAT_RGBA;\r\n        }\r\n\r\n        return this._texture.format !== undefined ? this._texture.format : Constants.TEXTUREFORMAT_RGBA;\r\n    }\r\n\r\n    /**\r\n     * Indicates that textures need to be re-calculated for all materials\r\n     */\r\n    protected _markAllSubMeshesAsTexturesDirty() {\r\n        const scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n    }\r\n\r\n    /**\r\n     * Reads the pixels stored in the webgl texture and returns them as an ArrayBuffer.\r\n     * This will returns an RGBA array buffer containing either in values (0-255) or\r\n     * float values (0-1) depending of the underlying buffer type.\r\n     * @param faceIndex defines the face of the texture to read (in case of cube texture)\r\n     * @param level defines the LOD level of the texture to read (in case of Mip Maps)\r\n     * @param buffer defines a user defined buffer to fill with data (can be null)\r\n     * @param flushRenderer true to flush the renderer from the pending commands before reading the pixels\r\n     * @param noDataConversion false to convert the data to Uint8Array (if texture type is UNSIGNED_BYTE) or to Float32Array (if texture type is anything but UNSIGNED_BYTE). If true, the type of the generated buffer (if buffer==null) will depend on the type of the texture\r\n     * @param x defines the region x coordinates to start reading from (default to 0)\r\n     * @param y defines the region y coordinates to start reading from (default to 0)\r\n     * @param width defines the region width to read from (default to the texture size at level)\r\n     * @param height defines the region width to read from (default to the texture size at level)\r\n     * @returns The Array buffer promise containing the pixels data.\r\n     */\r\n    public readPixels(\r\n        faceIndex = 0,\r\n        level = 0,\r\n        buffer: Nullable<ArrayBufferView> = null,\r\n        flushRenderer = true,\r\n        noDataConversion = false,\r\n        x = 0,\r\n        y = 0,\r\n        width = Number.MAX_VALUE,\r\n        height = Number.MAX_VALUE\r\n    ): Nullable<Promise<ArrayBufferView>> {\r\n        if (!this._texture) {\r\n            return null;\r\n        }\r\n\r\n        const engine = this._getEngine();\r\n        if (!engine) {\r\n            return null;\r\n        }\r\n\r\n        const size = this.getSize();\r\n        let maxWidth = size.width;\r\n        let maxHeight = size.height;\r\n        if (level !== 0) {\r\n            maxWidth = maxWidth / Math.pow(2, level);\r\n            maxHeight = maxHeight / Math.pow(2, level);\r\n            maxWidth = Math.round(maxWidth);\r\n            maxHeight = Math.round(maxHeight);\r\n        }\r\n\r\n        width = Math.min(maxWidth, width);\r\n        height = Math.min(maxHeight, height);\r\n\r\n        try {\r\n            if (this._texture.isCube) {\r\n                return engine._readTexturePixels(this._texture, width, height, faceIndex, level, buffer, flushRenderer, noDataConversion, x, y);\r\n            }\r\n\r\n            return engine._readTexturePixels(this._texture, width, height, -1, level, buffer, flushRenderer, noDataConversion, x, y);\r\n        } catch (e) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _readPixelsSync(faceIndex = 0, level = 0, buffer: Nullable<ArrayBufferView> = null, flushRenderer = true, noDataConversion = false): Nullable<ArrayBufferView> {\r\n        if (!this._texture) {\r\n            return null;\r\n        }\r\n\r\n        const size = this.getSize();\r\n        let width = size.width;\r\n        let height = size.height;\r\n\r\n        const engine = this._getEngine();\r\n        if (!engine) {\r\n            return null;\r\n        }\r\n\r\n        if (level != 0) {\r\n            width = width / Math.pow(2, level);\r\n            height = height / Math.pow(2, level);\r\n\r\n            width = Math.round(width);\r\n            height = Math.round(height);\r\n        }\r\n\r\n        try {\r\n            if (this._texture.isCube) {\r\n                return engine._readTexturePixelsSync(this._texture, width, height, faceIndex, level, buffer, flushRenderer, noDataConversion);\r\n            }\r\n\r\n            return engine._readTexturePixelsSync(this._texture, width, height, -1, level, buffer, flushRenderer, noDataConversion);\r\n        } catch (e) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public get _lodTextureHigh(): Nullable<BaseTexture> {\r\n        if (this._texture) {\r\n            return this._texture._lodTextureHigh;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /** @internal */\r\n    public get _lodTextureMid(): Nullable<BaseTexture> {\r\n        if (this._texture) {\r\n            return this._texture._lodTextureMid;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /** @internal */\r\n    public get _lodTextureLow(): Nullable<BaseTexture> {\r\n        if (this._texture) {\r\n            return this._texture._lodTextureLow;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Dispose the texture and release its associated resources.\r\n     */\r\n    public override dispose(): void {\r\n        if (this._scene) {\r\n            // Animations\r\n            if (this._scene.stopAnimation) {\r\n                this._scene.stopAnimation(this);\r\n            }\r\n\r\n            // Remove from scene\r\n            this._scene.removePendingData(this);\r\n            const index = this._scene.textures.indexOf(this);\r\n\r\n            if (index >= 0) {\r\n                this._scene.textures.splice(index, 1);\r\n            }\r\n            this._scene.onTextureRemovedObservable.notifyObservers(this);\r\n            this._scene = null;\r\n\r\n            if (this._parentContainer) {\r\n                const index = this._parentContainer.textures.indexOf(this);\r\n                if (index > -1) {\r\n                    this._parentContainer.textures.splice(index, 1);\r\n                }\r\n                this._parentContainer = null;\r\n            }\r\n        }\r\n\r\n        // Callback\r\n        this.onDisposeObservable.notifyObservers(this);\r\n        this.onDisposeObservable.clear();\r\n\r\n        this.metadata = null;\r\n\r\n        super.dispose();\r\n    }\r\n\r\n    /**\r\n     * Serialize the texture into a JSON representation that can be parsed later on.\r\n     * @param allowEmptyName True to force serialization even if name is empty. Default: false\r\n     * @returns the JSON representation of the texture\r\n     */\r\n    public serialize(allowEmptyName = false): any {\r\n        if (!this.name && !allowEmptyName) {\r\n            return null;\r\n        }\r\n\r\n        const serializationObject = SerializationHelper.Serialize(this);\r\n\r\n        // Animations\r\n        SerializationHelper.AppendSerializedAnimations(this, serializationObject);\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Helper function to be called back once a list of texture contains only ready textures.\r\n     * @param textures Define the list of textures to wait for\r\n     * @param callback Define the callback triggered once the entire list will be ready\r\n     */\r\n    public static WhenAllReady(textures: BaseTexture[], callback: () => void): void {\r\n        let numRemaining = textures.length;\r\n        if (numRemaining === 0) {\r\n            callback();\r\n            return;\r\n        }\r\n\r\n        for (let i = 0; i < textures.length; i++) {\r\n            const texture = textures[i];\r\n\r\n            if (texture.isReady()) {\r\n                if (--numRemaining === 0) {\r\n                    callback();\r\n                }\r\n            } else {\r\n                const onLoadObservable = (texture as any).onLoadObservable as Observable<BaseTexture>;\r\n\r\n                if (onLoadObservable) {\r\n                    onLoadObservable.addOnce(() => {\r\n                        if (--numRemaining === 0) {\r\n                            callback();\r\n                        }\r\n                    });\r\n                } else {\r\n                    if (--numRemaining === 0) {\r\n                        callback();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private static _IsScene(sceneOrEngine: Scene | AbstractEngine): sceneOrEngine is Scene {\r\n        return sceneOrEngine.getClassName() === \"Scene\";\r\n    }\r\n}\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { ISize } from \"../Maths/math.size\";\r\nimport type { Nullable } from \"../types\";\r\n\r\nimport type { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\n\r\n/**\r\n * Transform some pixel data to a base64 string\r\n * @param pixels defines the pixel data to transform to base64\r\n * @param size defines the width and height of the (texture) data\r\n * @param invertY true if the data must be inverted for the Y coordinate during the conversion\r\n * @returns The base64 encoded string or null\r\n */\r\nexport function GenerateBase64StringFromPixelData(pixels: ArrayBufferView, size: ISize, invertY = false): Nullable<string> {\r\n    const width = size.width;\r\n    const height = size.height;\r\n\r\n    if (pixels instanceof Float32Array) {\r\n        let len = pixels.byteLength / pixels.BYTES_PER_ELEMENT;\r\n        const npixels = new Uint8Array(len);\r\n\r\n        while (--len >= 0) {\r\n            let val = pixels[len];\r\n            if (val < 0) {\r\n                val = 0;\r\n            } else if (val > 1) {\r\n                val = 1;\r\n            }\r\n            npixels[len] = val * 255;\r\n        }\r\n\r\n        pixels = npixels;\r\n    }\r\n\r\n    const canvas = document.createElement(\"canvas\");\r\n    canvas.width = width;\r\n    canvas.height = height;\r\n\r\n    const ctx = canvas.getContext(\"2d\");\r\n    if (!ctx) {\r\n        return null;\r\n    }\r\n\r\n    const imageData = ctx.createImageData(width, height);\r\n    const castData = <any>imageData.data;\r\n    castData.set(pixels);\r\n    ctx.putImageData(imageData, 0, 0);\r\n\r\n    if (invertY) {\r\n        const canvas2 = document.createElement(\"canvas\");\r\n        canvas2.width = width;\r\n        canvas2.height = height;\r\n\r\n        const ctx2 = canvas2.getContext(\"2d\");\r\n        if (!ctx2) {\r\n            return null;\r\n        }\r\n\r\n        ctx2.translate(0, height);\r\n        ctx2.scale(1, -1);\r\n        ctx2.drawImage(canvas, 0, 0);\r\n\r\n        return canvas2.toDataURL(\"image/png\");\r\n    }\r\n\r\n    return canvas.toDataURL(\"image/png\");\r\n}\r\n\r\n/**\r\n * Reads the pixels stored in the webgl texture and returns them as a base64 string\r\n * @param texture defines the texture to read pixels from\r\n * @param faceIndex defines the face of the texture to read (in case of cube texture)\r\n * @param level defines the LOD level of the texture to read (in case of Mip Maps)\r\n * @returns The base64 encoded string or null\r\n */\r\nexport function GenerateBase64StringFromTexture(texture: BaseTexture, faceIndex = 0, level = 0): Nullable<string> {\r\n    const internalTexture = texture.getInternalTexture();\r\n    if (!internalTexture) {\r\n        return null;\r\n    }\r\n\r\n    const pixels = texture._readPixelsSync(faceIndex, level);\r\n    if (!pixels) {\r\n        return null;\r\n    }\r\n\r\n    return GenerateBase64StringFromPixelData(pixels, texture.getSize(), internalTexture.invertY);\r\n}\r\n\r\n/**\r\n * Reads the pixels stored in the webgl texture and returns them as a base64 string\r\n * @param texture defines the texture to read pixels from\r\n * @param faceIndex defines the face of the texture to read (in case of cube texture)\r\n * @param level defines the LOD level of the texture to read (in case of Mip Maps)\r\n * @returns The base64 encoded string or null wrapped in a promise\r\n */\r\nexport async function GenerateBase64StringFromTextureAsync(texture: BaseTexture, faceIndex = 0, level = 0): Promise<Nullable<string>> {\r\n    const internalTexture = texture.getInternalTexture();\r\n    if (!internalTexture) {\r\n        return null;\r\n    }\r\n\r\n    const pixels = await texture.readPixels(faceIndex, level);\r\n    if (!pixels) {\r\n        return null;\r\n    }\r\n\r\n    return GenerateBase64StringFromPixelData(pixels, texture.getSize(), internalTexture.invertY);\r\n}\r\n\r\n/**\r\n * Class used to host copy specific utilities\r\n * (Back-compat)\r\n */\r\nexport const CopyTools = {\r\n    /**\r\n     * Transform some pixel data to a base64 string\r\n     * @param pixels defines the pixel data to transform to base64\r\n     * @param size defines the width and height of the (texture) data\r\n     * @param invertY true if the data must be inverted for the Y coordinate during the conversion\r\n     * @returns The base64 encoded string or null\r\n     */\r\n    GenerateBase64StringFromPixelData,\r\n\r\n    /**\r\n     * Reads the pixels stored in the webgl texture and returns them as a base64 string\r\n     * @param texture defines the texture to read pixels from\r\n     * @param faceIndex defines the face of the texture to read (in case of cube texture)\r\n     * @param level defines the LOD level of the texture to read (in case of Mip Maps)\r\n     * @returns The base64 encoded string or null\r\n     */\r\n    GenerateBase64StringFromTexture,\r\n\r\n    /**\r\n     * Reads the pixels stored in the webgl texture and returns them as a base64 string\r\n     * @param texture defines the texture to read pixels from\r\n     * @param faceIndex defines the face of the texture to read (in case of cube texture)\r\n     * @param level defines the LOD level of the texture to read (in case of Mip Maps)\r\n     * @returns The base64 encoded string or null wrapped in a promise\r\n     */\r\n    GenerateBase64StringFromTextureAsync,\r\n};\r\n", "/**\r\n * Defines if the system should use OpenGL convention for UVs when creating geometry or loading .babylon files (false by default)\r\n */\r\nexport let useOpenGLOrientationForUV = false;\r\n\r\n/**\r\n * Sets whether to use OpenGL convention for UVs\r\n * @param value the new value\r\n */\r\nexport function setOpenGLOrientationForUV(value: boolean) {\r\n    useOpenGLOrientationForUV = value;\r\n}\r\n\r\n/**\r\n * Options used to control default behaviors regarding compatibility support\r\n * @deprecated please use named exports\r\n */\r\nexport const CompatibilityOptions = {\r\n    /* eslint-disable @typescript-eslint/naming-convention */\r\n    get UseOpenGLOrientationForUV() {\r\n        return useOpenGLOrientationForUV;\r\n    },\r\n    set UseOpenGLOrientationForUV(value) {\r\n        useOpenGLOrientationForUV = value;\r\n    },\r\n    /* eslint-enable @typescript-eslint/naming-convention */\r\n};\r\n", "import { serialize } from \"../../Misc/decorators\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Matrix, TmpVectors, Vector3 } from \"../../Maths/math.vector\";\r\nimport { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport { GetClass, RegisterClass } from \"../../Misc/typeStore\";\r\nimport { _WarnImport } from \"../../Misc/devTools\";\r\nimport type { IInspectable } from \"../../Misc/iInspectable\";\r\nimport type { AbstractEngine } from \"../../Engines/abstractEngine\";\r\nimport { TimingTools } from \"../../Misc/timingTools\";\r\nimport { InstantiationTools } from \"../../Misc/instantiationTools\";\r\nimport { Plane } from \"../../Maths/math.plane\";\r\nimport { EncodeArrayBufferToBase64 } from \"../../Misc/stringTools\";\r\nimport { GenerateBase64StringFromTexture, GenerateBase64StringFromTextureAsync } from \"../../Misc/copyTools\";\r\nimport { useOpenGLOrientationForUV } from \"../../Compat/compatibilityOptions\";\r\nimport type { InternalTexture } from \"./internalTexture\";\r\n\r\nimport type { CubeTexture } from \"../../Materials/Textures/cubeTexture\";\r\nimport type { MirrorTexture } from \"../../Materials/Textures/mirrorTexture\";\r\nimport type { RenderTargetTexture } from \"../../Materials/Textures/renderTargetTexture\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { VideoTexture, VideoTextureSettings } from \"./videoTexture\";\r\n\r\nimport { SerializationHelper } from \"../../Misc/decorators.serialization\";\r\n\r\n/**\r\n * Defines the available options when creating a texture\r\n */\r\nexport interface ITextureCreationOptions {\r\n    /** Defines if the texture will require mip maps or not (default: false) */\r\n    noMipmap?: boolean;\r\n\r\n    /** Defines if the texture needs to be inverted on the y axis during loading (default: true) */\r\n    invertY?: boolean;\r\n\r\n    /** Defines the sampling mode we want for the texture while fetching from it (Texture.NEAREST_SAMPLINGMODE...) (default: Texture.TRILINEAR_SAMPLINGMODE) */\r\n    samplingMode?: number;\r\n\r\n    /** Defines a callback triggered when the texture has been loaded (default: null) */\r\n    onLoad?: Nullable<() => void>;\r\n\r\n    /** Defines a callback triggered when an error occurred during the loading session (default: null) */\r\n    onError?: Nullable<(message?: string, exception?: any) => void>;\r\n\r\n    /** Defines the buffer to load the texture from in case the texture is loaded from a buffer representation (default: null) */\r\n    buffer?: Nullable<string | ArrayBuffer | ArrayBufferView | HTMLImageElement | Blob | ImageBitmap>;\r\n\r\n    /** Defines if the buffer we are loading the texture from should be deleted after load (default: false) */\r\n    deleteBuffer?: boolean;\r\n\r\n    /** Defines the format of the texture we are trying to load (Engine.TEXTUREFORMAT_RGBA...) (default: ) */\r\n    format?: number;\r\n\r\n    /** Defines an optional mime type information (default: undefined) */\r\n    mimeType?: string;\r\n\r\n    /** Options to be passed to the loader (default: undefined) */\r\n    loaderOptions?: any;\r\n\r\n    /** Specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg) (default: undefined) */\r\n    creationFlags?: number;\r\n\r\n    /** Defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU) (default: false) */\r\n    useSRGBBuffer?: boolean;\r\n\r\n    /** Defines the underlying texture from an already existing one */\r\n    internalTexture?: InternalTexture;\r\n\r\n    /** Defines the underlying texture texture space */\r\n    gammaSpace?: boolean;\r\n\r\n    /** Defines the extension to use to pick the right loader */\r\n    forcedExtension?: string;\r\n}\r\n\r\n/**\r\n * This represents a texture in babylon. It can be easily loaded from a network, base64 or html input.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/materials_introduction#texture\r\n */\r\nexport class Texture extends BaseTexture {\r\n    /**\r\n     * Gets or sets a general boolean used to indicate that textures containing direct data (buffers) must be saved as part of the serialization process\r\n     */\r\n    public static SerializeBuffers = true;\r\n\r\n    /**\r\n     * Gets or sets a general boolean used to indicate that texture buffers must be saved as part of the serialization process.\r\n     * If no buffer exists, one will be created as base64 string from the internal webgl data.\r\n     */\r\n    public static ForceSerializeBuffers = false;\r\n\r\n    /**\r\n     * This observable will notify when any texture had a loading error\r\n     */\r\n    public static OnTextureLoadErrorObservable = new Observable<BaseTexture>();\r\n\r\n    /** @internal */\r\n    public static _SerializeInternalTextureUniqueId = false;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public static _CubeTextureParser = (jsonTexture: any, scene: Scene, rootUrl: string): CubeTexture => {\r\n        throw _WarnImport(\"CubeTexture\");\r\n    };\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public static _CreateMirror = (name: string, renderTargetSize: number, scene: Scene, generateMipMaps: boolean): MirrorTexture => {\r\n        throw _WarnImport(\"MirrorTexture\");\r\n    };\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public static _CreateRenderTargetTexture = (name: string, renderTargetSize: number, scene: Scene, generateMipMaps: boolean, creationFlags?: number): RenderTargetTexture => {\r\n        throw _WarnImport(\"RenderTargetTexture\");\r\n    };\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _CreateVideoTexture(\r\n        name: Nullable<string>,\r\n        src: string | string[] | HTMLVideoElement,\r\n        scene: Nullable<Scene>,\r\n        generateMipMaps = false,\r\n        invertY = false,\r\n        samplingMode: number = Texture.TRILINEAR_SAMPLINGMODE,\r\n        settings: Partial<VideoTextureSettings> = {},\r\n        onError?: Nullable<(message?: string, exception?: any) => void>,\r\n        format: number = Constants.TEXTUREFORMAT_RGBA\r\n    ): VideoTexture {\r\n        throw _WarnImport(\"VideoTexture\");\r\n    }\r\n\r\n    /** nearest is mag = nearest and min = nearest and no mip */\r\n    public static readonly NEAREST_SAMPLINGMODE = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n    /** nearest is mag = nearest and min = nearest and mip = linear */\r\n    public static readonly NEAREST_NEAREST_MIPLINEAR = Constants.TEXTURE_NEAREST_NEAREST_MIPLINEAR; // nearest is mag = nearest and min = nearest and mip = linear\r\n\r\n    /** Bilinear is mag = linear and min = linear and no mip */\r\n    public static readonly BILINEAR_SAMPLINGMODE = Constants.TEXTURE_BILINEAR_SAMPLINGMODE;\r\n    /** Bilinear is mag = linear and min = linear and mip = nearest */\r\n    public static readonly LINEAR_LINEAR_MIPNEAREST = Constants.TEXTURE_LINEAR_LINEAR_MIPNEAREST; // Bilinear is mag = linear and min = linear and mip = nearest\r\n\r\n    /** Trilinear is mag = linear and min = linear and mip = linear */\r\n    public static readonly TRILINEAR_SAMPLINGMODE = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE;\r\n    /** Trilinear is mag = linear and min = linear and mip = linear */\r\n    public static readonly LINEAR_LINEAR_MIPLINEAR = Constants.TEXTURE_LINEAR_LINEAR_MIPLINEAR; // Trilinear is mag = linear and min = linear and mip = linear\r\n\r\n    /** mag = nearest and min = nearest and mip = nearest */\r\n    public static readonly NEAREST_NEAREST_MIPNEAREST = Constants.TEXTURE_NEAREST_NEAREST_MIPNEAREST;\r\n    /** mag = nearest and min = linear and mip = nearest */\r\n    public static readonly NEAREST_LINEAR_MIPNEAREST = Constants.TEXTURE_NEAREST_LINEAR_MIPNEAREST;\r\n    /** mag = nearest and min = linear and mip = linear */\r\n    public static readonly NEAREST_LINEAR_MIPLINEAR = Constants.TEXTURE_NEAREST_LINEAR_MIPLINEAR;\r\n    /** mag = nearest and min = linear and mip = none */\r\n    public static readonly NEAREST_LINEAR = Constants.TEXTURE_NEAREST_LINEAR;\r\n    /** mag = nearest and min = nearest and mip = none */\r\n    public static readonly NEAREST_NEAREST = Constants.TEXTURE_NEAREST_NEAREST;\r\n    /** mag = linear and min = nearest and mip = nearest */\r\n    public static readonly LINEAR_NEAREST_MIPNEAREST = Constants.TEXTURE_LINEAR_NEAREST_MIPNEAREST;\r\n    /** mag = linear and min = nearest and mip = linear */\r\n    public static readonly LINEAR_NEAREST_MIPLINEAR = Constants.TEXTURE_LINEAR_NEAREST_MIPLINEAR;\r\n    /** mag = linear and min = linear and mip = none */\r\n    public static readonly LINEAR_LINEAR = Constants.TEXTURE_LINEAR_LINEAR;\r\n    /** mag = linear and min = nearest and mip = none */\r\n    public static readonly LINEAR_NEAREST = Constants.TEXTURE_LINEAR_NEAREST;\r\n\r\n    /** Explicit coordinates mode */\r\n    public static readonly EXPLICIT_MODE = Constants.TEXTURE_EXPLICIT_MODE;\r\n    /** Spherical coordinates mode */\r\n    public static readonly SPHERICAL_MODE = Constants.TEXTURE_SPHERICAL_MODE;\r\n    /** Planar coordinates mode */\r\n    public static readonly PLANAR_MODE = Constants.TEXTURE_PLANAR_MODE;\r\n    /** Cubic coordinates mode */\r\n    public static readonly CUBIC_MODE = Constants.TEXTURE_CUBIC_MODE;\r\n    /** Projection coordinates mode */\r\n    public static readonly PROJECTION_MODE = Constants.TEXTURE_PROJECTION_MODE;\r\n    /** Inverse Cubic coordinates mode */\r\n    public static readonly SKYBOX_MODE = Constants.TEXTURE_SKYBOX_MODE;\r\n    /** Inverse Cubic coordinates mode */\r\n    public static readonly INVCUBIC_MODE = Constants.TEXTURE_INVCUBIC_MODE;\r\n    /** Equirectangular coordinates mode */\r\n    public static readonly EQUIRECTANGULAR_MODE = Constants.TEXTURE_EQUIRECTANGULAR_MODE;\r\n    /** Equirectangular Fixed coordinates mode */\r\n    public static readonly FIXED_EQUIRECTANGULAR_MODE = Constants.TEXTURE_FIXED_EQUIRECTANGULAR_MODE;\r\n    /** Equirectangular Fixed Mirrored coordinates mode */\r\n    public static readonly FIXED_EQUIRECTANGULAR_MIRRORED_MODE = Constants.TEXTURE_FIXED_EQUIRECTANGULAR_MIRRORED_MODE;\r\n\r\n    /** Texture is not repeating outside of 0..1 UVs */\r\n    public static readonly CLAMP_ADDRESSMODE = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n    /** Texture is repeating outside of 0..1 UVs */\r\n    public static readonly WRAP_ADDRESSMODE = Constants.TEXTURE_WRAP_ADDRESSMODE;\r\n    /** Texture is repeating and mirrored */\r\n    public static readonly MIRROR_ADDRESSMODE = Constants.TEXTURE_MIRROR_ADDRESSMODE;\r\n\r\n    /**\r\n     * Gets or sets a boolean which defines if the texture url must be build from the serialized URL instead of just using the name and loading them side by side with the scene file\r\n     */\r\n    public static UseSerializedUrlIfAny = false;\r\n\r\n    /**\r\n     * Define the url of the texture.\r\n     */\r\n    @serialize()\r\n    public url: Nullable<string> = null;\r\n\r\n    /**\r\n     * Define an offset on the texture to offset the u coordinates of the UVs\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/moreMaterials#offsetting\r\n     */\r\n    @serialize()\r\n    public uOffset = 0;\r\n\r\n    /**\r\n     * Define an offset on the texture to offset the v coordinates of the UVs\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/moreMaterials#offsetting\r\n     */\r\n    @serialize()\r\n    public vOffset = 0;\r\n\r\n    /**\r\n     * Define an offset on the texture to scale the u coordinates of the UVs\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/moreMaterials#tiling\r\n     */\r\n    @serialize()\r\n    public uScale = 1.0;\r\n\r\n    /**\r\n     * Define an offset on the texture to scale the v coordinates of the UVs\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/moreMaterials#tiling\r\n     */\r\n    @serialize()\r\n    public vScale = 1.0;\r\n\r\n    /**\r\n     * Define an offset on the texture to rotate around the u coordinates of the UVs\r\n     * The angle is defined in radians.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/moreMaterials\r\n     */\r\n    @serialize()\r\n    public uAng = 0;\r\n\r\n    /**\r\n     * Define an offset on the texture to rotate around the v coordinates of the UVs\r\n     * The angle is defined in radians.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/moreMaterials\r\n     */\r\n    @serialize()\r\n    public vAng = 0;\r\n\r\n    /**\r\n     * Define an offset on the texture to rotate around the w coordinates of the UVs (in case of 3d texture)\r\n     * The angle is defined in radians.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/moreMaterials\r\n     */\r\n    @serialize()\r\n    public wAng = 0;\r\n\r\n    /**\r\n     * Defines the center of rotation (U)\r\n     */\r\n    @serialize()\r\n    public uRotationCenter = 0.5;\r\n\r\n    /**\r\n     * Defines the center of rotation (V)\r\n     */\r\n    @serialize()\r\n    public vRotationCenter = 0.5;\r\n\r\n    /**\r\n     * Defines the center of rotation (W)\r\n     */\r\n    @serialize()\r\n    public wRotationCenter = 0.5;\r\n\r\n    /**\r\n     * Sets this property to true to avoid deformations when rotating the texture with non-uniform scaling\r\n     */\r\n    @serialize()\r\n    public homogeneousRotationInUVTransform = false;\r\n\r\n    /**\r\n     * Are mip maps generated for this texture or not.\r\n     */\r\n    override get noMipmap(): boolean {\r\n        return this._noMipmap;\r\n    }\r\n\r\n    /**\r\n     * List of inspectable custom properties (used by the Inspector)\r\n     * @see https://doc.babylonjs.com/toolsAndResources/inspector#extensibility\r\n     */\r\n    public inspectableCustomProperties: Nullable<IInspectable[]> = null;\r\n\r\n    /** @internal */\r\n    public _noMipmap: boolean = false;\r\n    /** @internal */\r\n    public _invertY: boolean = false;\r\n    private _rowGenerationMatrix: Nullable<Matrix> = null;\r\n    private _cachedTextureMatrix: Nullable<Matrix> = null;\r\n    private _projectionModeMatrix: Nullable<Matrix> = null;\r\n    private _t0: Nullable<Vector3> = null;\r\n    private _t1: Nullable<Vector3> = null;\r\n    private _t2: Nullable<Vector3> = null;\r\n\r\n    private _cachedUOffset: number = -1;\r\n    private _cachedVOffset: number = -1;\r\n    private _cachedUScale: number = 0;\r\n    private _cachedVScale: number = 0;\r\n    private _cachedUAng: number = -1;\r\n    private _cachedVAng: number = -1;\r\n    private _cachedWAng: number = -1;\r\n    private _cachedReflectionProjectionMatrixId: number = -1;\r\n    private _cachedURotationCenter: number = -1;\r\n    private _cachedVRotationCenter: number = -1;\r\n    private _cachedWRotationCenter: number = -1;\r\n    private _cachedHomogeneousRotationInUVTransform: boolean = false;\r\n    private _cachedIdentity3x2: boolean = true;\r\n\r\n    private _cachedReflectionTextureMatrix: Nullable<Matrix> = null;\r\n    private _cachedReflectionUOffset = -1;\r\n    private _cachedReflectionVOffset = -1;\r\n    private _cachedReflectionUScale = 0;\r\n    private _cachedReflectionVScale = 0;\r\n    private _cachedReflectionCoordinatesMode = -1;\r\n\r\n    /** @internal */\r\n    public _buffer: Nullable<string | ArrayBuffer | ArrayBufferView | HTMLImageElement | Blob | ImageBitmap> = null;\r\n    private _deleteBuffer: boolean = false;\r\n    protected _format: Nullable<number> = null;\r\n    private _delayedOnLoad: Nullable<() => void> = null;\r\n    private _delayedOnError: Nullable<() => void> = null;\r\n    private _mimeType?: string;\r\n    private _loaderOptions?: any;\r\n    private _creationFlags?: number;\r\n    /** @internal */\r\n    public _useSRGBBuffer?: boolean;\r\n    private _forcedExtension?: string;\r\n\r\n    /** Returns the texture mime type if it was defined by a loader (undefined else) */\r\n    public get mimeType() {\r\n        return this._mimeType;\r\n    }\r\n\r\n    /**\r\n     * Observable triggered once the texture has been loaded.\r\n     */\r\n    public onLoadObservable: Observable<Texture> = new Observable<Texture>();\r\n\r\n    protected _isBlocking: boolean = true;\r\n    /**\r\n     * Is the texture preventing material to render while loading.\r\n     * If false, a default texture will be used instead of the loading one during the preparation step.\r\n     */\r\n    public override set isBlocking(value: boolean) {\r\n        this._isBlocking = value;\r\n    }\r\n    @serialize()\r\n    public override get isBlocking(): boolean {\r\n        return this._isBlocking;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if the texture needs to be inverted on the y axis during loading\r\n     */\r\n    public get invertY(): boolean {\r\n        return this._invertY;\r\n    }\r\n\r\n    /**\r\n     * Instantiates a new texture.\r\n     * This represents a texture in babylon. It can be easily loaded from a network, base64 or html input.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/materials_introduction#texture\r\n     * @param url defines the url of the picture to load as a texture\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param noMipmapOrOptions defines if the texture will require mip maps or not or set of all options to create the texture\r\n     * @param invertY defines if the texture needs to be inverted on the y axis during loading\r\n     * @param samplingMode defines the sampling mode we want for the texture while fetching from it (Texture.NEAREST_SAMPLINGMODE...)\r\n     * @param onLoad defines a callback triggered when the texture has been loaded\r\n     * @param onError defines a callback triggered when an error occurred during the loading session\r\n     * @param buffer defines the buffer to load the texture from in case the texture is loaded from a buffer representation\r\n     * @param deleteBuffer defines if the buffer we are loading the texture from should be deleted after load\r\n     * @param format defines the format of the texture we are trying to load (Engine.TEXTUREFORMAT_RGBA...)\r\n     * @param mimeType defines an optional mime type information\r\n     * @param loaderOptions options to be passed to the loader\r\n     * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\r\n     * @param forcedExtension defines the extension to use to pick the right loader\r\n     */\r\n    constructor(\r\n        url: Nullable<string>,\r\n        sceneOrEngine?: Nullable<Scene | AbstractEngine>,\r\n        noMipmapOrOptions?: boolean | ITextureCreationOptions,\r\n        invertY?: boolean,\r\n        samplingMode: number = Texture.TRILINEAR_SAMPLINGMODE,\r\n        onLoad: Nullable<() => void> = null,\r\n        onError: Nullable<(message?: string, exception?: any) => void> = null,\r\n        buffer: Nullable<string | ArrayBuffer | ArrayBufferView | HTMLImageElement | Blob | ImageBitmap> = null,\r\n        deleteBuffer: boolean = false,\r\n        format?: number,\r\n        mimeType?: string,\r\n        loaderOptions?: any,\r\n        creationFlags?: number,\r\n        forcedExtension?: string\r\n    ) {\r\n        super(sceneOrEngine);\r\n\r\n        this.name = url || \"\";\r\n        this.url = url;\r\n\r\n        let noMipmap: boolean;\r\n        let useSRGBBuffer: boolean = false;\r\n        let internalTexture: Nullable<InternalTexture> = null;\r\n        let gammaSpace = true;\r\n\r\n        if (typeof noMipmapOrOptions === \"object\" && noMipmapOrOptions !== null) {\r\n            noMipmap = noMipmapOrOptions.noMipmap ?? false;\r\n            invertY = noMipmapOrOptions.invertY ?? !useOpenGLOrientationForUV;\r\n            samplingMode = noMipmapOrOptions.samplingMode ?? Texture.TRILINEAR_SAMPLINGMODE;\r\n            onLoad = noMipmapOrOptions.onLoad ?? null;\r\n            onError = noMipmapOrOptions.onError ?? null;\r\n            buffer = noMipmapOrOptions.buffer ?? null;\r\n            deleteBuffer = noMipmapOrOptions.deleteBuffer ?? false;\r\n            format = noMipmapOrOptions.format;\r\n            mimeType = noMipmapOrOptions.mimeType;\r\n            loaderOptions = noMipmapOrOptions.loaderOptions;\r\n            creationFlags = noMipmapOrOptions.creationFlags;\r\n            useSRGBBuffer = noMipmapOrOptions.useSRGBBuffer ?? false;\r\n            internalTexture = noMipmapOrOptions.internalTexture ?? null;\r\n            gammaSpace = noMipmapOrOptions.gammaSpace ?? gammaSpace;\r\n            forcedExtension = noMipmapOrOptions.forcedExtension ?? forcedExtension;\r\n        } else {\r\n            noMipmap = !!noMipmapOrOptions;\r\n        }\r\n\r\n        this._gammaSpace = gammaSpace;\r\n        this._noMipmap = noMipmap;\r\n        this._invertY = invertY === undefined ? !useOpenGLOrientationForUV : invertY;\r\n        this._initialSamplingMode = samplingMode;\r\n        this._buffer = buffer;\r\n        this._deleteBuffer = deleteBuffer;\r\n        this._mimeType = mimeType;\r\n        this._loaderOptions = loaderOptions;\r\n        this._creationFlags = creationFlags;\r\n        this._useSRGBBuffer = useSRGBBuffer;\r\n        this._forcedExtension = forcedExtension;\r\n        if (format) {\r\n            this._format = format;\r\n        }\r\n\r\n        const scene = this.getScene();\r\n        const engine = this._getEngine();\r\n        if (!engine) {\r\n            return;\r\n        }\r\n\r\n        engine.onBeforeTextureInitObservable.notifyObservers(this);\r\n\r\n        const load = () => {\r\n            if (this._texture) {\r\n                if (this._texture._invertVScale) {\r\n                    this.vScale *= -1;\r\n                    this.vOffset += 1;\r\n                }\r\n\r\n                // Update texture to match internal texture's wrapping\r\n                if (this._texture._cachedWrapU !== null) {\r\n                    this.wrapU = this._texture._cachedWrapU;\r\n                    this._texture._cachedWrapU = null;\r\n                }\r\n                if (this._texture._cachedWrapV !== null) {\r\n                    this.wrapV = this._texture._cachedWrapV;\r\n                    this._texture._cachedWrapV = null;\r\n                }\r\n                if (this._texture._cachedWrapR !== null) {\r\n                    this.wrapR = this._texture._cachedWrapR;\r\n                    this._texture._cachedWrapR = null;\r\n                }\r\n            }\r\n\r\n            if (this.onLoadObservable.hasObservers()) {\r\n                this.onLoadObservable.notifyObservers(this);\r\n            }\r\n            if (onLoad) {\r\n                onLoad();\r\n            }\r\n\r\n            if (!this.isBlocking && scene) {\r\n                scene.resetCachedMaterial();\r\n            }\r\n        };\r\n\r\n        const errorHandler = (message?: string, exception?: any) => {\r\n            this._loadingError = true;\r\n            this._errorObject = { message, exception };\r\n            if (onError) {\r\n                onError(message, exception);\r\n            }\r\n            Texture.OnTextureLoadErrorObservable.notifyObservers(this);\r\n        };\r\n\r\n        if (!this.url && !internalTexture) {\r\n            this._delayedOnLoad = load;\r\n            this._delayedOnError = errorHandler;\r\n            return;\r\n        }\r\n\r\n        this._texture = internalTexture ?? this._getFromCache(this.url, noMipmap, samplingMode, this._invertY, useSRGBBuffer, this.isCube);\r\n\r\n        if (!this._texture) {\r\n            if (!scene || !scene.useDelayedTextureLoading) {\r\n                try {\r\n                    this._texture = engine.createTexture(\r\n                        this.url,\r\n                        noMipmap,\r\n                        this._invertY,\r\n                        scene,\r\n                        samplingMode,\r\n                        load,\r\n                        errorHandler,\r\n                        this._buffer,\r\n                        undefined,\r\n                        this._format,\r\n                        this._forcedExtension,\r\n                        mimeType,\r\n                        loaderOptions,\r\n                        creationFlags,\r\n                        useSRGBBuffer\r\n                    );\r\n                } catch (e) {\r\n                    errorHandler(\"error loading\", e);\r\n                    throw e;\r\n                }\r\n                if (deleteBuffer) {\r\n                    this._buffer = null;\r\n                }\r\n            } else {\r\n                this.delayLoadState = Constants.DELAYLOADSTATE_NOTLOADED;\r\n\r\n                this._delayedOnLoad = load;\r\n                this._delayedOnError = errorHandler;\r\n            }\r\n        } else {\r\n            if (this._texture.isReady) {\r\n                TimingTools.SetImmediate(() => load());\r\n            } else {\r\n                const loadObserver = this._texture.onLoadedObservable.add(load);\r\n                this._texture.onErrorObservable.add((e) => {\r\n                    errorHandler(e.message, e.exception);\r\n                    this._texture?.onLoadedObservable.remove(loadObserver);\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update the url (and optional buffer) of this texture if url was null during construction.\r\n     * @param url the url of the texture\r\n     * @param buffer the buffer of the texture (defaults to null)\r\n     * @param onLoad callback called when the texture is loaded  (defaults to null)\r\n     * @param forcedExtension defines the extension to use to pick the right loader\r\n     */\r\n    public updateURL(\r\n        url: string,\r\n        buffer: Nullable<string | ArrayBuffer | ArrayBufferView | HTMLImageElement | Blob | ImageBitmap> = null,\r\n        onLoad?: () => void,\r\n        forcedExtension?: string\r\n    ): void {\r\n        if (this.url) {\r\n            this.releaseInternalTexture();\r\n            this.getScene()!.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(this);\r\n            });\r\n        }\r\n\r\n        if (!this.name || this.name.startsWith(\"data:\")) {\r\n            this.name = url;\r\n        }\r\n        this.url = url;\r\n        this._buffer = buffer;\r\n        this._forcedExtension = forcedExtension;\r\n        this.delayLoadState = Constants.DELAYLOADSTATE_NOTLOADED;\r\n\r\n        if (onLoad) {\r\n            this._delayedOnLoad = onLoad;\r\n        }\r\n        this.delayLoad();\r\n    }\r\n\r\n    /**\r\n     * Finish the loading sequence of a texture flagged as delayed load.\r\n     * @internal\r\n     */\r\n    public override delayLoad(): void {\r\n        if (this.delayLoadState !== Constants.DELAYLOADSTATE_NOTLOADED) {\r\n            return;\r\n        }\r\n\r\n        const scene = this.getScene();\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        this.delayLoadState = Constants.DELAYLOADSTATE_LOADED;\r\n        this._texture = this._getFromCache(this.url, this._noMipmap, this.samplingMode, this._invertY, this._useSRGBBuffer, this.isCube);\r\n\r\n        if (!this._texture) {\r\n            this._texture = scene\r\n                .getEngine()\r\n                .createTexture(\r\n                    this.url,\r\n                    this._noMipmap,\r\n                    this._invertY,\r\n                    scene,\r\n                    this.samplingMode,\r\n                    this._delayedOnLoad,\r\n                    this._delayedOnError,\r\n                    this._buffer,\r\n                    null,\r\n                    this._format,\r\n                    this._forcedExtension,\r\n                    this._mimeType,\r\n                    this._loaderOptions,\r\n                    this._creationFlags,\r\n                    this._useSRGBBuffer\r\n                );\r\n            if (this._deleteBuffer) {\r\n                this._buffer = null;\r\n            }\r\n        } else {\r\n            if (this._delayedOnLoad) {\r\n                if (this._texture.isReady) {\r\n                    TimingTools.SetImmediate(this._delayedOnLoad);\r\n                } else {\r\n                    this._texture.onLoadedObservable.add(this._delayedOnLoad);\r\n                }\r\n            }\r\n        }\r\n\r\n        this._delayedOnLoad = null;\r\n        this._delayedOnError = null;\r\n    }\r\n\r\n    private _prepareRowForTextureGeneration(x: number, y: number, z: number, t: Vector3): void {\r\n        x *= this._cachedUScale;\r\n        y *= this._cachedVScale;\r\n\r\n        x -= this.uRotationCenter * this._cachedUScale;\r\n        y -= this.vRotationCenter * this._cachedVScale;\r\n        z -= this.wRotationCenter;\r\n\r\n        Vector3.TransformCoordinatesFromFloatsToRef(x, y, z, this._rowGenerationMatrix!, t);\r\n\r\n        t.x += this.uRotationCenter * this._cachedUScale + this._cachedUOffset;\r\n        t.y += this.vRotationCenter * this._cachedVScale + this._cachedVOffset;\r\n        t.z += this.wRotationCenter;\r\n    }\r\n\r\n    /**\r\n     * Get the current texture matrix which includes the requested offsetting, tiling and rotation components.\r\n     * @param uBase The horizontal base offset multiplier (1 by default)\r\n     * @returns the transform matrix of the texture.\r\n     */\r\n    public override getTextureMatrix(uBase = 1): Matrix {\r\n        if (\r\n            this.uOffset === this._cachedUOffset &&\r\n            this.vOffset === this._cachedVOffset &&\r\n            this.uScale * uBase === this._cachedUScale &&\r\n            this.vScale === this._cachedVScale &&\r\n            this.uAng === this._cachedUAng &&\r\n            this.vAng === this._cachedVAng &&\r\n            this.wAng === this._cachedWAng &&\r\n            this.uRotationCenter === this._cachedURotationCenter &&\r\n            this.vRotationCenter === this._cachedVRotationCenter &&\r\n            this.wRotationCenter === this._cachedWRotationCenter &&\r\n            this.homogeneousRotationInUVTransform === this._cachedHomogeneousRotationInUVTransform\r\n        ) {\r\n            return this._cachedTextureMatrix!;\r\n        }\r\n\r\n        this._cachedUOffset = this.uOffset;\r\n        this._cachedVOffset = this.vOffset;\r\n        this._cachedUScale = this.uScale * uBase;\r\n        this._cachedVScale = this.vScale;\r\n        this._cachedUAng = this.uAng;\r\n        this._cachedVAng = this.vAng;\r\n        this._cachedWAng = this.wAng;\r\n        this._cachedURotationCenter = this.uRotationCenter;\r\n        this._cachedVRotationCenter = this.vRotationCenter;\r\n        this._cachedWRotationCenter = this.wRotationCenter;\r\n        this._cachedHomogeneousRotationInUVTransform = this.homogeneousRotationInUVTransform;\r\n\r\n        if (!this._cachedTextureMatrix || !this._rowGenerationMatrix) {\r\n            this._cachedTextureMatrix = Matrix.Zero();\r\n            this._rowGenerationMatrix = new Matrix();\r\n            this._t0 = Vector3.Zero();\r\n            this._t1 = Vector3.Zero();\r\n            this._t2 = Vector3.Zero();\r\n        }\r\n\r\n        Matrix.RotationYawPitchRollToRef(this.vAng, this.uAng, this.wAng, this._rowGenerationMatrix!);\r\n\r\n        if (this.homogeneousRotationInUVTransform) {\r\n            Matrix.TranslationToRef(-this._cachedURotationCenter, -this._cachedVRotationCenter, -this._cachedWRotationCenter, TmpVectors.Matrix[0]);\r\n            Matrix.TranslationToRef(this._cachedURotationCenter, this._cachedVRotationCenter, this._cachedWRotationCenter, TmpVectors.Matrix[1]);\r\n            Matrix.ScalingToRef(this._cachedUScale, this._cachedVScale, 0, TmpVectors.Matrix[2]);\r\n            Matrix.TranslationToRef(this._cachedUOffset, this._cachedVOffset, 0, TmpVectors.Matrix[3]);\r\n\r\n            TmpVectors.Matrix[0].multiplyToRef(this._rowGenerationMatrix!, this._cachedTextureMatrix);\r\n            this._cachedTextureMatrix.multiplyToRef(TmpVectors.Matrix[1], this._cachedTextureMatrix);\r\n            this._cachedTextureMatrix.multiplyToRef(TmpVectors.Matrix[2], this._cachedTextureMatrix);\r\n            this._cachedTextureMatrix.multiplyToRef(TmpVectors.Matrix[3], this._cachedTextureMatrix);\r\n\r\n            // copy the translation row to the 3rd row of the matrix so that we don't need to update the shaders (which expects the translation to be on the 3rd row)\r\n            this._cachedTextureMatrix.setRowFromFloats(2, this._cachedTextureMatrix.m[12], this._cachedTextureMatrix.m[13], this._cachedTextureMatrix.m[14], 1);\r\n        } else {\r\n            this._prepareRowForTextureGeneration(0, 0, 0, this._t0!);\r\n            this._prepareRowForTextureGeneration(1.0, 0, 0, this._t1!);\r\n            this._prepareRowForTextureGeneration(0, 1.0, 0, this._t2!);\r\n\r\n            this._t1!.subtractInPlace(this._t0!);\r\n            this._t2!.subtractInPlace(this._t0!);\r\n\r\n            Matrix.FromValuesToRef(\r\n                this._t1!.x,\r\n                this._t1!.y,\r\n                this._t1!.z,\r\n                0.0,\r\n                this._t2!.x,\r\n                this._t2!.y,\r\n                this._t2!.z,\r\n                0.0,\r\n                this._t0!.x,\r\n                this._t0!.y,\r\n                this._t0!.z,\r\n                0.0,\r\n                0.0,\r\n                0.0,\r\n                0.0,\r\n                1.0,\r\n                this._cachedTextureMatrix\r\n            );\r\n        }\r\n\r\n        const scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return this._cachedTextureMatrix;\r\n        }\r\n\r\n        const previousIdentity3x2 = this._cachedIdentity3x2;\r\n        this._cachedIdentity3x2 = this._cachedTextureMatrix.isIdentityAs3x2();\r\n\r\n        if (this.optimizeUVAllocation && previousIdentity3x2 !== this._cachedIdentity3x2) {\r\n            // We flag the materials that are using this texture as \"texture dirty\" because depending on the fact that the matrix is the identity or not, some defines\r\n            // will get different values (see PrepareDefinesForMergedUV), meaning we should regenerate the effect accordingly\r\n            scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(this);\r\n            });\r\n        }\r\n\r\n        return this._cachedTextureMatrix;\r\n    }\r\n\r\n    /**\r\n     * Get the current matrix used to apply reflection. This is useful to rotate an environment texture for instance.\r\n     * @returns The reflection texture transform\r\n     */\r\n    public override getReflectionTextureMatrix(): Matrix {\r\n        const scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return this._cachedReflectionTextureMatrix!;\r\n        }\r\n\r\n        if (\r\n            this.uOffset === this._cachedReflectionUOffset &&\r\n            this.vOffset === this._cachedReflectionVOffset &&\r\n            this.uScale === this._cachedReflectionUScale &&\r\n            this.vScale === this._cachedReflectionVScale &&\r\n            this.coordinatesMode === this._cachedReflectionCoordinatesMode\r\n        ) {\r\n            if (this.coordinatesMode === Texture.PROJECTION_MODE) {\r\n                if (this._cachedReflectionProjectionMatrixId === scene.getProjectionMatrix().updateFlag) {\r\n                    return this._cachedReflectionTextureMatrix!;\r\n                }\r\n            } else {\r\n                return this._cachedReflectionTextureMatrix!;\r\n            }\r\n        }\r\n\r\n        if (!this._cachedReflectionTextureMatrix) {\r\n            this._cachedReflectionTextureMatrix = Matrix.Zero();\r\n        }\r\n\r\n        if (!this._projectionModeMatrix) {\r\n            this._projectionModeMatrix = Matrix.Zero();\r\n        }\r\n\r\n        const flagMaterialsAsTextureDirty = this._cachedReflectionCoordinatesMode !== this.coordinatesMode;\r\n\r\n        this._cachedReflectionUOffset = this.uOffset;\r\n        this._cachedReflectionVOffset = this.vOffset;\r\n        this._cachedReflectionUScale = this.uScale;\r\n        this._cachedReflectionVScale = this.vScale;\r\n        this._cachedReflectionCoordinatesMode = this.coordinatesMode;\r\n\r\n        switch (this.coordinatesMode) {\r\n            case Texture.PLANAR_MODE: {\r\n                Matrix.IdentityToRef(this._cachedReflectionTextureMatrix);\r\n                (<any>this._cachedReflectionTextureMatrix)[0] = this.uScale;\r\n                (<any>this._cachedReflectionTextureMatrix)[5] = this.vScale;\r\n                (<any>this._cachedReflectionTextureMatrix)[12] = this.uOffset;\r\n                (<any>this._cachedReflectionTextureMatrix)[13] = this.vOffset;\r\n                break;\r\n            }\r\n            case Texture.PROJECTION_MODE: {\r\n                Matrix.FromValuesToRef(0.5, 0.0, 0.0, 0.0, 0.0, -0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.5, 0.5, 1.0, 1.0, this._projectionModeMatrix);\r\n\r\n                const projectionMatrix = scene.getProjectionMatrix();\r\n                this._cachedReflectionProjectionMatrixId = projectionMatrix.updateFlag;\r\n                projectionMatrix.multiplyToRef(this._projectionModeMatrix, this._cachedReflectionTextureMatrix);\r\n                break;\r\n            }\r\n            default:\r\n                Matrix.IdentityToRef(this._cachedReflectionTextureMatrix);\r\n                break;\r\n        }\r\n\r\n        if (flagMaterialsAsTextureDirty) {\r\n            // We flag the materials that are using this texture as \"texture dirty\" if the coordinatesMode has changed.\r\n            // Indeed, this property is used to set the value of some defines used to generate the effect (in material.isReadyForSubMesh), so we must make sure this code will be re-executed and the effect recreated if necessary\r\n            scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(this);\r\n            });\r\n        }\r\n\r\n        return this._cachedReflectionTextureMatrix;\r\n    }\r\n\r\n    /**\r\n     * Clones the texture.\r\n     * @returns the cloned texture\r\n     */\r\n    public override clone(): Texture {\r\n        const options: ITextureCreationOptions = {\r\n            noMipmap: this._noMipmap,\r\n            invertY: this._invertY,\r\n            samplingMode: this.samplingMode,\r\n            onLoad: undefined,\r\n            onError: undefined,\r\n            buffer: this._texture ? this._texture._buffer : undefined,\r\n            deleteBuffer: this._deleteBuffer,\r\n            format: this.textureFormat,\r\n            mimeType: this.mimeType,\r\n            loaderOptions: this._loaderOptions,\r\n            creationFlags: this._creationFlags,\r\n            useSRGBBuffer: this._useSRGBBuffer,\r\n        };\r\n\r\n        return SerializationHelper.Clone(() => {\r\n            return new Texture(this._texture ? this._texture.url : null, this.getScene(), options);\r\n        }, this);\r\n    }\r\n\r\n    /**\r\n     * Serialize the texture to a JSON representation we can easily use in the respective Parse function.\r\n     * @returns The JSON representation of the texture\r\n     */\r\n    public override serialize(): any {\r\n        const savedName = this.name;\r\n\r\n        if (!Texture.SerializeBuffers) {\r\n            if (this.name.startsWith(\"data:\")) {\r\n                this.name = \"\";\r\n            }\r\n        }\r\n\r\n        if (this.name.startsWith(\"data:\") && this.url === this.name) {\r\n            this.url = \"\";\r\n        }\r\n\r\n        const serializationObject = super.serialize(Texture._SerializeInternalTextureUniqueId);\r\n\r\n        if (!serializationObject) {\r\n            return null;\r\n        }\r\n\r\n        if (Texture.SerializeBuffers || Texture.ForceSerializeBuffers) {\r\n            if (typeof this._buffer === \"string\" && (this._buffer as string).substring(0, 5) === \"data:\") {\r\n                serializationObject.base64String = this._buffer;\r\n                serializationObject.name = serializationObject.name.replace(\"data:\", \"\");\r\n            } else if (this.url && this.url.startsWith(\"data:\") && this._buffer instanceof Uint8Array) {\r\n                serializationObject.base64String = \"data:image/png;base64,\" + EncodeArrayBufferToBase64(this._buffer);\r\n            } else if (Texture.ForceSerializeBuffers || (this.url && this.url.startsWith(\"blob:\")) || this._forceSerialize) {\r\n                serializationObject.base64String =\r\n                    !this._engine || this._engine._features.supportSyncTextureRead ? GenerateBase64StringFromTexture(this) : GenerateBase64StringFromTextureAsync(this);\r\n            }\r\n        }\r\n\r\n        serializationObject.invertY = this._invertY;\r\n        serializationObject.samplingMode = this.samplingMode;\r\n        serializationObject._creationFlags = this._creationFlags;\r\n        serializationObject._useSRGBBuffer = this._useSRGBBuffer;\r\n        if (Texture._SerializeInternalTextureUniqueId) {\r\n            serializationObject.internalTextureUniqueId = this._texture?.uniqueId;\r\n        }\r\n        serializationObject.internalTextureLabel = this._texture?.label;\r\n        serializationObject.noMipmap = this._noMipmap;\r\n\r\n        this.name = savedName;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Get the current class name of the texture useful for serialization or dynamic coding.\r\n     * @returns \"Texture\"\r\n     */\r\n    public override getClassName(): string {\r\n        return \"Texture\";\r\n    }\r\n\r\n    /**\r\n     * Dispose the texture and release its associated resources.\r\n     */\r\n    public override dispose(): void {\r\n        super.dispose();\r\n\r\n        this.onLoadObservable.clear();\r\n\r\n        this._delayedOnLoad = null;\r\n        this._delayedOnError = null;\r\n        this._buffer = null;\r\n    }\r\n\r\n    /**\r\n     * Parse the JSON representation of a texture in order to recreate the texture in the given scene.\r\n     * @param parsedTexture Define the JSON representation of the texture\r\n     * @param scene Define the scene the parsed texture should be instantiated in\r\n     * @param rootUrl Define the root url of the parsing sequence in the case of relative dependencies\r\n     * @returns The parsed texture if successful\r\n     */\r\n    public static Parse(parsedTexture: any, scene: Scene, rootUrl: string): Nullable<BaseTexture> {\r\n        if (parsedTexture.customType) {\r\n            const customTexture = InstantiationTools.Instantiate(parsedTexture.customType);\r\n            // Update Sampling Mode\r\n            const parsedCustomTexture: any = customTexture.Parse(parsedTexture, scene, rootUrl);\r\n            if (parsedTexture.samplingMode && parsedCustomTexture.updateSamplingMode && parsedCustomTexture._samplingMode) {\r\n                if (parsedCustomTexture._samplingMode !== parsedTexture.samplingMode) {\r\n                    parsedCustomTexture.updateSamplingMode(parsedTexture.samplingMode);\r\n                }\r\n            }\r\n            return parsedCustomTexture;\r\n        }\r\n\r\n        if (parsedTexture.isCube && !parsedTexture.isRenderTarget) {\r\n            return Texture._CubeTextureParser(parsedTexture, scene, rootUrl);\r\n        }\r\n\r\n        const hasInternalTextureUniqueId = parsedTexture.internalTextureUniqueId !== undefined;\r\n\r\n        if (!parsedTexture.name && !parsedTexture.isRenderTarget && !hasInternalTextureUniqueId) {\r\n            return null;\r\n        }\r\n\r\n        let internalTexture: InternalTexture | undefined;\r\n\r\n        if (hasInternalTextureUniqueId) {\r\n            const cache = scene.getEngine().getLoadedTexturesCache();\r\n            for (const texture of cache) {\r\n                if (texture.uniqueId === parsedTexture.internalTextureUniqueId) {\r\n                    internalTexture = texture;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        const onLoaded = (texture: Texture | null) => {\r\n            // Clear cache\r\n            if (texture && texture._texture) {\r\n                texture._texture._cachedWrapU = null;\r\n                texture._texture._cachedWrapV = null;\r\n                texture._texture._cachedWrapR = null;\r\n            }\r\n\r\n            // Update Sampling Mode\r\n            if (parsedTexture.samplingMode) {\r\n                const sampling: number = parsedTexture.samplingMode;\r\n                if (texture && texture.samplingMode !== sampling) {\r\n                    texture.updateSamplingMode(sampling);\r\n                }\r\n            }\r\n            // Animations\r\n            if (texture && parsedTexture.animations) {\r\n                for (let animationIndex = 0; animationIndex < parsedTexture.animations.length; animationIndex++) {\r\n                    const parsedAnimation = parsedTexture.animations[animationIndex];\r\n                    const internalClass = GetClass(\"BABYLON.Animation\");\r\n                    if (internalClass) {\r\n                        texture.animations.push(internalClass.Parse(parsedAnimation));\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (texture && texture._texture) {\r\n                if (hasInternalTextureUniqueId && !internalTexture) {\r\n                    texture._texture._setUniqueId(parsedTexture.internalTextureUniqueId);\r\n                }\r\n\r\n                texture._texture.label = parsedTexture.internalTextureLabel;\r\n            }\r\n        };\r\n\r\n        const texture = SerializationHelper.Parse(\r\n            () => {\r\n                let generateMipMaps: boolean = true;\r\n                if (parsedTexture.noMipmap) {\r\n                    generateMipMaps = false;\r\n                }\r\n                if (parsedTexture.mirrorPlane) {\r\n                    const mirrorTexture = Texture._CreateMirror(parsedTexture.name, parsedTexture.renderTargetSize, scene, generateMipMaps);\r\n                    mirrorTexture._waitingRenderList = parsedTexture.renderList;\r\n                    mirrorTexture.mirrorPlane = Plane.FromArray(parsedTexture.mirrorPlane);\r\n                    onLoaded(mirrorTexture);\r\n                    return mirrorTexture;\r\n                } else if (parsedTexture.isRenderTarget) {\r\n                    let renderTargetTexture: Nullable<RenderTargetTexture> = null;\r\n                    if (parsedTexture.isCube) {\r\n                        // Search for an existing reflection probe (which contains a cube render target texture)\r\n                        if (scene.reflectionProbes) {\r\n                            for (let index = 0; index < scene.reflectionProbes.length; index++) {\r\n                                const probe = scene.reflectionProbes[index];\r\n                                if (probe.name === parsedTexture.name) {\r\n                                    return probe.cubeTexture;\r\n                                }\r\n                            }\r\n                        }\r\n                    } else {\r\n                        renderTargetTexture = Texture._CreateRenderTargetTexture(\r\n                            parsedTexture.name,\r\n                            parsedTexture.renderTargetSize,\r\n                            scene,\r\n                            generateMipMaps,\r\n                            parsedTexture._creationFlags ?? 0\r\n                        );\r\n                        renderTargetTexture._waitingRenderList = parsedTexture.renderList;\r\n                    }\r\n                    onLoaded(renderTargetTexture);\r\n                    return renderTargetTexture;\r\n                } else if (parsedTexture.isVideo) {\r\n                    const texture = Texture._CreateVideoTexture(\r\n                        rootUrl + (parsedTexture.url || parsedTexture.name),\r\n                        rootUrl + (parsedTexture.src || parsedTexture.url),\r\n                        scene,\r\n                        generateMipMaps,\r\n                        parsedTexture.invertY,\r\n                        parsedTexture.samplingMode,\r\n                        parsedTexture.settings || {}\r\n                    );\r\n                    onLoaded(texture);\r\n                    return texture;\r\n                } else {\r\n                    let texture: Texture;\r\n\r\n                    if (parsedTexture.base64String && !internalTexture) {\r\n                        // name and url are the same to ensure caching happens from the actual base64 string\r\n                        texture = Texture.CreateFromBase64String(\r\n                            parsedTexture.base64String,\r\n                            parsedTexture.base64String,\r\n                            scene,\r\n                            !generateMipMaps,\r\n                            parsedTexture.invertY,\r\n                            parsedTexture.samplingMode,\r\n                            () => {\r\n                                onLoaded(texture);\r\n                            },\r\n                            parsedTexture._creationFlags ?? 0,\r\n                            parsedTexture._useSRGBBuffer ?? false\r\n                        );\r\n\r\n                        // prettier name to fit with the loaded data\r\n                        texture.name = parsedTexture.name;\r\n                    } else {\r\n                        let url: string;\r\n                        if (parsedTexture.name && (parsedTexture.name.indexOf(\"://\") > 0 || parsedTexture.name.startsWith(\"data:\"))) {\r\n                            url = parsedTexture.name;\r\n                        } else {\r\n                            url = rootUrl + parsedTexture.name;\r\n                        }\r\n\r\n                        if (parsedTexture.url && (parsedTexture.url.startsWith(\"data:\") || Texture.UseSerializedUrlIfAny)) {\r\n                            url = parsedTexture.url;\r\n                        }\r\n\r\n                        const options: ITextureCreationOptions = {\r\n                            noMipmap: !generateMipMaps,\r\n                            invertY: parsedTexture.invertY,\r\n                            samplingMode: parsedTexture.samplingMode,\r\n                            onLoad: () => {\r\n                                onLoaded(texture);\r\n                            },\r\n                            internalTexture,\r\n                        };\r\n\r\n                        texture = new Texture(url, scene, options);\r\n                    }\r\n\r\n                    return texture;\r\n                }\r\n            },\r\n            parsedTexture,\r\n            scene\r\n        );\r\n\r\n        return texture;\r\n    }\r\n\r\n    /**\r\n     * Creates a texture from its base 64 representation.\r\n     * @param data Define the base64 payload without the data: prefix\r\n     * @param name Define the name of the texture in the scene useful fo caching purpose for instance\r\n     * @param scene Define the scene the texture should belong to\r\n     * @param noMipmapOrOptions defines if the texture will require mip maps or not or set of all options to create the texture\r\n     * @param invertY define if the texture needs to be inverted on the y axis during loading\r\n     * @param samplingMode define the sampling mode we want for the texture while fetching from it (Texture.NEAREST_SAMPLINGMODE...)\r\n     * @param onLoad define a callback triggered when the texture has been loaded\r\n     * @param onError define a callback triggered when an error occurred during the loading session\r\n     * @param format define the format of the texture we are trying to load (Engine.TEXTUREFORMAT_RGBA...)\r\n     * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\r\n     * @param forcedExtension defines the extension to use to pick the right loader\r\n     * @returns the created texture\r\n     */\r\n    public static CreateFromBase64String(\r\n        data: string,\r\n        name: string,\r\n        scene: Scene,\r\n        noMipmapOrOptions?: boolean | ITextureCreationOptions,\r\n        invertY?: boolean,\r\n        samplingMode: number = Texture.TRILINEAR_SAMPLINGMODE,\r\n        onLoad: Nullable<() => void> = null,\r\n        onError: Nullable<() => void> = null,\r\n        format: number = Constants.TEXTUREFORMAT_RGBA,\r\n        creationFlags?: number,\r\n        forcedExtension?: string\r\n    ): Texture {\r\n        return new Texture(\r\n            \"data:\" + name,\r\n            scene,\r\n            noMipmapOrOptions,\r\n            invertY,\r\n            samplingMode,\r\n            onLoad,\r\n            onError,\r\n            data,\r\n            false,\r\n            format,\r\n            undefined,\r\n            undefined,\r\n            creationFlags,\r\n            forcedExtension\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Creates a texture from its data: representation. (data: will be added in case only the payload has been passed in)\r\n     * @param name Define the name of the texture in the scene useful fo caching purpose for instance\r\n     * @param buffer define the buffer to load the texture from in case the texture is loaded from a buffer representation\r\n     * @param scene Define the scene the texture should belong to\r\n     * @param deleteBuffer define if the buffer we are loading the texture from should be deleted after load\r\n     * @param noMipmapOrOptions defines if the texture will require mip maps or not or set of all options to create the texture\r\n     * @param invertY define if the texture needs to be inverted on the y axis during loading\r\n     * @param samplingMode define the sampling mode we want for the texture while fetching from it (Texture.NEAREST_SAMPLINGMODE...)\r\n     * @param onLoad define a callback triggered when the texture has been loaded\r\n     * @param onError define a callback triggered when an error occurred during the loading session\r\n     * @param format define the format of the texture we are trying to load (Engine.TEXTUREFORMAT_RGBA...)\r\n     * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\r\n     * @param forcedExtension defines the extension to use to pick the right loader\r\n     * @returns the created texture\r\n     */\r\n    public static LoadFromDataString(\r\n        name: string,\r\n        buffer: any,\r\n        scene: Scene,\r\n        deleteBuffer: boolean = false,\r\n        noMipmapOrOptions?: boolean | ITextureCreationOptions,\r\n        invertY: boolean = true,\r\n        samplingMode: number = Texture.TRILINEAR_SAMPLINGMODE,\r\n        onLoad: Nullable<() => void> = null,\r\n        onError: Nullable<(message?: string, exception?: any) => void> = null,\r\n        format: number = Constants.TEXTUREFORMAT_RGBA,\r\n        creationFlags?: number,\r\n        forcedExtension?: string\r\n    ): Texture {\r\n        if (name.substring(0, 5) !== \"data:\") {\r\n            name = \"data:\" + name;\r\n        }\r\n\r\n        return new Texture(\r\n            name,\r\n            scene,\r\n            noMipmapOrOptions,\r\n            invertY,\r\n            samplingMode,\r\n            onLoad,\r\n            onError,\r\n            buffer,\r\n            deleteBuffer,\r\n            format,\r\n            undefined,\r\n            undefined,\r\n            creationFlags,\r\n            forcedExtension\r\n        );\r\n    }\r\n}\r\n\r\n// References the dependencies.\r\nRegisterClass(\"BABYLON.Texture\", Texture);\r\nSerializationHelper._TextureParser = Texture.Parse;\r\n"],
  "mappings": "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",
  "names": ["index", "texture"]
}
