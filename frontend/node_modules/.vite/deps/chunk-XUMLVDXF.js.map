{
  "version": 3,
  "sources": ["../../../dev/core/src/FlowGraph/Blocks/Data/flowGraphGetPropertyBlock.ts"],
  "sourcesContent": ["import type { AssetType, FlowGraphAssetType } from \"core/FlowGraph/flowGraphAssetsContext\";\nimport type { IFlowGraphBlockConfiguration } from \"core/FlowGraph/flowGraphBlock\";\nimport type { FlowGraphContext } from \"core/FlowGraph/flowGraphContext\";\nimport type { FlowGraphDataConnection } from \"core/FlowGraph/flowGraphDataConnection\";\nimport { RichTypeAny } from \"core/FlowGraph/flowGraphRichTypes\";\nimport { RegisterClass } from \"core/Misc/typeStore\";\nimport { FlowGraphBlockNames } from \"../flowGraphBlockNames\";\nimport { FlowGraphCachedOperationBlock } from \"./flowGraphCachedOperationBlock\";\n\nexport interface IFlowGraphGetPropertyBlockConfiguration<O extends FlowGraphAssetType> extends IFlowGraphBlockConfiguration {\n    /**\n     * The name of the property that will be set\n     */\n    propertyName?: string;\n\n    /**\n     * The target asset from which the property will be retrieved\n     */\n    object?: AssetType<O>;\n\n    /**\n     * If true, the block will reset the output to the default value when the target asset is undefined.\n     */\n    resetToDefaultWhenUndefined?: boolean;\n}\n\n/**\n * This block will deliver a property of an asset, based on the property name and an input asset.\n * The property name can include dots (\".\"), which will be interpreted as a path to the property.\n *\n * For example, with an input of a mesh asset, the property name \"position.x\" will deliver the x component of the position of the mesh.\n *\n * Note that it is recommended to input the object on which you are working on (i.e. a material) rather than providing a mesh as object and then getting the material from it.\n */\nexport class FlowGraphGetPropertyBlock<P extends any, O extends FlowGraphAssetType> extends FlowGraphCachedOperationBlock<P> {\n    /**\n     * Input connection: The asset from which the property will be retrieved\n     */\n    public readonly object: FlowGraphDataConnection<AssetType<O>>;\n\n    /**\n     * Input connection: The name of the property that will be set\n     */\n    public readonly propertyName: FlowGraphDataConnection<string>;\n\n    /**\n     * Input connection: A function that can be used to get the value of the property.\n     * This will be used if defined, instead of the default get function.\n     */\n    public readonly customGetFunction: FlowGraphDataConnection<(target: AssetType<O>, propertyName: string, context: FlowGraphContext) => P | undefined>;\n\n    constructor(\n        /**\n         * the configuration of the block\n         */\n        public override config: IFlowGraphGetPropertyBlockConfiguration<O>\n    ) {\n        super(RichTypeAny, config);\n        this.object = this.registerDataInput(\"object\", RichTypeAny, config.object);\n        this.propertyName = this.registerDataInput(\"propertyName\", RichTypeAny, config.propertyName);\n        this.customGetFunction = this.registerDataInput(\"customGetFunction\", RichTypeAny);\n    }\n\n    public override _doOperation(context: FlowGraphContext): P | undefined {\n        const getter = this.customGetFunction.getValue(context);\n        let value;\n        if (getter) {\n            value = getter(this.object.getValue(context), this.propertyName.getValue(context), context);\n        } else {\n            const target = this.object.getValue(context);\n            const propertyName = this.propertyName.getValue(context);\n            value = target && propertyName ? this._getPropertyValue(target, propertyName) : undefined;\n        }\n        return value;\n    }\n\n    private _getPropertyValue(target: AssetType<O>, propertyName: string): P | undefined {\n        const path = propertyName.split(\".\");\n        let value: any = target;\n        for (const prop of path) {\n            value = value[prop];\n            if (value === undefined) {\n                return;\n            }\n        }\n        return value as P;\n    }\n\n    public override getClassName(): string {\n        return FlowGraphBlockNames.GetProperty;\n    }\n}\n\nRegisterClass(FlowGraphBlockNames.GetProperty, FlowGraphGetPropertyBlock);\n"],
  "mappings": ";;;;;;;;;;;AAkCM,IAAO,4BAAP,cAAsF,8BAAgC;EAiBxH,YAIoB,QAAkD;AAElE,UAAM,aAAa,MAAM;AAFT,SAAA,SAAA;AAGhB,SAAK,SAAS,KAAK,kBAAkB,UAAU,aAAa,OAAO,MAAM;AACzE,SAAK,eAAe,KAAK,kBAAkB,gBAAgB,aAAa,OAAO,YAAY;AAC3F,SAAK,oBAAoB,KAAK,kBAAkB,qBAAqB,WAAW;EACpF;EAEgB,aAAa,SAAyB;AAClD,UAAM,SAAS,KAAK,kBAAkB,SAAS,OAAO;AACtD,QAAI;AACJ,QAAI,QAAQ;AACR,cAAQ,OAAO,KAAK,OAAO,SAAS,OAAO,GAAG,KAAK,aAAa,SAAS,OAAO,GAAG,OAAO;IAC9F,OAAO;AACH,YAAM,SAAS,KAAK,OAAO,SAAS,OAAO;AAC3C,YAAM,eAAe,KAAK,aAAa,SAAS,OAAO;AACvD,cAAQ,UAAU,eAAe,KAAK,kBAAkB,QAAQ,YAAY,IAAI;IACpF;AACA,WAAO;EACX;EAEQ,kBAAkB,QAAsB,cAAoB;AAChE,UAAM,OAAO,aAAa,MAAM,GAAG;AACnC,QAAI,QAAa;AACjB,eAAW,QAAQ,MAAM;AACrB,cAAQ,MAAM,IAAI;AAClB,UAAI,UAAU,QAAW;AACrB;MACJ;IACJ;AACA,WAAO;EACX;EAEgB,eAAY;AACxB,WAAA;EACJ;;AAGJ,cAAa,6BAAkC,yBAAyB;",
  "names": []
}
