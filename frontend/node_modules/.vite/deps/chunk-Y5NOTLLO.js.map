{
  "version": 3,
  "sources": ["../../../dev/core/src/FlowGraph/Blocks/Execution/ControlFlow/flowGraphWaitAllBlock.ts"],
  "sourcesContent": ["import type { FlowGraphContext } from \"../../../flowGraphContext\";\r\nimport type { FlowGraphSignalConnection } from \"../../../flowGraphSignalConnection\";\r\nimport { FlowGraphExecutionBlockWithOutSignal } from \"../../../flowGraphExecutionBlockWithOutSignal\";\r\nimport type { IFlowGraphBlockConfiguration } from \"../../../flowGraphBlock\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport type { FlowGraphDataConnection } from \"core/FlowGraph/flowGraphDataConnection\";\r\nimport { RichTypeNumber } from \"core/FlowGraph/flowGraphRichTypes\";\r\nimport { FlowGraphBlockNames } from \"../../flowGraphBlockNames\";\r\n/**\r\n * Configuration for the wait all block.\r\n */\r\nexport interface IFlowGraphWaitAllBlockConfiguration extends IFlowGraphBlockConfiguration {\r\n    /**\r\n     * The number of input signals. There will always be at least one input flow.\r\n     * glTF interactivity has a max of 64 input flows.\r\n     */\r\n    inputSignalCount: number;\r\n}\r\n\r\n/**\r\n * A block that waits for all input flows to be activated before activating its output flow.\r\n */\r\nexport class FlowGraphWaitAllBlock extends FlowGraphExecutionBlockWithOutSignal {\r\n    /**\r\n     * Input connection: Resets the block.\r\n     */\r\n    public reset: FlowGraphSignalConnection;\r\n\r\n    /**\r\n     * Output connection:When the last missing flow is activated\r\n     */\r\n    public completed: FlowGraphSignalConnection;\r\n\r\n    /**\r\n     * Output connection: The number of remaining inputs to be activated.\r\n     */\r\n    public remainingInputs: FlowGraphDataConnection<number>;\r\n    /**\r\n     * An array of input signals\r\n     */\r\n    public readonly inFlows: FlowGraphSignalConnection[] = [];\r\n    private _cachedActivationState: boolean[] = [];\r\n\r\n    constructor(\r\n        /**\r\n         * the configuration of the block\r\n         */\r\n        public override config: IFlowGraphWaitAllBlockConfiguration\r\n    ) {\r\n        super(config);\r\n\r\n        this.reset = this._registerSignalInput(\"reset\");\r\n        this.completed = this._registerSignalOutput(\"completed\");\r\n        this.remainingInputs = this.registerDataOutput(\"remainingInputs\", RichTypeNumber, this.config.inputSignalCount || 0);\r\n        // The first inFlow is the default input signal all execution blocks have\r\n        for (let i = 0; i < this.config.inputSignalCount; i++) {\r\n            this.inFlows.push(this._registerSignalInput(`in_${i}`));\r\n        }\r\n        // no need for in\r\n        this._unregisterSignalInput(\"in\");\r\n    }\r\n\r\n    private _getCurrentActivationState(context: FlowGraphContext) {\r\n        const activationState = this._cachedActivationState;\r\n        activationState.length = 0;\r\n        if (!context._hasExecutionVariable(this, \"activationState\")) {\r\n            for (let i = 0; i < this.config.inputSignalCount; i++) {\r\n                activationState.push(false);\r\n            }\r\n        } else {\r\n            const contextActivationState = context._getExecutionVariable(this, \"activationState\", [] as boolean[]);\r\n            for (let i = 0; i < contextActivationState.length; i++) {\r\n                activationState.push(contextActivationState[i]);\r\n            }\r\n        }\r\n        return activationState;\r\n    }\r\n\r\n    public _execute(context: FlowGraphContext, callingSignal: FlowGraphSignalConnection): void {\r\n        const activationState = this._getCurrentActivationState(context);\r\n        if (callingSignal === this.reset) {\r\n            for (let i = 0; i < this.config.inputSignalCount; i++) {\r\n                activationState[i] = false;\r\n            }\r\n        } else {\r\n            const index = this.inFlows.indexOf(callingSignal);\r\n            if (index >= 0) {\r\n                activationState[index] = true;\r\n            }\r\n        }\r\n        this.remainingInputs.setValue(activationState.filter((v) => !v).length, context);\r\n\r\n        context._setExecutionVariable(this, \"activationState\", activationState.slice());\r\n\r\n        if (!activationState.includes(false)) {\r\n            this.completed._activateSignal(context);\r\n            for (let i = 0; i < this.config.inputSignalCount; i++) {\r\n                activationState[i] = false;\r\n            }\r\n        } else {\r\n            callingSignal !== this.reset && this.out._activateSignal(context);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @returns class name of the block.\r\n     */\r\n    public override getClassName(): string {\r\n        return FlowGraphBlockNames.WaitAll;\r\n    }\r\n\r\n    /**\r\n     * Serializes this block into a object\r\n     * @param serializationObject the object to serialize to\r\n     */\r\n    public override serialize(serializationObject?: any): void {\r\n        super.serialize(serializationObject);\r\n        serializationObject.config.inputFlows = this.config.inputSignalCount;\r\n    }\r\n}\r\nRegisterClass(FlowGraphBlockNames.WaitAll, FlowGraphWaitAllBlock);\r\n"],
  "mappings": ";;;;;;;;;;;AAsBM,IAAO,wBAAP,cAAqC,qCAAoC;EAqB3E,YAIoB,QAA2C;AAE3D,UAAM,MAAM;AAFI,SAAA,SAAA;AAPJ,SAAA,UAAuC,CAAA;AAC/C,SAAA,yBAAoC,CAAA;AAUxC,SAAK,QAAQ,KAAK,qBAAqB,OAAO;AAC9C,SAAK,YAAY,KAAK,sBAAsB,WAAW;AACvD,SAAK,kBAAkB,KAAK,mBAAmB,mBAAmB,gBAAgB,KAAK,OAAO,oBAAoB,CAAC;AAEnH,aAAS,IAAI,GAAG,IAAI,KAAK,OAAO,kBAAkB,KAAK;AACnD,WAAK,QAAQ,KAAK,KAAK,qBAAqB,MAAM,CAAC,EAAE,CAAC;IAC1D;AAEA,SAAK,uBAAuB,IAAI;EACpC;EAEQ,2BAA2B,SAAyB;AACxD,UAAM,kBAAkB,KAAK;AAC7B,oBAAgB,SAAS;AACzB,QAAI,CAAC,QAAQ,sBAAsB,MAAM,iBAAiB,GAAG;AACzD,eAAS,IAAI,GAAG,IAAI,KAAK,OAAO,kBAAkB,KAAK;AACnD,wBAAgB,KAAK,KAAK;MAC9B;IACJ,OAAO;AACH,YAAM,yBAAyB,QAAQ,sBAAsB,MAAM,mBAAmB,CAAA,CAAe;AACrG,eAAS,IAAI,GAAG,IAAI,uBAAuB,QAAQ,KAAK;AACpD,wBAAgB,KAAK,uBAAuB,CAAC,CAAC;MAClD;IACJ;AACA,WAAO;EACX;EAEO,SAAS,SAA2B,eAAwC;AAC/E,UAAM,kBAAkB,KAAK,2BAA2B,OAAO;AAC/D,QAAI,kBAAkB,KAAK,OAAO;AAC9B,eAAS,IAAI,GAAG,IAAI,KAAK,OAAO,kBAAkB,KAAK;AACnD,wBAAgB,CAAC,IAAI;MACzB;IACJ,OAAO;AACH,YAAM,QAAQ,KAAK,QAAQ,QAAQ,aAAa;AAChD,UAAI,SAAS,GAAG;AACZ,wBAAgB,KAAK,IAAI;MAC7B;IACJ;AACA,SAAK,gBAAgB,SAAS,gBAAgB,OAAO,CAAC,MAAM,CAAC,CAAC,EAAE,QAAQ,OAAO;AAE/E,YAAQ,sBAAsB,MAAM,mBAAmB,gBAAgB,MAAK,CAAE;AAE9E,QAAI,CAAC,gBAAgB,SAAS,KAAK,GAAG;AAClC,WAAK,UAAU,gBAAgB,OAAO;AACtC,eAAS,IAAI,GAAG,IAAI,KAAK,OAAO,kBAAkB,KAAK;AACnD,wBAAgB,CAAC,IAAI;MACzB;IACJ,OAAO;AACH,wBAAkB,KAAK,SAAS,KAAK,IAAI,gBAAgB,OAAO;IACpE;EACJ;;;;EAKgB,eAAY;AACxB,WAAA;EACJ;;;;;EAMgB,UAAU,qBAAyB;AAC/C,UAAM,UAAU,mBAAmB;AACnC,wBAAoB,OAAO,aAAa,KAAK,OAAO;EACxD;;AAEJ,cAAa,yBAA8B,qBAAqB;",
  "names": []
}
