{
  "version": 3,
  "sources": ["../../../dev/core/src/AudioV2/abstractAudio/staticSound.ts", "../../../dev/core/src/AudioV2/abstractAudio/staticSoundBuffer.ts", "../../../dev/core/src/AudioV2/abstractAudio/staticSoundInstance.ts", "../../../dev/core/src/AudioV2/webAudio/webAudioStaticSound.ts"],
  "sourcesContent": ["import { SoundState } from \"../soundState\";\nimport type { IAbstractSoundOptions, IAbstractSoundPlayOptions, IAbstractSoundStoredOptions } from \"./abstractSound\";\nimport { AbstractSound } from \"./abstractSound\";\nimport type { AudioEngineV2 } from \"./audioEngineV2\";\nimport type { IStaticSoundBufferOptions, StaticSoundBuffer } from \"./staticSoundBuffer\";\nimport type { _StaticSoundInstance } from \"./staticSoundInstance\";\n\n/** @internal */\nexport interface IStaticSoundOptionsBase {\n    /**\n     * The amount of time to play the sound for, in seconds. Defaults to `0`.\n     * - If less than or equal to `0`, the sound plays for its full duration.\n     */\n    duration: number;\n    /**\n     * The end of the loop range in seconds. Defaults to `0`.\n     * - If less than or equal to `0`, the loop plays for the sound's full duration.\n     * - Has no effect if {@link loop} is `false`.\n     */\n    loopEnd: number;\n    /**\n     * The start of the loop range in seconds. Defaults to `0`.\n     * - If less than or equal to `0`, the loop starts at the beginning of the sound.\n     * - Has no effect if {@link loop} is `false`.\n     *\n     */\n    loopStart: number;\n}\n\n/**\n * Options stored in a static sound.\n * @internal\n */\nexport interface IStaticSoundStoredOptions extends IAbstractSoundStoredOptions, IStaticSoundOptionsBase {\n    /**\n     * The pitch of the sound, in cents. Defaults to `0`.\n     * - Can be combined with {@link playbackRate}.\n     */\n    pitch: number;\n    /**\n     * The playback rate of the sound. Defaults to `1`.\n     * - Can be combined with {@link pitch}.\n     */\n    playbackRate: number;\n}\n\n/**\n * Options for creating a static sound.\n */\nexport interface IStaticSoundOptions extends IAbstractSoundOptions, IStaticSoundBufferOptions, IStaticSoundStoredOptions {}\n\n/**\n * Options for playing a static sound.\n */\nexport interface IStaticSoundPlayOptions extends IAbstractSoundPlayOptions, IStaticSoundOptionsBase {\n    /**\n     * The time to wait before playing the sound, in seconds. Defaults to `0`.\n     */\n    waitTime: number;\n}\n\n/**\n * Options for stopping a static sound.\n */\nexport interface IStaticSoundStopOptions {\n    /**\n     * The time to wait before stopping the sound, in seconds. Defaults to `0`.\n     */\n    waitTime: number;\n}\n\n/**\n * Abstract class representing a static sound.\n *\n * A static sound has a sound buffer that is loaded into memory all at once. This allows it to have more capabilities\n * than a streaming sound, such as loop points and playback rate changes, but it also means that the sound must be\n * fully downloaded and decoded before it can be played, which may take a long time for sounds with long durations.\n *\n * To prevent downloading and decoding a sound multiple times, a sound's buffer can be shared with other sounds.\n * See {@link CreateSoundBufferAsync}, {@link StaticSoundBuffer} and {@link StaticSound.buffer} for more information.\n *\n * Static sounds are created by the {@link CreateSoundAsync} function.\n */\nexport abstract class StaticSound extends AbstractSound {\n    protected override _instances: Set<_StaticSoundInstance>;\n    protected abstract override readonly _options: IStaticSoundStoredOptions;\n\n    /**\n     * The sound buffer that the sound uses.\n     *\n     * This buffer can be shared with other static sounds.\n     */\n    public abstract readonly buffer: StaticSoundBuffer;\n\n    protected constructor(name: string, engine: AudioEngineV2) {\n        super(name, engine);\n    }\n\n    /**\n     * The amount of time to play the sound for, in seconds. Defaults to `0`.\n     * - If less than or equal to `0`, the sound plays for its full duration.\n     */\n    public get duration(): number {\n        return this._options.duration;\n    }\n\n    public set duration(value: number) {\n        this._options.duration = value;\n    }\n\n    /**\n     * The start of the loop range, in seconds. Defaults to `0`.\n     * - If less than or equal to `0`, the loop starts at the beginning of the sound.\n     */\n    public get loopStart(): number {\n        return this._options.loopStart;\n    }\n\n    public set loopStart(value: number) {\n        this._options.loopStart = value;\n    }\n\n    /**\n     * The end of the loop range, in seconds. Defaults to `0`.\n     * - If less than or equal to `0`, the loop plays for the sound's full duration.\n     */\n    public get loopEnd(): number {\n        return this._options.loopEnd;\n    }\n\n    public set loopEnd(value: number) {\n        this._options.loopEnd = value;\n    }\n\n    /**\n     * The pitch of the sound, in cents. Defaults to `0`.\n     * - Gets combined with {@link playbackRate} to determine the final pitch.\n     */\n    public get pitch(): number {\n        return this._options.pitch;\n    }\n\n    public set pitch(value: number) {\n        this._options.pitch = value;\n\n        const it = this._instances.values();\n        for (let instance = it.next(); !instance.done; instance = it.next()) {\n            instance.value.pitch = value;\n        }\n    }\n\n    /**\n     * The playback rate of the sound. Defaults to `1`.\n     * - Gets combined with {@link pitch} to determine the final playback rate.\n     */\n    public get playbackRate(): number {\n        return this._options.playbackRate;\n    }\n\n    public set playbackRate(value: number) {\n        this._options.playbackRate = value;\n\n        const it = this._instances.values();\n        for (let instance = it.next(); !instance.done; instance = it.next()) {\n            instance.value.playbackRate = value;\n        }\n    }\n\n    protected abstract override _createInstance(): _StaticSoundInstance;\n\n    /**\n     * Plays the sound.\n     * - Triggers `onEndedObservable` if played for the full duration and the `loop` option is not set.\n     * @param options The options to use when playing the sound. Options set here override the sound's options.\n     */\n    public play(options: Partial<IStaticSoundPlayOptions> = {}): void {\n        if (this.state === SoundState.Paused) {\n            this.resume();\n            return;\n        }\n\n        options.duration ??= this.duration;\n        options.loop ??= this.loop;\n        options.loopStart ??= this.loopStart;\n        options.loopEnd ??= this.loopEnd;\n        options.startOffset ??= this.startOffset;\n        options.volume ??= 1;\n        options.waitTime ??= 0;\n\n        const instance = this._createInstance();\n        this._beforePlay(instance);\n        instance.play(options);\n        this._afterPlay(instance);\n\n        this._stopExcessInstances();\n    }\n\n    /**\n     * Stops the sound.\n     * - Triggers `onEndedObservable` if the sound is playing.\n     * @param options - The options to use when stopping the sound.\n     */\n    public stop(options: Partial<IStaticSoundStopOptions> = {}): void {\n        if (options.waitTime && 0 < options.waitTime) {\n            this._setState(SoundState.Stopping);\n        } else {\n            this._setState(SoundState.Stopped);\n        }\n\n        if (!this._instances) {\n            return;\n        }\n\n        for (const instance of Array.from(this._instances)) {\n            instance.stop(options);\n        }\n    }\n}\n", "import type { AudioEngineV2 } from \"./audioEngineV2\";\n\n/**\n * Options for creating a static sound buffer.\n */\nexport interface IStaticSoundBufferOptions {\n    /**\n     * Whether to skip codec checking before attempting to load each source URL when `source` is a string array. Defaults to `false`.\n     * - Has no effect if the sound's source is not a string array.\n     * @see {@link CreateSoundAsync} `source` parameter.\n     */\n    skipCodecCheck: boolean;\n}\n\n/**\n * Abstract class representing a static sound buffer.\n *\n * A static sound buffer is a fully downloaded and decoded array of audio data that is ready to be played.\n *\n * Static sound buffers can be reused multiple times by different {@link StaticSound} instances.\n *\n * Static sound buffers are created by the {@link CreateSoundBufferAsync} function.\n *\n * @see {@link StaticSound.buffer}\n */\nexport abstract class StaticSoundBuffer {\n    /**\n     * The engine that the sound buffer belongs to.\n     */\n    public readonly engine: AudioEngineV2;\n\n    protected constructor(engine: AudioEngineV2) {\n        this.engine = engine;\n    }\n\n    /**\n     * The sample rate of the sound buffer.\n     */\n    public abstract readonly sampleRate: number;\n\n    /**\n     * The length of the sound buffer, in sample frames.\n     */\n    public abstract readonly length: number;\n\n    /**\n     * The duration of the sound buffer, in seconds.\n     */\n    public abstract readonly duration: number;\n\n    /**\n     * The number of channels in the sound buffer.\n     */\n    public abstract readonly channelCount: number;\n}\n", "import type { IAbstractSoundInstanceOptions } from \"./abstractSoundInstance\";\nimport { _AbstractSoundInstance } from \"./abstractSoundInstance\";\nimport type { IStaticSoundOptionsBase, IStaticSoundPlayOptions, IStaticSoundStopOptions } from \"./staticSound\";\n\n/**\n * Options for creating a static sound instance.\n * @internal\n */\nexport interface IStaticSoundInstanceOptions extends IAbstractSoundInstanceOptions, IStaticSoundOptionsBase {}\n\n/** @internal */\nexport abstract class _StaticSoundInstance extends _AbstractSoundInstance {\n    protected abstract override readonly _options: IStaticSoundInstanceOptions;\n\n    public abstract pitch: number;\n    public abstract playbackRate: number;\n\n    public abstract override play(options: Partial<IStaticSoundPlayOptions>): void;\n    public abstract override stop(options?: Partial<IStaticSoundStopOptions>): void;\n}\n", "import type { Nullable } from \"../../types\";\nimport type { AbstractAudioNode } from \"../abstractAudio/abstractAudioNode\";\nimport type { IStaticSoundOptions, IStaticSoundPlayOptions, IStaticSoundStopOptions, IStaticSoundStoredOptions } from \"../abstractAudio/staticSound\";\nimport { StaticSound } from \"../abstractAudio/staticSound\";\nimport type { IStaticSoundBufferOptions } from \"../abstractAudio/staticSoundBuffer\";\nimport { StaticSoundBuffer } from \"../abstractAudio/staticSoundBuffer\";\nimport type { IStaticSoundInstanceOptions } from \"../abstractAudio/staticSoundInstance\";\nimport { _StaticSoundInstance } from \"../abstractAudio/staticSoundInstance\";\nimport { _HasSpatialAudioOptions } from \"../abstractAudio/subProperties/abstractSpatialAudio\";\nimport type { _SpatialAudio } from \"../abstractAudio/subProperties/spatialAudio\";\nimport { _StereoAudio } from \"../abstractAudio/subProperties/stereoAudio\";\nimport { _CleanUrl, _FileExtensionRegex } from \"../audioUtils\";\nimport { SoundState } from \"../soundState\";\nimport { _WebAudioBusAndSoundSubGraph } from \"./subNodes/webAudioBusAndSoundSubGraph\";\nimport { _SpatialWebAudio } from \"./subProperties/spatialWebAudio\";\nimport type { _WebAudioEngine } from \"./webAudioEngine\";\nimport type { IWebAudioInNode, IWebAudioOutNode, IWebAudioSuperNode } from \"./webAudioNode\";\n\ntype StaticSoundSourceType = ArrayBuffer | AudioBuffer | StaticSoundBuffer | string | string[];\n\n/** @internal */\nexport class _WebAudioStaticSound extends StaticSound implements IWebAudioSuperNode {\n    private _buffer: _WebAudioStaticSoundBuffer;\n    private _spatial: Nullable<_SpatialWebAudio> = null;\n    private readonly _spatialAutoUpdate: boolean = true;\n    private readonly _spatialMinUpdateTime: number = 0;\n    private _stereo: Nullable<_StereoAudio> = null;\n\n    protected override readonly _options: IStaticSoundStoredOptions;\n    protected _subGraph: _WebAudioBusAndSoundSubGraph;\n\n    /** @internal */\n    public _audioContext: AudioContext | OfflineAudioContext;\n\n    /** @internal */\n    public override readonly engine: _WebAudioEngine;\n\n    /** @internal */\n    public constructor(name: string, engine: _WebAudioEngine, options: Partial<IStaticSoundOptions>) {\n        super(name, engine);\n\n        if (typeof options.spatialAutoUpdate === \"boolean\") {\n            this._spatialAutoUpdate = options.spatialAutoUpdate;\n        }\n\n        if (typeof options.spatialMinUpdateTime === \"number\") {\n            this._spatialMinUpdateTime = options.spatialMinUpdateTime;\n        }\n\n        this._options = {\n            autoplay: options.autoplay ?? false,\n            duration: options.duration ?? 0,\n            loop: options.loop ?? false,\n            loopEnd: options.loopEnd ?? 0,\n            loopStart: options.loopStart ?? 0,\n            maxInstances: options.maxInstances ?? Infinity,\n            pitch: options.pitch ?? 0,\n            playbackRate: options.playbackRate ?? 1,\n            startOffset: options.startOffset ?? 0,\n        };\n\n        this._subGraph = new _WebAudioStaticSound._SubGraph(this);\n    }\n\n    /** @internal */\n    public async _init(source: StaticSoundSourceType, options: Partial<IStaticSoundOptions>): Promise<void> {\n        this._audioContext = this.engine._audioContext;\n\n        if (source instanceof _WebAudioStaticSoundBuffer) {\n            this._buffer = source as _WebAudioStaticSoundBuffer;\n        } else if (typeof source === \"string\" || Array.isArray(source) || source instanceof ArrayBuffer || source instanceof AudioBuffer) {\n            this._buffer = (await this.engine.createSoundBufferAsync(source, options)) as _WebAudioStaticSoundBuffer;\n        }\n\n        if (options.outBus) {\n            this.outBus = options.outBus;\n        } else {\n            await this.engine.isReadyPromise;\n            this.outBus = this.engine.defaultMainBus;\n        }\n\n        await this._subGraph.init(options);\n\n        if (_HasSpatialAudioOptions(options)) {\n            this._initSpatialProperty();\n        }\n\n        if (options.autoplay) {\n            this.play();\n        }\n\n        this.engine._addNode(this);\n    }\n\n    /** @internal */\n    public get buffer(): _WebAudioStaticSoundBuffer {\n        return this._buffer;\n    }\n\n    /** @internal */\n    public get _inNode() {\n        return this._subGraph._inNode;\n    }\n\n    /** @internal */\n    public get _outNode() {\n        return this._subGraph._outNode;\n    }\n\n    /** @internal */\n    public override get spatial(): _SpatialAudio {\n        if (this._spatial) {\n            return this._spatial;\n        }\n        return this._initSpatialProperty();\n    }\n\n    /** @internal */\n    public override get stereo(): _StereoAudio {\n        return this._stereo ?? (this._stereo = new _StereoAudio(this._subGraph));\n    }\n\n    /** @internal */\n    public override dispose(): void {\n        super.dispose();\n\n        this._spatial?.dispose();\n        this._spatial = null;\n\n        this._stereo = null;\n\n        this._subGraph.dispose();\n\n        this.engine._removeNode(this);\n    }\n\n    /** @internal */\n    public getClassName(): string {\n        return \"_WebAudioStaticSound\";\n    }\n\n    protected _createInstance(): _WebAudioStaticSoundInstance {\n        return new _WebAudioStaticSoundInstance(this, this._options);\n    }\n\n    protected override _connect(node: IWebAudioInNode): boolean {\n        const connected = super._connect(node);\n\n        if (!connected) {\n            return false;\n        }\n\n        // If the wrapped node is not available now, it will be connected later by the subgraph.\n        if (node._inNode) {\n            this._outNode?.connect(node._inNode);\n        }\n\n        return true;\n    }\n\n    protected override _disconnect(node: IWebAudioInNode): boolean {\n        const disconnected = super._disconnect(node);\n\n        if (!disconnected) {\n            return false;\n        }\n\n        if (node._inNode) {\n            this._outNode?.disconnect(node._inNode);\n        }\n\n        return true;\n    }\n\n    private _initSpatialProperty(): _SpatialAudio {\n        if (!this._spatial) {\n            this._spatial = new _SpatialWebAudio(this._subGraph, this._spatialAutoUpdate, this._spatialMinUpdateTime);\n        }\n\n        return this._spatial;\n    }\n\n    private static _SubGraph = class extends _WebAudioBusAndSoundSubGraph {\n        protected override _owner: _WebAudioStaticSound;\n\n        protected get _downstreamNodes(): Nullable<Set<AbstractAudioNode>> {\n            return this._owner._downstreamNodes ?? null;\n        }\n\n        protected get _upstreamNodes(): Nullable<Set<AbstractAudioNode>> {\n            return this._owner._upstreamNodes ?? null;\n        }\n    };\n}\n\n/** @internal */\nexport class _WebAudioStaticSoundBuffer extends StaticSoundBuffer {\n    /** @internal */\n    public _audioBuffer: AudioBuffer;\n\n    /** @internal */\n    public override readonly engine: _WebAudioEngine;\n\n    /** @internal */\n    public constructor(engine: _WebAudioEngine) {\n        super(engine);\n    }\n\n    public async _init(source: StaticSoundSourceType, options: Partial<IStaticSoundBufferOptions>): Promise<void> {\n        if (source instanceof AudioBuffer) {\n            this._audioBuffer = source;\n        } else if (typeof source === \"string\") {\n            await this._initFromUrl(source);\n        } else if (Array.isArray(source)) {\n            await this._initFromUrls(source, options.skipCodecCheck ?? false);\n        } else if (source instanceof ArrayBuffer) {\n            await this._initFromArrayBuffer(source);\n        }\n    }\n\n    /** @internal */\n    public get channelCount(): number {\n        return this._audioBuffer.numberOfChannels;\n    }\n\n    /** @internal */\n    public get duration(): number {\n        return this._audioBuffer.duration;\n    }\n\n    /** @internal */\n    public get length(): number {\n        return this._audioBuffer.length;\n    }\n\n    /** @internal */\n    public get sampleRate(): number {\n        return this._audioBuffer.sampleRate;\n    }\n\n    private async _initFromArrayBuffer(arrayBuffer: ArrayBuffer): Promise<void> {\n        this._audioBuffer = await this.engine._audioContext.decodeAudioData(arrayBuffer);\n    }\n\n    private async _initFromUrl(url: string): Promise<void> {\n        url = _CleanUrl(url);\n        await this._initFromArrayBuffer(await (await fetch(url)).arrayBuffer());\n    }\n\n    private async _initFromUrls(urls: string[], skipCodecCheck: boolean): Promise<void> {\n        for (const url of urls) {\n            if (skipCodecCheck) {\n                await this._initFromUrl(url);\n            } else {\n                const matches = url.match(_FileExtensionRegex);\n                const format = matches?.at(1);\n                if (format && this.engine.isFormatValid(format)) {\n                    try {\n                        await this._initFromUrl(url);\n                    } catch (e) {\n                        if (format && 0 < format.length) {\n                            this.engine.flagInvalidFormat(format);\n                        }\n                    }\n                }\n            }\n\n            if (this._audioBuffer) {\n                break;\n            }\n        }\n    }\n}\n\n/** @internal */\nclass _WebAudioStaticSoundInstance extends _StaticSoundInstance implements IWebAudioOutNode {\n    private _enginePlayTime: number = 0;\n    private _enginePauseTime: number = 0;\n    private _sourceNode: Nullable<AudioBufferSourceNode> = null;\n    private _volumeNode: GainNode;\n\n    protected override readonly _options: IStaticSoundInstanceOptions;\n    protected override _sound: _WebAudioStaticSound;\n\n    /** @internal */\n    public override readonly engine: _WebAudioEngine;\n\n    public constructor(sound: _WebAudioStaticSound, options: IStaticSoundInstanceOptions) {\n        super(sound);\n\n        this._options = options;\n\n        this._volumeNode = new GainNode(sound._audioContext);\n        this._initSourceNode();\n    }\n\n    /** @internal */\n    public get currentTime(): number {\n        if (this._state === SoundState.Stopped) {\n            return 0;\n        }\n\n        const timeSinceLastStart = this._state === SoundState.Paused ? 0 : this.engine.currentTime - this._enginePlayTime;\n        return this._enginePauseTime + timeSinceLastStart + this._options.startOffset;\n    }\n\n    public set currentTime(value: number) {\n        const restart = this._state === SoundState.Starting || this._state === SoundState.Started;\n\n        if (restart) {\n            this.stop();\n            this._deinitSourceNode();\n        }\n\n        this._options.startOffset = value;\n\n        if (restart) {\n            this.play();\n        }\n    }\n\n    public get _outNode(): Nullable<AudioNode> {\n        return this._volumeNode;\n    }\n\n    /** @internal */\n    public set pitch(value: number) {\n        if (this._sourceNode) {\n            this.engine._setAudioParam(this._sourceNode.detune, value);\n        }\n    }\n\n    /** @internal */\n    public set playbackRate(value: number) {\n        if (this._sourceNode) {\n            this.engine._setAudioParam(this._sourceNode.playbackRate, value);\n        }\n    }\n\n    /** @internal */\n    public get startTime(): number {\n        if (this._state === SoundState.Stopped) {\n            return 0;\n        }\n\n        return this._enginePlayTime;\n    }\n\n    /** @internal */\n    public override dispose(): void {\n        super.dispose();\n\n        this._sourceNode = null;\n\n        this.stop();\n\n        this._deinitSourceNode();\n\n        this.engine.stateChangedObservable.removeCallback(this._onEngineStateChanged);\n    }\n\n    /** @internal */\n    public getClassName(): string {\n        return \"_WebAudioStaticSoundInstance\";\n    }\n\n    /** @internal */\n    public play(options: Partial<IStaticSoundPlayOptions> = {}): void {\n        if (this._state === SoundState.Started) {\n            return;\n        }\n\n        if (options.duration !== undefined) {\n            this._options.duration = options.duration;\n        }\n        if (options.loop !== undefined) {\n            this._options.loop = options.loop;\n        }\n        if (options.loopStart !== undefined) {\n            this._options.loopStart = options.loopStart;\n        }\n        if (options.loopEnd !== undefined) {\n            this._options.loopEnd = options.loopEnd;\n        }\n        if (options.startOffset !== undefined) {\n            this._options.startOffset = options.startOffset;\n        }\n\n        let startOffset = this._options.startOffset;\n\n        if (this._state === SoundState.Paused) {\n            startOffset += this.currentTime;\n            startOffset %= this._sound.buffer.duration;\n        }\n\n        this._enginePlayTime = this.engine.currentTime + (options.waitTime ?? 0);\n\n        this._volumeNode.gain.value = options.volume ?? 1;\n\n        this._initSourceNode();\n\n        if (this.engine.state === \"running\") {\n            this._setState(SoundState.Started);\n            this._sourceNode?.start(this._enginePlayTime, startOffset, this._options.duration > 0 ? this._options.duration : undefined);\n        } else if (this._options.loop) {\n            this._setState(SoundState.Starting);\n            this.engine.stateChangedObservable.add(this._onEngineStateChanged);\n        }\n    }\n\n    /** @internal */\n    public pause(): void {\n        if (this._state === SoundState.Paused) {\n            return;\n        }\n\n        this._setState(SoundState.Paused);\n        this._enginePauseTime += this.engine.currentTime - this._enginePlayTime;\n\n        this._sourceNode?.stop();\n        this._deinitSourceNode();\n    }\n\n    /** @internal */\n    public resume(): void {\n        if (this._state === SoundState.Paused) {\n            this.play();\n        }\n    }\n\n    /** @internal */\n    public stop(options: Partial<IStaticSoundStopOptions> = {}): void {\n        if (this._state === SoundState.Stopped) {\n            return;\n        }\n\n        this._setState(SoundState.Stopped);\n\n        const engineStopTime = this.engine.currentTime + (options.waitTime ?? 0);\n        this._sourceNode?.stop(engineStopTime);\n\n        this.engine.stateChangedObservable.removeCallback(this._onEngineStateChanged);\n    }\n\n    protected override _connect(node: AbstractAudioNode): boolean {\n        const connected = super._connect(node);\n\n        if (!connected) {\n            return false;\n        }\n\n        // If the wrapped node is not available now, it will be connected later by the sound's subgraph.\n        if (node instanceof _WebAudioStaticSound && node._inNode) {\n            this._outNode?.connect(node._inNode);\n        }\n\n        return true;\n    }\n\n    protected override _disconnect(node: AbstractAudioNode): boolean {\n        const disconnected = super._disconnect(node);\n\n        if (!disconnected) {\n            return false;\n        }\n\n        if (node instanceof _WebAudioStaticSound && node._inNode) {\n            this._outNode?.disconnect(node._inNode);\n        }\n\n        return true;\n    }\n\n    protected _onEnded = () => {\n        this._enginePlayTime = 0;\n\n        this.onEndedObservable.notifyObservers(this);\n        this._deinitSourceNode();\n    };\n\n    private _deinitSourceNode(): void {\n        if (!this._sourceNode) {\n            return;\n        }\n\n        if (!this._disconnect(this._sound)) {\n            throw new Error(\"Disconnect failed\");\n        }\n\n        this._sourceNode.disconnect(this._volumeNode);\n        this._sourceNode.removeEventListener(\"ended\", this._onEnded);\n\n        this._sourceNode = null;\n    }\n\n    private _initSourceNode(): void {\n        if (!this._sourceNode) {\n            this._sourceNode = new AudioBufferSourceNode(this._sound._audioContext, { buffer: this._sound.buffer._audioBuffer });\n\n            this._sourceNode.addEventListener(\"ended\", this._onEnded, { once: true });\n            this._sourceNode.connect(this._volumeNode);\n\n            if (!this._connect(this._sound)) {\n                throw new Error(\"Connect failed\");\n            }\n        }\n\n        const node = this._sourceNode;\n        node.detune.value = this._sound.pitch;\n        node.loop = this._options.loop;\n        node.loopEnd = this._options.loopEnd;\n        node.loopStart = this._options.loopStart;\n        node.playbackRate.value = this._sound.playbackRate;\n    }\n\n    private _onEngineStateChanged = () => {\n        if (this.engine.state !== \"running\") {\n            return;\n        }\n\n        if (this._options.loop && this.state === SoundState.Starting) {\n            this.play();\n        }\n\n        this.engine.stateChangedObservable.removeCallback(this._onEngineStateChanged);\n    };\n}\n"],
  "mappings": ";;;;;;;;;;;;;;AAmFM,IAAgB,cAAhB,cAAoC,cAAa;EAWnD,YAAsB,MAAc,QAAqB;AACrD,UAAM,MAAM,MAAM;EACtB;;;;;EAMA,IAAW,WAAQ;AACf,WAAO,KAAK,SAAS;EACzB;EAEA,IAAW,SAAS,OAAa;AAC7B,SAAK,SAAS,WAAW;EAC7B;;;;;EAMA,IAAW,YAAS;AAChB,WAAO,KAAK,SAAS;EACzB;EAEA,IAAW,UAAU,OAAa;AAC9B,SAAK,SAAS,YAAY;EAC9B;;;;;EAMA,IAAW,UAAO;AACd,WAAO,KAAK,SAAS;EACzB;EAEA,IAAW,QAAQ,OAAa;AAC5B,SAAK,SAAS,UAAU;EAC5B;;;;;EAMA,IAAW,QAAK;AACZ,WAAO,KAAK,SAAS;EACzB;EAEA,IAAW,MAAM,OAAa;AAC1B,SAAK,SAAS,QAAQ;AAEtB,UAAM,KAAK,KAAK,WAAW,OAAM;AACjC,aAAS,WAAW,GAAG,KAAI,GAAI,CAAC,SAAS,MAAM,WAAW,GAAG,KAAI,GAAI;AACjE,eAAS,MAAM,QAAQ;IAC3B;EACJ;;;;;EAMA,IAAW,eAAY;AACnB,WAAO,KAAK,SAAS;EACzB;EAEA,IAAW,aAAa,OAAa;AACjC,SAAK,SAAS,eAAe;AAE7B,UAAM,KAAK,KAAK,WAAW,OAAM;AACjC,aAAS,WAAW,GAAG,KAAI,GAAI,CAAC,SAAS,MAAM,WAAW,GAAG,KAAI,GAAI;AACjE,eAAS,MAAM,eAAe;IAClC;EACJ;;;;;;EASO,KAAK,UAA4C,CAAA,GAAE;AACtD,QAAI,KAAK,UAAK,GAAwB;AAClC,WAAK,OAAM;AACX;IACJ;AAEA,YAAQ,aAAR,QAAQ,WAAa,KAAK;AAC1B,YAAQ,SAAR,QAAQ,OAAS,KAAK;AACtB,YAAQ,cAAR,QAAQ,YAAc,KAAK;AAC3B,YAAQ,YAAR,QAAQ,UAAY,KAAK;AACzB,YAAQ,gBAAR,QAAQ,cAAgB,KAAK;AAC7B,YAAQ,WAAR,QAAQ,SAAW;AACnB,YAAQ,aAAR,QAAQ,WAAa;AAErB,UAAM,WAAW,KAAK,gBAAe;AACrC,SAAK,YAAY,QAAQ;AACzB,aAAS,KAAK,OAAO;AACrB,SAAK,WAAW,QAAQ;AAExB,SAAK,qBAAoB;EAC7B;;;;;;EAOO,KAAK,UAA4C,CAAA,GAAE;AACtD,QAAI,QAAQ,YAAY,IAAI,QAAQ,UAAU;AAC1C,WAAK;QAAS;;MAAA;IAClB,OAAO;AACH,WAAK;QAAS;;MAAA;IAClB;AAEA,QAAI,CAAC,KAAK,YAAY;AAClB;IACJ;AAEA,eAAW,YAAY,MAAM,KAAK,KAAK,UAAU,GAAG;AAChD,eAAS,KAAK,OAAO;IACzB;EACJ;;;;AC/LE,IAAgB,oBAAhB,MAAiC;EAMnC,YAAsB,QAAqB;AACvC,SAAK,SAAS;EAClB;;;;ACtBE,IAAgB,uBAAhB,cAA6C,uBAAsB;;;;ACUnE,IAAO,uBAAP,MAAO,8BAA6B,YAAW;;EAiBjD,YAAmB,MAAc,QAAyB,SAAqC;AAC3F,UAAM,MAAM,MAAM;AAhBd,SAAA,WAAuC;AAC9B,SAAA,qBAA8B;AAC9B,SAAA,wBAAgC;AACzC,SAAA,UAAkC;AAetC,QAAI,OAAO,QAAQ,sBAAsB,WAAW;AAChD,WAAK,qBAAqB,QAAQ;IACtC;AAEA,QAAI,OAAO,QAAQ,yBAAyB,UAAU;AAClD,WAAK,wBAAwB,QAAQ;IACzC;AAEA,SAAK,WAAW;MACZ,UAAU,QAAQ,YAAY;MAC9B,UAAU,QAAQ,YAAY;MAC9B,MAAM,QAAQ,QAAQ;MACtB,SAAS,QAAQ,WAAW;MAC5B,WAAW,QAAQ,aAAa;MAChC,cAAc,QAAQ,gBAAgB;MACtC,OAAO,QAAQ,SAAS;MACxB,cAAc,QAAQ,gBAAgB;MACtC,aAAa,QAAQ,eAAe;;AAGxC,SAAK,YAAY,IAAI,sBAAqB,UAAU,IAAI;EAC5D;;EAGO,MAAM,MAAM,QAA+B,SAAqC;AACnF,SAAK,gBAAgB,KAAK,OAAO;AAEjC,QAAI,kBAAkB,4BAA4B;AAC9C,WAAK,UAAU;IACnB,WAAW,OAAO,WAAW,YAAY,MAAM,QAAQ,MAAM,KAAK,kBAAkB,eAAe,kBAAkB,aAAa;AAC9H,WAAK,UAAW,MAAM,KAAK,OAAO,uBAAuB,QAAQ,OAAO;IAC5E;AAEA,QAAI,QAAQ,QAAQ;AAChB,WAAK,SAAS,QAAQ;IAC1B,OAAO;AACH,YAAM,KAAK,OAAO;AAClB,WAAK,SAAS,KAAK,OAAO;IAC9B;AAEA,UAAM,KAAK,UAAU,KAAK,OAAO;AAEjC,QAAI,wBAAwB,OAAO,GAAG;AAClC,WAAK,qBAAoB;IAC7B;AAEA,QAAI,QAAQ,UAAU;AAClB,WAAK,KAAI;IACb;AAEA,SAAK,OAAO,SAAS,IAAI;EAC7B;;EAGA,IAAW,SAAM;AACb,WAAO,KAAK;EAChB;;EAGA,IAAW,UAAO;AACd,WAAO,KAAK,UAAU;EAC1B;;EAGA,IAAW,WAAQ;AACf,WAAO,KAAK,UAAU;EAC1B;;EAGA,IAAoB,UAAO;AACvB,QAAI,KAAK,UAAU;AACf,aAAO,KAAK;IAChB;AACA,WAAO,KAAK,qBAAoB;EACpC;;EAGA,IAAoB,SAAM;AACtB,WAAO,KAAK,YAAY,KAAK,UAAU,IAAI,aAAa,KAAK,SAAS;EAC1E;;EAGgB,UAAO;AAxH3B;AAyHQ,UAAM,QAAO;AAEb,eAAK,aAAL,mBAAe;AACf,SAAK,WAAW;AAEhB,SAAK,UAAU;AAEf,SAAK,UAAU,QAAO;AAEtB,SAAK,OAAO,YAAY,IAAI;EAChC;;EAGO,eAAY;AACf,WAAO;EACX;EAEU,kBAAe;AACrB,WAAO,IAAI,6BAA6B,MAAM,KAAK,QAAQ;EAC/D;EAEmB,SAAS,MAAqB;AA9IrD;AA+IQ,UAAM,YAAY,MAAM,SAAS,IAAI;AAErC,QAAI,CAAC,WAAW;AACZ,aAAO;IACX;AAGA,QAAI,KAAK,SAAS;AACd,iBAAK,aAAL,mBAAe,QAAQ,KAAK;IAChC;AAEA,WAAO;EACX;EAEmB,YAAY,MAAqB;AA7JxD;AA8JQ,UAAM,eAAe,MAAM,YAAY,IAAI;AAE3C,QAAI,CAAC,cAAc;AACf,aAAO;IACX;AAEA,QAAI,KAAK,SAAS;AACd,iBAAK,aAAL,mBAAe,WAAW,KAAK;IACnC;AAEA,WAAO;EACX;EAEQ,uBAAoB;AACxB,QAAI,CAAC,KAAK,UAAU;AAChB,WAAK,WAAW,IAAI,iBAAiB,KAAK,WAAW,KAAK,oBAAoB,KAAK,qBAAqB;IAC5G;AAEA,WAAO,KAAK;EAChB;;AAEe,qBAAA,YAAY,cAAc,6BAA4B;EAGjE,IAAc,mBAAgB;AAC1B,WAAO,KAAK,OAAO,oBAAoB;EAC3C;EAEA,IAAc,iBAAc;AACxB,WAAO,KAAK,OAAO,kBAAkB;EACzC;;AAKF,IAAO,6BAAP,cAA0C,kBAAiB;;EAQ7D,YAAmB,QAAuB;AACtC,UAAM,MAAM;EAChB;EAEO,MAAM,MAAM,QAA+B,SAA2C;AACzF,QAAI,kBAAkB,aAAa;AAC/B,WAAK,eAAe;IACxB,WAAW,OAAO,WAAW,UAAU;AACnC,YAAM,KAAK,aAAa,MAAM;IAClC,WAAW,MAAM,QAAQ,MAAM,GAAG;AAC9B,YAAM,KAAK,cAAc,QAAQ,QAAQ,kBAAkB,KAAK;IACpE,WAAW,kBAAkB,aAAa;AACtC,YAAM,KAAK,qBAAqB,MAAM;IAC1C;EACJ;;EAGA,IAAW,eAAY;AACnB,WAAO,KAAK,aAAa;EAC7B;;EAGA,IAAW,WAAQ;AACf,WAAO,KAAK,aAAa;EAC7B;;EAGA,IAAW,SAAM;AACb,WAAO,KAAK,aAAa;EAC7B;;EAGA,IAAW,aAAU;AACjB,WAAO,KAAK,aAAa;EAC7B;EAEQ,MAAM,qBAAqB,aAAwB;AACvD,SAAK,eAAe,MAAM,KAAK,OAAO,cAAc,gBAAgB,WAAW;EACnF;EAEQ,MAAM,aAAa,KAAW;AAClC,UAAM,UAAU,GAAG;AACnB,UAAM,KAAK,qBAAqB,OAAO,MAAM,MAAM,GAAG,GAAG,YAAW,CAAE;EAC1E;EAEQ,MAAM,cAAc,MAAgB,gBAAuB;AAC/D,eAAW,OAAO,MAAM;AACpB,UAAI,gBAAgB;AAChB,cAAM,KAAK,aAAa,GAAG;MAC/B,OAAO;AACH,cAAM,UAAU,IAAI,MAAM,mBAAmB;AAC7C,cAAM,SAAS,mCAAS,GAAG;AAC3B,YAAI,UAAU,KAAK,OAAO,cAAc,MAAM,GAAG;AAC7C,cAAI;AACA,kBAAM,KAAK,aAAa,GAAG;UAC/B,SAAS,GAAG;AACR,gBAAI,UAAU,IAAI,OAAO,QAAQ;AAC7B,mBAAK,OAAO,kBAAkB,MAAM;YACxC;UACJ;QACJ;MACJ;AAEA,UAAI,KAAK,cAAc;AACnB;MACJ;IACJ;EACJ;;AAIJ,IAAM,+BAAN,cAA2C,qBAAoB;EAY3D,YAAmB,OAA6B,SAAoC;AAChF,UAAM,KAAK;AAZP,SAAA,kBAA0B;AAC1B,SAAA,mBAA2B;AAC3B,SAAA,cAA+C;AAmM7C,SAAA,WAAW,MAAK;AACtB,WAAK,kBAAkB;AAEvB,WAAK,kBAAkB,gBAAgB,IAAI;AAC3C,WAAK,kBAAiB;IAC1B;AAqCQ,SAAA,wBAAwB,MAAK;AACjC,UAAI,KAAK,OAAO,UAAU,WAAW;AACjC;MACJ;AAEA,UAAI,KAAK,SAAS,QAAQ,KAAK,UAAK,GAA0B;AAC1D,aAAK,KAAI;MACb;AAEA,WAAK,OAAO,uBAAuB,eAAe,KAAK,qBAAqB;IAChF;AA3OI,SAAK,WAAW;AAEhB,SAAK,cAAc,IAAI,SAAS,MAAM,aAAa;AACnD,SAAK,gBAAe;EACxB;;EAGA,IAAW,cAAW;AAClB,QAAI,KAAK,WAAM,GAAyB;AACpC,aAAO;IACX;AAEA,UAAM,qBAAqB,KAAK,WAAM,IAAyB,IAAI,KAAK,OAAO,cAAc,KAAK;AAClG,WAAO,KAAK,mBAAmB,qBAAqB,KAAK,SAAS;EACtE;EAEA,IAAW,YAAY,OAAa;AAChC,UAAM,UAAU,KAAK,WAAM,KAA4B,KAAK,WAAM;AAElE,QAAI,SAAS;AACT,WAAK,KAAI;AACT,WAAK,kBAAiB;IAC1B;AAEA,SAAK,SAAS,cAAc;AAE5B,QAAI,SAAS;AACT,WAAK,KAAI;IACb;EACJ;EAEA,IAAW,WAAQ;AACf,WAAO,KAAK;EAChB;;EAGA,IAAW,MAAM,OAAa;AAC1B,QAAI,KAAK,aAAa;AAClB,WAAK,OAAO,eAAe,KAAK,YAAY,QAAQ,KAAK;IAC7D;EACJ;;EAGA,IAAW,aAAa,OAAa;AACjC,QAAI,KAAK,aAAa;AAClB,WAAK,OAAO,eAAe,KAAK,YAAY,cAAc,KAAK;IACnE;EACJ;;EAGA,IAAW,YAAS;AAChB,QAAI,KAAK,WAAM,GAAyB;AACpC,aAAO;IACX;AAEA,WAAO,KAAK;EAChB;;EAGgB,UAAO;AACnB,UAAM,QAAO;AAEb,SAAK,cAAc;AAEnB,SAAK,KAAI;AAET,SAAK,kBAAiB;AAEtB,SAAK,OAAO,uBAAuB,eAAe,KAAK,qBAAqB;EAChF;;EAGO,eAAY;AACf,WAAO;EACX;;EAGO,KAAK,UAA4C,CAAA,GAAE;AA5W9D;AA6WQ,QAAI,KAAK,WAAM,GAAyB;AACpC;IACJ;AAEA,QAAI,QAAQ,aAAa,QAAW;AAChC,WAAK,SAAS,WAAW,QAAQ;IACrC;AACA,QAAI,QAAQ,SAAS,QAAW;AAC5B,WAAK,SAAS,OAAO,QAAQ;IACjC;AACA,QAAI,QAAQ,cAAc,QAAW;AACjC,WAAK,SAAS,YAAY,QAAQ;IACtC;AACA,QAAI,QAAQ,YAAY,QAAW;AAC/B,WAAK,SAAS,UAAU,QAAQ;IACpC;AACA,QAAI,QAAQ,gBAAgB,QAAW;AACnC,WAAK,SAAS,cAAc,QAAQ;IACxC;AAEA,QAAI,cAAc,KAAK,SAAS;AAEhC,QAAI,KAAK,WAAM,GAAwB;AACnC,qBAAe,KAAK;AACpB,qBAAe,KAAK,OAAO,OAAO;IACtC;AAEA,SAAK,kBAAkB,KAAK,OAAO,eAAe,QAAQ,YAAY;AAEtE,SAAK,YAAY,KAAK,QAAQ,QAAQ,UAAU;AAEhD,SAAK,gBAAe;AAEpB,QAAI,KAAK,OAAO,UAAU,WAAW;AACjC,WAAK;QAAS;;MAAA;AACd,iBAAK,gBAAL,mBAAkB,MAAM,KAAK,iBAAiB,aAAa,KAAK,SAAS,WAAW,IAAI,KAAK,SAAS,WAAW;IACrH,WAAW,KAAK,SAAS,MAAM;AAC3B,WAAK;QAAS;;MAAA;AACd,WAAK,OAAO,uBAAuB,IAAI,KAAK,qBAAqB;IACrE;EACJ;;EAGO,QAAK;AAxZhB;AAyZQ,QAAI,KAAK,WAAM,GAAwB;AACnC;IACJ;AAEA,SAAK;MAAS;;IAAA;AACd,SAAK,oBAAoB,KAAK,OAAO,cAAc,KAAK;AAExD,eAAK,gBAAL,mBAAkB;AAClB,SAAK,kBAAiB;EAC1B;;EAGO,SAAM;AACT,QAAI,KAAK,WAAM,GAAwB;AACnC,WAAK,KAAI;IACb;EACJ;;EAGO,KAAK,UAA4C,CAAA,GAAE;AA5a9D;AA6aQ,QAAI,KAAK,WAAM,GAAyB;AACpC;IACJ;AAEA,SAAK;MAAS;;IAAA;AAEd,UAAM,iBAAiB,KAAK,OAAO,eAAe,QAAQ,YAAY;AACtE,eAAK,gBAAL,mBAAkB,KAAK;AAEvB,SAAK,OAAO,uBAAuB,eAAe,KAAK,qBAAqB;EAChF;EAEmB,SAAS,MAAuB;AAzbvD;AA0bQ,UAAM,YAAY,MAAM,SAAS,IAAI;AAErC,QAAI,CAAC,WAAW;AACZ,aAAO;IACX;AAGA,QAAI,gBAAgB,wBAAwB,KAAK,SAAS;AACtD,iBAAK,aAAL,mBAAe,QAAQ,KAAK;IAChC;AAEA,WAAO;EACX;EAEmB,YAAY,MAAuB;AAxc1D;AAycQ,UAAM,eAAe,MAAM,YAAY,IAAI;AAE3C,QAAI,CAAC,cAAc;AACf,aAAO;IACX;AAEA,QAAI,gBAAgB,wBAAwB,KAAK,SAAS;AACtD,iBAAK,aAAL,mBAAe,WAAW,KAAK;IACnC;AAEA,WAAO;EACX;EASQ,oBAAiB;AACrB,QAAI,CAAC,KAAK,aAAa;AACnB;IACJ;AAEA,QAAI,CAAC,KAAK,YAAY,KAAK,MAAM,GAAG;AAChC,YAAM,IAAI,MAAM,mBAAmB;IACvC;AAEA,SAAK,YAAY,WAAW,KAAK,WAAW;AAC5C,SAAK,YAAY,oBAAoB,SAAS,KAAK,QAAQ;AAE3D,SAAK,cAAc;EACvB;EAEQ,kBAAe;AACnB,QAAI,CAAC,KAAK,aAAa;AACnB,WAAK,cAAc,IAAI,sBAAsB,KAAK,OAAO,eAAe,EAAE,QAAQ,KAAK,OAAO,OAAO,aAAY,CAAE;AAEnH,WAAK,YAAY,iBAAiB,SAAS,KAAK,UAAU,EAAE,MAAM,KAAI,CAAE;AACxE,WAAK,YAAY,QAAQ,KAAK,WAAW;AAEzC,UAAI,CAAC,KAAK,SAAS,KAAK,MAAM,GAAG;AAC7B,cAAM,IAAI,MAAM,gBAAgB;MACpC;IACJ;AAEA,UAAM,OAAO,KAAK;AAClB,SAAK,OAAO,QAAQ,KAAK,OAAO;AAChC,SAAK,OAAO,KAAK,SAAS;AAC1B,SAAK,UAAU,KAAK,SAAS;AAC7B,SAAK,YAAY,KAAK,SAAS;AAC/B,SAAK,aAAa,QAAQ,KAAK,OAAO;EAC1C;;",
  "names": []
}
