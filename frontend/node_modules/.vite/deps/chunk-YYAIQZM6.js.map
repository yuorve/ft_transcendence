{
  "version": 3,
  "sources": ["../../../dev/core/src/AudioV2/abstractAudio/streamingSound.ts", "../../../dev/core/src/AudioV2/abstractAudio/streamingSoundInstance.ts", "../../../dev/core/src/AudioV2/webAudio/webAudioStreamingSound.ts"],
  "sourcesContent": ["import { SoundState } from \"../soundState\";\nimport type { IAbstractSoundOptions, IAbstractSoundPlayOptions, IAbstractSoundStoredOptions } from \"./abstractSound\";\nimport { AbstractSound } from \"./abstractSound\";\nimport type { AudioEngineV2 } from \"./audioEngineV2\";\nimport type { _StreamingSoundInstance } from \"./streamingSoundInstance\";\n\n/** @internal */\nexport interface IStreamingSoundOptionsBase {\n    /**\n     * The number of instances to preload. Defaults to 1.\n     * */\n    preloadCount: number;\n}\n\n/**\n * Options for creating a streaming sound.\n */\nexport interface IStreamingSoundOptions extends IAbstractSoundOptions, IStreamingSoundOptionsBase {}\n\n/**\n * Options for playing a streaming sound.\n */\nexport interface IStreamingSoundPlayOptions extends IAbstractSoundPlayOptions {}\n\n/**\n * Options stored in a streaming sound.\n * @internal\n */\nexport interface IStreamingSoundStoredOptions extends IAbstractSoundStoredOptions, IStreamingSoundOptionsBase {}\n\n/**\n * Abstract class representing a streaming sound.\n *\n * A streaming sound has a sound buffer that is loaded into memory in chunks as it is played. This allows it to be played\n * more quickly than a static sound, but it also means that it cannot have loop points or playback rate changes.\n *\n * Due to the way streaming sounds are typically implemented, there can be a significant delay when attempting to play\n * a streaming sound for the first time. To prevent this delay, it is recommended to preload instances of the sound\n * using the {@link IStreamingSoundStoredOptions.preloadCount} options, or the {@link preloadInstanceAsync} and\n * {@link preloadInstancesAsync} methods before calling the `play` method.\n *\n * Streaming sounds are created by the {@link CreateStreamingSoundAsync} function.\n */\nexport abstract class StreamingSound extends AbstractSound {\n    private _preloadedInstances = new Array<_StreamingSoundInstance>();\n\n    protected abstract override readonly _options: IStreamingSoundStoredOptions;\n\n    protected constructor(name: string, engine: AudioEngineV2) {\n        super(name, engine);\n    }\n\n    /**\n     * The number of instances to preload. Defaults to `1`.\n     */\n    public get preloadCount(): number {\n        return this._options.preloadCount ?? 1;\n    }\n\n    /**\n     * Returns the number of instances that have been preloaded.\n     */\n    public get preloadCompletedCount(): number {\n        return this._preloadedInstances.length;\n    }\n\n    /**\n     * Preloads an instance of the sound.\n     * @returns A promise that resolves when the instance is preloaded.\n     */\n    public preloadInstanceAsync(): Promise<void> {\n        const instance = this._createInstance();\n\n        this._addPreloadedInstance(instance);\n\n        return instance.preloadedPromise;\n    }\n\n    /**\n     * Preloads the given number of instances of the sound.\n     * @param count - The number of instances to preload.\n     * @returns A promise that resolves when all instances are preloaded.\n     */\n    public async preloadInstancesAsync(count: number): Promise<void> {\n        for (let i = 0; i < count; i++) {\n            this.preloadInstanceAsync();\n        }\n\n        await Promise.all(this._preloadedInstances.map((instance) => instance.preloadedPromise));\n    }\n\n    /**\n     * Plays the sound.\n     * - Triggers `onEndedObservable` if played for the full duration and the `loop` option is not set.\n     * @param options The options to use when playing the sound. Options set here override the sound's options.\n     */\n    public play(options: Partial<IStreamingSoundPlayOptions> = {}): void {\n        if (this.state === SoundState.Paused) {\n            this.resume();\n            return;\n        }\n\n        let instance: _StreamingSoundInstance;\n\n        if (this.preloadCompletedCount > 0) {\n            instance = this._preloadedInstances[0];\n            instance.startOffset = this.startOffset;\n            this._removePreloadedInstance(instance);\n        } else {\n            instance = this._createInstance();\n        }\n\n        const onInstanceStateChanged = () => {\n            if (instance.state === SoundState.Started) {\n                this._stopExcessInstances();\n                instance.onStateChangedObservable.removeCallback(onInstanceStateChanged);\n            }\n        };\n        instance.onStateChangedObservable.add(onInstanceStateChanged);\n\n        options.startOffset ??= this.startOffset;\n        options.loop ??= this.loop;\n        options.volume ??= 1;\n\n        this._beforePlay(instance);\n        instance.play(options);\n        this._afterPlay(instance);\n    }\n\n    /**\n     * Stops the sound.\n     */\n    public stop(): void {\n        this._setState(SoundState.Stopped);\n\n        if (!this._instances) {\n            return;\n        }\n\n        for (const instance of Array.from(this._instances)) {\n            instance.stop();\n        }\n    }\n\n    protected abstract override _createInstance(): _StreamingSoundInstance;\n\n    private _addPreloadedInstance(instance: _StreamingSoundInstance): void {\n        if (!this._preloadedInstances.includes(instance)) {\n            this._preloadedInstances.push(instance);\n        }\n    }\n\n    private _removePreloadedInstance(instance: _StreamingSoundInstance): void {\n        const index = this._preloadedInstances.indexOf(instance);\n        if (index !== -1) {\n            this._preloadedInstances.splice(index, 1);\n        }\n    }\n}\n", "import { Observable } from \"../../Misc/observable\";\nimport type { IAbstractSoundInstanceOptions } from \"./abstractSoundInstance\";\nimport { _AbstractSoundInstance } from \"./abstractSoundInstance\";\nimport type { IStreamingSoundOptionsBase, StreamingSound } from \"./streamingSound\";\n\n/**\n * Options for creating streaming sound instance.\n * @internal\n */\nexport interface IStreamingSoundInstanceOptions extends IAbstractSoundInstanceOptions, IStreamingSoundOptionsBase {}\n\n/** @internal */\nexport abstract class _StreamingSoundInstance extends _AbstractSoundInstance {\n    private _rejectPreloadedProimse: (reason?: any) => void;\n    private _resolvePreloadedPromise: () => void;\n\n    protected abstract override readonly _options: IStreamingSoundInstanceOptions;\n\n    /** @internal */\n    public readonly onReadyObservable = new Observable<_StreamingSoundInstance>();\n\n    /** @internal */\n    public readonly preloadedPromise = new Promise<void>((resolve, reject) => {\n        this._rejectPreloadedProimse = reject;\n        this._resolvePreloadedPromise = resolve;\n    });\n\n    protected constructor(sound: StreamingSound) {\n        super(sound);\n\n        this.onErrorObservable.add(this._rejectPreloadedProimse);\n        this.onReadyObservable.add(this._resolvePreloadedPromise);\n    }\n\n    /** @internal */\n    public set startOffset(value: number) {\n        this._options.startOffset = value;\n    }\n\n    /** @internal */\n    public override dispose(): void {\n        super.dispose();\n\n        this.onErrorObservable.clear();\n        this.onReadyObservable.clear();\n\n        this._resolvePreloadedPromise();\n    }\n}\n", "import { Logger } from \"../../Misc/logger\";\nimport { Tools } from \"../../Misc/tools\";\nimport type { Nullable } from \"../../types\";\nimport type { AbstractAudioNode } from \"../abstractAudio/abstractAudioNode\";\nimport type {} from \"../abstractAudio/abstractSound\";\nimport type { IStreamingSoundOptions, IStreamingSoundPlayOptions, IStreamingSoundStoredOptions } from \"../abstractAudio/streamingSound\";\nimport { StreamingSound } from \"../abstractAudio/streamingSound\";\nimport { _StreamingSoundInstance } from \"../abstractAudio/streamingSoundInstance\";\nimport { _HasSpatialAudioOptions } from \"../abstractAudio/subProperties/abstractSpatialAudio\";\nimport type { _SpatialAudio } from \"../abstractAudio/subProperties/spatialAudio\";\nimport { _StereoAudio } from \"../abstractAudio/subProperties/stereoAudio\";\nimport { _CleanUrl } from \"../audioUtils\";\nimport { SoundState } from \"../soundState\";\nimport { _WebAudioBusAndSoundSubGraph } from \"./subNodes/webAudioBusAndSoundSubGraph\";\nimport { _SpatialWebAudio } from \"./subProperties/spatialWebAudio\";\nimport type { _WebAudioEngine } from \"./webAudioEngine\";\nimport type { IWebAudioInNode, IWebAudioOutNode, IWebAudioSuperNode } from \"./webAudioNode\";\n\ntype StreamingSoundSourceType = HTMLMediaElement | string | string[];\n\n/** @internal */\nexport class _WebAudioStreamingSound extends StreamingSound implements IWebAudioSuperNode {\n    private _spatial: Nullable<_SpatialAudio> = null;\n    private readonly _spatialAutoUpdate: boolean = true;\n    private readonly _spatialMinUpdateTime: number = 0;\n    private _stereo: Nullable<_StereoAudio> = null;\n\n    protected override readonly _options: IStreamingSoundStoredOptions;\n    protected _subGraph: _WebAudioBusAndSoundSubGraph;\n\n    /** @internal */\n    public _audioContext: AudioContext;\n\n    /** @internal */\n    public override readonly engine: _WebAudioEngine;\n\n    /** @internal */\n    public _source: StreamingSoundSourceType;\n\n    /** @internal */\n    public constructor(name: string, engine: _WebAudioEngine, options: Partial<IStreamingSoundOptions>) {\n        super(name, engine);\n\n        if (typeof options.spatialAutoUpdate === \"boolean\") {\n            this._spatialAutoUpdate = options.spatialAutoUpdate;\n        }\n\n        if (typeof options.spatialMinUpdateTime === \"number\") {\n            this._spatialMinUpdateTime = options.spatialMinUpdateTime;\n        }\n\n        this._options = {\n            autoplay: options.autoplay ?? false,\n            loop: options.loop ?? false,\n            maxInstances: options.maxInstances ?? Infinity,\n            preloadCount: options.preloadCount ?? 1,\n            startOffset: options.startOffset ?? 0,\n        };\n\n        this._subGraph = new _WebAudioStreamingSound._SubGraph(this);\n    }\n\n    /** @internal */\n    public async _init(source: StreamingSoundSourceType, options: Partial<IStreamingSoundOptions>): Promise<void> {\n        const audioContext = this.engine._audioContext;\n\n        if (!(audioContext instanceof AudioContext)) {\n            throw new Error(\"Unsupported audio context type.\");\n        }\n\n        this._audioContext = audioContext;\n        this._source = source;\n\n        if (options.outBus) {\n            this.outBus = options.outBus;\n        } else {\n            await this.engine.isReadyPromise;\n            this.outBus = this.engine.defaultMainBus;\n        }\n\n        await this._subGraph.init(options);\n\n        if (_HasSpatialAudioOptions(options)) {\n            this._initSpatialProperty();\n        }\n\n        if (this.preloadCount) {\n            await this.preloadInstancesAsync(this.preloadCount);\n        }\n\n        if (options.autoplay) {\n            this.play(options);\n        }\n\n        this.engine._addNode(this);\n    }\n\n    /** @internal */\n    public get _inNode() {\n        return this._subGraph._inNode;\n    }\n\n    /** @internal */\n    public get _outNode() {\n        return this._subGraph._outNode;\n    }\n\n    /** @internal */\n    public override get spatial(): _SpatialAudio {\n        if (this._spatial) {\n            return this._spatial;\n        }\n        return this._initSpatialProperty();\n    }\n\n    /** @internal */\n    public override get stereo(): _StereoAudio {\n        return this._stereo ?? (this._stereo = new _StereoAudio(this._subGraph));\n    }\n\n    /** @internal */\n    public override dispose(): void {\n        super.dispose();\n\n        this._spatial = null;\n        this._stereo = null;\n\n        this._subGraph.dispose();\n\n        this.engine._removeNode(this);\n    }\n\n    /** @internal */\n    public getClassName(): string {\n        return \"_WebAudioStreamingSound\";\n    }\n\n    protected _createInstance(): _WebAudioStreamingSoundInstance {\n        return new _WebAudioStreamingSoundInstance(this, this._options);\n    }\n\n    protected override _connect(node: IWebAudioInNode): boolean {\n        const connected = super._connect(node);\n\n        if (!connected) {\n            return false;\n        }\n\n        // If the wrapped node is not available now, it will be connected later by the subgraph.\n        if (node._inNode) {\n            this._outNode?.connect(node._inNode);\n        }\n\n        return true;\n    }\n\n    protected override _disconnect(node: IWebAudioInNode): boolean {\n        const disconnected = super._disconnect(node);\n\n        if (!disconnected) {\n            return false;\n        }\n\n        if (node._inNode) {\n            this._outNode?.disconnect(node._inNode);\n        }\n\n        return true;\n    }\n\n    private _initSpatialProperty(): _SpatialAudio {\n        if (!this._spatial) {\n            this._spatial = new _SpatialWebAudio(this._subGraph, this._spatialAutoUpdate, this._spatialMinUpdateTime);\n        }\n\n        return this._spatial;\n    }\n\n    private static _SubGraph = class extends _WebAudioBusAndSoundSubGraph {\n        protected override _owner: _WebAudioStreamingSound;\n\n        protected get _downstreamNodes(): Nullable<Set<AbstractAudioNode>> {\n            return this._owner._downstreamNodes ?? null;\n        }\n\n        protected get _upstreamNodes(): Nullable<Set<AbstractAudioNode>> {\n            return this._owner._upstreamNodes ?? null;\n        }\n    };\n}\n\n/** @internal */\nclass _WebAudioStreamingSoundInstance extends _StreamingSoundInstance implements IWebAudioOutNode {\n    private _currentTimeChangedWhilePaused = false;\n    private _enginePlayTime: number = Infinity;\n    private _enginePauseTime: number = 0;\n    private _isReady: boolean = false;\n    private _isReadyPromise: Promise<HTMLMediaElement> = new Promise((resolve, reject) => {\n        this._resolveIsReadyPromise = resolve;\n        this._rejectIsReadyPromise = reject;\n    });\n    private _mediaElement: HTMLMediaElement;\n    private _sourceNode: Nullable<MediaElementAudioSourceNode>;\n    private _volumeNode: GainNode;\n\n    protected override readonly _options: IStreamingSoundStoredOptions;\n    protected override _sound: _WebAudioStreamingSound;\n\n    /** @internal */\n    public override readonly engine: _WebAudioEngine;\n\n    public constructor(sound: _WebAudioStreamingSound, options: IStreamingSoundStoredOptions) {\n        super(sound);\n\n        this._options = options;\n        this._volumeNode = new GainNode(sound._audioContext);\n\n        if (typeof sound._source === \"string\") {\n            this._initFromUrl(sound._source);\n        } else if (Array.isArray(sound._source)) {\n            this._initFromUrls(sound._source);\n        } else if (sound._source instanceof HTMLMediaElement) {\n            this._initFromMediaElement(sound._source);\n        }\n    }\n\n    /** @internal */\n    public get currentTime(): number {\n        if (this._state === SoundState.Stopped) {\n            return 0;\n        }\n\n        const timeSinceLastStart = this._state === SoundState.Paused ? 0 : this.engine.currentTime - this._enginePlayTime;\n        return this._enginePauseTime + timeSinceLastStart + this._options.startOffset;\n    }\n\n    public set currentTime(value: number) {\n        const restart = this._state === SoundState.Starting || this._state === SoundState.Started;\n\n        if (restart) {\n            this._mediaElement.pause();\n            this._setState(SoundState.Stopped);\n        }\n\n        this._options.startOffset = value;\n\n        if (restart) {\n            this.play({ startOffset: value });\n        } else if (this._state === SoundState.Paused) {\n            this._currentTimeChangedWhilePaused = true;\n        }\n    }\n\n    public get _outNode(): Nullable<AudioNode> {\n        return this._volumeNode;\n    }\n\n    /** @internal */\n    public get startTime(): number {\n        if (this._state === SoundState.Stopped) {\n            return 0;\n        }\n\n        return this._enginePlayTime;\n    }\n\n    /** @internal */\n    public override dispose(): void {\n        super.dispose();\n\n        this.stop();\n\n        this._sourceNode?.disconnect(this._volumeNode);\n        this._sourceNode = null;\n\n        this._mediaElement.removeEventListener(\"error\", this._onError);\n        this._mediaElement.removeEventListener(\"ended\", this._onEnded);\n        this._mediaElement.removeEventListener(\"canplaythrough\", this._onCanPlayThrough);\n\n        for (const source of Array.from(this._mediaElement.children)) {\n            this._mediaElement.removeChild(source);\n        }\n\n        this.engine.stateChangedObservable.removeCallback(this._onEngineStateChanged);\n        this.engine.userGestureObservable.removeCallback(this._onUserGesture);\n    }\n\n    /** @internal */\n    public play(options: Partial<IStreamingSoundPlayOptions> = {}): void {\n        if (this._state === SoundState.Started) {\n            return;\n        }\n\n        if (options.loop !== undefined) {\n            this._options.loop = options.loop;\n        }\n        this._mediaElement.loop = this._options.loop;\n\n        let startOffset = options.startOffset;\n\n        if (this._currentTimeChangedWhilePaused) {\n            startOffset = this._options.startOffset;\n            this._currentTimeChangedWhilePaused = false;\n        } else if (this._state === SoundState.Paused) {\n            startOffset = this.currentTime + this._options.startOffset;\n        }\n\n        if (startOffset && startOffset > 0) {\n            this._mediaElement.currentTime = startOffset;\n        }\n\n        this._volumeNode.gain.value = options.volume ?? 1;\n\n        this._play();\n    }\n\n    /** @internal */\n    public pause(): void {\n        if (this._state !== SoundState.Starting && this._state !== SoundState.Started) {\n            return;\n        }\n\n        this._setState(SoundState.Paused);\n        this._enginePauseTime += this.engine.currentTime - this._enginePlayTime;\n\n        this._mediaElement.pause();\n    }\n\n    /** @internal */\n    public resume(): void {\n        if (this._state === SoundState.Paused) {\n            this.play();\n        } else if (this._currentTimeChangedWhilePaused) {\n            this.play();\n        }\n    }\n\n    /** @internal */\n    public override stop(): void {\n        if (this._state === SoundState.Stopped) {\n            return;\n        }\n\n        this._stop();\n    }\n\n    /** @internal */\n    public getClassName(): string {\n        return \"_WebAudioStreamingSoundInstance\";\n    }\n\n    protected override _connect(node: AbstractAudioNode): boolean {\n        const connected = super._connect(node);\n\n        if (!connected) {\n            return false;\n        }\n\n        // If the wrapped node is not available now, it will be connected later by the sound's subgraph.\n        if (node instanceof _WebAudioStreamingSound && node._inNode) {\n            this._outNode?.connect(node._inNode);\n        }\n\n        return true;\n    }\n\n    protected override _disconnect(node: AbstractAudioNode): boolean {\n        const disconnected = super._disconnect(node);\n\n        if (!disconnected) {\n            return false;\n        }\n\n        if (node instanceof _WebAudioStreamingSound && node._inNode) {\n            this._outNode?.disconnect(node._inNode);\n        }\n\n        return true;\n    }\n\n    private _initFromMediaElement(mediaElement: HTMLMediaElement): void {\n        Tools.SetCorsBehavior(mediaElement.currentSrc, mediaElement);\n\n        mediaElement.controls = false;\n        mediaElement.loop = this._options.loop;\n        mediaElement.preload = \"auto\";\n\n        mediaElement.addEventListener(\"canplaythrough\", this._onCanPlayThrough, { once: true });\n        mediaElement.addEventListener(\"ended\", this._onEnded, { once: true });\n        mediaElement.addEventListener(\"error\", this._onError, { once: true });\n\n        mediaElement.load();\n\n        this._sourceNode = new MediaElementAudioSourceNode(this._sound._audioContext, { mediaElement: mediaElement });\n        this._sourceNode.connect(this._volumeNode);\n\n        if (!this._connect(this._sound)) {\n            throw new Error(\"Connect failed\");\n        }\n\n        this._mediaElement = mediaElement;\n    }\n\n    private _initFromUrl(url: string): void {\n        const audio = new Audio(_CleanUrl(url));\n        this._initFromMediaElement(audio);\n    }\n\n    private _initFromUrls(urls: string[]): void {\n        const audio = new Audio();\n\n        for (const url of urls) {\n            const source = document.createElement(\"source\");\n            source.src = _CleanUrl(url);\n            audio.appendChild(source);\n        }\n\n        this._initFromMediaElement(audio);\n    }\n\n    private _onCanPlayThrough: () => void = () => {\n        this._isReady = true;\n        this._resolveIsReadyPromise(this._mediaElement);\n        this.onReadyObservable.notifyObservers(this);\n    };\n\n    private _onEnded: () => void = () => {\n        this.onEndedObservable.notifyObservers(this);\n        this.dispose();\n    };\n\n    private _onError: (reason: any) => void = (reason: any) => {\n        this._setState(SoundState.FailedToStart);\n        this.onErrorObservable.notifyObservers(reason);\n        this._rejectIsReadyPromise(reason);\n        this.dispose();\n    };\n\n    private _onEngineStateChanged = () => {\n        if (this.engine.state !== \"running\") {\n            return;\n        }\n\n        if (this._options.loop && this.state === SoundState.Starting) {\n            this.play();\n        }\n\n        this.engine.stateChangedObservable.removeCallback(this._onEngineStateChanged);\n    };\n\n    private _onUserGesture = () => {\n        this.play();\n    };\n\n    private _play(): void {\n        this._setState(SoundState.Starting);\n\n        if (!this._isReady) {\n            this._playWhenReady();\n            return;\n        }\n\n        if (this._state !== SoundState.Starting) {\n            return;\n        }\n\n        if (this.engine.state === \"running\") {\n            const result = this._mediaElement.play();\n\n            this._enginePlayTime = this.engine.currentTime;\n            this._setState(SoundState.Started);\n\n            // It's possible that the play() method fails on Safari, even if the audio engine's state is \"running\".\n            // This occurs when the audio context is paused by the system and resumed automatically by the audio engine\n            // without a user interaction (e.g. when the Vision Pro exits and reenters immersive mode).\n            result.catch(() => {\n                this._setState(SoundState.FailedToStart);\n\n                if (this._options.loop) {\n                    this.engine.userGestureObservable.addOnce(this._onUserGesture);\n                }\n            });\n        } else if (this._options.loop) {\n            this.engine.stateChangedObservable.add(this._onEngineStateChanged);\n        } else {\n            this.stop();\n            this._setState(SoundState.FailedToStart);\n        }\n    }\n\n    private _playWhenReady(): void {\n        this._isReadyPromise\n            .then(() => {\n                this._play();\n            })\n            .catch(() => {\n                Logger.Error(\"Streaming sound instance failed to play\");\n                this._setState(SoundState.FailedToStart);\n            });\n    }\n\n    private _rejectIsReadyPromise: (reason?: any) => void;\n    private _resolveIsReadyPromise: (mediaElement: HTMLMediaElement) => void;\n\n    private _stop(): void {\n        this._mediaElement.pause();\n        this._setState(SoundState.Stopped);\n        this._onEnded();\n        this.engine.stateChangedObservable.removeCallback(this._onEngineStateChanged);\n    }\n}\n"],
  "mappings": "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",
  "names": []
}
