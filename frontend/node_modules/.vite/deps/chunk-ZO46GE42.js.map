{
  "version": 3,
  "sources": ["../../../dev/core/src/FlowGraph/Blocks/Data/Math/flowGraphMatrixMathBlocks.ts"],
  "sourcesContent": ["import type { IFlowGraphBlockConfiguration } from \"core/FlowGraph/flowGraphBlock\";\nimport { FlowGraphBlock } from \"core/FlowGraph/flowGraphBlock\";\nimport type { FlowGraphContext } from \"core/FlowGraph/flowGraphContext\";\nimport type { FlowGraphDataConnection } from \"core/FlowGraph/flowGraphDataConnection\";\nimport {\n    FlowGraphTypes,\n    getRichTypeByFlowGraphType,\n    RichTypeBoolean,\n    RichTypeMatrix,\n    RichTypeNumber,\n    RichTypeQuaternion,\n    RichTypeVector3,\n} from \"core/FlowGraph/flowGraphRichTypes\";\nimport { Matrix, Quaternion, Vector3 } from \"core/Maths/math.vector\";\nimport { FlowGraphBlockNames } from \"../../flowGraphBlockNames\";\nimport { RegisterClass } from \"core/Misc/typeStore\";\nimport { FlowGraphUnaryOperationBlock } from \"../flowGraphUnaryOperationBlock\";\nimport type { FlowGraphMatrix2D } from \"core/FlowGraph/CustomTypes/flowGraphMatrix\";\nimport { FlowGraphBinaryOperationBlock } from \"../flowGraphBinaryOperationBlock\";\nimport type { FlowGraphMatrix } from \"core/FlowGraph/utils\";\n\n/**\n * Configuration for the matrix blocks.\n */\nexport interface IFlowGraphMatrixBlockConfiguration extends IFlowGraphBlockConfiguration {\n    /**\n     * The type of the matrix. Default is Matrix (which is 4x4)\n     */\n    matrixType: FlowGraphTypes;\n}\n/**\n * Transposes a matrix.\n */\nexport class FlowGraphTransposeBlock extends FlowGraphUnaryOperationBlock<FlowGraphMatrix, FlowGraphMatrix> {\n    /**\n     * Creates a new instance of the block.\n     * @param config the configuration of the block\n     */\n    constructor(config?: IFlowGraphMatrixBlockConfiguration) {\n        super(\n            getRichTypeByFlowGraphType(config?.matrixType || FlowGraphTypes.Matrix),\n            getRichTypeByFlowGraphType(config?.matrixType || FlowGraphTypes.Matrix),\n            (a) => (a.transpose ? a.transpose() : Matrix.Transpose(a as Matrix)),\n            FlowGraphBlockNames.Transpose,\n            config\n        );\n    }\n}\nRegisterClass(FlowGraphBlockNames.Transpose, FlowGraphTransposeBlock);\n\n/**\n * Gets the determinant of a matrix.\n */\nexport class FlowGraphDeterminantBlock extends FlowGraphUnaryOperationBlock<FlowGraphMatrix, number> {\n    /**\n     * Creates a new instance of the block.\n     * @param config the configuration of the block\n     */\n    constructor(config?: IFlowGraphMatrixBlockConfiguration) {\n        super(getRichTypeByFlowGraphType(config?.matrixType || FlowGraphTypes.Matrix), RichTypeNumber, (a) => a.determinant(), FlowGraphBlockNames.Determinant, config);\n    }\n}\nRegisterClass(FlowGraphBlockNames.Determinant, FlowGraphDeterminantBlock);\n\n/**\n * Inverts a matrix.\n */\nexport class FlowGraphInvertMatrixBlock extends FlowGraphUnaryOperationBlock<FlowGraphMatrix, FlowGraphMatrix> {\n    /**\n     * Creates a new instance of the inverse block.\n     * @param config the configuration of the block\n     */\n    constructor(config?: IFlowGraphMatrixBlockConfiguration) {\n        super(\n            getRichTypeByFlowGraphType(config?.matrixType || FlowGraphTypes.Matrix),\n            getRichTypeByFlowGraphType(config?.matrixType || FlowGraphTypes.Matrix),\n            (a) => ((a as FlowGraphMatrix2D).inverse ? (a as FlowGraphMatrix2D).inverse() : Matrix.Invert(a as Matrix)),\n            FlowGraphBlockNames.InvertMatrix,\n            config\n        );\n    }\n}\nRegisterClass(FlowGraphBlockNames.InvertMatrix, FlowGraphInvertMatrixBlock);\n\n/**\n * Multiplies two matrices.\n */\nexport class FlowGraphMatrixMultiplicationBlock extends FlowGraphBinaryOperationBlock<FlowGraphMatrix, FlowGraphMatrix, FlowGraphMatrix> {\n    /**\n     * Creates a new instance of the multiplication block.\n     * Note - this is similar to the math multiplication if not using matrix per-component multiplication.\n     * @param config the configuration of the block\n     */\n    constructor(config?: IFlowGraphMatrixBlockConfiguration) {\n        super(\n            getRichTypeByFlowGraphType(config?.matrixType || FlowGraphTypes.Matrix),\n            getRichTypeByFlowGraphType(config?.matrixType || FlowGraphTypes.Matrix),\n            getRichTypeByFlowGraphType(config?.matrixType || FlowGraphTypes.Matrix),\n            (a, b) => b.multiply(a as any),\n            FlowGraphBlockNames.MatrixMultiplication,\n            config\n        );\n    }\n}\nRegisterClass(FlowGraphBlockNames.MatrixMultiplication, FlowGraphMatrixMultiplicationBlock);\n\n/**\n * Matrix decompose block\n */\nexport class FlowGraphMatrixDecomposeBlock extends FlowGraphBlock {\n    /**\n     * The input of this block\n     */\n    public readonly input: FlowGraphDataConnection<Matrix>;\n\n    /**\n     * The position output of this block\n     */\n    public readonly position: FlowGraphDataConnection<Vector3>;\n    /**\n     * The rotation output of this block\n     */\n    public readonly rotationQuaternion: FlowGraphDataConnection<Quaternion>;\n    /**\n     * The scaling output of this block\n     */\n    public readonly scaling: FlowGraphDataConnection<Vector3>;\n\n    /**\n     * Is the matrix valid\n     */\n    public readonly isValid: FlowGraphDataConnection<boolean>;\n\n    constructor(config?: IFlowGraphBlockConfiguration) {\n        super(config);\n        this.input = this.registerDataInput(\"input\", RichTypeMatrix);\n        this.position = this.registerDataOutput(\"position\", RichTypeVector3);\n        this.rotationQuaternion = this.registerDataOutput(\"rotationQuaternion\", RichTypeQuaternion);\n        this.scaling = this.registerDataOutput(\"scaling\", RichTypeVector3);\n        this.isValid = this.registerDataOutput(\"isValid\", RichTypeBoolean, false);\n    }\n\n    public override _updateOutputs(context: FlowGraphContext) {\n        const cachedExecutionId = context._getExecutionVariable(this, \"executionId\", -1);\n        const cachedPosition = context._getExecutionVariable(this, \"cachedPosition\", null);\n        const cachedRotation = context._getExecutionVariable(this, \"cachedRotation\", null);\n        const cachedScaling = context._getExecutionVariable(this, \"cachedScaling\", null);\n        if (cachedExecutionId === context.executionId && cachedPosition && cachedRotation && cachedScaling) {\n            this.position.setValue(cachedPosition, context);\n            this.rotationQuaternion.setValue(cachedRotation, context);\n            this.scaling.setValue(cachedScaling, context);\n        } else {\n            const matrix = this.input.getValue(context);\n            const position = cachedPosition || new Vector3();\n            const rotation = cachedRotation || new Quaternion();\n            const scaling = cachedScaling || new Vector3();\n            // check matrix last column components should be 0,0,0,1\n            // round them to 4 decimal places\n            const m3 = Math.round(matrix.m[3] * 10000) / 10000;\n            const m7 = Math.round(matrix.m[7] * 10000) / 10000;\n            const m11 = Math.round(matrix.m[11] * 10000) / 10000;\n            const m15 = Math.round(matrix.m[15] * 10000) / 10000;\n            if (m3 !== 0 || m7 !== 0 || m11 !== 0 || m15 !== 1) {\n                this.isValid.setValue(false, context);\n                this.position.setValue(Vector3.Zero(), context);\n                this.rotationQuaternion.setValue(Quaternion.Identity(), context);\n                this.scaling.setValue(Vector3.One(), context);\n                return;\n            }\n            // make the checks for validity\n            const valid = matrix.decompose(scaling, rotation, position);\n            this.isValid.setValue(valid, context);\n            this.position.setValue(position, context);\n            this.rotationQuaternion.setValue(rotation, context);\n            this.scaling.setValue(scaling, context);\n            context._setExecutionVariable(this, \"cachedPosition\", position);\n            context._setExecutionVariable(this, \"cachedRotation\", rotation);\n            context._setExecutionVariable(this, \"cachedScaling\", scaling);\n            context._setExecutionVariable(this, \"executionId\", context.executionId);\n        }\n    }\n\n    public override getClassName(): string {\n        return FlowGraphBlockNames.MatrixDecompose;\n    }\n}\n\nRegisterClass(FlowGraphBlockNames.MatrixDecompose, FlowGraphMatrixDecomposeBlock);\n\n/**\n * Matrix compose block\n */\nexport class FlowGraphMatrixComposeBlock extends FlowGraphBlock {\n    /**\n     * The position input of this block\n     */\n    public readonly position: FlowGraphDataConnection<Vector3>;\n    /**\n     * The rotation input of this block\n     */\n    public readonly rotationQuaternion: FlowGraphDataConnection<Quaternion>;\n    /**\n     * The scaling input of this block\n     */\n    public readonly scaling: FlowGraphDataConnection<Vector3>;\n    /**\n     * The output of this block\n     */\n    public readonly value: FlowGraphDataConnection<Matrix>;\n\n    constructor(config?: IFlowGraphBlockConfiguration) {\n        super(config);\n        this.position = this.registerDataInput(\"position\", RichTypeVector3);\n        this.rotationQuaternion = this.registerDataInput(\"rotationQuaternion\", RichTypeQuaternion);\n        this.scaling = this.registerDataInput(\"scaling\", RichTypeVector3);\n        this.value = this.registerDataOutput(\"value\", RichTypeMatrix);\n    }\n\n    public override _updateOutputs(context: FlowGraphContext) {\n        const cachedExecutionId = context._getExecutionVariable(this, \"executionId\", -1);\n        const cachedMatrix = context._getExecutionVariable(this, \"cachedMatrix\", null);\n        if (cachedExecutionId === context.executionId && cachedMatrix) {\n            this.value.setValue(cachedMatrix, context);\n        } else {\n            const matrix = Matrix.Compose(this.scaling.getValue(context), this.rotationQuaternion.getValue(context), this.position.getValue(context));\n            this.value.setValue(matrix, context);\n            context._setExecutionVariable(this, \"cachedMatrix\", matrix);\n            context._setExecutionVariable(this, \"executionId\", context.executionId);\n        }\n    }\n\n    public override getClassName(): string {\n        return FlowGraphBlockNames.MatrixCompose;\n    }\n}\n\nRegisterClass(FlowGraphBlockNames.MatrixCompose, FlowGraphMatrixComposeBlock);\n"],
  "mappings": "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",
  "names": []
}
