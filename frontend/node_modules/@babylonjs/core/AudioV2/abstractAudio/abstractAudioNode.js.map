{"version":3,"file":"abstractAudioNode.js","sourceRoot":"","sources":["../../../../../dev/core/src/AudioV2/abstractAudio/abstractAudioNode.ts"],"names":[],"mappings":"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","sourcesContent":["import { Observable } from \"../../Misc/observable\";\nimport type { AudioEngineV2 } from \"./audioEngineV2\";\n\nexport const enum AudioNodeType {\n    HAS_INPUTS = 1,\n    HAS_OUTPUTS = 2,\n    HAS_INPUTS_AND_OUTPUTS = 3,\n}\n\n/**\n * Abstract class for an audio node.\n *\n * An audio node is a processing unit that can receive audio data from an upstream node and/or send audio data to a\n * downstream node.\n *\n * Nodes can be connected to other nodes to create an audio graph. The audio graph represents the flow of audio data.\n *\n * There are 3 types of audio nodes:\n * 1. Input: Receives audio data from upstream nodes.\n * 2. Output: Sends audio data to downstream nodes.\n * 3. Input/Output: Receives audio data from upstream nodes and sends audio data to downstream nodes.\n */\nexport abstract class AbstractAudioNode {\n    /**\n     * The connected downstream audio nodes.\n     * - Undefined for input nodes.\n     */\n    protected readonly _downstreamNodes?: Set<AbstractAudioNode>;\n\n    /**\n     * The connected upstream audio nodes.\n     * - Undefined for output nodes.\n     */\n    protected readonly _upstreamNodes?: Set<AbstractAudioNode>;\n\n    /**\n     * The audio engine this node belongs to.\n     */\n    public readonly engine: AudioEngineV2;\n\n    /**\n     * Observable for when the audio node is disposed.\n     */\n    public readonly onDisposeObservable = new Observable<AbstractAudioNode>();\n\n    protected constructor(engine: AudioEngineV2, nodeType: AudioNodeType) {\n        this.engine = engine;\n\n        if (nodeType & AudioNodeType.HAS_INPUTS) {\n            this._upstreamNodes = new Set<AbstractAudioNode>();\n        }\n\n        if (nodeType & AudioNodeType.HAS_OUTPUTS) {\n            this._downstreamNodes = new Set<AbstractAudioNode>();\n        }\n    }\n\n    /**\n     * Releases associated resources.\n     * - Triggers `onDisposeObservable`.\n     * @see {@link onDisposeObservable}\n     */\n    public dispose(): void {\n        if (this._downstreamNodes) {\n            for (const node of Array.from(this._downstreamNodes)) {\n                if (!this._disconnect(node)) {\n                    throw new Error(\"Disconnect failed\");\n                }\n            }\n            this._downstreamNodes.clear();\n        }\n\n        if (this._upstreamNodes) {\n            for (const node of Array.from(this._upstreamNodes)) {\n                if (!node._disconnect(this)) {\n                    throw new Error(\"Disconnect failed\");\n                }\n            }\n            this._upstreamNodes.clear();\n        }\n\n        this.onDisposeObservable.notifyObservers(this);\n        this.onDisposeObservable.clear();\n    }\n\n    /**\n     * Gets a string identifying the name of the class\n     * @returns the class's name as a string\n     */\n    public abstract getClassName(): string;\n\n    /**\n     * Connect to a downstream audio input node.\n     * @param node - The downstream audio input node to connect\n     * @returns `true` if the node is successfully connected; otherwise `false`\n     */\n    protected _connect(node: AbstractAudioNode): boolean {\n        if (!this._downstreamNodes) {\n            return false;\n        }\n\n        if (this._downstreamNodes.has(node)) {\n            return false;\n        }\n\n        if (!node._onConnect(this)) {\n            return false;\n        }\n\n        this._downstreamNodes.add(node);\n\n        return true;\n    }\n\n    /**\n     * Disconnects a downstream audio input node.\n     * @param node - The downstream audio input node to disconnect\n     * @returns `true` if the node is successfully disconnected; otherwise `false`\n     */\n    protected _disconnect(node: AbstractAudioNode): boolean {\n        if (!this._downstreamNodes) {\n            return false;\n        }\n\n        if (!this._downstreamNodes.delete(node)) {\n            return false;\n        }\n\n        return node._onDisconnect(this);\n    }\n\n    /**\n     * Called when an upstream audio output node is connecting.\n     * @param node - The connecting upstream audio node\n     * @returns `true` if the node is successfully connected; otherwise `false`\n     */\n    private _onConnect(node: AbstractAudioNode): boolean {\n        if (!this._upstreamNodes) {\n            return false;\n        }\n\n        if (this._upstreamNodes.has(node)) {\n            return false;\n        }\n\n        this._upstreamNodes.add(node);\n\n        return true;\n    }\n\n    /**\n     * Called when an upstream audio output node disconnects.\n     * @param node - The disconnecting upstream audio node\n     * @returns `true` if node is sucessfully disconnected; otherwise `false`\n     */\n    private _onDisconnect(node: AbstractAudioNode): boolean {\n        return this._upstreamNodes?.delete(node) ?? false;\n    }\n}\n\n/**\n * Abstract class for a named audio node.\n */\nexport abstract class AbstractNamedAudioNode extends AbstractAudioNode {\n    private _name: string;\n\n    /**\n     * Observable for when the audio node is renamed.\n     */\n    public readonly onNameChangedObservable = new Observable<{ newName: string; oldName: string; node: AbstractNamedAudioNode }>();\n\n    protected constructor(name: string, engine: AudioEngineV2, nodeType: AudioNodeType) {\n        super(engine, nodeType);\n\n        this._name = name;\n    }\n\n    /**\n     * The name of the audio node.\n     * - Triggers `onNameChangedObservable` when changed.\n     * @see {@link onNameChangedObservable}\n     */\n    public get name(): string {\n        return this._name;\n    }\n\n    public set name(newName: string) {\n        if (this._name === newName) {\n            return;\n        }\n\n        const oldName = this._name;\n\n        this._name = newName;\n\n        this.onNameChangedObservable.notifyObservers({ newName, oldName, node: this });\n    }\n\n    public override dispose(): void {\n        super.dispose();\n\n        this.onNameChangedObservable.clear();\n    }\n}\n"]}