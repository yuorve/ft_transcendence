{"version":3,"file":"spatialAudioAttacherComponent.js","sourceRoot":"","sources":["../../../../../../dev/core/src/AudioV2/abstractAudio/components/spatialAudioAttacherComponent.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,UAAU,EAAE,OAAO,EAAE,MAAM,4BAA4B,CAAC;AAQjE;;;;GAIG;AACH,MAAM,OAAO,8BAA8B;IASvC,gBAAgB;IAChB,YAAmB,gBAA8D;QATjF,gBAAgB;QACR,oBAAe,0DAA8E;QACpF,cAAS,GAAG,IAAI,OAAO,EAAE,CAAC;QAC1B,wBAAmB,GAAG,IAAI,UAAU,EAAE,CAAC;QAChD,eAAU,GAAmB,IAAI,CAAC;QAElC,oBAAe,GAAY,KAAK,CAAC;QAmDzC;;WAEG;QACI,YAAO,GAAG,GAAG,EAAE;YAClB,IAAI,CAAC,MAAM,EAAE,CAAC;QAClB,CAAC,CAAC;QApDE,IAAI,CAAC,iBAAiB,GAAG,gBAAgB,CAAC;IAC9C,CAAC;IAED;;OAEG;IACH,IAAW,UAAU;QACjB,OAAO,IAAI,CAAC,UAAU,KAAK,IAAI,CAAC;IACpC,CAAC;IAED;;;;;;;;;OASG;IACI,MAAM,CAAC,SAAyB,EAAE,cAAuB,EAAE,cAA0C;QACxG,IAAI,IAAI,CAAC,UAAU,KAAK,SAAS,EAAE,CAAC;YAChC,OAAO;QACX,CAAC;QAED,IAAI,CAAC,MAAM,EAAE,CAAC;QAEd,IAAI,CAAC,SAAS,EAAE,CAAC;YACb,OAAO;QACX,CAAC;QAED,IAAI,CAAC,eAAe,GAAG,cAAc,CAAC;QAEtC,IAAI,CAAC,UAAU,GAAG,SAAS,CAAC;QAC5B,IAAI,CAAC,UAAU,CAAC,mBAAmB,CAAC,GAAG,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;QAEtD,IAAI,CAAC,eAAe,GAAG,cAAc,CAAC;IAC1C,CAAC;IAED;;OAEG;IACI,MAAM;QACT,IAAI,CAAC,UAAU,EAAE,mBAAmB,CAAC,cAAc,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;QAClE,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC;IAC3B,CAAC;IASD;;;;OAIG;IACI,MAAM;QACT,IAAI,IAAI,CAAC,eAAe,8CAAsC,EAAE,CAAC;YAC7D,IAAI,IAAI,CAAC,eAAe,IAAK,IAAI,CAAC,UAA2B,CAAC,eAAe,EAAE,CAAC;gBAC5E,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAE,IAAI,CAAC,UAA2B,CAAC,eAAe,EAAE,CAAC,WAAW,CAAC,WAAW,CAAC,CAAC;YACzG,CAAC;iBAAM,CAAC;gBACJ,IAAI,CAAC,UAAU,EAAE,cAAc,EAAE,CAAC,mBAAmB,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;YAC1E,CAAC;YAED,IAAI,CAAC,iBAAiB,CAAC,QAAQ,CAAC,QAAQ,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;YACzD,IAAI,CAAC,iBAAiB,CAAC,eAAe,EAAE,CAAC;QAC7C,CAAC;QAED,IAAI,IAAI,CAAC,eAAe,8CAAsC,EAAE,CAAC;YAC7D,IAAI,CAAC,UAAU,EAAE,cAAc,EAAE,CAAC,SAAS,CAAC,SAAS,EAAE,IAAI,CAAC,mBAAmB,CAAC,CAAC;YAEjF,IAAI,CAAC,iBAAiB,CAAC,kBAAkB,CAAC,QAAQ,CAAC,IAAI,CAAC,mBAAmB,CAAC,CAAC;YAC7E,IAAI,CAAC,iBAAiB,CAAC,eAAe,EAAE,CAAC;QAC7C,CAAC;IACL,CAAC;CACJ","sourcesContent":["import { Quaternion, Vector3 } from \"../../../Maths/math.vector\";\nimport type { AbstractMesh } from \"../../../Meshes/abstractMesh\";\nimport type { Node } from \"../../../node\";\nimport type { Nullable } from \"../../../types\";\nimport { SpatialAudioAttachmentType } from \"../../spatialAudioAttachmentType\";\nimport type { _SpatialAudioSubNode } from \"../subNodes/spatialAudioSubNode\";\nimport type { _SpatialAudioListener } from \"../subProperties/spatialAudioListener\";\n\n/**\n * Provides a common interface for attaching an audio listener or source to a specific entity, ensuring only one entity\n * is attached at a time.\n * @internal\n */\nexport class _SpatialAudioAttacherComponent {\n    /** @internal */\n    private _attachmentType: SpatialAudioAttachmentType = SpatialAudioAttachmentType.PositionAndRotation;\n    private readonly _position = new Vector3();\n    private readonly _rotationQuaternion = new Quaternion();\n    private _sceneNode: Nullable<Node> = null;\n    private readonly _spatialAudioNode: _SpatialAudioSubNode | _SpatialAudioListener;\n    private _useBoundingBox: boolean = false;\n\n    /** @internal */\n    public constructor(spatialAudioNode: _SpatialAudioSubNode | _SpatialAudioListener) {\n        this._spatialAudioNode = spatialAudioNode;\n    }\n\n    /**\n     * Returns `true` if attached to a scene node; otherwise returns `false`.\n     */\n    public get isAttached(): boolean {\n        return this._sceneNode !== null;\n    }\n\n    /**\n     * Attaches to a scene node.\n     *\n     * Detaches automatically before attaching to the given scene node.\n     * If `sceneNode` is `null` it is the same as calling `detach()`.\n     *\n     * @param sceneNode The scene node to attach to, or `null` to detach.\n     * @param useBoundingBox Whether to use the scene node's bounding box for positioning. Defaults to `false`.\n     * @param attachmentType Whether to attach to the scene node's position and/or rotation. Defaults to `PositionAndRotation`.\n     */\n    public attach(sceneNode: Nullable<Node>, useBoundingBox: boolean, attachmentType: SpatialAudioAttachmentType): void {\n        if (this._sceneNode === sceneNode) {\n            return;\n        }\n\n        this.detach();\n\n        if (!sceneNode) {\n            return;\n        }\n\n        this._attachmentType = attachmentType;\n\n        this._sceneNode = sceneNode;\n        this._sceneNode.onDisposeObservable.add(this.dispose);\n\n        this._useBoundingBox = useBoundingBox;\n    }\n\n    /**\n     * Detaches from the scene node if attached.\n     */\n    public detach() {\n        this._sceneNode?.onDisposeObservable.removeCallback(this.dispose);\n        this._sceneNode = null;\n    }\n\n    /**\n     * Releases associated resources.\n     */\n    public dispose = () => {\n        this.detach();\n    };\n\n    /**\n     * Updates the position and rotation of the associated audio engine object in the audio rendering graph.\n     *\n     * This is called automatically by default and only needs to be called manually if automatic updates are disabled.\n     */\n    public update() {\n        if (this._attachmentType & SpatialAudioAttachmentType.Position) {\n            if (this._useBoundingBox && (this._sceneNode as AbstractMesh).getBoundingInfo) {\n                this._position.copyFrom((this._sceneNode as AbstractMesh).getBoundingInfo().boundingBox.centerWorld);\n            } else {\n                this._sceneNode?.getWorldMatrix().getTranslationToRef(this._position);\n            }\n\n            this._spatialAudioNode.position.copyFrom(this._position);\n            this._spatialAudioNode._updatePosition();\n        }\n\n        if (this._attachmentType & SpatialAudioAttachmentType.Rotation) {\n            this._sceneNode?.getWorldMatrix().decompose(undefined, this._rotationQuaternion);\n\n            this._spatialAudioNode.rotationQuaternion.copyFrom(this._rotationQuaternion);\n            this._spatialAudioNode._updateRotation();\n        }\n    }\n}\n"]}