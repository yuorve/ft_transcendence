import { _StereoAudioSubNode } from "../../abstractAudio/subNodes/stereoAudioSubNode.js";
/** @internal */
export async function _CreateStereoAudioSubNodeAsync(engine) {
    return new _StereoWebAudioSubNode(engine);
}
/** @internal */
export class _StereoWebAudioSubNode extends _StereoAudioSubNode {
    /** @internal */
    constructor(engine) {
        super(engine);
        this._pan = 0;
        this.node = new StereoPannerNode(engine.audioContext);
    }
    /** @internal */
    get pan() {
        return this._pan;
    }
    /** @internal */
    set pan(value) {
        this._pan = value;
        this.engine._setAudioParam(this.node.pan, value);
    }
    /** @internal */
    get inNode() {
        return this.node;
    }
    /** @internal */
    get outNode() {
        return this.node;
    }
    /** @internal */
    getClassName() {
        return "_StereoWebAudioSubNode";
    }
    _connect(node) {
        const connected = super._connect(node);
        if (!connected) {
            return false;
        }
        // If the wrapped node is not available now, it will be connected later by the subgraph.
        if (node.inNode) {
            this.node.connect(node.inNode);
        }
        return true;
    }
    _disconnect(node) {
        const disconnected = super._disconnect(node);
        if (!disconnected) {
            return false;
        }
        if (node.inNode) {
            this.node.disconnect(node.inNode);
        }
        return true;
    }
}
//# sourceMappingURL=stereoWebAudioSubNode.js.map