{"version":3,"file":"thinWebGPUEngine.js","sourceRoot":"","sources":["../../../../dev/core/src/Engines/thinWebGPUEngine.ts"],"names":[],"mappings":"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","sourcesContent":["import type { InternalTexture } from \"core/Materials/Textures/internalTexture\";\r\nimport { AbstractEngine } from \"./abstractEngine\";\r\nimport type { WebGPUCacheRenderPipeline } from \"./WebGPU/webgpuCacheRenderPipeline\";\r\nimport type { WebGPUTextureManager } from \"./WebGPU/webgpuTextureManager\";\r\nimport type { WebGPUHardwareTexture } from \"./WebGPU/webgpuHardwareTexture\";\r\nimport type { Nullable } from \"core/types\";\r\nimport { Logger } from \"core/Misc/logger\";\r\nimport { WebGPUTextureHelper } from \"./WebGPU/webgpuTextureHelper\";\r\nimport type { WebGPURenderTargetWrapper } from \"./WebGPU/webgpuRenderTargetWrapper\";\r\nimport { WebGPUPerfCounter } from \"./WebGPU/webgpuPerfCounter\";\r\nimport type { WebGPUSnapshotRendering } from \"./WebGPU/webgpuSnapshotRendering\";\r\nimport { Constants } from \"./constants\";\r\nimport type { WebGPUBundleList } from \"./WebGPU/webgpuBundleList\";\r\nimport type { WebGPUTimestampQuery } from \"./WebGPU/webgpuTimestampQuery\";\r\nimport type { WebGPUOcclusionQuery } from \"./WebGPU/webgpuOcclusionQuery\";\r\n\r\n/**\r\n * The base engine class for WebGPU\r\n */\r\nexport abstract class ThinWebGPUEngine extends AbstractEngine {\r\n    // TODO WEBGPU remove those variables when code stabilized\r\n    /** @internal */\r\n    public dbgShowShaderCode = false;\r\n    /** @internal */\r\n    public dbgSanityChecks = true;\r\n    /** @internal */\r\n    public dbgVerboseLogsNumFrames = 10;\r\n    /** @internal */\r\n    public dbgLogIfNotDrawWrapper = true;\r\n    /** @internal */\r\n    public dbgShowEmptyEnableEffectCalls = true;\r\n    /** @internal */\r\n    public dbgVerboseLogsForFirstFrames = false;\r\n\r\n    /** @internal */\r\n    public _textureHelper: WebGPUTextureManager;\r\n    /** @internal */\r\n    public _cacheRenderPipeline: WebGPUCacheRenderPipeline;\r\n    /** @internal */\r\n    public _occlusionQuery: WebGPUOcclusionQuery;\r\n\r\n    // Frame Life Cycle (recreated each frame)\r\n    /** @internal */\r\n    public _renderEncoder: GPUCommandEncoder;\r\n    /** @internal */\r\n    public _uploadEncoder: GPUCommandEncoder;\r\n\r\n    /** @internal */\r\n    public _currentRenderPass: Nullable<GPURenderPassEncoder> = null;\r\n\r\n    protected _snapshotRendering: WebGPUSnapshotRendering;\r\n    protected _snapshotRenderingMode = Constants.SNAPSHOTRENDERING_STANDARD;\r\n\r\n    /** @internal */\r\n    public _timestampQuery: WebGPUTimestampQuery;\r\n    /** @internal */\r\n    public _timestampIndex = 0;\r\n\r\n    /** @internal */\r\n    public _debugStackRenderPass: string[] = [];\r\n\r\n    /**\r\n     * Gets the GPU time spent in the main render pass for the last frame rendered (in nanoseconds).\r\n     * You have to enable the \"timestamp-query\" extension in the engine constructor options and set engine.enableGPUTimingMeasurements = true.\r\n     * It will only return time spent in the main pass, not additional render target / compute passes (if any)!\r\n     */\r\n    public readonly gpuTimeInFrameForMainPass?: WebGPUPerfCounter;\r\n\r\n    /**\r\n     * Used for both the compatibilityMode=false and the snapshot rendering modes (as both can't be enabled at the same time)\r\n     * @internal\r\n     */\r\n    public _bundleList: WebGPUBundleList;\r\n\r\n    /**\r\n     * Enables or disables GPU timing measurements.\r\n     * Note that this is only supported if the \"timestamp-query\" extension is enabled in the options.\r\n     */\r\n    public get enableGPUTimingMeasurements(): boolean {\r\n        return this._timestampQuery.enable;\r\n    }\r\n\r\n    public set enableGPUTimingMeasurements(enable: boolean) {\r\n        if (this._timestampQuery.enable === enable) {\r\n            return;\r\n        }\r\n        (this.gpuTimeInFrameForMainPass as any) = enable ? new WebGPUPerfCounter() : undefined;\r\n        this._timestampQuery.enable = enable;\r\n    }\r\n\r\n    protected _currentPassIsMainPass() {\r\n        return this._currentRenderTarget === null;\r\n    }\r\n\r\n    /** @internal */\r\n    public _endCurrentRenderPass(): number {\r\n        if (!this._currentRenderPass) {\r\n            return 0;\r\n        }\r\n\r\n        if (this._debugStackRenderPass.length !== 0) {\r\n            for (let i = 0; i < this._debugStackRenderPass.length; ++i) {\r\n                this._currentRenderPass.popDebugGroup();\r\n            }\r\n        }\r\n\r\n        const currentPassIndex = this._currentPassIsMainPass() ? 2 : 1;\r\n\r\n        if (!this._snapshotRendering.endRenderPass(this._currentRenderPass) && !this.compatibilityMode) {\r\n            this._bundleList.run(this._currentRenderPass);\r\n            this._bundleList.reset();\r\n        }\r\n        this._currentRenderPass.end();\r\n\r\n        this._timestampQuery.endPass(\r\n            this._timestampIndex,\r\n            (this._currentRenderTarget && (this._currentRenderTarget as WebGPURenderTargetWrapper).gpuTimeInFrame\r\n                ? (this._currentRenderTarget as WebGPURenderTargetWrapper).gpuTimeInFrame\r\n                : this.gpuTimeInFrameForMainPass) as WebGPUPerfCounter\r\n        );\r\n        this._timestampIndex += 2;\r\n\r\n        if (this.dbgVerboseLogsForFirstFrames) {\r\n            if ((this as any)._count === undefined) {\r\n                (this as any)._count = 0;\r\n            }\r\n            if (!(this as any)._count || (this as any)._count < this.dbgVerboseLogsNumFrames) {\r\n                Logger.Log(\r\n                    \"frame #\" +\r\n                        (this as any)._count +\r\n                        \" - \" +\r\n                        (currentPassIndex === 2 ? \"main\" : \"render target\") +\r\n                        \" end pass\" +\r\n                        (currentPassIndex === 1 ? \" - internalTexture.uniqueId=\" + this._currentRenderTarget?.texture?.uniqueId : \"\")\r\n                );\r\n            }\r\n        }\r\n        this._debugPopGroup?.(0);\r\n        this._currentRenderPass = null;\r\n\r\n        return currentPassIndex;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _generateMipmaps(texture: InternalTexture, commandEncoder?: GPUCommandEncoder) {\r\n        commandEncoder = commandEncoder ?? this._renderEncoder;\r\n\r\n        const gpuHardwareTexture = texture._hardwareTexture as Nullable<WebGPUHardwareTexture>;\r\n\r\n        if (!gpuHardwareTexture) {\r\n            return;\r\n        }\r\n\r\n        if (commandEncoder === this._renderEncoder) {\r\n            // We must close the current pass (if any) because we are going to use the render encoder to generate the mipmaps (so, we are going to create a new render pass)\r\n            this._endCurrentRenderPass();\r\n        }\r\n\r\n        const format = (texture._hardwareTexture as WebGPUHardwareTexture).format;\r\n        const mipmapCount = WebGPUTextureHelper.ComputeNumMipmapLevels(texture.width, texture.height);\r\n\r\n        if (this.dbgVerboseLogsForFirstFrames) {\r\n            if ((this as any)._count === undefined) {\r\n                (this as any)._count = 0;\r\n            }\r\n            if (!(this as any)._count || (this as any)._count < this.dbgVerboseLogsNumFrames) {\r\n                Logger.Log(\r\n                    \"frame #\" +\r\n                        (this as any)._count +\r\n                        \" - generate mipmaps - width=\" +\r\n                        texture.width +\r\n                        \", height=\" +\r\n                        texture.height +\r\n                        \", isCube=\" +\r\n                        texture.isCube +\r\n                        \", command encoder=\" +\r\n                        (commandEncoder === this._renderEncoder ? \"render\" : \"copy\")\r\n                );\r\n            }\r\n        }\r\n\r\n        if (texture.isCube) {\r\n            this._textureHelper.generateCubeMipmaps(gpuHardwareTexture, format, mipmapCount, commandEncoder);\r\n        } else {\r\n            this._textureHelper.generateMipmaps(gpuHardwareTexture, format, mipmapCount, 0, texture.is3D, commandEncoder);\r\n        }\r\n    }\r\n}\r\n"]}