{"version":3,"file":"flowGraphDataSwitchBlock.js","sourceRoot":"","sources":["../../../../../../dev/core/src/FlowGraph/Blocks/Data/flowGraphDataSwitchBlock.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,cAAc,EAAqC,gCAAsC;AAGlG,OAAO,EAAE,WAAW,EAAE,oCAA0C;AAEhE,OAAO,EAAE,eAAe,EAAE,SAAS,EAAE,uBAA6B;AAElE,OAAO,EAAE,aAAa,EAAE,mCAA4B;AAepD;;;;GAIG;AACH,MAAM,OAAO,wBAA4B,SAAQ,cAAc;IAkB3D;IACI;;OAEG;IACa,MAAiD;QAEjE,KAAK,CAAC,MAAM,CAAC,CAAC;QAFE,WAAM,GAAN,MAAM,CAA2C;QAN7D,gBAAW,GAA4C,IAAI,GAAG,EAAE,CAAC;QAUrE,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,iBAAiB,CAAC,MAAM,EAAE,WAAW,EAAE,GAAG,CAAC,CAAC;QAC7D,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,iBAAiB,CAAC,SAAS,EAAE,WAAW,CAAC,CAAC;QAC9D,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,kBAAkB,CAAC,OAAO,EAAE,WAAW,CAAC,CAAC;QAE3D,mCAAmC;QACnC,CAAC,IAAI,CAAC,MAAM,CAAC,KAAK,IAAI,EAAE,CAAC,CAAC,OAAO,CAAC,CAAC,SAAS,EAAE,EAAE;YAC5C,mEAAmE;YACnE,SAAS,GAAG,eAAe,CAAC,SAAS,CAAC,CAAC;YACvC,IAAI,IAAI,CAAC,MAAM,CAAC,oBAAoB,EAAE,CAAC;gBACnC,SAAS,GAAG,SAAS,GAAG,CAAC,CAAC;gBAC1B,IAAI,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,SAAS,CAAC,EAAE,CAAC;oBAClC,OAAO;gBACX,CAAC;YACL,CAAC;YACD,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,SAAS,EAAE,IAAI,CAAC,iBAAiB,CAAC,MAAM,SAAS,EAAE,EAAE,WAAW,CAAC,CAAC,CAAC;QAC5F,CAAC,CAAC,CAAC;IACP,CAAC;IAEe,cAAc,CAAC,OAAyB;QACpD,MAAM,cAAc,GAAG,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC;QACnD,IAAI,WAA0B,CAAC;QAC/B,IAAI,SAAS,CAAC,cAAc,CAAC,EAAE,CAAC;YAC5B,WAAW,GAAG,IAAI,CAAC,sBAAsB,CAAC,eAAe,CAAC,cAAc,CAAC,EAAE,OAAO,CAAC,CAAC;QACxF,CAAC;aAAM,CAAC;YACJ,WAAW,GAAG,IAAI,CAAC,OAAO,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC;QACjD,CAAC;QAED,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,WAAW,EAAE,OAAO,CAAC,CAAC;IAC9C,CAAC;IAEO,sBAAsB,CAAC,SAAiB,EAAE,OAAyB;QACvE,OAAO,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,SAAS,CAAC,EAAE,QAAQ,CAAC,OAAO,CAAC,CAAC;IAC9D,CAAC;IAEe,YAAY;QACxB,uEAAsC;IAC1C,CAAC;CACJ;AACD,aAAa,kEAAiC,wBAAwB,CAAC,CAAC","sourcesContent":["import { FlowGraphBlock, type IFlowGraphBlockConfiguration } from \"core/FlowGraph/flowGraphBlock\";\nimport type { FlowGraphContext } from \"core/FlowGraph/flowGraphContext\";\nimport type { FlowGraphDataConnection } from \"core/FlowGraph/flowGraphDataConnection\";\nimport { RichTypeAny } from \"core/FlowGraph/flowGraphRichTypes\";\nimport type { FlowGraphNumber } from \"core/FlowGraph/utils\";\nimport { getNumericValue, isNumeric } from \"core/FlowGraph/utils\";\nimport { FlowGraphBlockNames } from \"../flowGraphBlockNames\";\nimport { RegisterClass } from \"core/Misc/typeStore\";\n\nexport interface IFlowGraphDataSwitchBlockConfiguration<T> extends IFlowGraphBlockConfiguration {\n    /**\n     * The possible values for the selection.\n     *\n     */\n    cases: FlowGraphNumber[];\n\n    /**\n     * If true, the cases will be treated as integers, meaning 1.1, 1.0, 0.1e1  and 1 will a single case - \"1\".\n     * This is the default behavior in glTF interactivity.\n     */\n    treatCasesAsIntegers?: boolean;\n}\n/**\n * This block conditionally outputs one of its inputs, based on a condition and a list of cases.\n *\n * This of it as a passive (data) version of the switch statement in programming languages.\n */\nexport class FlowGraphDataSwitchBlock<T> extends FlowGraphBlock {\n    /**\n     * Current selection value.\n     */\n    public readonly case: FlowGraphDataConnection<FlowGraphNumber>;\n\n    /**\n     * Input: default value to output if no case is matched.\n     */\n    public readonly default: FlowGraphDataConnection<T>;\n\n    /**\n     * Output: the value that is output based on the selection.\n     */\n    public readonly value: FlowGraphDataConnection<T | undefined>;\n\n    private _inputCases: Map<number, FlowGraphDataConnection<T>> = new Map();\n\n    constructor(\n        /**\n         * the configuration of the block\n         */\n        public override config: IFlowGraphDataSwitchBlockConfiguration<T>\n    ) {\n        super(config);\n\n        this.case = this.registerDataInput(\"case\", RichTypeAny, NaN);\n        this.default = this.registerDataInput(\"default\", RichTypeAny);\n        this.value = this.registerDataOutput(\"value\", RichTypeAny);\n\n        // iterate the set not using for of\n        (this.config.cases || []).forEach((caseValue) => {\n            // if treat as integers, make sure not to set it again if it exists\n            caseValue = getNumericValue(caseValue);\n            if (this.config.treatCasesAsIntegers) {\n                caseValue = caseValue | 0;\n                if (this._inputCases.has(caseValue)) {\n                    return;\n                }\n            }\n            this._inputCases.set(caseValue, this.registerDataInput(`in_${caseValue}`, RichTypeAny));\n        });\n    }\n\n    public override _updateOutputs(context: FlowGraphContext): void {\n        const selectionValue = this.case.getValue(context);\n        let outputValue: T | undefined;\n        if (isNumeric(selectionValue)) {\n            outputValue = this._getOutputValueForCase(getNumericValue(selectionValue), context);\n        } else {\n            outputValue = this.default.getValue(context);\n        }\n\n        this.value.setValue(outputValue, context);\n    }\n\n    private _getOutputValueForCase(caseValue: number, context: FlowGraphContext): T | undefined {\n        return this._inputCases.get(caseValue)?.getValue(context);\n    }\n\n    public override getClassName(): string {\n        return FlowGraphBlockNames.DataSwitch;\n    }\n}\nRegisterClass(FlowGraphBlockNames.DataSwitch, FlowGraphDataSwitchBlock);\n"]}