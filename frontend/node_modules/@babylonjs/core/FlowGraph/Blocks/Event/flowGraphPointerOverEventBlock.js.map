{"version":3,"file":"flowGraphPointerOverEventBlock.js","sourceRoot":"","sources":["../../../../../../dev/core/src/FlowGraph/Blocks/Event/flowGraphPointerOverEventBlock.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,mBAAmB,EAAE,qCAA2C;AAMzE,OAAO,EAAE,WAAW,EAAE,cAAc,EAAE,oCAA0C;AAChF,OAAO,EAAE,aAAa,EAAE,mCAA4B;AACpD,OAAO,EAAE,gBAAgB,EAAE,uBAA6B;AAoCxD;;;GAGG;AACH,MAAM,OAAO,8BAA+B,SAAQ,mBAAmB;IAkBnE,YAAmB,MAAqD;QACpE,KAAK,CAAC,MAAM,CAAC,CAAC;QAHO,SAAI,sDAAsD;QAI/E,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,kBAAkB,CAAC,WAAW,EAAE,cAAc,CAAC,CAAC;QACtE,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,iBAAiB,CAAC,YAAY,EAAE,WAAW,EAAE,MAAM,EAAE,UAAU,CAAC,CAAC;QACxF,IAAI,CAAC,gBAAgB,GAAG,IAAI,CAAC,kBAAkB,CAAC,kBAAkB,EAAE,WAAW,CAAC,CAAC;IACrF,CAAC;IAEe,aAAa,CAAC,OAAyB,EAAE,OAA0C;QAC/F,MAAM,IAAI,GAAG,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC;QAC/C,IAAI,CAAC,gBAAgB,CAAC,QAAQ,CAAC,OAAO,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;QACtD,8EAA8E;QAC9E,MAAM,SAAS,GAAG,OAAO,CAAC,GAAG,IAAI,gBAAgB,CAAC,OAAO,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC;QACrE,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,OAAO,CAAC,SAAS,EAAE,OAAO,CAAC,CAAC;QACpD,IAAI,CAAC,SAAS,IAAI,CAAC,OAAO,CAAC,IAAI,KAAK,IAAI,IAAI,gBAAgB,CAAC,OAAO,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC,EAAE,CAAC;YAChF,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC;YACvB,OAAO,CAAC,IAAI,CAAC,MAAM,EAAE,eAAe,CAAC;QACzC,CAAC;QACD,OAAO,IAAI,CAAC;IAChB,CAAC;IACe,oBAAoB,CAAC,QAA0B;QAC3D,QAAQ;IACZ,CAAC;IACe,mBAAmB,CAAC,QAA0B;QAC1D,QAAQ;IACZ,CAAC;IACe,YAAY;QACxB,mFAA4C;IAChD,CAAC;CACJ;AAED,aAAa,8EAAuC,8BAA8B,CAAC,CAAC","sourcesContent":["import type { FlowGraphContext } from \"core/FlowGraph/flowGraphContext\";\nimport { FlowGraphEventBlock } from \"core/FlowGraph/flowGraphEventBlock\";\nimport { FlowGraphEventType } from \"core/FlowGraph/flowGraphEventType\";\nimport { FlowGraphBlockNames } from \"../flowGraphBlockNames\";\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\nimport type { FlowGraphDataConnection } from \"core/FlowGraph/flowGraphDataConnection\";\nimport type { IFlowGraphBlockConfiguration } from \"core/FlowGraph/flowGraphBlock\";\nimport { RichTypeAny, RichTypeNumber } from \"core/FlowGraph/flowGraphRichTypes\";\nimport { RegisterClass } from \"core/Misc/typeStore\";\nimport { _isADescendantOf } from \"core/FlowGraph/utils\";\n\n/**\n * Configuration for the pointer over event block.\n */\nexport interface IFlowGraphPointerOverEventBlockConfiguration extends IFlowGraphBlockConfiguration {\n    /**\n     * Should this mesh block propagation of the event.\n     */\n    stopPropagation?: boolean;\n\n    /**\n     * The mesh to listen to. Can also be set by the asset input.\n     */\n    targetMesh?: AbstractMesh;\n}\n\n/**\n * Payload for the pointer over event.\n */\nexport interface IFlowGraphPointerOverEventPayload {\n    /**\n     * The pointer id.\n     */\n    pointerId: number;\n    /**\n     * The mesh that was picked.\n     */\n    mesh: AbstractMesh;\n\n    /**\n     * If populated, the hover event moved from this mesh to the `mesh` variable\n     */\n    out?: AbstractMesh;\n}\n\n/**\n * A pointer over event block.\n * This block can be used as an entry pointer to when a pointer is over a specific target mesh.\n */\nexport class FlowGraphPointerOverEventBlock extends FlowGraphEventBlock {\n    /**\n     * Output connection: The pointer id.\n     */\n    public readonly pointerId: FlowGraphDataConnection<number>;\n\n    /**\n     * Input connection: The mesh to listen to.\n     */\n    public readonly targetMesh: FlowGraphDataConnection<AbstractMesh>;\n\n    /**\n     * Output connection: The mesh that is under the pointer.\n     */\n    public readonly meshUnderPointer: FlowGraphDataConnection<AbstractMesh>;\n\n    public override readonly type: FlowGraphEventType = FlowGraphEventType.PointerOver;\n\n    public constructor(config?: IFlowGraphPointerOverEventBlockConfiguration) {\n        super(config);\n        this.pointerId = this.registerDataOutput(\"pointerId\", RichTypeNumber);\n        this.targetMesh = this.registerDataInput(\"targetMesh\", RichTypeAny, config?.targetMesh);\n        this.meshUnderPointer = this.registerDataOutput(\"meshUnderPointer\", RichTypeAny);\n    }\n\n    public override _executeEvent(context: FlowGraphContext, payload: IFlowGraphPointerOverEventPayload): boolean {\n        const mesh = this.targetMesh.getValue(context);\n        this.meshUnderPointer.setValue(payload.mesh, context);\n        // skip if we moved from a mesh that is under the hierarchy of the target mesh\n        const skipEvent = payload.out && _isADescendantOf(payload.out, mesh);\n        this.pointerId.setValue(payload.pointerId, context);\n        if (!skipEvent && (payload.mesh === mesh || _isADescendantOf(payload.mesh, mesh))) {\n            this._execute(context);\n            return !this.config?.stopPropagation;\n        }\n        return true;\n    }\n    public override _preparePendingTasks(_context: FlowGraphContext): void {\n        // no-op\n    }\n    public override _cancelPendingTasks(_context: FlowGraphContext): void {\n        // no-op\n    }\n    public override getClassName() {\n        return FlowGraphBlockNames.PointerOverEvent;\n    }\n}\n\nRegisterClass(FlowGraphBlockNames.PointerOverEvent, FlowGraphPointerOverEventBlock);\n"]}