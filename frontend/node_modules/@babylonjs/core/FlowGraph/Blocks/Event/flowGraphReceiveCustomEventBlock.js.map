{"version":3,"file":"flowGraphReceiveCustomEventBlock.js","sourceRoot":"","sources":["../../../../../../dev/core/src/FlowGraph/Blocks/Event/flowGraphReceiveCustomEventBlock.ts"],"names":[],"mappings":"AAEA,OAAO,EAAE,mBAAmB,EAAE,MAAM,2BAA2B,CAAC;AAEhE,OAAO,EAAE,KAAK,EAAE,MAAM,qBAAqB,CAAC;AAG5C,OAAO,EAAE,aAAa,EAAE,MAAM,yBAAyB,CAAC;AAExD,OAAO,EAAE,oBAAoB,EAAE,sCAA4C;AAiB3E;;;;GAIG;AACH,MAAM,OAAO,gCAAiC,SAAQ,mBAAmB;IAGrE;IACI;;OAEG;IACa,MAAsD;QAEtE,KAAK,CAAC,MAAM,CAAC,CAAC;QAFE,WAAM,GAAN,MAAM,CAAgD;QAN1D,iBAAY,GAAW,CAAC,CAAC;QASrC,0CAA0C;QAC1C,KAAK,MAAM,GAAG,IAAI,IAAI,CAAC,MAAM,CAAC,SAAS,EAAE,CAAC;YACtC,IAAI,CAAC,kBAAkB,CAAC,GAAG,EAAE,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC;QAClE,CAAC;IACL,CAAC;IAEM,oBAAoB,CAAC,OAAyB;QACjD,MAAM,UAAU,GAAG,OAAO,CAAC,aAAa,CAAC,WAAW,CAAC,wBAAwB,CAAC,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC;QACnG,yDAAyD;QACzD,IAAI,UAAU,IAAI,UAAU,CAAC,YAAY,EAAE,IAAI,UAAU,CAAC,SAAS,CAAC,MAAM,GAAG,oBAAoB,CAAC,gBAAgB,EAAE,CAAC;YACjH,IAAI,CAAC,YAAY,CAAC,OAAO,EAAE,kEAAkE,IAAI,CAAC,MAAM,CAAC,OAAO,YAAY,oBAAoB,CAAC,gBAAgB,GAAG,CAAC,CAAC;YACtK,OAAO;QACX,CAAC;QAED,MAAM,aAAa,GAAG,UAAU,CAAC,GAAG,CAAC,CAAC,SAAiC,EAAE,EAAE;YACvE,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,OAAO,CAAC,CAAC,GAAG,EAAE,EAAE;gBACnC,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,EAAE,QAAQ,CAAC,SAAS,CAAC,GAAG,CAAC,EAAE,OAAO,CAAC,CAAC;YAC/D,CAAC,CAAC,CAAC;YACH,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC;QAC3B,CAAC,CAAC,CAAC;QACH,OAAO,CAAC,qBAAqB,CAAC,IAAI,EAAE,gBAAgB,EAAE,aAAa,CAAC,CAAC;IACzE,CAAC;IACM,mBAAmB,CAAC,OAAyB;QAChD,MAAM,UAAU,GAAG,OAAO,CAAC,aAAa,CAAC,WAAW,CAAC,wBAAwB,CAAC,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC;QACnG,IAAI,UAAU,EAAE,CAAC;YACb,MAAM,aAAa,GAAG,OAAO,CAAC,qBAAqB,CAA4B,IAAI,EAAE,gBAAgB,EAAE,IAAI,CAAC,CAAC;YAC7G,UAAU,CAAC,MAAM,CAAC,aAAa,CAAC,CAAC;QACrC,CAAC;aAAM,CAAC;YACJ,KAAK,CAAC,IAAI,CAAC,kEAAkE,IAAI,CAAC,MAAM,CAAC,OAAO,EAAE,CAAC,CAAC;QACxG,CAAC;IACL,CAAC;IAEe,aAAa,CAAC,QAA0B,EAAE,QAAa;QACnE,OAAO,IAAI,CAAC;IAChB,CAAC;IAED;;OAEG;IACa,YAAY;QACxB,uFAA8C;IAClD,CAAC;CACJ;AACD,aAAa,kFAAyC,gCAAgC,CAAC,CAAC","sourcesContent":["import type { Observer } from \"../../../Misc/observable\";\r\nimport type { FlowGraphContext } from \"../../flowGraphContext\";\r\nimport { FlowGraphEventBlock } from \"../../flowGraphEventBlock\";\r\nimport type { Nullable } from \"../../../types\";\r\nimport { Tools } from \"../../../Misc/tools\";\r\nimport type { RichType } from \"../../flowGraphRichTypes\";\r\nimport type { IFlowGraphBlockConfiguration } from \"../../flowGraphBlock\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport { FlowGraphBlockNames } from \"../flowGraphBlockNames\";\r\nimport { FlowGraphCoordinator } from \"core/FlowGraph/flowGraphCoordinator\";\r\n/**\r\n * Parameters used to create a FlowGraphReceiveCustomEventBlock.\r\n */\r\nexport interface IFlowGraphReceiveCustomEventBlockConfiguration extends IFlowGraphBlockConfiguration {\r\n    /**\r\n     * The id of the event to receive.\r\n     * This event id is unique to the environment (not the context).\r\n     */\r\n    eventId: string;\r\n    /**\r\n     * The names of the data outputs for that event. Should be in the same order as the event data in\r\n     * SendCustomEvent\r\n     */\r\n    eventData: { [key: string]: { type: RichType<any> } };\r\n}\r\n\r\n/**\r\n * A block that receives a custom event.\r\n * It saves the event data in the data outputs, based on the provided eventData in the configuration. For example, if the event data is\r\n * `{ x: { type: RichTypeNumber }, y: { type: RichTypeNumber } }`, the block will have two data outputs: x and y.\r\n */\r\nexport class FlowGraphReceiveCustomEventBlock extends FlowGraphEventBlock {\r\n    public override initPriority: number = 1;\r\n\r\n    constructor(\r\n        /**\r\n         * the configuration of the block\r\n         */\r\n        public override config: IFlowGraphReceiveCustomEventBlockConfiguration\r\n    ) {\r\n        super(config);\r\n        // use event data to register data outputs\r\n        for (const key in this.config.eventData) {\r\n            this.registerDataOutput(key, this.config.eventData[key].type);\r\n        }\r\n    }\r\n\r\n    public _preparePendingTasks(context: FlowGraphContext): void {\r\n        const observable = context.configuration.coordinator.getCustomEventObservable(this.config.eventId);\r\n        // check if we are not exceeding the max number of events\r\n        if (observable && observable.hasObservers() && observable.observers.length > FlowGraphCoordinator.MaxEventsPerType) {\r\n            this._reportError(context, `FlowGraphReceiveCustomEventBlock: Too many observers for event ${this.config.eventId}. Max is ${FlowGraphCoordinator.MaxEventsPerType}.`);\r\n            return;\r\n        }\r\n\r\n        const eventObserver = observable.add((eventData: { [key: string]: any }) => {\r\n            Object.keys(eventData).forEach((key) => {\r\n                this.getDataOutput(key)?.setValue(eventData[key], context);\r\n            });\r\n            this._execute(context);\r\n        });\r\n        context._setExecutionVariable(this, \"_eventObserver\", eventObserver);\r\n    }\r\n    public _cancelPendingTasks(context: FlowGraphContext): void {\r\n        const observable = context.configuration.coordinator.getCustomEventObservable(this.config.eventId);\r\n        if (observable) {\r\n            const eventObserver = context._getExecutionVariable<Nullable<Observer<any[]>>>(this, \"_eventObserver\", null);\r\n            observable.remove(eventObserver);\r\n        } else {\r\n            Tools.Warn(`FlowGraphReceiveCustomEventBlock: Missing observable for event ${this.config.eventId}`);\r\n        }\r\n    }\r\n\r\n    public override _executeEvent(_context: FlowGraphContext, _payload: any): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @returns class name of the block.\r\n     */\r\n    public override getClassName(): string {\r\n        return FlowGraphBlockNames.ReceiveCustomEvent;\r\n    }\r\n}\r\nRegisterClass(FlowGraphBlockNames.ReceiveCustomEvent, FlowGraphReceiveCustomEventBlock);\r\n"]}