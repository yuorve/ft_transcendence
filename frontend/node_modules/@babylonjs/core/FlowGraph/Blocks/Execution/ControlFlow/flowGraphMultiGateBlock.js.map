{"version":3,"file":"flowGraphMultiGateBlock.js","sourceRoot":"","sources":["../../../../../../../dev/core/src/FlowGraph/Blocks/Execution/ControlFlow/flowGraphMultiGateBlock.ts"],"names":[],"mappings":"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","sourcesContent":["import { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport type { FlowGraphContext } from \"../../../flowGraphContext\";\r\nimport type { FlowGraphDataConnection } from \"../../../flowGraphDataConnection\";\r\nimport { FlowGraphExecutionBlock } from \"../../../flowGraphExecutionBlock\";\r\nimport { RichTypeFlowGraphInteger } from \"../../../flowGraphRichTypes\";\r\nimport type { FlowGraphSignalConnection } from \"../../../flowGraphSignalConnection\";\r\nimport type { IFlowGraphBlockConfiguration } from \"../../../flowGraphBlock\";\r\nimport { FlowGraphBlockNames } from \"../../flowGraphBlockNames\";\r\nimport { FlowGraphInteger } from \"core/FlowGraph/CustomTypes/flowGraphInteger\";\r\n/**\r\n * Configuration for the multi gate block.\r\n */\r\nexport interface IFlowGraphMultiGateBlockConfiguration extends IFlowGraphBlockConfiguration {\r\n    /**\r\n     * The number of output signals. Required.\r\n     */\r\n    outputSignalCount: number;\r\n    /**\r\n     * If the block should pick a random output flow from the ones that haven't been executed. Default to false.\r\n     */\r\n    isRandom?: boolean;\r\n    /**\r\n     * If the block should loop back to the first output flow after executing the last one. Default to false.\r\n     */\r\n    isLoop?: boolean;\r\n}\r\n\r\n/**\r\n * A block that has an input flow and routes it to any potential output flows, randomly or sequentially\r\n */\r\nexport class FlowGraphMultiGateBlock extends FlowGraphExecutionBlock {\r\n    /**\r\n     * Input connection: Resets the gate.\r\n     */\r\n    public readonly reset: FlowGraphSignalConnection;\r\n    /**\r\n     * Output connections: The output signals.\r\n     */\r\n    public readonly outputSignals: FlowGraphSignalConnection[] = [];\r\n    /**\r\n     * Output connection: The index of the current output flow.\r\n     */\r\n    public readonly lastIndex: FlowGraphDataConnection<FlowGraphInteger>;\r\n\r\n    constructor(\r\n        /**\r\n         * the configuration of the block\r\n         */\r\n        public override config: IFlowGraphMultiGateBlockConfiguration\r\n    ) {\r\n        super(config);\r\n        this.reset = this._registerSignalInput(\"reset\");\r\n        this.lastIndex = this.registerDataOutput(\"lastIndex\", RichTypeFlowGraphInteger, new FlowGraphInteger(-1));\r\n        this.setNumberOfOutputSignals(config?.outputSignalCount);\r\n    }\r\n\r\n    private _getNextIndex(indexesUsed: boolean[]): number {\r\n        // find the next index available from the indexes used array\r\n\r\n        // if all outputs were used, reset the indexes used array if we are in a loop multi gate\r\n        if (!indexesUsed.includes(false)) {\r\n            if (this.config.isLoop) {\r\n                indexesUsed.fill(false);\r\n            }\r\n        }\r\n        if (!this.config.isRandom) {\r\n            return indexesUsed.indexOf(false);\r\n        } else {\r\n            const unusedIndexes = indexesUsed.map((used, index) => (used ? -1 : index)).filter((index) => index !== -1);\r\n            return unusedIndexes.length ? unusedIndexes[Math.floor(Math.random() * unusedIndexes.length)] : -1;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the block's output signals. Would usually be passed from the constructor but can be changed afterwards.\r\n     * @param numberOutputSignals the number of output flows\r\n     */\r\n    public setNumberOfOutputSignals(numberOutputSignals: number = 1) {\r\n        // check the size of the outFlow Array, see if it is not larger than needed\r\n        while (this.outputSignals.length > numberOutputSignals) {\r\n            const flow = this.outputSignals.pop();\r\n            if (flow) {\r\n                flow.disconnectFromAll();\r\n                this._unregisterSignalOutput(flow.name);\r\n            }\r\n        }\r\n\r\n        while (this.outputSignals.length < numberOutputSignals) {\r\n            this.outputSignals.push(this._registerSignalOutput(`out_${this.outputSignals.length}`));\r\n        }\r\n    }\r\n\r\n    public _execute(context: FlowGraphContext, callingSignal: FlowGraphSignalConnection): void {\r\n        // set the state(s) of the block\r\n        if (!context._hasExecutionVariable(this, \"indexesUsed\")) {\r\n            context._setExecutionVariable(\r\n                this,\r\n                \"indexesUsed\",\r\n                this.outputSignals.map(() => false)\r\n            );\r\n        }\r\n\r\n        if (callingSignal === this.reset) {\r\n            context._deleteExecutionVariable(this, \"indexesUsed\");\r\n            this.lastIndex.setValue(new FlowGraphInteger(-1), context);\r\n            return;\r\n        }\r\n        const indexesUsed = context._getExecutionVariable(this, \"indexesUsed\", [] as boolean[]);\r\n        const nextIndex = this._getNextIndex(indexesUsed);\r\n        if (nextIndex > -1) {\r\n            this.lastIndex.setValue(new FlowGraphInteger(nextIndex), context);\r\n            indexesUsed[nextIndex] = true;\r\n            context._setExecutionVariable(this, \"indexesUsed\", indexesUsed);\r\n            this.outputSignals[nextIndex]._activateSignal(context);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @returns class name of the block.\r\n     */\r\n    public override getClassName(): string {\r\n        return FlowGraphBlockNames.MultiGate;\r\n    }\r\n\r\n    /**\r\n     * Serializes the block.\r\n     * @param serializationObject the object to serialize to.\r\n     */\r\n    public override serialize(serializationObject?: any): void {\r\n        super.serialize(serializationObject);\r\n        serializationObject.config.outputSignalCount = this.config.outputSignalCount;\r\n        serializationObject.config.isRandom = this.config.isRandom;\r\n        serializationObject.config.loop = this.config.isLoop;\r\n        serializationObject.config.startIndex = this.config.startIndex;\r\n    }\r\n}\r\nRegisterClass(FlowGraphBlockNames.MultiGate, FlowGraphMultiGateBlock);\r\n"]}