{"version":3,"file":"flowGraph.js","sourceRoot":"","sources":["../../../../dev/core/src/FlowGraph/flowGraph.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Observer } from \"../Misc/observable\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { FlowGraphEventBlock } from \"./flowGraphEventBlock\";\r\nimport { FlowGraphContext } from \"./flowGraphContext\";\r\nimport type { FlowGraphBlock } from \"./flowGraphBlock\";\r\nimport { FlowGraphExecutionBlock } from \"./flowGraphExecutionBlock\";\r\nimport type { FlowGraphCoordinator } from \"./flowGraphCoordinator\";\r\nimport type { IObjectAccessor } from \"./typeDefinitions\";\r\nimport type { IPathToObjectConverter } from \"../ObjectModel/objectModelInterfaces\";\r\nimport type { IAssetContainer } from \"core/IAssetContainer\";\r\nimport { FlowGraphEventType } from \"./flowGraphEventType\";\r\nimport type { IFlowGraphEventTrigger } from \"./flowGraphSceneEventCoordinator\";\r\nimport { FlowGraphSceneEventCoordinator } from \"./flowGraphSceneEventCoordinator\";\r\nimport type { FlowGraphMeshPickEventBlock } from \"./Blocks/Event/flowGraphMeshPickEventBlock\";\r\nimport { _isADescendantOf } from \"./utils\";\r\n\r\nexport const enum FlowGraphState {\r\n    /**\r\n     * The graph is stopped\r\n     */\r\n    Stopped,\r\n    /**\r\n     * The graph is running\r\n     */\r\n    Started,\r\n}\r\n\r\n/**\r\n * Parameters used to create a flow graph.\r\n */\r\nexport interface IFlowGraphParams {\r\n    /**\r\n     * The scene that the flow graph belongs to.\r\n     */\r\n    scene: Scene;\r\n    /**\r\n     * The event coordinator used by the flow graph.\r\n     */\r\n    coordinator: FlowGraphCoordinator;\r\n}\r\n\r\n/**\r\n * Options for parsing a flow graph.\r\n */\r\nexport interface IFlowGraphParseOptions {\r\n    /**\r\n     * A function that parses complex values in a scene.\r\n     * @param key the key of the value\r\n     * @param serializationObject the object to read the value from\r\n     * @param scene the scene to read the value from\r\n     */\r\n    valueParseFunction?: (key: string, serializationObject: any, assetsContainer: IAssetContainer, scene: Scene) => any;\r\n    /**\r\n     * The flow graph coordinator.\r\n     */\r\n    coordinator: FlowGraphCoordinator;\r\n    /**\r\n     * A function that converts a path to an object accessor.\r\n     */\r\n    pathConverter?: IPathToObjectConverter<IObjectAccessor>;\r\n}\r\n/**\r\n * Class used to represent a flow graph.\r\n * A flow graph is a graph of blocks that can be used to create complex logic.\r\n * Blocks can be added to the graph and connected to each other.\r\n * The graph can then be started, which will init and start all of its event blocks.\r\n *\r\n * @experimental FlowGraph is still in development and is subject to change.\r\n */\r\nexport class FlowGraph {\r\n    /**\r\n     * An observable that is triggered when the state of the graph changes.\r\n     */\r\n    public onStateChangedObservable: Observable<FlowGraphState> = new Observable();\r\n    /** @internal */\r\n    public _eventBlocks: { [keyof in FlowGraphEventType]: FlowGraphEventBlock[] } = {\r\n        [FlowGraphEventType.SceneReady]: [],\r\n        [FlowGraphEventType.SceneDispose]: [],\r\n        [FlowGraphEventType.SceneBeforeRender]: [],\r\n        [FlowGraphEventType.MeshPick]: [],\r\n        [FlowGraphEventType.PointerDown]: [],\r\n        [FlowGraphEventType.PointerUp]: [],\r\n        [FlowGraphEventType.PointerMove]: [],\r\n        [FlowGraphEventType.PointerOver]: [],\r\n        [FlowGraphEventType.PointerOut]: [],\r\n        [FlowGraphEventType.SceneAfterRender]: [],\r\n        [FlowGraphEventType.NoTrigger]: [],\r\n    };\r\n    /**\r\n     * @internal\r\n     */\r\n    public readonly _scene: Scene;\r\n    private _coordinator: FlowGraphCoordinator;\r\n    private _executionContexts: FlowGraphContext[] = [];\r\n    private _sceneEventCoordinator: FlowGraphSceneEventCoordinator;\r\n    private _eventObserver: Nullable<Observer<IFlowGraphEventTrigger>>;\r\n\r\n    /**\r\n     * The state of the graph\r\n     */\r\n    private _state: FlowGraphState = FlowGraphState.Stopped;\r\n\r\n    /**\r\n     * The state of the graph\r\n     */\r\n    public get state() {\r\n        return this._state;\r\n    }\r\n\r\n    /**\r\n     * The state of the graph\r\n     */\r\n    public set state(value: FlowGraphState) {\r\n        this._state = value;\r\n        this.onStateChangedObservable.notifyObservers(value);\r\n    }\r\n\r\n    /**\r\n     * Construct a Flow Graph\r\n     * @param params construction parameters. currently only the scene\r\n     */\r\n    public constructor(params: IFlowGraphParams) {\r\n        this._scene = params.scene;\r\n        this._sceneEventCoordinator = new FlowGraphSceneEventCoordinator(this._scene);\r\n        this._coordinator = params.coordinator;\r\n\r\n        this._eventObserver = this._sceneEventCoordinator.onEventTriggeredObservable.add((event) => {\r\n            for (const context of this._executionContexts) {\r\n                const order = this._getContextualOrder(event.type, context);\r\n                for (const block of order) {\r\n                    // iterate contexts\r\n                    if (!block._executeEvent(context, event.payload)) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            // custom behavior(s) of specific events\r\n            switch (event.type) {\r\n                case FlowGraphEventType.SceneReady:\r\n                    this._sceneEventCoordinator.sceneReadyTriggered = true;\r\n                    break;\r\n                case FlowGraphEventType.SceneBeforeRender:\r\n                    for (const context of this._executionContexts) {\r\n                        context._notifyOnTick(event.payload);\r\n                    }\r\n                    break;\r\n                case FlowGraphEventType.SceneDispose:\r\n                    this.dispose();\r\n                    break;\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Create a context. A context represents one self contained execution for the graph, with its own variables.\r\n     * @returns the context, where you can get and set variables\r\n     */\r\n    public createContext() {\r\n        const context = new FlowGraphContext({ scene: this._scene, coordinator: this._coordinator });\r\n        this._executionContexts.push(context);\r\n        return context;\r\n    }\r\n\r\n    /**\r\n     * Returns the execution context at a given index\r\n     * @param index the index of the context\r\n     * @returns the execution context at that index\r\n     */\r\n    public getContext(index: number) {\r\n        return this._executionContexts[index];\r\n    }\r\n\r\n    /**\r\n     * Add an event block. When the graph is started, it will start listening to events\r\n     * from the block and execute the graph when they are triggered.\r\n     * @param block the event block to be added\r\n     */\r\n    public addEventBlock(block: FlowGraphEventBlock): void {\r\n        if (block.type === FlowGraphEventType.PointerOver || block.type === FlowGraphEventType.PointerOut) {\r\n            this._scene.constantlyUpdateMeshUnderPointer = true;\r\n        }\r\n\r\n        // don't add if NoTrigger, but still start the pending tasks\r\n        if (block.type !== FlowGraphEventType.NoTrigger) {\r\n            this._eventBlocks[block.type].push(block);\r\n        }\r\n        // if already started, sort and add to the pending\r\n        if (this.state === FlowGraphState.Started) {\r\n            for (const context of this._executionContexts) {\r\n                block._startPendingTasks(context);\r\n            }\r\n        } else {\r\n            this.onStateChangedObservable.addOnce((state) => {\r\n                if (state === FlowGraphState.Started) {\r\n                    for (const context of this._executionContexts) {\r\n                        block._startPendingTasks(context);\r\n                    }\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Starts the flow graph. Initializes the event blocks and starts listening to events.\r\n     */\r\n    public start() {\r\n        if (this.state === FlowGraphState.Started) {\r\n            return;\r\n        }\r\n        if (this._executionContexts.length === 0) {\r\n            this.createContext();\r\n        }\r\n        this.onStateChangedObservable.add((state) => {\r\n            if (state === FlowGraphState.Started) {\r\n                this._startPendingEvents();\r\n                // the only event we need to check is the scene ready event. If the scene is already ready when the graph starts, we should start the pending tasks.\r\n                if (this._scene.isReady(true)) {\r\n                    this._sceneEventCoordinator.onEventTriggeredObservable.notifyObservers({ type: FlowGraphEventType.SceneReady });\r\n                }\r\n            }\r\n        });\r\n        this.state = FlowGraphState.Started;\r\n    }\r\n\r\n    private _startPendingEvents() {\r\n        for (const context of this._executionContexts) {\r\n            for (const type in this._eventBlocks) {\r\n                const order = this._getContextualOrder(type as FlowGraphEventType, context);\r\n                for (const block of order) {\r\n                    block._startPendingTasks(context);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private _getContextualOrder(type: FlowGraphEventType, context: FlowGraphContext): FlowGraphEventBlock[] {\r\n        const order = this._eventBlocks[type].sort((a, b) => b.initPriority - a.initPriority);\r\n\r\n        if (type === FlowGraphEventType.MeshPick) {\r\n            const meshPickOrder = [] as FlowGraphEventBlock[];\r\n            for (const block1 of order) {\r\n                // If the block is a mesh pick, guarantee that picks of children meshes come before picks of parent meshes\r\n                const mesh1 = (block1 as FlowGraphMeshPickEventBlock).asset.getValue(context);\r\n                let i = 0;\r\n                for (; i < order.length; i++) {\r\n                    const block2 = order[i];\r\n                    const mesh2 = (block2 as FlowGraphMeshPickEventBlock).asset.getValue(context);\r\n                    if (mesh1 && mesh2 && _isADescendantOf(mesh1, mesh2)) {\r\n                        break;\r\n                    }\r\n                }\r\n                meshPickOrder.splice(i, 0, block1);\r\n            }\r\n            return meshPickOrder;\r\n        }\r\n        return order;\r\n    }\r\n\r\n    /**\r\n     * Disposes of the flow graph. Cancels any pending tasks and removes all event listeners.\r\n     */\r\n    public dispose() {\r\n        if (this.state === FlowGraphState.Stopped) {\r\n            return;\r\n        }\r\n        this.state = FlowGraphState.Stopped;\r\n        for (const context of this._executionContexts) {\r\n            context._clearPendingBlocks();\r\n        }\r\n        this._executionContexts.length = 0;\r\n        for (const type in this._eventBlocks) {\r\n            this._eventBlocks[type as FlowGraphEventType].length = 0;\r\n        }\r\n        this._eventObserver?.remove();\r\n        this._sceneEventCoordinator.dispose();\r\n    }\r\n\r\n    /**\r\n     * Executes a function in all blocks of a flow graph, starting with the event blocks.\r\n     * @param visitor the function to execute.\r\n     */\r\n    public visitAllBlocks(visitor: (block: FlowGraphBlock) => void) {\r\n        const visitList: FlowGraphBlock[] = [];\r\n        const idsAddedToVisitList = new Set<string>();\r\n        for (const type in this._eventBlocks) {\r\n            for (const block of this._eventBlocks[type as FlowGraphEventType]) {\r\n                visitList.push(block);\r\n                idsAddedToVisitList.add(block.uniqueId);\r\n            }\r\n        }\r\n\r\n        while (visitList.length > 0) {\r\n            const block = visitList.pop()!;\r\n            visitor(block);\r\n\r\n            for (const dataIn of block.dataInputs) {\r\n                for (const connection of dataIn._connectedPoint) {\r\n                    if (!idsAddedToVisitList.has(connection._ownerBlock.uniqueId)) {\r\n                        visitList.push(connection._ownerBlock);\r\n                        idsAddedToVisitList.add(connection._ownerBlock.uniqueId);\r\n                    }\r\n                }\r\n            }\r\n            if (block instanceof FlowGraphExecutionBlock) {\r\n                for (const signalOut of block.signalOutputs) {\r\n                    for (const connection of signalOut._connectedPoint) {\r\n                        if (!idsAddedToVisitList.has(connection._ownerBlock.uniqueId)) {\r\n                            visitList.push(connection._ownerBlock);\r\n                            idsAddedToVisitList.add(connection._ownerBlock.uniqueId);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Serializes a graph\r\n     * @param serializationObject the object to write the values in\r\n     * @param valueSerializeFunction a function to serialize complex values\r\n     */\r\n    public serialize(serializationObject: any = {}, valueSerializeFunction?: (key: string, value: any, serializationObject: any) => void) {\r\n        serializationObject.allBlocks = [];\r\n        this.visitAllBlocks((block) => {\r\n            const serializedBlock: any = {};\r\n            block.serialize(serializedBlock);\r\n            serializationObject.allBlocks.push(serializedBlock);\r\n        });\r\n        serializationObject.executionContexts = [];\r\n        for (const context of this._executionContexts) {\r\n            const serializedContext: any = {};\r\n            context.serialize(serializedContext, valueSerializeFunction);\r\n            serializationObject.executionContexts.push(serializedContext);\r\n        }\r\n    }\r\n}\r\n"]}