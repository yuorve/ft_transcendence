{"version":3,"file":"flowGraphAsyncExecutionBlock.js","sourceRoot":"","sources":["../../../../dev/core/src/FlowGraph/flowGraphAsyncExecutionBlock.ts"],"names":[],"mappings":"AAEA,OAAO,EAAE,oCAAoC,EAAE,MAAM,wCAAwC,CAAC;AAG9F;;;GAGG;AACH,MAAM,OAAgB,4BAA6B,SAAQ,oCAAoC;IAQ3F,YAAY,MAAqC,EAAE,MAAiB;QAChE,KAAK,CAAC,MAAM,CAAC,CAAC;QAHR,yBAAoB,GAAuD,EAAE,CAAC;QAIpF,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,qBAAqB,CAAC,MAAM,CAAC,CAAC;QAC/C,MAAM,EAAE,OAAO,CAAC,CAAC,SAAS,EAAE,EAAE;YAC1B,IAAI,CAAC,oBAAoB,CAAC,SAAS,CAAC,GAAG,IAAI,CAAC,qBAAqB,CAAC,SAAS,GAAG,OAAO,CAAC,CAAC;QAC3F,CAAC,CAAC,CAAC;IACP,CAAC;IAUD;;;;;;OAMG;IACI,cAAc,CAAC,QAA0B,IAAS,CAAC;IAE1D;;;OAGG;IACI,kBAAkB,CAAC,OAAyB;QAC/C,IAAI,OAAO,CAAC,qBAAqB,CAAC,IAAI,EAAE,cAAc,EAAE,KAAK,CAAC,EAAE,CAAC;YAC7D,IAAI,CAAC,mBAAmB,CAAC,OAAO,CAAC,CAAC;YAClC,IAAI,CAAC,mBAAmB,CAAC,OAAO,CAAC,CAAC;QACtC,CAAC;QAED,IAAI,CAAC,oBAAoB,CAAC,OAAO,CAAC,CAAC;QACnC,OAAO,CAAC,gBAAgB,CAAC,IAAI,CAAC,CAAC;QAC/B,IAAI,CAAC,GAAG,CAAC,eAAe,CAAC,OAAO,CAAC,CAAC;QAClC,OAAO,CAAC,qBAAqB,CAAC,IAAI,EAAE,cAAc,EAAE,IAAI,CAAC,CAAC;IAC9D,CAAC;IAEM,mBAAmB,CAAC,OAAyB;QAChD,OAAO,CAAC,wBAAwB,CAAC,IAAI,EAAE,cAAc,CAAC,CAAC;QACvD,OAAO,CAAC,mBAAmB,CAAC,IAAI,CAAC,CAAC;IACtC,CAAC;CAGJ","sourcesContent":["import type { IFlowGraphBlockConfiguration } from \"./flowGraphBlock\";\r\nimport type { FlowGraphContext } from \"./flowGraphContext\";\r\nimport { FlowGraphExecutionBlockWithOutSignal } from \"./flowGraphExecutionBlockWithOutSignal\";\r\nimport type { FlowGraphSignalConnection } from \"./flowGraphSignalConnection\";\r\n\r\n/**\r\n * An async execution block can start tasks that will be executed asynchronously.\r\n * It should also be responsible for clearing it in _cancelPendingTasks.\r\n */\r\nexport abstract class FlowGraphAsyncExecutionBlock extends FlowGraphExecutionBlockWithOutSignal {\r\n    /**\r\n     * Output connection: The signal that is triggered when the asynchronous execution of this block is done.\r\n     */\r\n    public done: FlowGraphSignalConnection;\r\n\r\n    protected _eventsSignalOutputs: { [eventName: string]: FlowGraphSignalConnection } = {};\r\n\r\n    constructor(config?: IFlowGraphBlockConfiguration, events?: string[]) {\r\n        super(config);\r\n        this.done = this._registerSignalOutput(\"done\");\r\n        events?.forEach((eventName) => {\r\n            this._eventsSignalOutputs[eventName] = this._registerSignalOutput(eventName + \"Event\");\r\n        });\r\n    }\r\n    /**\r\n     * @internal\r\n     * This function can be overridden to start any\r\n     * pending tasks this node might have, such as\r\n     * timeouts and playing animations.\r\n     * @param context\r\n     */\r\n    public abstract _preparePendingTasks(context: FlowGraphContext): void;\r\n\r\n    /**\r\n     * @internal\r\n     * This function can be overridden to execute any\r\n     * logic that should be executed on every frame\r\n     * while the async task is pending.\r\n     * @param context the context in which it is running\r\n     */\r\n    public _executeOnTick(_context: FlowGraphContext): void {}\r\n\r\n    /**\r\n     * @internal\r\n     * @param context\r\n     */\r\n    public _startPendingTasks(context: FlowGraphContext) {\r\n        if (context._getExecutionVariable(this, \"_initialized\", false)) {\r\n            this._cancelPendingTasks(context);\r\n            this._resetAfterCanceled(context);\r\n        }\r\n\r\n        this._preparePendingTasks(context);\r\n        context._addPendingBlock(this);\r\n        this.out._activateSignal(context);\r\n        context._setExecutionVariable(this, \"_initialized\", true);\r\n    }\r\n\r\n    public _resetAfterCanceled(context: FlowGraphContext) {\r\n        context._deleteExecutionVariable(this, \"_initialized\");\r\n        context._removePendingBlock(this);\r\n    }\r\n\r\n    public abstract _cancelPendingTasks(context: FlowGraphContext): void;\r\n}\r\n"]}