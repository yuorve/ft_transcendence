{"version":3,"file":"flowGraphParser.js","sourceRoot":"","sources":["../../../../dev/core/src/FlowGraph/flowGraphParser.ts"],"names":[],"mappings":"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","sourcesContent":["import type { IAssetContainer } from \"core/IAssetContainer\";\nimport { blockFactory } from \"./Blocks/flowGraphBlockFactory\";\nimport type { FlowGraphBlockNames } from \"./Blocks/flowGraphBlockNames\";\nimport type { FlowGraph, IFlowGraphParseOptions } from \"./flowGraph\";\nimport type { FlowGraphBlock, IFlowGraphBlockParseOptions } from \"./flowGraphBlock\";\nimport type { FlowGraphContext, IFlowGraphContextParseOptions } from \"./flowGraphContext\";\nimport type { FlowGraphCoordinatorParseOptions } from \"./flowGraphCoordinator\";\nimport { FlowGraphCoordinator } from \"./flowGraphCoordinator\";\nimport type { FlowGraphDataConnection } from \"./flowGraphDataConnection\";\nimport { FlowGraphEventBlock } from \"./flowGraphEventBlock\";\nimport { FlowGraphExecutionBlock } from \"./flowGraphExecutionBlock\";\nimport type { FlowGraphSignalConnection } from \"./flowGraphSignalConnection\";\nimport { defaultValueParseFunction, needsPathConverter } from \"./serialization\";\nimport type { ISerializedFlowGraph, ISerializedFlowGraphBlock, ISerializedFlowGraphContext } from \"./typeDefinitions\";\nimport type { Node } from \"core/node\";\nimport { getRichTypeByFlowGraphType, RichType } from \"./flowGraphRichTypes\";\nimport type { FlowGraphConnection } from \"./flowGraphConnection\";\n\n/**\n * Given a list of blocks, find an output data connection that has a specific unique id\n * @param blocks a list of flow graph blocks\n * @param uniqueId the unique id of a connection\n * @returns the connection that has this unique id. throws an error if none was found\n */\nexport function GetDataOutConnectionByUniqueId(blocks: FlowGraphBlock[], uniqueId: string): FlowGraphDataConnection<any> {\n    for (const block of blocks) {\n        for (const dataOut of block.dataOutputs) {\n            if (dataOut.uniqueId === uniqueId) {\n                return dataOut;\n            }\n        }\n    }\n    throw new Error(\"Could not find data out connection with unique id \" + uniqueId);\n}\n\n/**\n * Given a list of blocks, find an input signal connection that has a specific unique id\n * @param blocks a list of flow graph blocks\n * @param uniqueId the unique id of a connection\n * @returns the connection that has this unique id. throws an error if none was found\n */\nexport function GetSignalInConnectionByUniqueId(blocks: FlowGraphBlock[], uniqueId: string): FlowGraphSignalConnection {\n    for (const block of blocks) {\n        if (block instanceof FlowGraphExecutionBlock) {\n            for (const signalIn of block.signalInputs) {\n                if (signalIn.uniqueId === uniqueId) {\n                    return signalIn;\n                }\n            }\n        }\n    }\n    throw new Error(\"Could not find signal in connection with unique id \" + uniqueId);\n}\n\n/**\n * Parses a serialized coordinator.\n * @param serializedObject the object to parse\n * @param options the options to use when parsing\n * @returns the parsed coordinator\n */\nexport async function ParseCoordinatorAsync(serializedObject: any, options: FlowGraphCoordinatorParseOptions) {\n    const valueParseFunction = options.valueParseFunction ?? defaultValueParseFunction;\n    const coordinator = new FlowGraphCoordinator({ scene: options.scene });\n\n    if (serializedObject.dispatchEventsSynchronously) {\n        coordinator.dispatchEventsSynchronously = serializedObject.dispatchEventsSynchronously;\n    }\n\n    await options.scene.whenReadyAsync();\n    // if custom default values are defined, set them in the global context\n    if (serializedObject._defaultValues) {\n        for (const key in serializedObject._defaultValues) {\n            // key is the FlowGraphType, value is the default value\n            const value = serializedObject._defaultValues[key];\n            getRichTypeByFlowGraphType(key).defaultValue = value;\n        }\n    }\n    // async-parse the flow graphs. This can be done in parallel\n    await Promise.all(\n        serializedObject._flowGraphs?.map((serializedGraph: any) => ParseFlowGraphAsync(serializedGraph, { coordinator, valueParseFunction, pathConverter: options.pathConverter }))\n    );\n    return coordinator;\n}\n\n/**\n * Parses a graph from a given serialization object\n * @param serializationObject the object where the values are written\n * @param options options for parsing the graph\n * @returns the parsed graph\n */\nexport async function ParseFlowGraphAsync(serializationObject: ISerializedFlowGraph, options: IFlowGraphParseOptions): Promise<FlowGraph> {\n    // get all classes types needed for the blocks using the block factory\n    const resolvedClasses = await Promise.all(\n        serializationObject.allBlocks.map(async (serializedBlock) => {\n            const classFactory = blockFactory(serializedBlock.className as FlowGraphBlockNames);\n            return classFactory();\n        })\n    );\n    // async will be used when we start using the block async factory\n    return ParseFlowGraph(serializationObject, options, resolvedClasses);\n}\n\n/**\n * Parses a graph from a given serialization object\n * @param serializationObject the object where the values are written\n * @param options options for parsing the graph\n * @param resolvedClasses the resolved classes for the blocks\n * @returns the parsed graph\n */\nexport function ParseFlowGraph(serializationObject: ISerializedFlowGraph, options: IFlowGraphParseOptions, resolvedClasses: (typeof FlowGraphBlock)[]) {\n    const graph = options.coordinator.createGraph();\n    const blocks: FlowGraphBlock[] = [];\n    const valueParseFunction = options.valueParseFunction ?? defaultValueParseFunction;\n    // Parse all blocks\n    // for (const serializedBlock of serializationObject.allBlocks) {\n    for (let i = 0; i < serializationObject.allBlocks.length; i++) {\n        const serializedBlock = serializationObject.allBlocks[i];\n        const block = ParseFlowGraphBlockWithClassType(\n            serializedBlock,\n            { scene: options.coordinator.config.scene, pathConverter: options.pathConverter, assetsContainer: options.coordinator.config.scene, valueParseFunction },\n            resolvedClasses[i]\n        );\n        blocks.push(block);\n        if (block instanceof FlowGraphEventBlock) {\n            graph.addEventBlock(block);\n        }\n    }\n    // After parsing all blocks, connect them\n    for (const block of blocks) {\n        for (const dataIn of block.dataInputs) {\n            for (const serializedConnection of dataIn.connectedPointIds) {\n                const connection = GetDataOutConnectionByUniqueId(blocks, serializedConnection);\n                dataIn.connectTo(connection);\n            }\n        }\n        if (block instanceof FlowGraphExecutionBlock) {\n            for (const signalOut of block.signalOutputs) {\n                for (const serializedConnection of signalOut.connectedPointIds) {\n                    const connection = GetSignalInConnectionByUniqueId(blocks, serializedConnection);\n                    signalOut.connectTo(connection);\n                }\n            }\n        }\n    }\n    for (const serializedContext of serializationObject.executionContexts) {\n        ParseFlowGraphContext(serializedContext, { graph, valueParseFunction }, serializationObject.rightHanded);\n    }\n    return graph;\n}\n\n/**\n * Parses a context\n * @param serializationObject the object containing the context serialization values\n * @param options the options for parsing the context\n * @param rightHanded whether the serialized data is right handed\n * @returns\n */\nexport function ParseFlowGraphContext(serializationObject: ISerializedFlowGraphContext, options: IFlowGraphContextParseOptions, rightHanded?: boolean): FlowGraphContext {\n    const result = options.graph.createContext();\n    if (serializationObject.enableLogging) {\n        result.enableLogging = true;\n    }\n    result.treatDataAsRightHanded = rightHanded || false;\n    const valueParseFunction = options.valueParseFunction ?? defaultValueParseFunction;\n    result.uniqueId = serializationObject.uniqueId;\n    const scene = result.getScene();\n    // check if assets context is available\n    if (serializationObject._assetsContext) {\n        const ac = serializationObject._assetsContext;\n        const assetsContext: IAssetContainer = {\n            meshes: ac.meshes?.map((m: string) => scene.getMeshById(m)),\n            lights: ac.lights?.map((l: string) => scene.getLightByName(l)),\n            cameras: ac.cameras?.map((c: string) => scene.getCameraByName(c)),\n            materials: ac.materials?.map((m: string) => scene.getMaterialById(m)),\n            textures: ac.textures?.map((t: string) => scene.getTextureByName(t)),\n            animations: ac.animations?.map((a: string) => scene.animations.find((anim) => anim.name === a)),\n            skeletons: ac.skeletons?.map((s: string) => scene.getSkeletonByName(s)),\n            particleSystems: ac.particleSystems?.map((ps: string) => scene.getParticleSystemById(ps)),\n            animationGroups: ac.animationGroups?.map((ag: string) => scene.getAnimationGroupByName(ag)),\n            transformNodes: ac.transformNodes?.map((tn: string) => scene.getTransformNodeById(tn)),\n            rootNodes: [],\n            multiMaterials: [],\n            morphTargetManagers: [],\n            geometries: [],\n            actionManagers: [],\n            environmentTexture: null,\n            postProcesses: [],\n            sounds: null,\n            effectLayers: [],\n            layers: [],\n            reflectionProbes: [],\n            lensFlareSystems: [],\n            proceduralTextures: [],\n            getNodes: function (): Array<Node> {\n                throw new Error(\"Function not implemented.\");\n            },\n        };\n        result.assetsContext = assetsContext;\n    }\n    for (const key in serializationObject._userVariables) {\n        const value = valueParseFunction(key, serializationObject._userVariables, result.assetsContext, scene);\n        result.userVariables[key] = value;\n    }\n    for (const key in serializationObject._connectionValues) {\n        const value = valueParseFunction(key, serializationObject._connectionValues, result.assetsContext, scene);\n        result._setConnectionValueByKey(key, value);\n    }\n\n    return result;\n}\n\n/**\n * Parses a block from a serialization object\n * This function is async due to the factory method that is used to create the block's class. If you load the class externally use ParseBlockWithClassType\n * @param serializationObject the object to parse from\n * @param parseOptions options for parsing the block\n * @returns the parsed block\n */\nexport async function ParseBlockAsync(serializationObject: ISerializedFlowGraphBlock, parseOptions: IFlowGraphBlockParseOptions): Promise<FlowGraphBlock> {\n    const classFactory = blockFactory(serializationObject.className as FlowGraphBlockNames);\n    const classType = await classFactory();\n    return ParseFlowGraphBlockWithClassType(serializationObject, parseOptions, classType);\n}\n\n/**\n * Parses a block from a serialization object\n * @param serializationObject the object to parse from\n * @param parseOptions options for parsing the block\n * @param classType the class type of the block. This is used when the class is not loaded asynchronously\n * @returns the parsed block\n */\nexport function ParseFlowGraphBlockWithClassType(\n    serializationObject: ISerializedFlowGraphBlock,\n    parseOptions: IFlowGraphBlockParseOptions,\n    classType: typeof FlowGraphBlock\n): FlowGraphBlock {\n    const parsedConfig: any = {};\n    const valueParseFunction = parseOptions.valueParseFunction ?? defaultValueParseFunction;\n    if (serializationObject.config) {\n        for (const key in serializationObject.config) {\n            parsedConfig[key] = valueParseFunction(key, serializationObject.config, parseOptions.assetsContainer || parseOptions.scene, parseOptions.scene);\n        }\n    }\n    if (needsPathConverter(serializationObject.className)) {\n        if (!parseOptions.pathConverter) {\n            throw new Error(\"Path converter is required for this block\");\n        }\n        parsedConfig.pathConverter = parseOptions.pathConverter;\n    }\n    const obj = new classType(parsedConfig);\n    obj.uniqueId = serializationObject.uniqueId;\n    for (let i = 0; i < serializationObject.dataInputs.length; i++) {\n        const dataInput = obj.getDataInput(serializationObject.dataInputs[i].name);\n        if (dataInput) {\n            dataInput.deserialize(serializationObject.dataInputs[i]);\n        } else {\n            throw new Error(\"Could not find data input with name \" + serializationObject.dataInputs[i].name + \" in block \" + serializationObject.className);\n        }\n    }\n    for (let i = 0; i < serializationObject.dataOutputs.length; i++) {\n        const dataOutput = obj.getDataOutput(serializationObject.dataOutputs[i].name);\n        if (dataOutput) {\n            dataOutput.deserialize(serializationObject.dataOutputs[i]);\n        } else {\n            throw new Error(\"Could not find data output with name \" + serializationObject.dataOutputs[i].name + \" in block \" + serializationObject.className);\n        }\n    }\n    obj.metadata = serializationObject.metadata;\n    obj.deserialize && obj.deserialize(serializationObject);\n    return obj;\n}\n\n/**\n * Parses a connection from an object\n * @param serializationObject the object to parse from.\n * @param ownerBlock the block that owns the connection.\n * @param classType the class type of the connection.\n * @returns the parsed connection.\n */\nexport function ParseGraphConnectionWithClassType<BlockT extends FlowGraphBlock>(serializationObject: any = {}, ownerBlock: BlockT, classType: typeof FlowGraphConnection) {\n    const connection = new classType(serializationObject.name, serializationObject._connectionType, ownerBlock);\n    connection.deserialize(serializationObject);\n    return connection;\n}\n\n/**\n * Parses a data connection from a serialized object.\n * @param serializationObject the object to parse from\n * @param ownerBlock the block that owns the connection\n * @param classType the class type of the data connection\n * @returns the parsed connection\n */\nexport function ParseGraphDataConnection(serializationObject: any, ownerBlock: FlowGraphBlock, classType: typeof FlowGraphDataConnection): FlowGraphDataConnection<any> {\n    const richType = ParseRichType(serializationObject.richType);\n    const defaultValue = serializationObject.defaultValue;\n    const connection = new classType(serializationObject.name, serializationObject._connectionType, ownerBlock, richType, defaultValue, !!serializationObject._optional);\n    connection.deserialize(serializationObject);\n    return connection;\n}\n\n/**\n * Parses a rich type from a serialization object.\n * @param serializationObject a serialization object\n * @returns the parsed rich type\n */\nfunction ParseRichType(serializationObject: any): RichType<any> {\n    return new RichType(serializationObject.typeName, serializationObject.defaultValue);\n}\n"]}