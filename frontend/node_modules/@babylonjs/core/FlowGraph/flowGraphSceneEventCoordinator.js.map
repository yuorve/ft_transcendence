{"version":3,"file":"flowGraphSceneEventCoordinator.js","sourceRoot":"","sources":["../../../../dev/core/src/FlowGraph/flowGraphSceneEventCoordinator.ts"],"names":[],"mappings":"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","sourcesContent":["import type { PointerInfo } from \"core/Events/pointerEvents\";\nimport { PointerEventTypes } from \"core/Events/pointerEvents\";\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\nimport type { Observer } from \"core/Misc/observable\";\nimport { Observable } from \"core/Misc/observable\";\nimport type { Scene } from \"core/scene\";\nimport type { Nullable } from \"core/types\";\nimport { FlowGraphEventType } from \"./flowGraphEventType\";\n\n/**\n * the interface of the object the scene event coordinator will trigger.\n */\nexport interface IFlowGraphEventTrigger {\n    /**\n     * The type of the event\n     */\n    type: FlowGraphEventType;\n    /**\n     * The data of the event\n     */\n    payload?: any;\n}\n\n/**\n * This class is responsible for coordinating the events that are triggered in the scene.\n * It registers all observers needed to track certain events and triggers the blocks that are listening to them.\n * Abstracting the events from the class will allow us to easily change the events that are being listened to, and trigger them in any order.\n */\nexport class FlowGraphSceneEventCoordinator {\n    /**\n     * @internal\n     */\n    public readonly _scene: Scene;\n\n    /**\n     * register to this observable to get flow graph event notifications.\n     */\n    public onEventTriggeredObservable: Observable<IFlowGraphEventTrigger> = new Observable();\n\n    /**\n     * Was scene-ready already triggered?\n     */\n    public sceneReadyTriggered: boolean = false;\n\n    private _sceneDisposeObserver: Nullable<Observer<Scene>>;\n    private _sceneReadyObserver: Nullable<Observer<Scene>>;\n    private _sceneOnBeforeRenderObserver: Nullable<Observer<Scene>>;\n    private _meshPickedObserver: Nullable<Observer<PointerInfo>>;\n    private _meshUnderPointerObserver: Nullable<Observer<{ mesh: Nullable<AbstractMesh>; pointerId: number }>>;\n    private _pointerUnderMeshState: { [pointerId: number]: Nullable<AbstractMesh> } = {};\n\n    private _startingTime: number = 0;\n\n    constructor(scene: Scene) {\n        this._scene = scene;\n        this._initialize();\n    }\n\n    private _initialize() {\n        this._sceneReadyObserver = this._scene.onReadyObservable.add(() => {\n            if (!this.sceneReadyTriggered) {\n                this.onEventTriggeredObservable.notifyObservers({ type: FlowGraphEventType.SceneReady });\n                this.sceneReadyTriggered = true;\n            }\n        });\n\n        this._sceneDisposeObserver = this._scene.onDisposeObservable.add(() => {\n            this.onEventTriggeredObservable.notifyObservers({ type: FlowGraphEventType.SceneDispose });\n        });\n        this._sceneOnBeforeRenderObserver = this._scene.onBeforeRenderObservable.add(() => {\n            const deltaTime = this._scene.getEngine().getDeltaTime() / 1000; // set in seconds\n            this.onEventTriggeredObservable.notifyObservers({\n                type: FlowGraphEventType.SceneBeforeRender,\n                payload: {\n                    timeSinceStart: this._startingTime,\n                    deltaTime,\n                },\n            });\n            this._startingTime += deltaTime;\n        });\n\n        this._meshPickedObserver = this._scene.onPointerObservable.add((pointerInfo) => {\n            this.onEventTriggeredObservable.notifyObservers({ type: FlowGraphEventType.MeshPick, payload: pointerInfo });\n        }, PointerEventTypes.POINTERPICK); // should it be pointerdown?\n\n        this._meshUnderPointerObserver = this._scene.onMeshUnderPointerUpdatedObservable.add((data) => {\n            // check if the data has changed. Check the state of the last change and see if it is a mesh or null.\n            // if it is a mesh and the previous state was null, trigger over event. If it is null and the previous state was a mesh, trigger out event.\n            // if it is a mesh and the previous state was a mesh, trigger out from the old mesh and over the new mesh\n            // if it is null and the previous state was null, do nothing.\n            const pointerId = data.pointerId;\n            const mesh = data.mesh;\n            const previousState = this._pointerUnderMeshState[pointerId];\n            if (!previousState && mesh) {\n                this.onEventTriggeredObservable.notifyObservers({ type: FlowGraphEventType.PointerOver, payload: { pointerId, mesh } });\n            } else if (previousState && !mesh) {\n                this.onEventTriggeredObservable.notifyObservers({ type: FlowGraphEventType.PointerOut, payload: { pointerId, mesh: previousState } });\n            } else if (previousState && mesh && previousState !== mesh) {\n                this.onEventTriggeredObservable.notifyObservers({ type: FlowGraphEventType.PointerOut, payload: { pointerId, mesh: previousState, over: mesh } });\n                this.onEventTriggeredObservable.notifyObservers({ type: FlowGraphEventType.PointerOver, payload: { pointerId, mesh, out: previousState } });\n            }\n            this._pointerUnderMeshState[pointerId] = mesh;\n        }, PointerEventTypes.POINTERMOVE);\n    }\n\n    public dispose() {\n        this._sceneDisposeObserver?.remove();\n        this._sceneReadyObserver?.remove();\n        this._sceneOnBeforeRenderObserver?.remove();\n        this._meshPickedObserver?.remove();\n        this._meshUnderPointerObserver?.remove();\n        this.onEventTriggeredObservable.clear();\n    }\n}\n"]}