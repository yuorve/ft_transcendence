{"version":3,"file":"serialization.js","sourceRoot":"","sources":["../../../../dev/core/src/FlowGraph/serialization.ts"],"names":[],"mappings":"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","sourcesContent":["import type { IAssetContainer } from \"core/IAssetContainer\";\r\nimport { Color3, Color4 } from \"../Maths/math.color\";\r\nimport { Matrix, Quaternion, Vector2, Vector3, Vector4 } from \"../Maths/math.vector\";\r\nimport type { Scene } from \"../scene\";\r\nimport { FlowGraphBlockNames } from \"./Blocks/flowGraphBlockNames\";\r\nimport { FlowGraphInteger } from \"./CustomTypes/flowGraphInteger\";\r\nimport { FlowGraphTypes, getRichTypeByFlowGraphType } from \"./flowGraphRichTypes\";\r\nimport type { TransformNode } from \"core/Meshes/transformNode\";\r\nimport { FlowGraphMatrix2D, FlowGraphMatrix3D } from \"./CustomTypes/flowGraphMatrix\";\r\n\r\nfunction isMeshClassName(className: string) {\r\n    return (\r\n        className === \"Mesh\" ||\r\n        className === \"AbstractMesh\" ||\r\n        className === \"GroundMesh\" ||\r\n        className === \"InstanceMesh\" ||\r\n        className === \"LinesMesh\" ||\r\n        className === \"GoldbergMesh\" ||\r\n        className === \"GreasedLineMesh\" ||\r\n        className === \"TrailMesh\"\r\n    );\r\n}\r\n\r\nfunction isVectorClassName(className: string) {\r\n    return (\r\n        className === FlowGraphTypes.Vector2 ||\r\n        className === FlowGraphTypes.Vector3 ||\r\n        className === FlowGraphTypes.Vector4 ||\r\n        className === FlowGraphTypes.Quaternion ||\r\n        className === FlowGraphTypes.Color3 ||\r\n        className === FlowGraphTypes.Color4\r\n    );\r\n}\r\n\r\nfunction isMatrixClassName(className: string) {\r\n    return className === FlowGraphTypes.Matrix || className === FlowGraphTypes.Matrix2D || className === FlowGraphTypes.Matrix3D;\r\n}\r\n\r\nfunction isAnimationGroupClassName(className: string) {\r\n    return className === \"AnimationGroup\";\r\n}\r\n\r\nfunction parseVector(className: string, value: Array<number>, flipHandedness = false) {\r\n    if (className === FlowGraphTypes.Vector2) {\r\n        return Vector2.FromArray(value);\r\n    } else if (className === FlowGraphTypes.Vector3) {\r\n        if (flipHandedness) {\r\n            value[2] *= -1;\r\n        }\r\n        return Vector3.FromArray(value);\r\n    } else if (className === FlowGraphTypes.Vector4) {\r\n        return Vector4.FromArray(value);\r\n    } else if (className === FlowGraphTypes.Quaternion) {\r\n        if (flipHandedness) {\r\n            value[2] *= -1;\r\n            value[3] *= -1;\r\n        }\r\n        return Quaternion.FromArray(value);\r\n    } else if (className === FlowGraphTypes.Color3) {\r\n        return new Color3(value[0], value[1], value[2]);\r\n    } else if (className === FlowGraphTypes.Color4) {\r\n        return new Color4(value[0], value[1], value[2], value[3]);\r\n    } else {\r\n        throw new Error(`Unknown vector class name ${className}`);\r\n    }\r\n}\r\n\r\n/**\r\n * The default function that serializes values in a context object to a serialization object\r\n * @param key the key where the value should be stored in the serialization object\r\n * @param value the value to store\r\n * @param serializationObject the object where the value will be stored\r\n */\r\nexport function defaultValueSerializationFunction(key: string, value: any, serializationObject: any) {\r\n    const className = value?.getClassName?.() ?? \"\";\r\n    if (isVectorClassName(className) || isMatrixClassName(className)) {\r\n        serializationObject[key] = {\r\n            value: value.asArray(),\r\n            className,\r\n        };\r\n    } else if (className === FlowGraphTypes.Integer) {\r\n        serializationObject[key] = {\r\n            value: value.value,\r\n            className,\r\n        };\r\n    } else {\r\n        if (className && (value.id || value.name)) {\r\n            serializationObject[key] = {\r\n                id: value.id,\r\n                name: value.name,\r\n                className,\r\n            };\r\n        } else {\r\n            // only if it is not an object\r\n            if (typeof value !== \"object\") {\r\n                serializationObject[key] = value;\r\n            } else {\r\n                throw new Error(`Could not serialize value ${value}`);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * The default function that parses values stored in a serialization object\r\n * @param key the key to the value that will be parsed\r\n * @param serializationObject the object that will be parsed\r\n * @param assetsContainer the assets container that will be used to find the objects\r\n * @param scene\r\n * @returns\r\n */\r\nexport function defaultValueParseFunction(key: string, serializationObject: any, assetsContainer: IAssetContainer, scene: Scene) {\r\n    const intermediateValue = serializationObject[key];\r\n    let finalValue;\r\n    const className = intermediateValue?.type ?? intermediateValue?.className;\r\n    if (isMeshClassName(className)) {\r\n        let nodes: TransformNode[] = scene.meshes.filter((m) => (intermediateValue.id ? m.id === intermediateValue.id : m.name === intermediateValue.name));\r\n        if (nodes.length === 0) {\r\n            nodes = scene.transformNodes.filter((m) => (intermediateValue.id ? m.id === intermediateValue.id : m.name === intermediateValue.name));\r\n        }\r\n        finalValue = intermediateValue.uniqueId ? nodes.find((m) => m.uniqueId === intermediateValue.uniqueId) : nodes[0];\r\n    } else if (isVectorClassName(className)) {\r\n        finalValue = parseVector(className, intermediateValue.value);\r\n    } else if (isAnimationGroupClassName(className)) {\r\n        // do not use the scene.getAnimationGroupByName because it is possible that two AGs will have the same name\r\n        const ags = scene.animationGroups.filter((ag) => ag.name === intermediateValue.name);\r\n        // uniqueId changes on each load. this is used for the glTF loader, that uses serialization after the scene was loaded.\r\n        finalValue = ags.length === 1 ? ags[0] : ags.find((ag) => ag.uniqueId === intermediateValue.uniqueId);\r\n    } else if (className === FlowGraphTypes.Matrix) {\r\n        finalValue = Matrix.FromArray(intermediateValue.value);\r\n    } else if (className === FlowGraphTypes.Matrix2D) {\r\n        finalValue = new FlowGraphMatrix2D(intermediateValue.value);\r\n    } else if (className === FlowGraphTypes.Matrix3D) {\r\n        finalValue = new FlowGraphMatrix3D(intermediateValue.value);\r\n    } else if (className === FlowGraphTypes.Integer) {\r\n        finalValue = FlowGraphInteger.FromValue(intermediateValue.value);\r\n    } else if (className === FlowGraphTypes.Number || className === FlowGraphTypes.String || className === FlowGraphTypes.Boolean) {\r\n        finalValue = intermediateValue.value[0];\r\n    } else if (intermediateValue && intermediateValue.value !== undefined) {\r\n        finalValue = intermediateValue.value;\r\n    } else {\r\n        if (Array.isArray(intermediateValue)) {\r\n            // configuration data of an event\r\n            finalValue = intermediateValue.reduce((acc, val) => {\r\n                if (!val.eventData) {\r\n                    return acc;\r\n                }\r\n                acc[val.id] = {\r\n                    type: getRichTypeByFlowGraphType(val.type),\r\n                };\r\n                if (typeof val.value !== \"undefined\") {\r\n                    acc[val.id].value = defaultValueParseFunction(\"value\", val, assetsContainer, scene);\r\n                }\r\n                return acc;\r\n            }, {});\r\n        } else {\r\n            finalValue = intermediateValue;\r\n        }\r\n    }\r\n    return finalValue;\r\n}\r\n\r\n/**\r\n * Given a name of a flow graph block class, return if this\r\n * class needs to be created with a path converter. Used in\r\n * parsing.\r\n * @param className the name of the flow graph block class\r\n * @returns a boolean indicating if the class needs a path converter\r\n */\r\nexport function needsPathConverter(className: string) {\r\n    // I am not using the ClassName property here because it was causing a circular dependency\r\n    // that jest didn't like!\r\n    return className === FlowGraphBlockNames.JsonPointerParser;\r\n}\r\n"]}