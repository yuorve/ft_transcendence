{"version":3,"file":"typeDefinitions.js","sourceRoot":"","sources":["../../../../dev/core/src/FlowGraph/typeDefinitions.ts"],"names":[],"mappings":"","sourcesContent":["import type { IAnimatable } from \"core/Animations/animatable.interface\";\r\nimport type { Animation } from \"core/Animations/animation\";\r\nimport type { FlowGraphConnectionType } from \"./flowGraphConnection\";\r\n\r\n/**\r\n * Interpolation generator\r\n */\r\nexport interface IInterpolationPropertyInfo {\r\n    /**\r\n     * type of the interpolation\r\n     */\r\n    type: number;\r\n    /**\r\n     * The name of the property\r\n     */\r\n    name: string;\r\n    /** @internal */\r\n    getValue: (target: any, source: Float32Array, offset: number, scale: number) => any;\r\n    /** @internal */\r\n    getStride: (target: any) => number;\r\n    /**\r\n     * @internal\r\n     */\r\n    buildAnimations(target: any, name: string, fps: number, keys: any[]): { babylonAnimatable: IAnimatable; babylonAnimation: Animation }[];\r\n}\r\n\r\n/**\r\n * An accessor that allows modifying properties on some other object.\r\n */\r\nexport interface IObjectAccessor<GLTFTargetType = any, BabylonTargetType = any, BabylonValueType = any> {\r\n    /**\r\n     * The number of components that are changed in the property when setting this value.\r\n     * This will usually be 1. But, for example, Babylon has both orthoLeft and orthoRight (two components) properties that are changed when setting xmag (single value in glTF).\r\n     * Defaults to 1 if not provided!\r\n     */\r\n    componentsCount?: number;\r\n    /**\r\n     * The (babylon) type of the property.\r\n     */\r\n    type: string;\r\n    /**\r\n     * Get the value of the property.\r\n     */\r\n    get: (target: GLTFTargetType, index?: number, payload?: any) => BabylonValueType | undefined;\r\n    /**\r\n     * Get the target of the property.\r\n     */\r\n    getTarget: (target: GLTFTargetType, index?: number, payload?: any) => BabylonTargetType | undefined;\r\n    /**\r\n     * is the property readonly?\r\n     */\r\n    isReadOnly?: boolean;\r\n    /**\r\n     * @deprecated Use get instead\r\n     */\r\n    getPropertyName?: Array<(target: GLTFTargetType) => string>;\r\n    /**\r\n     * Set a new value to the property.\r\n     * @param newValue the new value to set\r\n     * @param target the target object\r\n     * @param index the index of the target object in the array (optional)\r\n     */\r\n    set?: (newValue: BabylonValueType, target: GLTFTargetType, index?: number, payload?: any) => void;\r\n    /**\r\n     * Interpolation/animation information for the property.\r\n     * This is an array that can be used to animate the value over time.\r\n     */\r\n    interpolation?: IInterpolationPropertyInfo[];\r\n}\r\n\r\n/**\r\n * A Serialized Flow Graph Context\r\n */\r\nexport interface ISerializedFlowGraphContext {\r\n    /**\r\n     * The unique id of the context\r\n     */\r\n    uniqueId: string;\r\n    /**\r\n     * User variables\r\n     */\r\n    _userVariables: { [key: string]: any };\r\n    /**\r\n     * Values of the connection points\r\n     */\r\n    _connectionValues: { [key: string]: any };\r\n\r\n    /**\r\n     * Assets context, if not the scene\r\n     */\r\n    _assetsContext?: { [key: string]: any };\r\n\r\n    /**\r\n     * Should logging be enabled?\r\n     */\r\n    enableLogging?: boolean;\r\n}\r\n\r\n/**\r\n * A Serialized Flow Graph Connection\r\n */\r\nexport interface ISerializedFlowGraphConnection {\r\n    /**\r\n     * The unique id of the connection\r\n     */\r\n    uniqueId: string;\r\n    /**\r\n     * The name of the connection\r\n     */\r\n    name: string;\r\n    /**\r\n     * The type of the connection\r\n     */\r\n    _connectionType: FlowGraphConnectionType;\r\n    /**\r\n     * The id of the connection that this is connected to\r\n     */\r\n    connectedPointIds: string[];\r\n}\r\n\r\n/**\r\n * A Serialized Flow Graph Block\r\n */\r\nexport interface ISerializedFlowGraphBlock {\r\n    /**\r\n     * The class name of the block\r\n     */\r\n    className: string;\r\n    /**\r\n     * The glTF type of the block\r\n     */\r\n    type: string;\r\n    /**\r\n     * Configuration parameters for the block\r\n     */\r\n    config: any;\r\n    /**\r\n     * The unique id of the block\r\n     */\r\n    uniqueId: string;\r\n    /**\r\n     * Input connection data\r\n     */\r\n    dataInputs: ISerializedFlowGraphConnection[];\r\n    /**\r\n     * Output connection data\r\n     */\r\n    dataOutputs: ISerializedFlowGraphConnection[];\r\n    /**\r\n     * Metadata for the block\r\n     */\r\n    metadata: any;\r\n    /**\r\n     * Input connection signal\r\n     */\r\n    signalInputs: ISerializedFlowGraphConnection[];\r\n    /**\r\n     * Output connection signal\r\n     */\r\n    signalOutputs: ISerializedFlowGraphConnection[];\r\n}\r\n\r\n/**\r\n * A Serialized Flow Graph\r\n */\r\nexport interface ISerializedFlowGraph {\r\n    /**\r\n     * Contexts belonging to the flow graph\r\n     */\r\n    executionContexts: ISerializedFlowGraphContext[];\r\n    /**\r\n     * Blocks belonging to the flow graph\r\n     */\r\n    allBlocks: ISerializedFlowGraphBlock[];\r\n\r\n    /**\r\n     * Is the flow graph in RHS mode?\r\n     */\r\n    rightHanded?: boolean;\r\n}\r\n"]}