{"version":3,"file":"exrLoader.compression.js","sourceRoot":"","sources":["../../../../../../../dev/core/src/Materials/Textures/Loaders/EXR/exrLoader.compression.ts"],"names":[],"mappings":"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","sourcesContent":["import { ApplyLut, HufUncompress, ReverseLutFromBitmap, Wav2Decode } from \"./exrLoader.compression.huf\";\r\nimport { DecodeRunLength } from \"./exrLoader.compression.rle\";\r\nimport { InterleaveScalar, ParseUint16, ParseUint32, ParseUint8, Predictor } from \"./exrLoader.core\";\r\nimport { BITMAP_SIZE, INT16_SIZE, USHORT_RANGE, type IEXRDecoder } from \"./exrLoader.interfaces\";\r\n\r\n/**\r\n * Inspired by https://github.com/sciecode/three.js/blob/dev/examples/jsm/loaders/EXRLoader.js\r\n * Referred to the original Industrial Light & Magic OpenEXR implementation and the TinyEXR / Syoyo Fujita\r\n * implementation.\r\n */\r\n\r\n// /*\r\n// Copyright (c) 2014 - 2017, Syoyo Fujita\r\n// All rights reserved.\r\n\r\n// Redistribution and use in source and binary forms, with or without\r\n// modification, are permitted provided that the following conditions are met:\r\n//     * Redistributions of source code must retain the above copyright\r\n//       notice, this list of conditions and the following disclaimer.\r\n//     * Redistributions in binary form must reproduce the above copyright\r\n//       notice, this list of conditions and the following disclaimer in the\r\n//       documentation and/or other materials provided with the distribution.\r\n//     * Neither the name of the Syoyo Fujita nor the\r\n//       names of its contributors may be used to endorse or promote products\r\n//       derived from this software without specific prior written permission.\r\n\r\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\r\n// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n// DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\r\n// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\r\n// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\r\n// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\r\n// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\r\n// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n// */\r\n\r\n// // TinyEXR contains some OpenEXR code, which is licensed under ------------\r\n\r\n// ///////////////////////////////////////////////////////////////////////////\r\n// //\r\n// // Copyright (c) 2002, Industrial Light & Magic, a division of Lucas\r\n// // Digital Ltd. LLC\r\n// //\r\n// // All rights reserved.\r\n// //\r\n// // Redistribution and use in source and binary forms, with or without\r\n// // modification, are permitted provided that the following conditions are\r\n// // met:\r\n// // *       Redistributions of source code must retain the above copyright\r\n// // notice, this list of conditions and the following disclaimer.\r\n// // *       Redistributions in binary form must reproduce the above\r\n// // copyright notice, this list of conditions and the following disclaimer\r\n// // in the documentation and/or other materials provided with the\r\n// // distribution.\r\n// // *       Neither the name of Industrial Light & Magic nor the names of\r\n// // its contributors may be used to endorse or promote products derived\r\n// // from this software without specific prior written permission.\r\n// //\r\n// // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\r\n// // \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\r\n// // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\r\n// // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\r\n// // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n// // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\r\n// // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\r\n// // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\r\n// // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n// // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\r\n// // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n// //\r\n// ///////////////////////////////////////////////////////////////////////////\r\n\r\n// // End of OpenEXR license -------------------------------------------------\r\n\r\n// FFlate access\r\ndeclare const fflate: any;\r\n\r\n/**\r\n * No compression\r\n * @param decoder defines the decoder to use\r\n * @returns a decompressed data view\r\n */\r\nexport function UncompressRAW(decoder: IEXRDecoder): DataView {\r\n    return new DataView(decoder.array.buffer, decoder.offset.value, decoder.size);\r\n}\r\n\r\n/**\r\n * RLE compression\r\n * @param decoder defines the decoder to use\r\n * @returns a decompressed data view\r\n */\r\nexport function UncompressRLE(decoder: IEXRDecoder): DataView {\r\n    const compressed = decoder.viewer.buffer.slice(decoder.offset.value, decoder.offset.value + decoder.size);\r\n\r\n    const rawBuffer = new Uint8Array(DecodeRunLength(compressed));\r\n    const tmpBuffer = new Uint8Array(rawBuffer.length);\r\n\r\n    Predictor(rawBuffer);\r\n\r\n    InterleaveScalar(rawBuffer, tmpBuffer);\r\n\r\n    return new DataView(tmpBuffer.buffer);\r\n}\r\n\r\n/**\r\n * Zip compression\r\n * @param decoder defines the decoder to use\r\n * @returns a decompressed data view\r\n */\r\nexport function UncompressZIP(decoder: IEXRDecoder): DataView {\r\n    const compressed = decoder.array.slice(decoder.offset.value, decoder.offset.value + decoder.size);\r\n\r\n    const rawBuffer = fflate.unzlibSync(compressed);\r\n    const tmpBuffer = new Uint8Array(rawBuffer.length);\r\n\r\n    Predictor(rawBuffer);\r\n\r\n    InterleaveScalar(rawBuffer, tmpBuffer);\r\n\r\n    return new DataView(tmpBuffer.buffer);\r\n}\r\n\r\n/**\r\n * PXR compression\r\n * @param decoder defines the decoder to use\r\n * @returns a decompressed data view\r\n */\r\nexport function UncompressPXR(decoder: IEXRDecoder): DataView {\r\n    const compressed = decoder.array.slice(decoder.offset.value, decoder.offset.value + decoder.size);\r\n\r\n    const rawBuffer = fflate.unzlibSync(compressed);\r\n\r\n    const sz = decoder.lines * decoder.channels * decoder.width;\r\n    const tmpBuffer = decoder.type == 1 ? new Uint16Array(sz) : new Uint32Array(sz);\r\n\r\n    let tmpBufferEnd = 0;\r\n    let writePtr = 0;\r\n    const ptr = new Array(4);\r\n\r\n    for (let y = 0; y < decoder.lines; y++) {\r\n        for (let c = 0; c < decoder.channels; c++) {\r\n            let pixel = 0;\r\n\r\n            switch (decoder.type) {\r\n                case 1:\r\n                    ptr[0] = tmpBufferEnd;\r\n                    ptr[1] = ptr[0] + decoder.width;\r\n                    tmpBufferEnd = ptr[1] + decoder.width;\r\n\r\n                    for (let j = 0; j < decoder.width; ++j) {\r\n                        const diff = (rawBuffer[ptr[0]++] << 8) | rawBuffer[ptr[1]++];\r\n\r\n                        pixel += diff;\r\n\r\n                        tmpBuffer[writePtr] = pixel;\r\n                        writePtr++;\r\n                    }\r\n\r\n                    break;\r\n\r\n                case 2:\r\n                    ptr[0] = tmpBufferEnd;\r\n                    ptr[1] = ptr[0] + decoder.width;\r\n                    ptr[2] = ptr[1] + decoder.width;\r\n                    tmpBufferEnd = ptr[2] + decoder.width;\r\n\r\n                    for (let j = 0; j < decoder.width; ++j) {\r\n                        const diff = (rawBuffer[ptr[0]++] << 24) | (rawBuffer[ptr[1]++] << 16) | (rawBuffer[ptr[2]++] << 8);\r\n\r\n                        pixel += diff;\r\n\r\n                        tmpBuffer[writePtr] = pixel;\r\n                        writePtr++;\r\n                    }\r\n\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n\r\n    return new DataView(tmpBuffer.buffer);\r\n}\r\n\r\n/**\r\n * PIZ compression\r\n * @param decoder defines the decoder to use\r\n * @returns a decompressed data view\r\n */\r\nexport function UncompressPIZ(decoder: IEXRDecoder): DataView {\r\n    const inDataView = decoder.viewer;\r\n    const inOffset = { value: decoder.offset.value };\r\n\r\n    const outBuffer = new Uint16Array(decoder.width * decoder.scanlineBlockSize * (decoder.channels * decoder.type));\r\n    const bitmap = new Uint8Array(BITMAP_SIZE);\r\n\r\n    // Setup channel info\r\n    let outBufferEnd = 0;\r\n    const pizChannelData = new Array(decoder.channels);\r\n    for (let i = 0; i < decoder.channels; i++) {\r\n        pizChannelData[i] = {};\r\n        pizChannelData[i][\"start\"] = outBufferEnd;\r\n        pizChannelData[i][\"end\"] = pizChannelData[i][\"start\"];\r\n        pizChannelData[i][\"nx\"] = decoder.width;\r\n        pizChannelData[i][\"ny\"] = decoder.lines;\r\n        pizChannelData[i][\"size\"] = decoder.type;\r\n\r\n        outBufferEnd += pizChannelData[i].nx * pizChannelData[i].ny * pizChannelData[i].size;\r\n    }\r\n\r\n    // Read range compression data\r\n    const minNonZero = ParseUint16(inDataView, inOffset);\r\n    const maxNonZero = ParseUint16(inDataView, inOffset);\r\n\r\n    if (maxNonZero >= BITMAP_SIZE) {\r\n        throw new Error(\"Wrong PIZ_COMPRESSION BITMAP_SIZE\");\r\n    }\r\n\r\n    if (minNonZero <= maxNonZero) {\r\n        for (let i = 0; i < maxNonZero - minNonZero + 1; i++) {\r\n            bitmap[i + minNonZero] = ParseUint8(inDataView, inOffset);\r\n        }\r\n    }\r\n\r\n    // Reverse LUT\r\n    const lut = new Uint16Array(USHORT_RANGE);\r\n    const maxValue = ReverseLutFromBitmap(bitmap, lut);\r\n\r\n    const length = ParseUint32(inDataView, inOffset);\r\n\r\n    // Huffman decoding\r\n    HufUncompress(decoder.array, inDataView, inOffset, length, outBuffer, outBufferEnd);\r\n\r\n    // Wavelet decoding\r\n    for (let i = 0; i < decoder.channels; ++i) {\r\n        const cd = pizChannelData[i];\r\n\r\n        for (let j = 0; j < pizChannelData[i].size; ++j) {\r\n            Wav2Decode(outBuffer, cd.start + j, cd.nx, cd.size, cd.ny, cd.nx * cd.size, maxValue);\r\n        }\r\n    }\r\n\r\n    // Expand the pixel data to their original range\r\n    ApplyLut(lut, outBuffer, outBufferEnd);\r\n\r\n    // Rearrange the pixel data into the format expected by the caller.\r\n    let tmpOffset = 0;\r\n    const tmpBuffer = new Uint8Array(outBuffer.buffer.byteLength);\r\n    for (let y = 0; y < decoder.lines; y++) {\r\n        for (let c = 0; c < decoder.channels; c++) {\r\n            const cd = pizChannelData[c];\r\n\r\n            const n = cd.nx * cd.size;\r\n            const cp = new Uint8Array(outBuffer.buffer, cd.end * INT16_SIZE, n * INT16_SIZE);\r\n\r\n            tmpBuffer.set(cp, tmpOffset);\r\n            tmpOffset += n * INT16_SIZE;\r\n            cd.end += n;\r\n        }\r\n    }\r\n\r\n    return new DataView(tmpBuffer.buffer);\r\n}\r\n"]}