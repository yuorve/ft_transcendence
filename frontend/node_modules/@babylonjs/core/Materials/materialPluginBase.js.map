{"version":3,"file":"materialPluginBase.js","sourceRoot":"","sources":["../../../../dev/core/src/Materials/materialPluginBase.ts"],"names":[],"mappings":"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","sourcesContent":["import { serialize } from \"../Misc/decorators\";\r\nimport type { Nullable } from \"../types\";\r\nimport { MaterialPluginManager } from \"./materialPluginManager\";\r\nimport type { SmartArray } from \"../Misc/smartArray\";\r\nimport { Constants } from \"../Engines/constants\";\r\n\r\nimport type { AbstractEngine } from \"../Engines/abstractEngine\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { SubMesh } from \"../Meshes/subMesh\";\r\nimport type { IAnimatable } from \"../Animations/animatable.interface\";\r\nimport type { UniformBuffer } from \"./uniformBuffer\";\r\nimport type { EffectFallbacks } from \"./effectFallbacks\";\r\nimport type { MaterialDefines } from \"./materialDefines\";\r\nimport type { Material } from \"./material\";\r\nimport type { BaseTexture } from \"./Textures/baseTexture\";\r\nimport type { RenderTargetTexture } from \"./Textures/renderTargetTexture\";\r\nimport { SerializationHelper } from \"../Misc/decorators.serialization\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\nimport { ShaderLanguage } from \"./shaderLanguage\";\r\n\r\n/**\r\n * Base class for material plugins.\r\n * @since 5.0\r\n */\r\nexport class MaterialPluginBase {\r\n    /**\r\n     * Defines the name of the plugin\r\n     */\r\n    @serialize()\r\n    public name: string;\r\n\r\n    /**\r\n     * Defines the priority of the plugin. Lower numbers run first.\r\n     */\r\n    @serialize()\r\n    public priority: number = 500;\r\n\r\n    /**\r\n     * Indicates that any #include directive in the plugin code must be replaced by the corresponding code.\r\n     */\r\n    @serialize()\r\n    public resolveIncludes: boolean = false;\r\n\r\n    /**\r\n     * Indicates that this plugin should be notified for the extra events (HasRenderTargetTextures / FillRenderTargetTextures / HardBindForSubMesh)\r\n     */\r\n    @serialize()\r\n    public registerForExtraEvents: boolean = false;\r\n\r\n    /**\r\n     * Specifies if the material plugin should be serialized, `true` to skip serialization\r\n     */\r\n    public doNotSerialize = false;\r\n\r\n    protected _material: Material;\r\n    protected _pluginManager: MaterialPluginManager;\r\n    protected _pluginDefineNames?: { [name: string]: any };\r\n\r\n    /**\r\n     * Gets a boolean indicating that the plugin is compatible with a given shader language.\r\n     * @param shaderLanguage The shader language to use.\r\n     * @returns true if the plugin is compatible with the shader language\r\n     */\r\n    public isCompatible(shaderLanguage: ShaderLanguage): boolean {\r\n        switch (shaderLanguage) {\r\n            case ShaderLanguage.GLSL:\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    }\r\n\r\n    protected _enable(enable: boolean) {\r\n        if (enable) {\r\n            this._pluginManager._activatePlugin(this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Helper function to mark defines as being dirty.\r\n     */\r\n    public readonly markAllDefinesAsDirty: () => void;\r\n\r\n    /**\r\n     * Creates a new material plugin\r\n     * @param material parent material of the plugin\r\n     * @param name name of the plugin\r\n     * @param priority priority of the plugin\r\n     * @param defines list of defines used by the plugin. The value of the property is the default value for this property\r\n     * @param addToPluginList true to add the plugin to the list of plugins managed by the material plugin manager of the material (default: true)\r\n     * @param enable true to enable the plugin (it is handy if the plugin does not handle properties to switch its current activation)\r\n     * @param resolveIncludes Indicates that any #include directive in the plugin code must be replaced by the corresponding code (default: false)\r\n     */\r\n    constructor(material: Material, name: string, priority: number, defines?: { [key: string]: any }, addToPluginList = true, enable = false, resolveIncludes = false) {\r\n        this._material = material;\r\n        this.name = name;\r\n        this.priority = priority;\r\n        this.resolveIncludes = resolveIncludes;\r\n\r\n        if (!material.pluginManager) {\r\n            material.pluginManager = new MaterialPluginManager(material);\r\n            material.onDisposeObservable.add(() => {\r\n                material.pluginManager = undefined;\r\n            });\r\n        }\r\n\r\n        this._pluginDefineNames = defines;\r\n        this._pluginManager = material.pluginManager;\r\n\r\n        if (addToPluginList) {\r\n            this._pluginManager._addPlugin(this);\r\n        }\r\n\r\n        if (enable) {\r\n            this._enable(true);\r\n        }\r\n\r\n        this.markAllDefinesAsDirty = material._dirtyCallbacks[Constants.MATERIAL_AllDirtyFlag];\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name useful for serialization or dynamic coding.\r\n     * @returns The class name.\r\n     */\r\n    public getClassName(): string {\r\n        return \"MaterialPluginBase\";\r\n    }\r\n\r\n    /**\r\n     * Specifies that the submesh is ready to be used.\r\n     * @param _defines the list of \"defines\" to update.\r\n     * @param _scene defines the scene the material belongs to.\r\n     * @param _engine the engine this scene belongs to.\r\n     * @param _subMesh the submesh to check for readiness\r\n     * @returns - boolean indicating that the submesh is ready or not.\r\n     */\r\n    public isReadyForSubMesh(_defines: MaterialDefines, _scene: Scene, _engine: AbstractEngine, _subMesh: SubMesh): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Binds the material data (this function is called even if mustRebind() returns false)\r\n     * @param _uniformBuffer defines the Uniform buffer to fill in.\r\n     * @param _scene defines the scene the material belongs to.\r\n     * @param _engine defines the engine the material belongs to.\r\n     * @param _subMesh the submesh to bind data for\r\n     */\r\n    public hardBindForSubMesh(_uniformBuffer: UniformBuffer, _scene: Scene, _engine: AbstractEngine, _subMesh: SubMesh): void {}\r\n\r\n    /**\r\n     * Binds the material data.\r\n     * @param _uniformBuffer defines the Uniform buffer to fill in.\r\n     * @param _scene defines the scene the material belongs to.\r\n     * @param _engine the engine this scene belongs to.\r\n     * @param _subMesh the submesh to bind data for\r\n     */\r\n    public bindForSubMesh(_uniformBuffer: UniformBuffer, _scene: Scene, _engine: AbstractEngine, _subMesh: SubMesh): void {}\r\n\r\n    /**\r\n     * Disposes the resources of the material.\r\n     * @param _forceDisposeTextures - Forces the disposal of all textures.\r\n     */\r\n    public dispose(_forceDisposeTextures?: boolean): void {}\r\n\r\n    /**\r\n     * Returns a list of custom shader code fragments to customize the shader.\r\n     * @param _shaderType \"vertex\" or \"fragment\"\r\n     * @param _shaderLanguage The shader language to use.\r\n     * @returns null if no code to be added, or a list of pointName =\\> code.\r\n     * Note that `pointName` can also be a regular expression if it starts with a `!`.\r\n     * In that case, the string found by the regular expression (if any) will be\r\n     * replaced by the code provided.\r\n     */\r\n    public getCustomCode(_shaderType: string, _shaderLanguage = ShaderLanguage.GLSL): Nullable<{ [pointName: string]: string }> {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Collects all defines.\r\n     * @param defines The object to append to.\r\n     */\r\n    public collectDefines(defines: { [name: string]: { type: string; default: any } }): void {\r\n        if (!this._pluginDefineNames) {\r\n            return;\r\n        }\r\n        for (const key of Object.keys(this._pluginDefineNames)) {\r\n            if (key[0] === \"_\") {\r\n                continue;\r\n            }\r\n\r\n            const type = typeof this._pluginDefineNames[key];\r\n            defines[key] = {\r\n                type: type === \"number\" ? \"number\" : type === \"string\" ? \"string\" : type === \"boolean\" ? \"boolean\" : \"object\",\r\n                default: this._pluginDefineNames[key],\r\n            };\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the defines for the next rendering. Called before PrepareDefinesForAttributes is called.\r\n     * @param _defines the list of \"defines\" to update.\r\n     * @param _scene defines the scene to the material belongs to.\r\n     * @param _mesh the mesh being rendered\r\n     */\r\n    public prepareDefinesBeforeAttributes(_defines: MaterialDefines, _scene: Scene, _mesh: AbstractMesh): void {}\r\n\r\n    /**\r\n     * Sets the defines for the next rendering\r\n     * @param _defines the list of \"defines\" to update.\r\n     * @param _scene defines the scene to the material belongs to.\r\n     * @param _mesh the mesh being rendered\r\n     */\r\n    public prepareDefines(_defines: MaterialDefines, _scene: Scene, _mesh: AbstractMesh): void {}\r\n\r\n    /**\r\n     * Checks to see if a texture is used in the material.\r\n     * @param _texture - Base texture to use.\r\n     * @returns - Boolean specifying if a texture is used in the material.\r\n     */\r\n    public hasTexture(_texture: BaseTexture): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that current material needs to register RTT\r\n     * @returns true if this uses a render target otherwise false.\r\n     */\r\n    public hasRenderTargetTextures(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Fills the list of render target textures.\r\n     * @param _renderTargets the list of render targets to update\r\n     */\r\n    public fillRenderTargetTextures(_renderTargets: SmartArray<RenderTargetTexture>): void {}\r\n\r\n    /**\r\n     * Returns an array of the actively used textures.\r\n     * @param _activeTextures Array of BaseTextures\r\n     */\r\n    public getActiveTextures(_activeTextures: BaseTexture[]): void {}\r\n\r\n    /**\r\n     * Returns the animatable textures.\r\n     * @param _animatables Array of animatable textures.\r\n     */\r\n    public getAnimatables(_animatables: IAnimatable[]): void {}\r\n\r\n    /**\r\n     * Add fallbacks to the effect fallbacks list.\r\n     * @param defines defines the Base texture to use.\r\n     * @param fallbacks defines the current fallback list.\r\n     * @param currentRank defines the current fallback rank.\r\n     * @returns the new fallback rank.\r\n     */\r\n    public addFallbacks(defines: MaterialDefines, fallbacks: EffectFallbacks, currentRank: number): number {\r\n        return currentRank;\r\n    }\r\n\r\n    /**\r\n     * Gets the samplers used by the plugin.\r\n     * @param _samplers list that the sampler names should be added to.\r\n     */\r\n    public getSamplers(_samplers: string[]): void {}\r\n\r\n    /**\r\n     * Gets the attributes used by the plugin.\r\n     * @param _attributes list that the attribute names should be added to.\r\n     * @param _scene the scene that the material belongs to.\r\n     * @param _mesh the mesh being rendered.\r\n     */\r\n    public getAttributes(_attributes: string[], _scene: Scene, _mesh: AbstractMesh): void {}\r\n\r\n    /**\r\n     * Gets the uniform buffers names added by the plugin.\r\n     * @param _ubos list that the ubo names should be added to.\r\n     */\r\n    public getUniformBuffersNames(_ubos: string[]): void {}\r\n\r\n    /**\r\n     * Gets the description of the uniforms to add to the ubo (if engine supports ubos) or to inject directly in the vertex/fragment shaders (if engine does not support ubos)\r\n     * @param _shaderLanguage The shader language to use.\r\n     * @returns the description of the uniforms\r\n     */\r\n    public getUniforms(_shaderLanguage = ShaderLanguage.GLSL): {\r\n        ubo?: Array<{ name: string; size?: number; type?: string; arraySize?: number }>;\r\n        vertex?: string;\r\n        fragment?: string;\r\n    } {\r\n        return {};\r\n    }\r\n\r\n    /**\r\n     * Makes a duplicate of the current configuration into another one.\r\n     * @param plugin define the config where to copy the info\r\n     */\r\n    public copyTo(plugin: MaterialPluginBase): void {\r\n        SerializationHelper.Clone(() => plugin, this);\r\n    }\r\n\r\n    /**\r\n     * Serializes this plugin configuration.\r\n     * @returns - An object with the serialized config.\r\n     */\r\n    public serialize(): any {\r\n        return SerializationHelper.Serialize(this);\r\n    }\r\n\r\n    /**\r\n     * Parses a plugin configuration from a serialized object.\r\n     * @param source - Serialized object.\r\n     * @param scene Defines the scene we are parsing for\r\n     * @param rootUrl Defines the rootUrl to load from\r\n     */\r\n    public parse(source: any, scene: Scene, rootUrl: string): void {\r\n        SerializationHelper.Parse(() => this, source, scene, rootUrl);\r\n    }\r\n}\r\n\r\n// Register Class Name\r\nRegisterClass(\"BABYLON.MaterialPluginBase\", MaterialPluginBase);\r\n"]}