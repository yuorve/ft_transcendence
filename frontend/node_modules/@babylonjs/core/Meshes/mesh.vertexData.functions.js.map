{"version":3,"file":"mesh.vertexData.functions.js","sourceRoot":"","sources":["../../../../dev/core/src/Meshes/mesh.vertexData.functions.ts"],"names":[],"mappings":"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","sourcesContent":["import type { IndicesArray } from \"core/types\";\r\nimport { BitArray } from \"core/Misc/bitArray\";\r\n\r\n/**\r\n * Sort (in place) the index array so that faces with common indices are close\r\n * @param indices the array of indices to sort\r\n */\r\nexport function OptimizeIndices(indices: IndicesArray) {\r\n    const faces: Array<Array<number>> = [];\r\n    const faceCount = indices.length / 3;\r\n\r\n    // Step 1: Break the indices array into faces\r\n    for (let i = 0; i < faceCount; i++) {\r\n        faces.push([indices[i * 3], indices[i * 3 + 1], indices[i * 3 + 2]]);\r\n    }\r\n\r\n    // Step 2: Build a graph connecting faces sharing a vertex\r\n    const vertexToFaceMap = new Map<number, number[]>();\r\n    faces.forEach((face, faceIndex) => {\r\n        face.forEach((vertex) => {\r\n            let face = vertexToFaceMap.get(vertex);\r\n            if (!face) {\r\n                vertexToFaceMap.set(vertex, (face = []));\r\n            }\r\n            face.push(faceIndex);\r\n        });\r\n    });\r\n\r\n    // Step 3: Traverse faces using DFS to ensure connected faces are close\r\n    const visited = new BitArray(faceCount);\r\n    const sortedFaces: Array<number[]> = [];\r\n\r\n    // Using a stack and not a recursive version to avoid call stack overflow\r\n    const deepFirstSearchStack = (startFaceIndex: number) => {\r\n        const stack: Array<number> = [startFaceIndex];\r\n\r\n        while (stack.length > 0) {\r\n            const currentFaceIndex = stack.pop()!;\r\n\r\n            if (visited.get(currentFaceIndex)) {\r\n                continue;\r\n            }\r\n            visited.set(currentFaceIndex, true);\r\n            sortedFaces.push(faces[currentFaceIndex]);\r\n\r\n            // Push unvisited neighbors (faces sharing a vertex) onto the stack\r\n            faces[currentFaceIndex].forEach((vertex) => {\r\n                const neighbors = vertexToFaceMap.get(vertex);\r\n\r\n                if (!neighbors) {\r\n                    return;\r\n                }\r\n\r\n                neighbors.forEach((neighborFaceIndex) => {\r\n                    if (!visited.get(neighborFaceIndex)) {\r\n                        stack.push(neighborFaceIndex);\r\n                    }\r\n                });\r\n            });\r\n        }\r\n    };\r\n\r\n    // Start DFS from the first face\r\n    for (let i = 0; i < faceCount; i++) {\r\n        if (!visited.get(i)) {\r\n            deepFirstSearchStack(i);\r\n        }\r\n    }\r\n\r\n    // Step 4: Flatten the sorted faces back into an array\r\n    let index = 0;\r\n    sortedFaces.forEach((face) => {\r\n        indices[index++] = face[0];\r\n        indices[index++] = face[1];\r\n        indices[index++] = face[2];\r\n    });\r\n}\r\n"]}