{"version":3,"file":"mesh.vertexData.subdivide.js","sourceRoot":"","sources":["../../../../dev/core/src/Meshes/mesh.vertexData.subdivide.ts"],"names":[],"mappings":"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","sourcesContent":["import { Vector3 } from \"core/Maths/math.vector\";\r\nimport { VertexData } from \"./mesh.vertexData\";\r\nimport { Scalar } from \"core/Maths/math.scalar\";\r\nimport type { FloatArray } from \"core/types\";\r\n\r\n/**\r\n * Inspired by https://github.com/stevinz/three-subdivide\r\n * Thanks a lot to https://github.com/stevinz\r\n */\r\n\r\n/**\r\n * Interface used to configure the subdivision process\r\n */\r\nexport interface ISubdivideOptions {\r\n    /** Apply only flat subdivision - false by default */\r\n    flatOnly?: boolean;\r\n    /** Split all triangles at edges shared by coplanar triangles - true by default*/\r\n    split?: boolean;\r\n    /**  Should UV values be averaged during subdivision - false by default */\r\n    uvSmooth?: boolean;\r\n    /** Should edges / breaks in geometry be ignored during subdivision? - false by default */\r\n    preserveEdges?: boolean;\r\n    /** How much to weigh favoring heavy corners vs favoring Loop's formula - 1 by default*/\r\n    weight?: number;\r\n}\r\n\r\nconst _positionShift = Math.pow(10, 4);\r\n\r\n/**\r\n * Rounds a number (simulate integer rounding)\r\n * @internal\r\n */\r\nfunction round(x: number): number {\r\n    return (x + (x > 0 ? 0.5 : -0.5)) << 0;\r\n}\r\n\r\n/**\r\n * Generates a hash string from a number\r\n * @internal\r\n */\r\nfunction hashFromNumber(num: number, shift = _positionShift): string {\r\n    let roundedNumber = round(num * shift);\r\n    if (roundedNumber === 0) {\r\n        roundedNumber = 0; // prevent -0\r\n    }\r\n    return `${roundedNumber}`;\r\n}\r\n\r\n/**\r\n * Generates a hash string from a Vector3\r\n * @internal\r\n */\r\nfunction hashFromVector(v: Vector3, shift = _positionShift): string {\r\n    return `${hashFromNumber(v.x, shift)},${hashFromNumber(v.y, shift)},${hashFromNumber(v.z, shift)}`;\r\n}\r\n\r\n/**\r\n * Gathers attribute names from a VertexData object\r\n * @internal\r\n */\r\nfunction gatherAttributes(vertexData: VertexData): string[] {\r\n    const desired = [\"positions\", \"normals\", \"uvs\"];\r\n    const available = Object.keys(vertexData).filter((k) => Array.isArray((vertexData as any)[k]));\r\n    return Array.from(new Set([...desired, ...available]));\r\n}\r\n\r\n/**\r\n * Sets triangle data into an attribute array\r\n * @internal\r\n */\r\nfunction setTriangle(arr: number[], index: number, itemSize: number, vec0: number[], vec1: number[], vec2: number[]): void {\r\n    for (let i = 0; i < itemSize; i++) {\r\n        arr[index + i] = vec0[i];\r\n        arr[index + itemSize + i] = vec1[i];\r\n        arr[index + 2 * itemSize + i] = vec2[i];\r\n    }\r\n}\r\n\r\n/**\r\n * Converts indexed VertexData to a non-indexed form\r\n * @internal\r\n */\r\nfunction toNonIndexed(vertexData: VertexData): VertexData {\r\n    if (!vertexData.indices || vertexData.indices.length === 0) {\r\n        return vertexData; // already non-indexed\r\n    }\r\n    const newPositions: number[] = [];\r\n    const newNormals: number[] = [];\r\n    const newUVs: number[] = [];\r\n    const indices = vertexData.indices;\r\n    const pos = vertexData.positions!;\r\n    const norm = vertexData.normals;\r\n    const uv = vertexData.uvs;\r\n\r\n    for (let i = 0; i < indices.length; i++) {\r\n        const idx = indices[i];\r\n        newPositions.push(pos[3 * idx], pos[3 * idx + 1], pos[3 * idx + 2]);\r\n        if (norm) {\r\n            newNormals.push(norm[3 * idx], norm[3 * idx + 1], norm[3 * idx + 2]);\r\n        }\r\n        if (uv) {\r\n            newUVs.push(uv[2 * idx], uv[2 * idx + 1]);\r\n        }\r\n    }\r\n\r\n    const newVertexData = new VertexData();\r\n    newVertexData.positions = newPositions;\r\n    if (newNormals.length) {\r\n        newVertexData.normals = newNormals;\r\n    }\r\n    if (newUVs.length) {\r\n        newVertexData.uvs = newUVs;\r\n    }\r\n    return newVertexData;\r\n}\r\n\r\n/** Helper to read a Vector3 from an attribute array\r\n * @internal\r\n */\r\nfunction readVector(destination: Vector3, attribute: FloatArray, index: number, itemSize: number) {\r\n    if (itemSize === 3) {\r\n        destination.fromArray(attribute, index * 3);\r\n        return;\r\n    }\r\n    // For uvs (itemSize 2), return a Vector3 with z = 0.\r\n    destination.set(attribute[index * 2], attribute[index * 2 + 1], 0);\r\n}\r\n\r\nfunction processFlatAttribute(source: FloatArray, vertexCount: number, output: number[]) {\r\n    const v0 = new Vector3();\r\n    const v1 = new Vector3();\r\n    const v2 = new Vector3();\r\n    const m01 = new Vector3();\r\n    const m12 = new Vector3();\r\n    const m20 = new Vector3();\r\n\r\n    for (let i = 0; i < vertexCount; i += 3) {\r\n        const j = i * 3;\r\n        v0.set(source[j], source[j + 1], source[j + 2]);\r\n        v1.set(source[j + 3], source[j + 4], source[j + 5]);\r\n        v2.set(source[j + 6], source[j + 7], source[j + 8]);\r\n        v0.addToRef(v1, m01);\r\n        m01.scaleInPlace(0.5);\r\n        v1.addToRef(v2, m12);\r\n        m12.scaleInPlace(0.5);\r\n        v2.addToRef(v0, m20);\r\n        m20.scaleInPlace(0.5);\r\n\r\n        // Positions\r\n        output.push(v0.x, v0.y, v0.z, m01.x, m01.y, m01.z, m20.x, m20.y, m20.z);\r\n        output.push(v1.x, v1.y, v1.z, m12.x, m12.y, m12.z, m01.x, m01.y, m01.z);\r\n        output.push(v2.x, v2.y, v2.z, m20.x, m20.y, m20.z, m12.x, m12.y, m12.z);\r\n        output.push(m01.x, m01.y, m01.z, m12.x, m12.y, m12.z, m20.x, m20.y, m20.z);\r\n    }\r\n}\r\n\r\n/**\r\n * Applies one iteration of flat subdivision (each triangle becomes 4).\r\n * @internal\r\n */\r\nfunction flat(vertexData: VertexData): VertexData {\r\n    const data = toNonIndexed(vertexData);\r\n    const positions = data.positions!;\r\n    const normals = data.normals;\r\n    const uvs = data.uvs;\r\n    const vertexCount = positions.length / 3;\r\n\r\n    const newPositions: number[] = [];\r\n    const newNormals: number[] = [];\r\n    const newUVs: number[] = [];\r\n    processFlatAttribute(positions, vertexCount, newPositions);\r\n\r\n    if (normals && normals.length) {\r\n        processFlatAttribute(normals, vertexCount, newNormals);\r\n    }\r\n\r\n    if (uvs && uvs.length) {\r\n        for (let i = 0; i < vertexCount; i += 3) {\r\n            const j = i * 2;\r\n            const uv0 = [uvs[j], uvs[j + 1]];\r\n            const uv1 = [uvs[j + 2], uvs[j + 3]];\r\n            const uv2 = [uvs[j + 4], uvs[j + 5]];\r\n\r\n            const uv01 = [(uv0[0] + uv1[0]) / 2, (uv0[1] + uv1[1]) / 2];\r\n            const uv12 = [(uv1[0] + uv2[0]) / 2, (uv1[1] + uv2[1]) / 2];\r\n            const uv20 = [(uv2[0] + uv0[0]) / 2, (uv2[1] + uv0[1]) / 2];\r\n\r\n            newUVs.push(...uv0, ...uv01, ...uv20);\r\n            newUVs.push(...uv1, ...uv12, ...uv01);\r\n            newUVs.push(...uv2, ...uv20, ...uv12);\r\n            newUVs.push(...uv01, ...uv12, ...uv20);\r\n        }\r\n    }\r\n\r\n    const newVertexCount = newPositions.length / 3;\r\n    const newIndices: number[] = [];\r\n    for (let i = 0; i < newVertexCount; i++) {\r\n        newIndices.push(i);\r\n    }\r\n\r\n    const newVertexData = new VertexData();\r\n    newVertexData.positions = newPositions;\r\n    if (newNormals.length) {\r\n        newVertexData.normals = newNormals;\r\n    }\r\n    if (newUVs.length) {\r\n        newVertexData.uvs = newUVs;\r\n    }\r\n    newVertexData.indices = newIndices;\r\n    return newVertexData;\r\n}\r\n\r\n/**\r\n * Applies one iteration of smooth subdivision with vertex averaging.\r\n * This function uses the subdivideAttribute routine to adjust vertex data.\r\n * @internal\r\n */\r\nfunction smooth(vertexData: VertexData, options: ISubdivideOptions): VertexData {\r\n    // Convert to non-indexed and apply flat subdivision first.\r\n    const sourceData = toNonIndexed(vertexData);\r\n    const flatData = flat(sourceData);\r\n\r\n    const attributeList = gatherAttributes(sourceData);\r\n    const origPositions = sourceData.positions!;\r\n    const flatPositions = flatData.positions!;\r\n    const vertexCount = origPositions.length / 3;\r\n\r\n    // Build connectivity maps from the original geometry.\r\n    const hashToIndex: { [hash: string]: number[] } = {};\r\n    const existingNeighbors: { [hash: string]: { [neighborHash: string]: number[] } } = {};\r\n    const flatOpposites: { [hash: string]: number[] } = {};\r\n    const existingEdges: { [hash: string]: Set<string> } = {};\r\n\r\n    function addNeighbor(posHash: string, neighborHash: string, index: number): void {\r\n        if (!existingNeighbors[posHash]) {\r\n            existingNeighbors[posHash] = {};\r\n        }\r\n        if (!existingNeighbors[posHash][neighborHash]) {\r\n            existingNeighbors[posHash][neighborHash] = [];\r\n        }\r\n        existingNeighbors[posHash][neighborHash].push(index);\r\n    }\r\n    function addOpposite(posHash: string, index: number): void {\r\n        if (!flatOpposites[posHash]) {\r\n            flatOpposites[posHash] = [];\r\n        }\r\n        flatOpposites[posHash].push(index);\r\n    }\r\n    function addEdgePoint(posHash: string, edgeHash: string): void {\r\n        if (!existingEdges[posHash]) {\r\n            existingEdges[posHash] = new Set<string>();\r\n        }\r\n        existingEdges[posHash].add(edgeHash);\r\n    }\r\n\r\n    const temp = new Vector3();\r\n    const v0 = new Vector3();\r\n    const v1 = new Vector3();\r\n    const v2 = new Vector3();\r\n    const m01 = new Vector3();\r\n    const m12 = new Vector3();\r\n    const m20 = new Vector3();\r\n\r\n    // Process original positions\r\n    for (let i = 0; i < vertexCount; i += 3) {\r\n        readVector(v0, origPositions, i, 3);\r\n        readVector(v1, origPositions, i + 1, 3);\r\n        readVector(v2, origPositions, i + 2, 3);\r\n        const h0 = hashFromVector(v0);\r\n        const h1 = hashFromVector(v1);\r\n        const h2 = hashFromVector(v2);\r\n        addNeighbor(h0, h1, i + 1);\r\n        addNeighbor(h0, h2, i + 2);\r\n        addNeighbor(h1, h0, i);\r\n        addNeighbor(h1, h2, i + 2);\r\n        addNeighbor(h2, h0, i);\r\n        addNeighbor(h2, h1, i + 1);\r\n\r\n        // Opposites from flat subdivision: calculate midpoints.\r\n        v0.addToRef(v1, m01);\r\n        m01.scaleInPlace(0.5);\r\n        v1.addToRef(v2, m12);\r\n        m12.scaleInPlace(0.5);\r\n        v2.addToRef(v0, m20);\r\n        m20.scaleInPlace(0.5);\r\n\r\n        addOpposite(hashFromVector(m01), i + 2);\r\n        addOpposite(hashFromVector(m12), i);\r\n        addOpposite(hashFromVector(m20), i + 1);\r\n\r\n        // Track edges for preserveEdges.\r\n        addEdgePoint(h0, hashFromVector(m01));\r\n        addEdgePoint(h0, hashFromVector(m20));\r\n        addEdgePoint(h1, hashFromVector(m01));\r\n        addEdgePoint(h1, hashFromVector(m12));\r\n        addEdgePoint(h2, hashFromVector(m12));\r\n        addEdgePoint(h2, hashFromVector(m20));\r\n    }\r\n\r\n    // Build map from flat positions to indices.\r\n    for (let i = 0; i < flatPositions.length / 3; i++) {\r\n        readVector(temp, flatPositions, i, 3);\r\n        const h = hashFromVector(temp);\r\n        if (!hashToIndex[h]) {\r\n            hashToIndex[h] = [];\r\n        }\r\n        hashToIndex[h].push(i);\r\n    }\r\n\r\n    // Prepare temporary vectors for subdivideAttribute.\r\n    const _vertex: Vector3[] = [new Vector3(), new Vector3(), new Vector3()];\r\n    const _position: Vector3[] = [new Vector3(), new Vector3(), new Vector3()];\r\n    const _average = new Vector3();\r\n    const _temp = new Vector3();\r\n\r\n    // subdivideAttribute: adjusts vertex attributes using Loopâ€™s averaging rules.\r\n    function subdivideAttribute(attributeName: string, existingAttribute: number[], flattenedAttribute: number[]): number[] {\r\n        const itemSize = attributeName === \"uvs\" ? 2 : 3;\r\n        const flatVertexCount = flatPositions.length / 3;\r\n        const floatArray = new Array(flatVertexCount * itemSize);\r\n        let index = 0;\r\n        for (let i = 0; i < flatVertexCount; i += 3) {\r\n            for (let v = 0; v < 3; v++) {\r\n                if (attributeName === \"uvs\" && !options.uvSmooth) {\r\n                    // Simply copy UVs.\r\n                    readVector(_vertex[v], flattenedAttribute, i + v, 2);\r\n                } else if (attributeName === \"normals\") {\r\n                    readVector(_position[v], flatPositions, i + v, 3);\r\n                    const positionHash = hashFromVector(_position[v]);\r\n                    const positionsArr = hashToIndex[positionHash] || [];\r\n                    const k = positionsArr.length;\r\n                    const beta = 0.75 / k;\r\n                    const startWeight = 1.0 - beta * k;\r\n                    readVector(_vertex[v], flattenedAttribute, i + v, 3);\r\n                    _vertex[v].scaleInPlace(startWeight);\r\n                    positionsArr.forEach((positionIndex) => {\r\n                        readVector(_average, flattenedAttribute, positionIndex, 3);\r\n                        _average.scaleInPlace(beta);\r\n                        _vertex[v].addInPlace(_average);\r\n                    });\r\n                } else {\r\n                    // 'positions', 'colors', etc.\r\n                    readVector(_vertex[v], flattenedAttribute, i + v, itemSize);\r\n                    readVector(_position[v], flatPositions, i + v, 3);\r\n                    const positionHash = hashFromVector(_position[v]);\r\n                    const neighbors = existingNeighbors[positionHash];\r\n                    const opposites = flatOpposites[positionHash];\r\n                    if (neighbors) {\r\n                        if (options.preserveEdges) {\r\n                            const edgeSet = existingEdges[positionHash];\r\n                            let hasPair = true;\r\n                            edgeSet.forEach((edgeHash) => {\r\n                                if (flatOpposites[edgeHash] && flatOpposites[edgeHash].length % 2 !== 0) {\r\n                                    hasPair = false;\r\n                                }\r\n                            });\r\n                            if (!hasPair) {\r\n                                // If edges aren't paired, skip adjustment.\r\n                                continue;\r\n                            }\r\n                        }\r\n                        const neighborKeys = Object.keys(neighbors);\r\n                        const k = neighborKeys.length;\r\n                        const beta = (1 / k) * (5 / 8 - Math.pow(3 / 8 + (1 / 4) * Math.cos((2 * Math.PI) / k), 2));\r\n                        const heavy = 1 / k / k;\r\n                        const weight = Scalar.Lerp(heavy, beta, options.weight!);\r\n                        const startWeight = 1.0 - weight * k;\r\n                        _vertex[v].scaleInPlace(startWeight);\r\n                        for (const neighborHash in neighbors) {\r\n                            const neighborIndices = neighbors[neighborHash];\r\n                            _average.set(0, 0, 0);\r\n                            neighborIndices.forEach((neighborIndex) => {\r\n                                readVector(_temp, existingAttribute, neighborIndex, itemSize);\r\n                                _average.addInPlace(_temp);\r\n                            });\r\n                            _average.scaleInPlace(1 / neighborIndices.length);\r\n                            _average.scaleInPlace(weight);\r\n                            _vertex[v].addInPlace(_average);\r\n                        }\r\n                    } else if (opposites && opposites.length === 2) {\r\n                        const k = opposites.length;\r\n                        const beta = 0.125; // 1/8\r\n                        const startWeight = 1.0 - beta * k;\r\n                        _vertex[v].scaleInPlace(startWeight);\r\n                        opposites.forEach((oppositeIndex) => {\r\n                            readVector(_average, existingAttribute, oppositeIndex, itemSize);\r\n                            _average.scaleInPlace(beta);\r\n                            _vertex[v].addInPlace(_average);\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n            // Write out new triangle vertices.\r\n            setTriangle(floatArray, index, itemSize, _vertex[0].asArray(), _vertex[1].asArray(), _vertex[2].asArray());\r\n            index += itemSize * 3;\r\n        }\r\n        return floatArray;\r\n    }\r\n\r\n    // Build new attributes for the smoothed geometry.\r\n    const smoothData = new VertexData();\r\n    attributeList.forEach((attributeName) => {\r\n        if (attributeName === \"indices\") {\r\n            return;\r\n        }\r\n        const existingAttribute = (sourceData as any)[attributeName] as number[];\r\n        const flattenedAttribute = (flatData as any)[attributeName] as number[];\r\n        if (!existingAttribute || !flattenedAttribute) {\r\n            return;\r\n        }\r\n        const newArray = subdivideAttribute(attributeName, existingAttribute, flattenedAttribute);\r\n        (smoothData as any)[attributeName] = newArray;\r\n    });\r\n\r\n    // Rebuild indices sequentially.\r\n    const newPositions = smoothData.positions!;\r\n    const newIndices: number[] = [];\r\n    for (let i = 0; i < newPositions.length / 3; i++) {\r\n        newIndices.push(i);\r\n    }\r\n    smoothData.indices = newIndices;\r\n    return smoothData;\r\n}\r\n\r\n/**\r\n * Subdivide a vertexData using Loop algorithm\r\n * @param vertexData The vertexData to subdivide\r\n * @param level The number of times to subdivide\r\n * @param options The options to use when subdividing\r\n * @returns The subdivided vertexData\r\n */\r\nexport function Subdivide(vertexData: VertexData, level: number, options?: Partial<ISubdivideOptions>): VertexData {\r\n    options = {\r\n        flatOnly: false,\r\n        uvSmooth: false,\r\n        preserveEdges: false,\r\n        weight: 1,\r\n        ...options,\r\n    };\r\n\r\n    if (!vertexData.positions || vertexData.positions.length === 0 || level <= 0) {\r\n        return vertexData;\r\n    }\r\n\r\n    // Clone the input\r\n    let modified = vertexData.clone();\r\n\r\n    for (let i = 0; i < level; i++) {\r\n        if (options.flatOnly) {\r\n            modified = flat(modified);\r\n        } else {\r\n            modified = smooth(modified, options);\r\n        }\r\n    }\r\n\r\n    return modified;\r\n}\r\n"]}