{"version":3,"file":"screenshotTools.js","sourceRoot":"","sources":["../../../../dev/core/src/Misc/screenshotTools.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport { FxaaPostProcess } from \"../PostProcesses/fxaaPostProcess\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { Logger } from \"./logger\";\r\nimport { Tools } from \"./tools\";\r\nimport type { IScreenshotSize } from \"./interfaces/screenshotSize\";\r\nimport { DumpData } from \"./dumpTools\";\r\nimport type { Nullable } from \"../types\";\r\nimport { ApplyPostProcess } from \"./textureTools\";\r\n\r\nimport type { AbstractEngine } from \"../Engines/abstractEngine\";\r\nimport { _retryWithInterval } from \"./timingTools\";\r\n\r\nlet screenshotCanvas: Nullable<HTMLCanvasElement> = null;\r\n\r\n/**\r\n * Captures a screenshot of the current rendering\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG\r\n * @param engine defines the rendering engine\r\n * @param camera defines the source camera. If the camera is not the scene's active camera, {@link CreateScreenshotUsingRenderTarget} will be used instead, and `useFill` will be ignored\r\n * @param size This parameter can be set to a single number or to an object with the\r\n * following (optional) properties: precision, width, height. If a single number is passed,\r\n * it will be used for both width and height. If an object is passed, the screenshot size\r\n * will be derived from the parameters. The precision property is a multiplier allowing\r\n * rendering at a higher or lower resolution\r\n * @param successCallback defines the callback receives a single parameter which contains the\r\n * screenshot as a string of base64-encoded characters. This string can be assigned to the\r\n * src parameter of an <img> to display it\r\n * @param mimeType defines the MIME type of the screenshot image (default: image/png).\r\n * Check your browser for supported MIME types\r\n * @param forceDownload force the system to download the image even if a successCallback is provided\r\n * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.\r\n * @param useFill fill the screenshot dimensions with the render canvas and clip any overflow. If false, fit the canvas within the screenshot, as in letterboxing.\r\n */\r\nexport function CreateScreenshot(\r\n    engine: AbstractEngine,\r\n    camera: Camera,\r\n    size: IScreenshotSize | number,\r\n    successCallback?: (data: string) => void,\r\n    mimeType = \"image/png\",\r\n    forceDownload = false,\r\n    quality?: number,\r\n    useFill = false\r\n): void {\r\n    const { height, width } = _GetScreenshotSize(engine, camera, size);\r\n\r\n    if (!(height && width)) {\r\n        Logger.Error(\"Invalid 'size' parameter !\");\r\n        return;\r\n    }\r\n\r\n    const scene = camera.getScene();\r\n    if (scene.activeCamera !== camera) {\r\n        CreateScreenshotUsingRenderTarget(\r\n            engine,\r\n            camera,\r\n            size,\r\n            (data) => {\r\n                if (forceDownload) {\r\n                    const blob = new Blob([data]);\r\n                    Tools.DownloadBlob(blob);\r\n                    if (successCallback) {\r\n                        successCallback(\"\");\r\n                    }\r\n                } else if (successCallback) {\r\n                    successCallback(data);\r\n                }\r\n            },\r\n            mimeType,\r\n            1.0,\r\n            engine.getCreationOptions().antialias,\r\n            undefined,\r\n            undefined,\r\n            undefined,\r\n            undefined,\r\n            quality\r\n        );\r\n        return;\r\n    }\r\n\r\n    engine.onEndFrameObservable.addOnce(() => {\r\n        if (!screenshotCanvas) {\r\n            screenshotCanvas = document.createElement(\"canvas\");\r\n        }\r\n        screenshotCanvas.width = width;\r\n        screenshotCanvas.height = height;\r\n\r\n        const renderContext = screenshotCanvas.getContext(\"2d\");\r\n        const renderingCanvas = engine.getRenderingCanvas();\r\n        if (!renderContext || !renderingCanvas) {\r\n            Logger.Error(\"Failed to create screenshot. Rendering context or rendering canvas is not available.\");\r\n            return;\r\n        }\r\n\r\n        const srcWidth = renderingCanvas.width;\r\n        const srcHeight = renderingCanvas.height;\r\n        const destWidth = screenshotCanvas.width;\r\n        const destHeight = screenshotCanvas.height;\r\n\r\n        // Calculate scale factors for width and height.\r\n        const scaleX = destWidth / srcWidth;\r\n        const scaleY = destHeight / srcHeight;\r\n        // Use the larger of the two scales to fill the screenshot dimensions, else use the smaller to fit.\r\n        const scale = useFill ? Math.max(scaleX, scaleY) : Math.min(scaleX, scaleY);\r\n        const newWidth = srcWidth * scale;\r\n        const newHeight = srcHeight * scale;\r\n\r\n        // Center the image in the screenshot canvas\r\n        const offsetX = (destWidth - newWidth) / 2;\r\n        const offsetY = (destHeight - newHeight) / 2;\r\n\r\n        renderContext.drawImage(renderingCanvas, 0, 0, srcWidth, srcHeight, offsetX, offsetY, newWidth, newHeight);\r\n\r\n        if (forceDownload) {\r\n            Tools.EncodeScreenshotCanvasData(screenshotCanvas, undefined, mimeType, undefined, quality);\r\n            if (successCallback) {\r\n                successCallback(\"\");\r\n            }\r\n        } else {\r\n            Tools.EncodeScreenshotCanvasData(screenshotCanvas, successCallback, mimeType, undefined, quality);\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Captures a screenshot of the current rendering\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG\r\n * @param engine defines the rendering engine\r\n * @param camera defines the source camera. If the camera is not the scene's active camera, {@link CreateScreenshotUsingRenderTarget} will be used instead, and `useFill` will be ignored\r\n * @param size This parameter can be set to a single number or to an object with the\r\n * following (optional) properties: precision, width, height. If a single number is passed,\r\n * it will be used for both width and height. If an object is passed, the screenshot size\r\n * will be derived from the parameters. The precision property is a multiplier allowing\r\n * rendering at a higher or lower resolution\r\n * @param mimeType defines the MIME type of the screenshot image (default: image/png).\r\n * Check your browser for supported MIME types\r\n * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.\r\n * @param useFill fill the screenshot dimensions with the render canvas and clip any overflow. If false, fit the canvas within the screenshot, as in letterboxing.\r\n * @returns screenshot as a string of base64-encoded characters. This string can be assigned\r\n * to the src parameter of an <img> to display it\r\n */\r\nexport function CreateScreenshotAsync(\r\n    engine: AbstractEngine,\r\n    camera: Camera,\r\n    size: IScreenshotSize | number,\r\n    mimeType = \"image/png\",\r\n    quality?: number,\r\n    useFill = false\r\n): Promise<string> {\r\n    return new Promise((resolve, reject) => {\r\n        CreateScreenshot(\r\n            engine,\r\n            camera,\r\n            size,\r\n            (data) => {\r\n                if (typeof data !== \"undefined\") {\r\n                    resolve(data);\r\n                } else {\r\n                    reject(new Error(\"Data is undefined\"));\r\n                }\r\n            },\r\n            mimeType,\r\n            undefined,\r\n            quality,\r\n            useFill\r\n        );\r\n    });\r\n}\r\n\r\n/**\r\n * Captures and automatically downloads a screenshot of the current rendering for a specific size. This will render the entire canvas but will generate a blink (due to canvas resize)\r\n * If screenshot image data is needed, use {@link CreateScreenshotAsync} instead.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG\r\n * @param engine defines the rendering engine\r\n * @param camera defines the source camera. If the camera is not the scene's active camera, {@link CreateScreenshotUsingRenderTarget} will be used instead, and `useFill` will be ignored\r\n * @param width defines the expected width\r\n * @param height defines the expected height\r\n * @param mimeType defines the MIME type of the screenshot image (default: image/png).\r\n * Check your browser for supported MIME types\r\n * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.\r\n * @param useFill fill the screenshot dimensions with the render canvas and clip any overflow. If false, fit the canvas within the screenshot, as in letterboxing.\r\n * @returns promise that resolves once the screenshot is taken\r\n */\r\nexport function CreateScreenshotWithResizeAsync(\r\n    engine: AbstractEngine,\r\n    camera: Camera,\r\n    width: number,\r\n    height: number,\r\n    mimeType = \"image/png\",\r\n    quality?: number,\r\n    useFill = false\r\n): Promise<void> {\r\n    return new Promise((resolve) => {\r\n        CreateScreenshot(\r\n            engine,\r\n            camera,\r\n            { width: width, height: height },\r\n            () => {\r\n                resolve();\r\n            },\r\n            mimeType,\r\n            true,\r\n            quality,\r\n            useFill\r\n        );\r\n    });\r\n}\r\n\r\n/**\r\n * Generates an image screenshot from the specified camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG\r\n * @param engine The engine to use for rendering\r\n * @param camera The camera to use for rendering\r\n * @param size This parameter can be set to a single number or to an object with the\r\n * following (optional) properties: precision, width, height, finalWidth, finalHeight. If a single number is passed,\r\n * it will be used for both width and height, as well as finalWidth, finalHeight. If an object is passed, the screenshot size\r\n * will be derived from the parameters. The precision property is a multiplier allowing\r\n * rendering at a higher or lower resolution\r\n * @param successCallback The callback receives a single parameter which contains the\r\n * screenshot as a string of base64-encoded characters. This string can be assigned to the\r\n * src parameter of an <img> to display it\r\n * @param mimeType The MIME type of the screenshot image (default: image/png).\r\n * Check your browser for supported MIME types\r\n * @param samples Texture samples (default: 1)\r\n * @param antialiasing Whether antialiasing should be turned on or not (default: false)\r\n * @param fileName A name for for the downloaded file.\r\n * @param renderSprites Whether the sprites should be rendered or not (default: false)\r\n * @param enableStencilBuffer Whether the stencil buffer should be enabled or not (default: false)\r\n * @param useLayerMask if the camera's layer mask should be used to filter what should be rendered (default: true)\r\n * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.\r\n * @param customizeTexture An optional callback that can be used to modify the render target texture before taking the screenshot. This can be used, for instance, to enable camera post-processes before taking the screenshot.\r\n * @param customDumpData The function to use to dump the data. If not provided, the default DumpData function will be used.\r\n */\r\nexport function CreateScreenshotUsingRenderTarget(\r\n    engine: AbstractEngine,\r\n    camera: Camera,\r\n    size: IScreenshotSize | number,\r\n    successCallback?: (data: string) => void,\r\n    mimeType = \"image/png\",\r\n    samples = 1,\r\n    antialiasing = false,\r\n    fileName?: string,\r\n    renderSprites = false,\r\n    enableStencilBuffer = false,\r\n    useLayerMask = true,\r\n    quality?: number,\r\n    customizeTexture?: (texture: RenderTargetTexture) => void,\r\n    customDumpData?: (\r\n        width: number,\r\n        height: number,\r\n        data: ArrayBufferView,\r\n        successCallback?: (data: string | ArrayBuffer) => void,\r\n        mimeType?: string,\r\n        fileName?: string,\r\n        invertY?: boolean,\r\n        toArrayBuffer?: boolean,\r\n        quality?: number\r\n    ) => void\r\n): void {\r\n    const { height, width, finalWidth, finalHeight } = _GetScreenshotSize(engine, camera, size);\r\n    const targetTextureSize = { width, height };\r\n\r\n    if (!(height && width)) {\r\n        Logger.Error(\"Invalid 'size' parameter !\");\r\n        return;\r\n    }\r\n\r\n    // Prevent engine to render on screen while we do the screenshot\r\n    engine.skipFrameRender = true;\r\n\r\n    const originalGetRenderWidth = engine.getRenderWidth;\r\n    const originalGetRenderHeight = engine.getRenderHeight;\r\n\r\n    // Override getRenderWidth and getRenderHeight to return the desired size of the render\r\n    // A few internal methods are relying on the canvas size to compute the render size\r\n    // so we need to override these methods to ensure the correct size is used during the preparation of the render\r\n    // as well as the screenshot\r\n    engine.getRenderWidth = (useScreen = false) => {\r\n        if (!useScreen && engine._currentRenderTarget) {\r\n            return engine._currentRenderTarget.width;\r\n        }\r\n\r\n        return width;\r\n    };\r\n    engine.getRenderHeight = (useScreen = false) => {\r\n        if (!useScreen && engine._currentRenderTarget) {\r\n            return engine._currentRenderTarget.height;\r\n        }\r\n\r\n        return height;\r\n    };\r\n\r\n    // Trigger a resize event to ensure the intermediate renders have the correct size\r\n    if (engine.onResizeObservable.hasObservers()) {\r\n        engine.onResizeObservable.notifyObservers(engine);\r\n    }\r\n\r\n    const scene = camera.getScene();\r\n\r\n    // At this point size can be a number, or an object (according to engine.prototype.createRenderTargetTexture method)\r\n    const texture = new RenderTargetTexture(\r\n        \"screenShot\",\r\n        targetTextureSize,\r\n        scene,\r\n        false,\r\n        false,\r\n        Constants.TEXTURETYPE_UNSIGNED_BYTE,\r\n        false,\r\n        Texture.BILINEAR_SAMPLINGMODE,\r\n        undefined,\r\n        enableStencilBuffer,\r\n        undefined,\r\n        undefined,\r\n        undefined,\r\n        samples\r\n    );\r\n    texture.renderList = scene.meshes.slice();\r\n    texture.samples = samples;\r\n    texture.renderSprites = renderSprites;\r\n    texture.activeCamera = camera;\r\n    texture.forceLayerMaskCheck = useLayerMask;\r\n    customizeTexture?.(texture);\r\n\r\n    const dumpDataFunc = customDumpData || DumpData;\r\n\r\n    const renderWhenReady = () => {\r\n        _retryWithInterval(\r\n            () => texture.isReadyForRendering() && camera.isReady(true),\r\n            () => {\r\n                engine.onEndFrameObservable.addOnce(() => {\r\n                    if (finalWidth === width && finalHeight === height) {\r\n                        texture.readPixels(undefined, undefined, undefined, false)!.then((data) => {\r\n                            dumpDataFunc(width, height, data, successCallback as (data: string | ArrayBuffer) => void, mimeType, fileName, true, undefined, quality);\r\n                            texture.dispose();\r\n                        });\r\n                    } else {\r\n                        const importPromise = engine.isWebGPU ? import(\"../ShadersWGSL/pass.fragment\") : import(\"../Shaders/pass.fragment\");\r\n                        importPromise.then(() =>\r\n                            ApplyPostProcess(\"pass\", texture.getInternalTexture()!, scene, undefined, undefined, undefined, finalWidth, finalHeight).then((texture) => {\r\n                                engine._readTexturePixels(texture, finalWidth, finalHeight, -1, 0, null, true, false, 0, 0).then((data) => {\r\n                                    dumpDataFunc(\r\n                                        finalWidth,\r\n                                        finalHeight,\r\n                                        data,\r\n                                        successCallback as (data: string | ArrayBuffer) => void,\r\n                                        mimeType,\r\n                                        fileName,\r\n                                        true,\r\n                                        undefined,\r\n                                        quality\r\n                                    );\r\n                                    texture.dispose();\r\n                                });\r\n                            })\r\n                        );\r\n                    }\r\n                });\r\n                scene.incrementRenderId();\r\n                scene.resetCachedMaterial();\r\n\r\n                // Record the original scene setup\r\n                const originalCamera = scene.activeCamera;\r\n                const originalCameras = scene.activeCameras;\r\n                const originalOutputRenderTarget = camera.outputRenderTarget;\r\n                const originalSpritesEnabled = scene.spritesEnabled;\r\n\r\n                // Swap with the requested one\r\n                scene.activeCamera = camera;\r\n                scene.activeCameras = null;\r\n                camera.outputRenderTarget = texture;\r\n                scene.spritesEnabled = renderSprites;\r\n\r\n                const currentMeshList = scene.meshes;\r\n                scene.meshes = texture.renderList || scene.meshes;\r\n\r\n                // render the scene on the RTT\r\n                try {\r\n                    scene.render();\r\n                } finally {\r\n                    // Restore the original scene camera setup\r\n                    scene.activeCamera = originalCamera;\r\n                    scene.activeCameras = originalCameras;\r\n                    camera.outputRenderTarget = originalOutputRenderTarget;\r\n                    scene.spritesEnabled = originalSpritesEnabled;\r\n                    scene.meshes = currentMeshList;\r\n\r\n                    engine.getRenderWidth = originalGetRenderWidth;\r\n                    engine.getRenderHeight = originalGetRenderHeight;\r\n\r\n                    // Trigger a resize event to ensure the intermediate renders have the correct size\r\n                    if (engine.onResizeObservable.hasObservers()) {\r\n                        engine.onResizeObservable.notifyObservers(engine);\r\n                    }\r\n\r\n                    camera.getProjectionMatrix(true); // Force cache refresh;\r\n\r\n                    engine.skipFrameRender = false;\r\n                }\r\n            },\r\n            () => {\r\n                // Restore engine frame rendering on error\r\n                engine.skipFrameRender = false;\r\n                engine.getRenderWidth = originalGetRenderWidth;\r\n                engine.getRenderHeight = originalGetRenderHeight;\r\n            }\r\n        );\r\n    };\r\n\r\n    const renderToTexture = () => {\r\n        // render the RTT\r\n        scene.incrementRenderId();\r\n        scene.resetCachedMaterial();\r\n\r\n        renderWhenReady();\r\n    };\r\n\r\n    if (antialiasing) {\r\n        const fxaaPostProcess = new FxaaPostProcess(\"antialiasing\", 1.0, scene.activeCamera);\r\n        texture.addPostProcess(fxaaPostProcess);\r\n        // Async Shader Compilation can lead to none ready effects in synchronous code\r\n        fxaaPostProcess.onEffectCreatedObservable.addOnce((e) => {\r\n            if (!e.isReady()) {\r\n                e.onCompiled = () => {\r\n                    renderToTexture();\r\n                };\r\n            }\r\n            // The effect is ready we can render\r\n            else {\r\n                renderToTexture();\r\n            }\r\n        });\r\n    } else {\r\n        // No need to wait for extra resources to be ready\r\n        renderToTexture();\r\n    }\r\n}\r\n\r\n/**\r\n * Generates an image screenshot from the specified camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG\r\n * @param engine The engine to use for rendering\r\n * @param camera The camera to use for rendering\r\n * @param size This parameter can be set to a single number or to an object with the\r\n * following (optional) properties: precision, width, height. If a single number is passed,\r\n * it will be used for both width and height. If an object is passed, the screenshot size\r\n * will be derived from the parameters. The precision property is a multiplier allowing\r\n * rendering at a higher or lower resolution\r\n * @param mimeType The MIME type of the screenshot image (default: image/png).\r\n * Check your browser for supported MIME types\r\n * @param samples Texture samples (default: 1)\r\n * @param antialiasing Whether antialiasing should be turned on or not (default: false)\r\n * @param fileName A name for for the downloaded file.\r\n * @param renderSprites Whether the sprites should be rendered or not (default: false)\r\n * @param enableStencilBuffer Whether the stencil buffer should be enabled or not (default: false)\r\n * @param useLayerMask if the camera's layer mask should be used to filter what should be rendered (default: true)\r\n * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.\r\n * @param customizeTexture An optional callback that can be used to modify the render target texture before taking the screenshot. This can be used, for instance, to enable camera post-processes before taking the screenshot.\r\n * @param customDumpData The function to use to dump the data. If not provided, the default DumpData function will be used.\r\n * @returns screenshot as a string of base64-encoded characters. This string can be assigned\r\n * to the src parameter of an <img> to display it\r\n */\r\nexport function CreateScreenshotUsingRenderTargetAsync(\r\n    engine: AbstractEngine,\r\n    camera: Camera,\r\n    size: IScreenshotSize | number,\r\n    mimeType = \"image/png\",\r\n    samples = 1,\r\n    antialiasing = false,\r\n    fileName?: string,\r\n    renderSprites = false,\r\n    enableStencilBuffer = false,\r\n    useLayerMask = true,\r\n    quality?: number,\r\n    customizeTexture?: (texture: RenderTargetTexture) => void,\r\n    customDumpData?: (\r\n        width: number,\r\n        height: number,\r\n        data: ArrayBufferView,\r\n        successCallback?: (data: string | ArrayBuffer) => void,\r\n        mimeType?: string,\r\n        fileName?: string,\r\n        invertY?: boolean,\r\n        toArrayBuffer?: boolean,\r\n        quality?: number\r\n    ) => void\r\n): Promise<string> {\r\n    return new Promise((resolve, reject) => {\r\n        CreateScreenshotUsingRenderTarget(\r\n            engine,\r\n            camera,\r\n            size,\r\n            (data) => {\r\n                if (typeof data !== \"undefined\") {\r\n                    resolve(data);\r\n                } else {\r\n                    reject(new Error(\"Data is undefined\"));\r\n                }\r\n            },\r\n            mimeType,\r\n            samples,\r\n            antialiasing,\r\n            fileName,\r\n            renderSprites,\r\n            enableStencilBuffer,\r\n            useLayerMask,\r\n            quality,\r\n            customizeTexture,\r\n            customDumpData\r\n        );\r\n    });\r\n}\r\n\r\n/**\r\n * Gets height and width for screenshot size\r\n * @param engine The engine to use for rendering\r\n * @param camera The camera to use for rendering\r\n * @param size This size of the screenshot. can be a number or an object implementing IScreenshotSize\r\n * @returns height and width for screenshot size\r\n */\r\nfunction _GetScreenshotSize(engine: AbstractEngine, camera: Camera, size: IScreenshotSize | number): { height: number; width: number; finalWidth: number; finalHeight: number } {\r\n    let height = 0;\r\n    let width = 0;\r\n    let finalWidth = 0;\r\n    let finalHeight = 0;\r\n\r\n    //If a size value defined as object\r\n    if (typeof size === \"object\") {\r\n        const precision = size.precision\r\n            ? Math.abs(size.precision) // prevent GL_INVALID_VALUE : glViewport: negative width/height\r\n            : 1;\r\n\r\n        //If a width and height values is specified\r\n        if (size.width && size.height) {\r\n            height = size.height * precision;\r\n            width = size.width * precision;\r\n        }\r\n        //If passing only width, computing height to keep display canvas ratio.\r\n        else if (size.width && !size.height) {\r\n            width = size.width * precision;\r\n            height = Math.round(width / engine.getAspectRatio(camera));\r\n        }\r\n        //If passing only height, computing width to keep display canvas ratio.\r\n        else if (size.height && !size.width) {\r\n            height = size.height * precision;\r\n            width = Math.round(height * engine.getAspectRatio(camera));\r\n        } else {\r\n            width = Math.round(engine.getRenderWidth() * precision);\r\n            height = Math.round(width / engine.getAspectRatio(camera));\r\n        }\r\n\r\n        //If a finalWidth and finalHeight values is specified\r\n        if (size.finalWidth && size.finalHeight) {\r\n            finalHeight = size.finalHeight;\r\n            finalWidth = size.finalWidth;\r\n        }\r\n        //If passing only finalWidth, computing finalHeight to keep display canvas ratio.\r\n        else if (size.finalWidth && !size.finalHeight) {\r\n            finalWidth = size.finalWidth;\r\n            finalHeight = Math.round(finalWidth / engine.getAspectRatio(camera));\r\n        }\r\n        //If passing only finalHeight, computing finalWidth to keep display canvas ratio.\r\n        else if (size.finalHeight && !size.finalWidth) {\r\n            finalHeight = size.finalHeight;\r\n            finalWidth = Math.round(finalHeight * engine.getAspectRatio(camera));\r\n        } else {\r\n            finalWidth = width;\r\n            finalHeight = height;\r\n        }\r\n    }\r\n    //Assuming here that \"size\" parameter is a number\r\n    else if (!isNaN(size)) {\r\n        height = size;\r\n        width = size;\r\n        finalWidth = size;\r\n        finalHeight = size;\r\n    }\r\n\r\n    // When creating the image data from the CanvasRenderingContext2D, the width and height is clamped to the size of the _gl context\r\n    // On certain GPUs, it seems as if the _gl context truncates to an integer automatically. Therefore, if a user tries to pass the width of their canvas element\r\n    // and it happens to be a float (1000.5 x 600.5 px), the engine.readPixels will return a different size array than context.createImageData\r\n    // to resolve this, we truncate the floats here to ensure the same size\r\n    if (width) {\r\n        width = Math.floor(width);\r\n    }\r\n    if (height) {\r\n        height = Math.floor(height);\r\n    }\r\n    if (finalWidth) {\r\n        finalWidth = Math.floor(finalWidth);\r\n    }\r\n    if (finalHeight) {\r\n        finalHeight = Math.floor(finalHeight);\r\n    }\r\n\r\n    return { height: height | 0, width: width | 0, finalWidth: finalWidth | 0, finalHeight: finalHeight | 0 };\r\n}\r\n\r\n/**\r\n * Class containing a set of static utilities functions for screenshots\r\n */\r\nexport const ScreenshotTools = {\r\n    /**\r\n     * Captures a screenshot of the current rendering\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG\r\n     * @param engine defines the rendering engine\r\n     * @param camera defines the source camera. If the camera is not the scene's active camera, {@link CreateScreenshotUsingRenderTarget} will be used instead, and `useFill` will be ignored\r\n     * @param size This parameter can be set to a single number or to an object with the\r\n     * following (optional) properties: precision, width, height. If a single number is passed,\r\n     * it will be used for both width and height. If an object is passed, the screenshot size\r\n     * will be derived from the parameters. The precision property is a multiplier allowing\r\n     * rendering at a higher or lower resolution\r\n     * @param successCallback defines the callback receives a single parameter which contains the\r\n     * screenshot as a string of base64-encoded characters. This string can be assigned to the\r\n     * src parameter of an <img> to display it\r\n     * @param mimeType defines the MIME type of the screenshot image (default: image/png).\r\n     * Check your browser for supported MIME types\r\n     * @param forceDownload force the system to download the image even if a successCallback is provided\r\n     * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.\r\n     * @param useFill fill the screenshot dimensions with the render canvas and clip any overflow. If false, fit the canvas within the screenshot, as in letterboxing.\r\n     */\r\n    CreateScreenshot,\r\n\r\n    /**\r\n     * Captures a screenshot of the current rendering\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG\r\n     * @param engine defines the rendering engine\r\n     * @param camera defines the source camera. If the camera is not the scene's active camera, {@link CreateScreenshotUsingRenderTarget} will be used instead, and `useFill` will be ignored\r\n     * @param size This parameter can be set to a single number or to an object with the\r\n     * following (optional) properties: precision, width, height. If a single number is passed,\r\n     * it will be used for both width and height. If an object is passed, the screenshot size\r\n     * will be derived from the parameters. The precision property is a multiplier allowing\r\n     * rendering at a higher or lower resolution\r\n     * @param mimeType defines the MIME type of the screenshot image (default: image/png).\r\n     * Check your browser for supported MIME types\r\n     * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.\r\n     * @param useFill fill the screenshot dimensions with the render canvas and clip any overflow. If false, fit the canvas within the screenshot, as in letterboxing.\r\n     * @returns screenshot as a string of base64-encoded characters. This string can be assigned\r\n     * to the src parameter of an <img> to display it\r\n     */\r\n    CreateScreenshotAsync,\r\n\r\n    /**\r\n     * Captures and automatically downloads a screenshot of the current rendering for a specific size. This will render the entire canvas but will generate a blink (due to canvas resize)\r\n     * If screenshot image data is needed, use {@link CreateScreenshotAsync} instead.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG\r\n     * @param engine defines the rendering engine\r\n     * @param camera defines the source camera. If the camera is not the scene's active camera, {@link CreateScreenshotUsingRenderTarget} will be used instead, and `useFill` will be ignored\r\n     * @param width defines the expected width\r\n     * @param height defines the expected height\r\n     * @param mimeType defines the MIME type of the screenshot image (default: image/png).\r\n     * Check your browser for supported MIME types\r\n     * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.\r\n     * @param useFill fill the screenshot dimensions with the render canvas and clip any overflow. If false, fit the canvas within the screenshot, as in letterboxing.\r\n     * @returns promise that resolves once the screenshot is taken\r\n     */\r\n    CreateScreenshotWithResizeAsync,\r\n\r\n    /**\r\n     * Generates an image screenshot from the specified camera.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG\r\n     * @param engine The engine to use for rendering\r\n     * @param camera The camera to use for rendering\r\n     * @param size This parameter can be set to a single number or to an object with the\r\n     * following (optional) properties: precision, width, height. If a single number is passed,\r\n     * it will be used for both width and height. If an object is passed, the screenshot size\r\n     * will be derived from the parameters. The precision property is a multiplier allowing\r\n     * rendering at a higher or lower resolution\r\n     * @param successCallback The callback receives a single parameter which contains the\r\n     * screenshot as a string of base64-encoded characters. This string can be assigned to the\r\n     * src parameter of an <img> to display it\r\n     * @param mimeType The MIME type of the screenshot image (default: image/png).\r\n     * Check your browser for supported MIME types\r\n     * @param samples Texture samples (default: 1)\r\n     * @param antialiasing Whether antialiasing should be turned on or not (default: false)\r\n     * @param fileName A name for for the downloaded file.\r\n     * @param renderSprites Whether the sprites should be rendered or not (default: false)\r\n     * @param enableStencilBuffer Whether the stencil buffer should be enabled or not (default: false)\r\n     * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.\r\n     */\r\n    CreateScreenshotUsingRenderTarget,\r\n\r\n    /**\r\n     * Generates an image screenshot from the specified camera.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG\r\n     * @param engine The engine to use for rendering\r\n     * @param camera The camera to use for rendering\r\n     * @param size This parameter can be set to a single number or to an object with the\r\n     * following (optional) properties: precision, width, height. If a single number is passed,\r\n     * it will be used for both width and height. If an object is passed, the screenshot size\r\n     * will be derived from the parameters. The precision property is a multiplier allowing\r\n     * rendering at a higher or lower resolution\r\n     * @param mimeType The MIME type of the screenshot image (default: image/png).\r\n     * Check your browser for supported MIME types\r\n     * @param samples Texture samples (default: 1)\r\n     * @param antialiasing Whether antialiasing should be turned on or not (default: false)\r\n     * @param fileName A name for for the downloaded file.\r\n     * @param renderSprites Whether the sprites should be rendered or not (default: false)\r\n     * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.\r\n     * @returns screenshot as a string of base64-encoded characters. This string can be assigned\r\n     * to the src parameter of an <img> to display it\r\n     */\r\n    CreateScreenshotUsingRenderTargetAsync,\r\n};\r\n\r\n/**\r\n * This will be executed automatically for UMD and es5.\r\n * If esm dev wants the side effects to execute they will have to run it manually\r\n * Once we build native modules those need to be exported.\r\n * @internal\r\n */\r\nconst initSideEffects = () => {\r\n    // References the dependencies.\r\n    Tools.CreateScreenshot = CreateScreenshot;\r\n    Tools.CreateScreenshotAsync = CreateScreenshotAsync;\r\n    Tools.CreateScreenshotUsingRenderTarget = CreateScreenshotUsingRenderTarget;\r\n    Tools.CreateScreenshotUsingRenderTargetAsync = CreateScreenshotUsingRenderTargetAsync;\r\n};\r\n\r\ninitSideEffects();\r\n"]}