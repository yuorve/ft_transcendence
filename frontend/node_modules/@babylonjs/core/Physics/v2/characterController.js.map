{"version":3,"file":"characterController.js","sourceRoot":"","sources":["../../../../../dev/core/src/Physics/v2/characterController.ts"],"names":[],"mappings":"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","sourcesContent":["import { Vector3, Quaternion, Matrix, TmpVectors } from \"../../Maths/math.vector\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { DeepImmutableObject } from \"../../types\";\r\nimport type { PhysicsBody } from \"./physicsBody\";\r\nimport { PhysicsShapeCapsule, type PhysicsShape } from \"./physicsShape\";\r\nimport { PhysicsMotionType } from \"./IPhysicsEnginePlugin\";\r\nimport type { HavokPlugin } from \"./Plugins/havokPlugin\";\r\nimport { BuildArray } from \"core/Misc/arrayTools\";\r\n\r\n/**\r\n * Shape properties for the character controller\r\n */\r\nexport interface CharacterShapeOptions {\r\n    /**\r\n     * optional shape used for collision detection\r\n     */\r\n    shape?: PhysicsShape;\r\n    /**\r\n     * capsule height for the capsule shape if no shape is provided\r\n     */\r\n    capsuleHeight?: number;\r\n    /**\r\n     * capsule radius for the capsule shape if no shape is provided\r\n     */\r\n    capsuleRadius?: number;\r\n}\r\n/**\r\n * State of the character on the surface\r\n */\r\nexport const enum CharacterSupportedState {\r\n    UNSUPPORTED,\r\n    SLIDING,\r\n    SUPPORTED,\r\n}\r\n\r\n/**\r\n * Surface information computed by checkSupport method\r\n */\r\nexport interface CharacterSurfaceInfo {\r\n    /**\r\n     * Indicates whether the surface is dynamic.\r\n     * A dynamic surface is one that can change its properties over time,\r\n     * such as moving platforms or surfaces that can be affected by external forces.\r\n     * surfaceInfo.supportedState is always CharacterSupportedState.SUPPORTED when isSurfaceDynamic is true.\r\n     */\r\n    isSurfaceDynamic: boolean;\r\n    /**\r\n     * The supported state of the character on the surface.\r\n     */\r\n    supportedState: CharacterSupportedState;\r\n    /**\r\n     * The average normal vector of the surface.\r\n     * This vector is perpendicular to the surface and points outwards.\r\n     */\r\n    averageSurfaceNormal: Vector3;\r\n    /**\r\n     * The average velocity of the surface.\r\n     * This vector represents the speed and direction in which the surface is moving.\r\n     */\r\n    averageSurfaceVelocity: Vector3;\r\n    /**\r\n     * The average angular velocity of the surface.\r\n     */\r\n    averageAngularSurfaceVelocity: Vector3;\r\n}\r\n\r\n/** @internal */\r\ninterface Contact {\r\n    /** @internal */\r\n    position: Vector3;\r\n    /** @internal */\r\n    normal: Vector3;\r\n    /** @internal */\r\n    distance: number;\r\n    /** @internal */\r\n    fraction: number;\r\n    /** @internal */\r\n    bodyB: { body: PhysicsBody; index: number };\r\n    /** @internal */\r\n    allowedPenetration: number;\r\n}\r\n\r\n/** @internal */\r\ninterface SurfaceConstraintInfo {\r\n    /** @internal */\r\n    planeNormal: Vector3;\r\n    /** @internal */\r\n    planeDistance: number;\r\n    /** @internal */\r\n    velocity: Vector3;\r\n    /** @internal */\r\n    angularVelocity: Vector3;\r\n    /** @internal */\r\n    staticFriction: number;\r\n    /** @internal */\r\n    extraUpStaticFriction: number;\r\n    /** @internal */\r\n    extraDownStaticFriction: number;\r\n    /** @internal */\r\n    dynamicFriction: number;\r\n    /** @internal */\r\n    priority: number;\r\n}\r\n\r\n/** @internal */\r\nconst enum SurfaceConstraintInteractionStatus {\r\n    OK,\r\n    FAILURE_3D,\r\n    FAILURE_2D,\r\n}\r\n\r\n/** @internal */\r\ninterface SurfaceConstraintInteraction {\r\n    /** @internal */\r\n    touched: boolean;\r\n    /** @internal */\r\n    stopped: boolean;\r\n    /** @internal */\r\n    surfaceTime: number;\r\n    /** @internal */\r\n    penaltyDistance: number;\r\n    /** @internal */\r\n    status: SurfaceConstraintInteractionStatus;\r\n}\r\n\r\n/** @internal */\r\nclass SimplexSolverOutput {\r\n    /** @internal */\r\n    public position: Vector3;\r\n    /** @internal */\r\n    public velocity: Vector3;\r\n    /** @internal */\r\n    public deltaTime: number;\r\n    /** @internal */\r\n    public planeInteractions: SurfaceConstraintInteraction[];\r\n}\r\n\r\n/** @internal */\r\nclass SimplexSolverActivePlanes {\r\n    /** @internal */\r\n    public index: number;\r\n    /** @internal */\r\n    public constraint: SurfaceConstraintInfo;\r\n    /** @internal */\r\n    public interaction: SurfaceConstraintInteraction;\r\n\r\n    /** @internal */\r\n    public copyFrom(other: SimplexSolverActivePlanes) {\r\n        this.index = other.index;\r\n        this.constraint = other.constraint;\r\n        this.interaction = other.interaction;\r\n    }\r\n}\r\n\r\n/** @internal */\r\nclass SimplexSolverInfo {\r\n    /** @internal */\r\n    public supportPlanes: Array<SimplexSolverActivePlanes> = new Array<SimplexSolverActivePlanes>(4);\r\n    /** @internal */\r\n    public numSupportPlanes: number = 0;\r\n    /** @internal */\r\n    public currentTime: number = 0;\r\n    /** @internal */\r\n    public inputConstraints: SurfaceConstraintInfo[];\r\n    /** @internal */\r\n    public outputInteractions: SurfaceConstraintInteraction[];\r\n    /** @internal */\r\n    public getOutput(constraint: SurfaceConstraintInfo): SurfaceConstraintInteraction {\r\n        return this.outputInteractions[this.inputConstraints.indexOf(constraint)]; //<todo.eoin This is O(1) in C++! Equivalent in TS?\r\n    }\r\n}\r\n\r\n/** @internal */\r\nfunction contactFromCast(hp: HavokPlugin, cp: any /*ContactPoint*/, castPath: Vector3, hitFraction: number, keepDistance: number): Contact {\r\n    //@ts-ignore\r\n    const bodyMap = hp._bodies;\r\n\r\n    const normal = Vector3.FromArray(cp[4]);\r\n    const dist = -hitFraction * castPath.dot(normal);\r\n    return {\r\n        position: Vector3.FromArray(cp[3]),\r\n        normal: normal,\r\n        distance: dist,\r\n        fraction: hitFraction,\r\n        bodyB: bodyMap.get(cp[0][0])!,\r\n        allowedPenetration: Math.min(Math.max(keepDistance - dist, 0.0), keepDistance),\r\n    };\r\n}\r\n\r\n/**\r\n * Character controller using physics\r\n */\r\nexport class PhysicsCharacterController {\r\n    private _position: Vector3;\r\n    private _orientation: Quaternion = Quaternion.Identity();\r\n    private _velocity: Vector3;\r\n    private _lastVelocity: Vector3;\r\n    private _shape: PhysicsShape;\r\n    private _manifold: Contact[] = [];\r\n    private _lastDisplacement: Vector3;\r\n    private _contactAngleSensitivity = 10.0;\r\n    private _lastInvDeltaTime: number;\r\n    private _scene: Scene;\r\n    private _tmpMatrix = new Matrix();\r\n    private _tmpVecs: Vector3[] = BuildArray(31, Vector3.Zero);\r\n\r\n    /**\r\n     * minimum distance to make contact\r\n     * default 0.05\r\n     */\r\n    public keepDistance: number = 0.05;\r\n    /**\r\n     * maximum distance to keep contact\r\n     * default 0.1\r\n     */\r\n    public keepContactTolerance: number = 0.1;\r\n    /**\r\n     * maximum number of raycast per integration starp\r\n     * default 10\r\n     */\r\n    public maxCastIterations: number = 10;\r\n    /**\r\n     * speed when recovery from penetration\r\n     * default 1.0\r\n     */\r\n    public penetrationRecoverySpeed = 1.0;\r\n    /**\r\n     * friction with static surfaces\r\n     * default 0\r\n     */\r\n    public staticFriction = 0;\r\n    /**\r\n     * friction with dynamic surfaces\r\n     * default 1\r\n     */\r\n    public dynamicFriction = 1;\r\n    /**\r\n     * cosine value of slop angle that can be climbed\r\n     * computed as `Math.cos(Math.PI * (angleInDegree / 180.0));`\r\n     * default 0.5 (value for a 60deg angle)\r\n     */\r\n    public maxSlopeCosine = 0.5;\r\n    /**\r\n     * character maximum speed\r\n     * default 10\r\n     */\r\n    public maxCharacterSpeedForSolver = 10.0;\r\n    /**\r\n     * up vector\r\n     */\r\n    public up = new Vector3(0, 1, 0);\r\n    /**\r\n     * Strength when pushing other bodies\r\n     * default 1e38\r\n     */\r\n    public characterStrength = 1e38;\r\n\r\n    /**\r\n     * Acceleration factor. A value of 1 means reaching max velocity immediately\r\n     */\r\n    public acceleration = 0.05;\r\n\r\n    /**\r\n     * maximum acceleration in world space coordinate\r\n     */\r\n    public maxAcceleration = 50;\r\n\r\n    /**\r\n     * character mass\r\n     * default 0\r\n     */\r\n    public characterMass = 0;\r\n    private _startCollector;\r\n    private _castCollector;\r\n\r\n    /**\r\n     * instanciate a new characterController\r\n     * @param position Initial position\r\n     * @param characterShapeOptions character physics shape options\r\n     * @param scene Scene\r\n     */\r\n    public constructor(position: Vector3, characterShapeOptions: CharacterShapeOptions, scene: Scene) {\r\n        this._position = position.clone();\r\n        this._velocity = Vector3.Zero();\r\n        this._lastVelocity = Vector3.Zero();\r\n        const r = characterShapeOptions.capsuleRadius ?? 0.6;\r\n        const h = characterShapeOptions.capsuleHeight ?? 1.8;\r\n        this._tmpVecs[0].set(0, h * 0.5 - r, 0);\r\n        this._tmpVecs[1].set(0, -h * 0.5 + r, 0);\r\n        this._shape = characterShapeOptions.shape ?? new PhysicsShapeCapsule(this._tmpVecs[0], this._tmpVecs[1], r, scene);\r\n        this._lastInvDeltaTime = 1.0 / 60.0;\r\n        this._lastDisplacement = Vector3.Zero();\r\n        this._scene = scene;\r\n\r\n        const hk = this._scene.getPhysicsEngine()!.getPhysicsPlugin() as HavokPlugin;\r\n        const hknp = hk._hknp;\r\n\r\n        this._startCollector = hknp.HP_QueryCollector_Create(16)[1];\r\n        this._castCollector = hknp.HP_QueryCollector_Create(16)[1];\r\n    }\r\n\r\n    /**\r\n     * Character position\r\n     * @returns Character position\r\n     */\r\n    public getPosition(): Vector3 {\r\n        return this._position;\r\n    }\r\n\r\n    /**\r\n     * Character velocity\r\n     * @returns Character velocity vector\r\n     */\r\n    public getVelocity(): Vector3 {\r\n        return this._velocity;\r\n    }\r\n\r\n    /**\r\n     * Set velocity vector\r\n     * @param velocity vector\r\n     */\r\n    public setVelocity(velocity: Vector3) {\r\n        this._velocity.copyFrom(velocity);\r\n    }\r\n\r\n    protected _validateManifold() {\r\n        const newManifold = [];\r\n        for (let i = 0; i < this._manifold.length; i++) {\r\n            if (!this._manifold[i].bodyB.body.isDisposed) {\r\n                newManifold.push(this._manifold[i]);\r\n            }\r\n        }\r\n        this._manifold = newManifold;\r\n    }\r\n\r\n    private _getPointVelocityToRef(body: { body: PhysicsBody; index: number }, pointWorld: Vector3, result: Vector3) {\r\n        //<todo does this really not exist in body interface?\r\n        const comWorld = this._tmpVecs[10];\r\n        this._getComWorldToRef(body, comWorld);\r\n        const relPos = this._tmpVecs[11];\r\n        pointWorld.subtractToRef(comWorld, relPos);\r\n        const av = this._tmpVecs[12];\r\n        body.body.getAngularVelocityToRef(av, body.index);\r\n        const arm = this._tmpVecs[13];\r\n        Vector3.CrossToRef(av, relPos, arm);\r\n        arm.addToRef(body.body.getLinearVelocity(body.index), result);\r\n    }\r\n\r\n    protected _compareContacts(contactA: Contact, contactB: Contact): number {\r\n        const angSquared = (1.0 - contactA.normal.dot(contactB.normal)) * this._contactAngleSensitivity * this._contactAngleSensitivity;\r\n        const planeDistSquared = (contactA.distance - contactB.distance) * (contactA.distance * contactB.distance);\r\n\r\n        const p1Vel = this._tmpVecs[7];\r\n        this._getPointVelocityToRef(contactA.bodyB, contactA.position, p1Vel);\r\n        const p2Vel = this._tmpVecs[8];\r\n        this._getPointVelocityToRef(contactB.bodyB, contactB.position, p2Vel);\r\n        const velocityDiff = this._tmpVecs[9];\r\n        p1Vel.subtractToRef(p2Vel, velocityDiff);\r\n        const velocityDiffSquared = velocityDiff.lengthSquared();\r\n\r\n        const fitness = angSquared * 10.0 + velocityDiffSquared * 0.1 + planeDistSquared;\r\n        return fitness;\r\n    }\r\n\r\n    protected _findContact(referenceContact: Contact, contactList: Contact[], threshold: number) {\r\n        let bestIdx = -1;\r\n        let bestFitness = threshold;\r\n        for (let i = 0; i < contactList.length; i++) {\r\n            const fitness = this._compareContacts(referenceContact, contactList[i]);\r\n            if (fitness < bestFitness) {\r\n                bestFitness = fitness;\r\n                bestIdx = i;\r\n            }\r\n        }\r\n        return bestIdx;\r\n    }\r\n\r\n    protected _updateManifold(startCollector: any /*HP_CollectorId*/, castCollector: any /*HP_CollectorId*/, castPath: Vector3): number {\r\n        const hk = this._scene.getPhysicsEngine()!.getPhysicsPlugin() as HavokPlugin;\r\n        const hknp = hk._hknp;\r\n\r\n        const numProximityHits = hknp.HP_QueryCollector_GetNumHits(startCollector)[1];\r\n        if (numProximityHits > 0) {\r\n            const newContacts = [];\r\n            let minDistance = 1e38;\r\n            const bodyMap = (<any>hk)._bodies;\r\n            for (let i = 0; i < numProximityHits; i++) {\r\n                const [distance, , contactWorld] = hknp.HP_QueryCollector_GetShapeProximityResult(startCollector, i)[1];\r\n                minDistance = Math.min(minDistance, distance);\r\n                newContacts.push({\r\n                    position: Vector3.FromArray(contactWorld[3]),\r\n                    normal: Vector3.FromArray(contactWorld[4]),\r\n                    distance: distance,\r\n                    fraction: 0,\r\n                    bodyB: bodyMap.get(contactWorld[0][0])!,\r\n                    allowedPenetration: Math.min(Math.max(this.keepDistance - distance, 0.0), this.keepDistance),\r\n                });\r\n            }\r\n\r\n            for (let i = this._manifold.length - 1; i >= 0; i--) {\r\n                const currentContact = this._manifold[i];\r\n                const bestMatch = this._findContact(currentContact, newContacts, 1.1);\r\n                if (bestMatch >= 0) {\r\n                    const newAllowedPenetration = Math.min(Math.max(this.keepDistance - newContacts[bestMatch].distance, 0.0), currentContact.allowedPenetration);\r\n                    this._manifold[i] = newContacts[bestMatch];\r\n                    this._manifold[i].allowedPenetration = newAllowedPenetration;\r\n                    newContacts.splice(bestMatch, 1);\r\n                } else {\r\n                    this._manifold.splice(i, 1);\r\n                }\r\n            }\r\n\r\n            const closestContactIndex = newContacts.findIndex((c) => c.distance == minDistance);\r\n            if (closestContactIndex >= 0) {\r\n                const bestMatch = this._findContact(newContacts[closestContactIndex], this._manifold, 0.1);\r\n                if (bestMatch >= 0) {\r\n                    const newAllowedPenetration = Math.min(\r\n                        Math.max(this.keepDistance - newContacts[closestContactIndex].distance, 0.0),\r\n                        this._manifold[bestMatch].allowedPenetration\r\n                    );\r\n                    this._manifold[bestMatch] = newContacts[closestContactIndex];\r\n                    this._manifold[bestMatch].allowedPenetration = newAllowedPenetration;\r\n                } else {\r\n                    this._manifold.push(newContacts[closestContactIndex]);\r\n                }\r\n            }\r\n        } else {\r\n            // No start hits; clear manifold completely\r\n            this._manifold.length = 0;\r\n        }\r\n\r\n        let numHitBodies = 0; //< == CASTCOLLECTOR_HIT_SINGLE_BODY\r\n        // Process shape cast results if any\r\n        const numCastHits = hknp.HP_QueryCollector_GetNumHits(castCollector)[1];\r\n        if (numCastHits > 0) {\r\n            let closestHitBody = null;\r\n            for (let i = 0; i < numCastHits; i++) {\r\n                const [fraction, , hitWorld] = hknp.HP_QueryCollector_GetShapeCastResult(castCollector, i)[1];\r\n                if (closestHitBody == null) {\r\n                    const contact = contactFromCast(hk, hitWorld, castPath, fraction, this.keepDistance);\r\n                    closestHitBody = hitWorld[0][0];\r\n                    const bestMatch = this._findContact(contact, this._manifold, 0.1);\r\n                    if (bestMatch == -1) {\r\n                        this._manifold.push(contact);\r\n                    }\r\n\r\n                    if (contact.bodyB.body.getMotionType(contact.bodyB.index) == PhysicsMotionType.STATIC) {\r\n                        // The closest body is static, so it cannot move away from CC and we don't need to look any further.\r\n                        break;\r\n                    }\r\n                } else if (closestHitBody._pluginData && hitWorld[0] != closestHitBody._pluginData.hpBodyId) {\r\n                    numHitBodies++;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Remove from the manifold contacts that are too similar as the simplex does not handle parallel planes\r\n        for (let e1 = this._manifold.length - 1; e1 >= 0; e1--) {\r\n            let e2 = e1 - 1;\r\n            for (; e2 >= 0; e2--) {\r\n                const fitness = this._compareContacts(this._manifold[e1], this._manifold[e2]);\r\n                if (fitness < 0.1) break;\r\n            }\r\n            if (e2 >= 0) {\r\n                this._manifold.slice(e1, 1);\r\n            }\r\n        }\r\n\r\n        return numHitBodies;\r\n    }\r\n\r\n    protected _createSurfaceConstraint(contact: Contact, timeTravelled: number): SurfaceConstraintInfo {\r\n        const constraint = {\r\n            //let distance = contact.distance - this.keepDistance;\r\n            planeNormal: contact.normal.clone(),\r\n            planeDistance: contact.distance,\r\n            staticFriction: this.staticFriction,\r\n            dynamicFriction: this.dynamicFriction,\r\n            extraUpStaticFriction: 0,\r\n            extraDownStaticFriction: 0,\r\n            velocity: Vector3.Zero(),\r\n            angularVelocity: Vector3.Zero(),\r\n            priority: 0,\r\n        };\r\n\r\n        const maxSlopeCosEps = 0.1;\r\n        const maxSlopeCosine = Math.max(this.maxSlopeCosine, maxSlopeCosEps);\r\n        const normalDotUp = contact.normal.dot(this.up);\r\n\r\n        const contactPosition = contact.position.clone();\r\n        if (normalDotUp > maxSlopeCosine) {\r\n            const com = this.getPosition();\r\n            const contactArm = this._tmpVecs[20];\r\n            contact.position.subtractToRef(com, contactArm);\r\n            const scale = contact.normal.dot(contactArm);\r\n            contactPosition.x = com.x + this.up.x * scale;\r\n            contactPosition.y = com.y + this.up.y * scale;\r\n            contactPosition.z = com.z + this.up.z * scale;\r\n        }\r\n\r\n        const motionType = contact.bodyB.body.getMotionType(contact.bodyB.index);\r\n        if (motionType != PhysicsMotionType.STATIC) {\r\n            //<todo Need hknpMotionUtil::predictPontVelocity\r\n        }\r\n\r\n        const shift = constraint.velocity.dot(constraint.planeNormal) * timeTravelled;\r\n        constraint.planeDistance -= shift;\r\n\r\n        if (motionType == PhysicsMotionType.STATIC) {\r\n            constraint.priority = 2;\r\n        } else if (motionType == PhysicsMotionType.ANIMATED) {\r\n            constraint.priority = 1;\r\n        }\r\n\r\n        return constraint;\r\n    }\r\n\r\n    protected _addMaxSlopePlane(maxSlopeCos: number, up: Vector3, index: number, constraints: SurfaceConstraintInfo[], allowedPenetration: number): boolean {\r\n        const verticalComponent = constraints[index].planeNormal.dot(up);\r\n        if (verticalComponent > 0.01 && verticalComponent < maxSlopeCos) {\r\n            const newConstraint = {\r\n                planeNormal: constraints[index].planeNormal.clone(),\r\n                planeDistance: constraints[index].planeDistance,\r\n                velocity: constraints[index].velocity.clone(),\r\n                angularVelocity: constraints[index].angularVelocity.clone(),\r\n                priority: constraints[index].priority,\r\n                dynamicFriction: constraints[index].dynamicFriction,\r\n                staticFriction: constraints[index].staticFriction,\r\n                extraDownStaticFriction: constraints[index].extraDownStaticFriction,\r\n                extraUpStaticFriction: constraints[index].extraUpStaticFriction,\r\n            };\r\n            const distance = newConstraint.planeDistance;\r\n            newConstraint.planeNormal.subtractInPlace(up.scale(verticalComponent));\r\n            newConstraint.planeNormal.normalize();\r\n            if (distance >= 0) {\r\n                newConstraint.planeDistance = distance * newConstraint.planeNormal.dot(constraints[index].planeNormal);\r\n            } else {\r\n                const penetrationToResolve = Math.min(0, distance + allowedPenetration);\r\n                newConstraint.planeDistance = penetrationToResolve / newConstraint.planeNormal.dot(constraints[index].planeNormal);\r\n                constraints[index].planeDistance = 0;\r\n                this._resolveConstraintPenetration(newConstraint, this.penetrationRecoverySpeed);\r\n            }\r\n            constraints.push(newConstraint);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    protected _resolveConstraintPenetration(constraint: SurfaceConstraintInfo, penetrationRecoverySpeed: number) {\r\n        // If penetrating we add extra velocity to push the character back out\r\n        const eps = 1e-6;\r\n        if (constraint.planeDistance < -eps) {\r\n            constraint.planeNormal.scaleToRef(constraint.planeDistance * penetrationRecoverySpeed, this._tmpVecs[6]);\r\n            constraint.velocity.subtractInPlace(this._tmpVecs[6]);\r\n        }\r\n    }\r\n\r\n    protected _createConstraintsFromManifold(dt: number, timeTravelled: number): SurfaceConstraintInfo[] {\r\n        const constraints = [];\r\n        for (let i = 0; i < this._manifold.length; i++) {\r\n            const surfaceConstraint = this._createSurfaceConstraint(this._manifold[i], timeTravelled);\r\n            constraints.push(surfaceConstraint);\r\n            this._addMaxSlopePlane(this.maxSlopeCosine, this.up, i, constraints, this._manifold[i].allowedPenetration);\r\n            this._resolveConstraintPenetration(surfaceConstraint, this.penetrationRecoverySpeed);\r\n        }\r\n        return constraints;\r\n    }\r\n\r\n    protected _simplexSolverSortInfo(info: SimplexSolverInfo) {\r\n        // simple bubble sort by (priority,velocity)\r\n        for (let i = 0; i < info.numSupportPlanes - 1; i++) {\r\n            for (let j = i + 1; j < info.numSupportPlanes; j++) {\r\n                const p0 = info.supportPlanes[i];\r\n                const p1 = info.supportPlanes[j];\r\n                if (p0.constraint.priority < p1.constraint.priority) {\r\n                    continue;\r\n                }\r\n                if (p0.constraint.priority == p1.constraint.priority) {\r\n                    const vel0 = p0.constraint.velocity.lengthSquared();\r\n                    const vel1 = p1.constraint.velocity.lengthSquared();\r\n                    if (vel0 < vel1) {\r\n                        continue;\r\n                    }\r\n                }\r\n                info.supportPlanes[i] = p1;\r\n                info.supportPlanes[j] = p0;\r\n            }\r\n        }\r\n    }\r\n\r\n    protected _simplexSolverSolve1d(info: SimplexSolverInfo, sci: SurfaceConstraintInfo, velocityIn: Vector3, velocityOut: Vector3) {\r\n        const eps = 1e-5;\r\n        const groundVelocity = sci.velocity;\r\n        const relativeVelocity = this._tmpVecs[22];\r\n        velocityIn.subtractToRef(groundVelocity, relativeVelocity);\r\n\r\n        const planeVel = relativeVelocity.dot(sci.planeNormal);\r\n\r\n        const origVelocity2 = relativeVelocity.lengthSquared();\r\n        relativeVelocity.subtractInPlace(sci.planeNormal.scale(planeVel));\r\n        {\r\n            const vp2 = planeVel * planeVel;\r\n            // static friction is active if\r\n            //  velProjPlane * friction > |(velParallel)|\r\n            //      vplane   *     f    >         vpar\r\n            //      vp       *     f    >         vpar\r\n            //      vp2      *     f2   >         vpar2\r\n            const extraStaticFriction = relativeVelocity.dot(this.up) > 0 ? sci.extraUpStaticFriction : sci.extraDownStaticFriction;\r\n            if (extraStaticFriction > 0) {\r\n                const horizontal = this.up.cross(sci.planeNormal);\r\n                const hor2 = horizontal.lengthSquared();\r\n                let horVel = 0.0;\r\n                if (hor2 > eps) {\r\n                    horizontal.scaleInPlace(1 / Math.sqrt(hor2));\r\n\r\n                    horVel = relativeVelocity.dot(horizontal);\r\n\r\n                    // horizontal component\r\n                    {\r\n                        const horVel2 = horVel * horVel;\r\n                        const f2 = sci.staticFriction * sci.staticFriction;\r\n                        if (vp2 * f2 >= horVel2) {\r\n                            relativeVelocity.subtractInPlace(horizontal.scale(horVel));\r\n                            horVel = 0;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // vert component\r\n                {\r\n                    const vertVel2 = origVelocity2 - horVel * horVel - vp2;\r\n                    const f2 = (sci.staticFriction + extraStaticFriction) * (sci.staticFriction + extraStaticFriction);\r\n                    if (vp2 * f2 >= vertVel2) {\r\n                        if (horVel == 0.0) {\r\n                            velocityOut.copyFrom(groundVelocity);\r\n                            return;\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                // static friction is active if\r\n                //  velProjPlane * friction > |(vel-velProjPlane)|\r\n                //      vp       *     f    >         rvProj\r\n                //\r\n                //  -> vp * f >= rvProj\r\n                //  -> vp * f >= sqrt( vel^2 - vp^2 )\r\n                //  -> vp^2 ( f^2 + 1 ) >= vel^2\r\n                const f2 = sci.staticFriction * sci.staticFriction;\r\n                if (vp2 * (1 + f2) >= origVelocity2) {\r\n                    velocityOut.copyFrom(groundVelocity);\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (sci.dynamicFriction < 1) {\r\n            //  apply dynamic friction 0 = conserve input velocity 1 = clip against normal\r\n            const velOut2 = relativeVelocity.lengthSquared();\r\n            if (velOut2 >= eps) {\r\n                if (velOut2 > 1e-4 * origVelocity2) {\r\n                    let f = Math.sqrt(origVelocity2 / velOut2);\r\n                    f = sci.dynamicFriction + (1 - sci.dynamicFriction) * f;\r\n                    relativeVelocity.scaleInPlace(f);\r\n                    const p = sci.planeNormal.dot(relativeVelocity);\r\n                    relativeVelocity.subtractInPlace(sci.planeNormal.scale(p));\r\n                }\r\n            }\r\n        }\r\n        velocityOut.copyFrom(relativeVelocity);\r\n        velocityOut.addInPlace(groundVelocity);\r\n    }\r\n\r\n    protected _simplexSolverSolveTest1d(sci: SurfaceConstraintInfo, velocityIn: Vector3): boolean {\r\n        const eps = 1e-3;\r\n        const relativeVelocity = this._tmpVecs[23];\r\n        velocityIn.subtractToRef(sci.velocity, relativeVelocity);\r\n        return relativeVelocity.dot(sci.planeNormal) < -eps;\r\n    }\r\n\r\n    protected _simplexSolverSolve2d(\r\n        info: SimplexSolverInfo,\r\n        maxSurfaceVelocity: Vector3,\r\n        sci0: SurfaceConstraintInfo,\r\n        sci1: SurfaceConstraintInfo,\r\n        velocityIn: Vector3,\r\n        velocityOut: Vector3\r\n    ) {\r\n        const eps = 1e-5;\r\n        const axis = sci0.planeNormal.cross(sci1.planeNormal);\r\n        const axisLen2 = axis.lengthSquared();\r\n\r\n        let solveSequentially = false;\r\n        let axisVel = null;\r\n\r\n        // eslint-disable-next-line no-constant-condition\r\n        while (true) {\r\n            // Check for parallel planes\r\n            if (axisLen2 <= eps || solveSequentially) {\r\n                info.getOutput(sci0).status = SurfaceConstraintInteractionStatus.FAILURE_2D;\r\n                info.getOutput(sci1).status = SurfaceConstraintInteractionStatus.FAILURE_2D;\r\n\r\n                if (sci0.priority > sci1.priority) {\r\n                    this._simplexSolverSolve1d(info, sci1, velocityIn, velocityOut);\r\n                    this._simplexSolverSolve1d(info, sci0, velocityIn, velocityOut);\r\n                } else {\r\n                    this._simplexSolverSolve1d(info, sci0, velocityIn, velocityOut);\r\n                    this._simplexSolverSolve1d(info, sci1, velocityIn, velocityOut);\r\n                }\r\n                return;\r\n            }\r\n\r\n            const invAxisLen = 1.0 / Math.sqrt(axisLen2);\r\n            axis.scaleInPlace(invAxisLen);\r\n\r\n            //  Calculate the velocity of the free axis\r\n            {\r\n                const r0 = sci0.planeNormal.cross(sci1.planeNormal);\r\n                const r1 = sci1.planeNormal.cross(axis);\r\n                const r2 = axis.cross(sci0.planeNormal);\r\n\r\n                const sVel = sci0.velocity.add(sci1.velocity);\r\n\r\n                const t = this._tmpVecs[2];\r\n                t.set(0.5 * axis.dot(sVel), sci0.planeNormal.dot(sci0.velocity), sci1.planeNormal.dot(sci1.velocity));\r\n                const m = Matrix.FromValues(r0.x, r1.x, r2.x, 0, r0.y, r1.y, r2.y, 0, r0.z, r1.z, r2.z, 0, 0, 0, 0, 1);\r\n                axisVel = Vector3.TransformNormal(t, m);\r\n                axisVel.scaleInPlace(invAxisLen);\r\n\r\n                if (Math.abs(axisVel.x) > maxSurfaceVelocity.x || Math.abs(axisVel.y) > maxSurfaceVelocity.y || Math.abs(axisVel.z) > maxSurfaceVelocity.z) {\r\n                    solveSequentially = true;\r\n                } else {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        const groundVelocity = axisVel;\r\n        const relativeVelocity = this._tmpVecs[24];\r\n        velocityIn.subtractToRef(groundVelocity, relativeVelocity);\r\n\r\n        const vel2 = relativeVelocity.lengthSquared();\r\n        const axisVert = this.up.dot(axis);\r\n        let axisProjVelocity = relativeVelocity.dot(axis);\r\n\r\n        let staticFriction = sci0.staticFriction + sci1.staticFriction;\r\n        if (axisVert * axisProjVelocity > 0) {\r\n            staticFriction += (sci0.extraUpStaticFriction + sci1.extraUpStaticFriction) * axisVert;\r\n        } else {\r\n            staticFriction += (sci0.extraDownStaticFriction + sci1.extraDownStaticFriction) * axisVert;\r\n        }\r\n        staticFriction *= 0.5;\r\n\r\n        const dynamicFriction = (sci0.dynamicFriction + sci1.dynamicFriction) * 0.5;\r\n        // static friction is active if\r\n        //  |vel-axisProjVelocity|(rv) * friction(f) > axisProjVelocity(av)\r\n        //  -> sqrt( vel2 - av2 ) * f > av\r\n        //  -> (vel2 - av2) * f2  > av2\r\n        const f2 = staticFriction * staticFriction;\r\n        const av2 = axisProjVelocity * axisProjVelocity;\r\n        if ((vel2 - av2) * f2 >= av2) {\r\n            // static friction kicks in\r\n            velocityOut.copyFrom(groundVelocity);\r\n            return;\r\n        }\r\n\r\n        if (dynamicFriction < 1) {\r\n            //  apply dynamic friction\r\n            if (axisProjVelocity * axisProjVelocity > 1e-4 * vel2) {\r\n                const tmp = 1.0 / axisProjVelocity;\r\n                const f = Math.abs(tmp) * Math.sqrt(vel2) * (1.0 - dynamicFriction) + dynamicFriction;\r\n                axisProjVelocity *= f;\r\n            }\r\n        }\r\n        velocityOut.copyFrom(groundVelocity);\r\n        velocityOut.addInPlace(axis.scale(axisProjVelocity));\r\n    }\r\n\r\n    protected _simplexSolverSolve3d(\r\n        info: SimplexSolverInfo,\r\n        maxSurfaceVelocity: Vector3,\r\n        sci0: SurfaceConstraintInfo,\r\n        sci1: SurfaceConstraintInfo,\r\n        sci2: SurfaceConstraintInfo,\r\n        allowResort: boolean,\r\n        velocityIn: Vector3,\r\n        velocityOut: Vector3\r\n    ) {\r\n        const eps = 1e-5;\r\n        //  Calculate the velocity of the point axis\r\n        let pointVel = null;\r\n        {\r\n            const r0 = sci1.planeNormal.cross(sci2.planeNormal);\r\n            const r1 = sci2.planeNormal.cross(sci0.planeNormal);\r\n            const r2 = sci0.planeNormal.cross(sci1.planeNormal);\r\n\r\n            const det = r0.dot(sci0.planeNormal);\r\n            let solveSequentially = false;\r\n            // eslint-disable-next-line no-constant-condition\r\n            while (true) {\r\n                if (Math.abs(det) < eps || solveSequentially) {\r\n                    if (allowResort) {\r\n                        this._simplexSolverSortInfo(info);\r\n                        sci0 = info.supportPlanes[0].constraint;\r\n                        sci1 = info.supportPlanes[1].constraint;\r\n                        sci2 = info.supportPlanes[2].constraint;\r\n                    }\r\n                    info.getOutput(sci0).status = SurfaceConstraintInteractionStatus.FAILURE_3D;\r\n                    info.getOutput(sci1).status = SurfaceConstraintInteractionStatus.FAILURE_3D;\r\n                    info.getOutput(sci2).status = SurfaceConstraintInteractionStatus.FAILURE_3D;\r\n\r\n                    const oldNum = info.numSupportPlanes;\r\n                    this._simplexSolverSolve2d(info, maxSurfaceVelocity, sci0, sci1, velocityIn, velocityOut);\r\n                    if (oldNum == info.numSupportPlanes) {\r\n                        this._simplexSolverSolve2d(info, maxSurfaceVelocity, sci0, sci2, velocityIn, velocityOut);\r\n                    }\r\n                    if (oldNum == info.numSupportPlanes) {\r\n                        this._simplexSolverSolve2d(info, maxSurfaceVelocity, sci1, sci2, velocityIn, velocityOut);\r\n                    }\r\n\r\n                    return;\r\n                }\r\n\r\n                const t = this._tmpVecs[2];\r\n                t.set(sci0.planeNormal.dot(sci0.velocity), sci1.planeNormal.dot(sci1.velocity), sci2.planeNormal.dot(sci2.velocity));\r\n                const m = Matrix.FromValues(r0.x, r0.y, r0.z, 0, r1.x, r1.y, r1.z, 0, r2.x, r2.y, r2.z, 0, 0, 0, 0, 1);\r\n                pointVel = Vector3.TransformNormal(t, m);\r\n                pointVel.scaleInPlace(1 / det);\r\n                if (Math.abs(pointVel.x) > maxSurfaceVelocity.x || Math.abs(pointVel.y) > maxSurfaceVelocity.y || Math.abs(pointVel.z) > maxSurfaceVelocity.z) {\r\n                    solveSequentially = true;\r\n                } else {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        velocityOut.copyFrom(pointVel);\r\n    }\r\n\r\n    protected _simplexSolverExamineActivePlanes(info: SimplexSolverInfo, maxSurfaceVelocity: Vector3, velocityIn: Vector3, velocityOut: Vector3) {\r\n        // eslint-disable-next-line no-constant-condition\r\n        while (true) {\r\n            switch (info.numSupportPlanes) {\r\n                case 1: {\r\n                    const sci = info.supportPlanes[0].constraint;\r\n                    this._simplexSolverSolve1d(info, sci, velocityIn, velocityOut);\r\n                    return;\r\n                }\r\n                case 2: {\r\n                    const velocity = Vector3.Zero();\r\n                    this._simplexSolverSolve1d(info, info.supportPlanes[1].constraint, velocityIn, velocity);\r\n                    const plane0Used = this._simplexSolverSolveTest1d(info.supportPlanes[0].constraint, velocity);\r\n                    if (!plane0Used) {\r\n                        // Only need plane 1, so remove plane 0\r\n                        info.supportPlanes[0].copyFrom(info.supportPlanes[1]);\r\n                        info.numSupportPlanes = 1;\r\n                        velocityOut.copyFrom(velocity);\r\n                    } else {\r\n                        this._simplexSolverSolve2d(info, maxSurfaceVelocity, info.supportPlanes[0].constraint, info.supportPlanes[1].constraint, velocityIn, velocityOut);\r\n                    }\r\n                    return;\r\n                }\r\n                case 3: {\r\n                    // Try to drop both planes\r\n                    {\r\n                        const velocity = Vector3.Zero();\r\n                        this._simplexSolverSolve1d(info, info.supportPlanes[2].constraint, velocityIn, velocityOut);\r\n\r\n                        const plane0Used = this._simplexSolverSolveTest1d(info.supportPlanes[0].constraint, velocity);\r\n                        if (!plane0Used) {\r\n                            const plane1Used = this._simplexSolverSolveTest1d(info.supportPlanes[1].constraint, velocity);\r\n                            if (!plane1Used) {\r\n                                velocityOut.copyFrom(velocity);\r\n                                info.supportPlanes[0].copyFrom(info.supportPlanes[2]);\r\n                                info.numSupportPlanes = 1;\r\n                                continue;\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    //  Try to drop plane 0 or 1\r\n                    {\r\n                        let droppedAPlane = false;\r\n                        for (let testPlane = 0; testPlane < 2; testPlane++) {\r\n                            const velocity = Vector3.Zero();\r\n                            this._simplexSolverSolve2d(\r\n                                info,\r\n                                maxSurfaceVelocity,\r\n                                info.supportPlanes[testPlane].constraint,\r\n                                info.supportPlanes[2].constraint,\r\n                                velocityIn,\r\n                                velocityOut\r\n                            );\r\n                            const planeUsed = this._simplexSolverSolveTest1d(info.supportPlanes[1 - testPlane].constraint, velocity);\r\n                            if (!planeUsed) {\r\n                                info.supportPlanes[0].copyFrom(info.supportPlanes[testPlane]);\r\n                                info.supportPlanes[1].copyFrom(info.supportPlanes[2]);\r\n                                info.numSupportPlanes--;\r\n                                droppedAPlane = true;\r\n                                break;\r\n                            }\r\n                        }\r\n\r\n                        if (droppedAPlane) {\r\n                            continue;\r\n                        }\r\n                    }\r\n\r\n                    // Otherwise, try and solve all three planes:\r\n                    this._simplexSolverSolve3d(\r\n                        info,\r\n                        maxSurfaceVelocity,\r\n                        info.supportPlanes[0].constraint,\r\n                        info.supportPlanes[1].constraint,\r\n                        info.supportPlanes[2].constraint,\r\n                        true,\r\n                        velocityIn,\r\n                        velocityOut\r\n                    );\r\n                    return;\r\n                }\r\n                case 4: {\r\n                    this._simplexSolverSortInfo(info);\r\n                    let droppedAPlane = false;\r\n\r\n                    for (let i = 0; i < 3; i++) {\r\n                        const velocity = Vector3.Zero();\r\n                        this._simplexSolverSolve3d(\r\n                            info,\r\n                            maxSurfaceVelocity,\r\n                            info.supportPlanes[(i + 1) % 3].constraint,\r\n                            info.supportPlanes[(i + 2) % 3].constraint,\r\n                            info.supportPlanes[3].constraint,\r\n                            false,\r\n                            velocityIn,\r\n                            velocity\r\n                        );\r\n                        const planeUsed = this._simplexSolverSolveTest1d(info.supportPlanes[i].constraint, velocity);\r\n                        if (!planeUsed) {\r\n                            info.supportPlanes[i].copyFrom(info.supportPlanes[2]);\r\n                            info.supportPlanes[2].copyFrom(info.supportPlanes[3]);\r\n                            info.numSupportPlanes = 3;\r\n                            droppedAPlane = true;\r\n                            break;\r\n                        }\r\n                    }\r\n\r\n                    if (droppedAPlane) {\r\n                        continue;\r\n                    }\r\n\r\n                    // Nothing can be dropped so we've failed to solve\r\n                    // Now we try all 3d combinations\r\n                    {\r\n                        const velocity = velocityIn.clone();\r\n                        const sci0 = info.supportPlanes[0].constraint;\r\n                        const sci1 = info.supportPlanes[1].constraint;\r\n                        const sci2 = info.supportPlanes[2].constraint;\r\n                        const sci3 = info.supportPlanes[3].constraint;\r\n                        const oldNum = info.numSupportPlanes;\r\n                        if (oldNum == info.numSupportPlanes) {\r\n                            this._simplexSolverSolve3d(info, maxSurfaceVelocity, sci0, sci1, sci2, false, velocity, velocity);\r\n                            // eslint-disable-next-line no-dupe-else-if\r\n                        } else if (oldNum == info.numSupportPlanes) {\r\n                            this._simplexSolverSolve3d(info, maxSurfaceVelocity, sci0, sci1, sci3, false, velocity, velocity);\r\n                            // eslint-disable-next-line no-dupe-else-if\r\n                        } else if (oldNum == info.numSupportPlanes) {\r\n                            this._simplexSolverSolve3d(info, maxSurfaceVelocity, sci0, sci2, sci3, false, velocity, velocity);\r\n                            // eslint-disable-next-line no-dupe-else-if\r\n                        } else if (oldNum == info.numSupportPlanes) {\r\n                            this._simplexSolverSolve3d(info, maxSurfaceVelocity, sci1, sci2, sci3, false, velocity, velocity);\r\n                        }\r\n\r\n                        velocityOut.copyFrom(velocity);\r\n                    }\r\n\r\n                    //  Search a plane to drop\r\n                    {\r\n                        //  Search the highest penalty value\r\n                        let maxStatus = SurfaceConstraintInteractionStatus.OK;\r\n                        for (let i = 0; i < 4; i++) {\r\n                            maxStatus = Math.max(maxStatus, info.supportPlanes[i].interaction.status);\r\n                        }\r\n\r\n                        // Remove the place with the lowest priority and the highest penalty\r\n                        let i = 0;\r\n                        for (; i < 4; i++) {\r\n                            if (maxStatus == info.supportPlanes[i].interaction.status) {\r\n                                info.supportPlanes[i].copyFrom(info.supportPlanes[3]);\r\n                                break;\r\n                            }\r\n                            info.numSupportPlanes--;\r\n                        }\r\n                    }\r\n\r\n                    //  Clear penalty flags for the other planes\r\n                    for (let i = 0; i < 3; i++) {\r\n                        info.supportPlanes[i].interaction.status = SurfaceConstraintInteractionStatus.OK;\r\n                    }\r\n\r\n                    continue;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    protected _simplexSolverSolve(\r\n        constraints: SurfaceConstraintInfo[],\r\n        velocity: Vector3,\r\n        deltaTime: number,\r\n        minDeltaTime: number,\r\n        up: Vector3,\r\n        maxSurfaceVelocity: Vector3\r\n    ): SimplexSolverOutput {\r\n        const eps = 1e-6;\r\n        const output = new SimplexSolverOutput();\r\n        output.position = Vector3.Zero();\r\n        output.velocity = velocity.clone();\r\n        output.planeInteractions = [];\r\n        let remainingTime = deltaTime;\r\n\r\n        for (let i = 0; i < constraints.length; i++) {\r\n            output.planeInteractions.push({\r\n                touched: false,\r\n                stopped: false,\r\n                surfaceTime: 0,\r\n                penaltyDistance: 0,\r\n                status: SurfaceConstraintInteractionStatus.OK,\r\n            });\r\n        }\r\n\r\n        const info = new SimplexSolverInfo();\r\n        info.inputConstraints = constraints;\r\n        info.outputInteractions = output.planeInteractions;\r\n        info.supportPlanes[0] = new SimplexSolverActivePlanes();\r\n        info.supportPlanes[1] = new SimplexSolverActivePlanes();\r\n        info.supportPlanes[2] = new SimplexSolverActivePlanes();\r\n        info.supportPlanes[3] = new SimplexSolverActivePlanes();\r\n\r\n        while (remainingTime > 0) {\r\n            // search for a plane which collides our current direction\r\n            let hitIndex = -1;\r\n            let minCollisionTime = remainingTime;\r\n            for (let i = 0; i < constraints.length; i++) {\r\n                //  Do not search existing active planes\r\n                if (info.numSupportPlanes >= 1 && info.supportPlanes[0].index == i) continue;\r\n                if (info.numSupportPlanes >= 2 && info.supportPlanes[1].index == i) continue;\r\n                if (info.numSupportPlanes >= 3 && info.supportPlanes[2].index == i) continue;\r\n                if (output.planeInteractions[i].status != SurfaceConstraintInteractionStatus.OK) {\r\n                    continue;\r\n                }\r\n\r\n                // Try to find the plane with the shortest time to move\r\n                const sci = constraints[i];\r\n                const relativeVel = this._tmpVecs[25];\r\n                output.velocity.subtractToRef(sci.velocity, relativeVel);\r\n                const relativeProjectedVel = -relativeVel.dot(sci.planeNormal);\r\n                // if projected velocity is pointing away skip it\r\n                if (relativeProjectedVel <= 0) {\r\n                    continue;\r\n                }\r\n\r\n                //  Calculate the time of impact\r\n                const relativePos = this._tmpVecs[26];\r\n                sci.velocity.scaleToRef(info.currentTime, this._tmpVecs[27]);\r\n                output.position.subtractToRef(this._tmpVecs[27], relativePos);\r\n                let projectedPos = sci.planeNormal.dot(relativePos);\r\n\r\n                // treat penetrations\r\n                const penaltyDist = output.planeInteractions[i].penaltyDistance;\r\n                if (penaltyDist < eps) {\r\n                    projectedPos = 0;\r\n                }\r\n                projectedPos += penaltyDist;\r\n\r\n                // check for new hit\r\n                if (projectedPos < minCollisionTime * relativeProjectedVel) {\r\n                    minCollisionTime = projectedPos / relativeProjectedVel;\r\n                    hitIndex = i;\r\n                }\r\n            }\r\n\r\n            //  integrate: Walk to our hitPosition we must walk more than 10 microseconds into the future to consider it valid.\r\n            const minAcceptableCollisionTime = 1e-4;\r\n            if (minCollisionTime > minAcceptableCollisionTime) {\r\n                info.currentTime += minCollisionTime;\r\n                remainingTime -= minCollisionTime;\r\n                output.position.addInPlace(output.velocity.scale(minCollisionTime));\r\n                for (let i = 0; i < info.numSupportPlanes; i++) {\r\n                    info.supportPlanes[i].interaction.surfaceTime += minCollisionTime;\r\n                    info.supportPlanes[i].interaction.touched = true;\r\n                }\r\n\r\n                output.deltaTime = info.currentTime;\r\n                if (info.currentTime > minDeltaTime) {\r\n                    return output;\r\n                }\r\n            }\r\n\r\n            //  If we have no hit than we are done\r\n            if (hitIndex < 0) {\r\n                output.deltaTime = deltaTime;\r\n                break;\r\n            }\r\n\r\n            //  Add our hit to our current list of active planes\r\n            const supportPlane = info.supportPlanes[info.numSupportPlanes++];\r\n            supportPlane.constraint = constraints[hitIndex];\r\n            supportPlane.interaction = output.planeInteractions[hitIndex];\r\n            supportPlane.interaction.penaltyDistance = (supportPlane.interaction.penaltyDistance + eps) * 2.0;\r\n            supportPlane.index = hitIndex;\r\n\r\n            // Move our character along the current set of active planes\r\n            this._simplexSolverExamineActivePlanes(info, maxSurfaceVelocity, velocity, output.velocity);\r\n        }\r\n\r\n        return output;\r\n    }\r\n\r\n    /**\r\n     * Compute a CharacterSurfaceInfo from current state and a direction\r\n     * @param deltaTime frame delta time in seconds. When using scene.deltaTime divide by 1000.0\r\n     * @param direction direction to check, usually gravity direction\r\n     * @returns a CharacterSurfaceInfo object\r\n     */\r\n    public checkSupport(deltaTime: number, direction: Vector3): CharacterSurfaceInfo {\r\n        const surfaceInfo = {\r\n            isSurfaceDynamic: false,\r\n            supportedState: CharacterSupportedState.UNSUPPORTED,\r\n            averageSurfaceNormal: Vector3.Zero(),\r\n            averageSurfaceVelocity: Vector3.Zero(),\r\n            averageAngularSurfaceVelocity: Vector3.Zero(),\r\n        };\r\n        this.checkSupportToRef(deltaTime, direction, surfaceInfo);\r\n        return surfaceInfo;\r\n    }\r\n\r\n    /**\r\n     * Compute a CharacterSurfaceInfo from current state and a direction\r\n     * @param deltaTime frame delta time in seconds. When using scene.deltaTime divide by 1000.0\r\n     * @param direction direction to check, usually gravity direction\r\n     * @param surfaceInfo output for surface info\r\n     */\r\n    public checkSupportToRef(deltaTime: number, direction: Vector3, surfaceInfo: CharacterSurfaceInfo): void {\r\n        const eps = 1e-4;\r\n\r\n        this._validateManifold();\r\n        const constraints = this._createConstraintsFromManifold(deltaTime, 0.0);\r\n        const storedVelocities: Vector3[] = [];\r\n        // Remove velocities and friction to make this a query of the static geometry\r\n        for (let i = 0; i < constraints.length; i++) {\r\n            storedVelocities.push(constraints[i].velocity.clone());\r\n            constraints[i].velocity.setAll(0);\r\n        }\r\n\r\n        const maxSurfaceVelocity = this._tmpVecs[3];\r\n        maxSurfaceVelocity.set(this.maxCharacterSpeedForSolver, this.maxCharacterSpeedForSolver, this.maxCharacterSpeedForSolver);\r\n        const output = this._simplexSolverSolve(constraints, direction, deltaTime, deltaTime, this.up, maxSurfaceVelocity);\r\n\r\n        surfaceInfo.averageSurfaceVelocity.setAll(0);\r\n        surfaceInfo.averageAngularSurfaceVelocity.setAll(0);\r\n        surfaceInfo.averageSurfaceNormal.setAll(0);\r\n        surfaceInfo.isSurfaceDynamic = false;\r\n\r\n        // If the constraints did not affect the character movement then it is unsupported and we can finish\r\n        if (output.velocity.equalsWithEpsilon(direction, eps)) {\r\n            surfaceInfo.supportedState = CharacterSupportedState.UNSUPPORTED;\r\n            return;\r\n        }\r\n\r\n        // Check how was the input velocity modified to determine if the character is supported or sliding\r\n        if (output.velocity.lengthSquared() < eps) {\r\n            surfaceInfo.supportedState = CharacterSupportedState.SUPPORTED;\r\n        } else {\r\n            output.velocity.normalize();\r\n            const angleSin = output.velocity.dot(direction);\r\n            const cosSqr = 1 - angleSin * angleSin;\r\n            if (cosSqr < this.maxSlopeCosine * this.maxSlopeCosine) {\r\n                surfaceInfo.supportedState = CharacterSupportedState.SLIDING;\r\n            } else {\r\n                surfaceInfo.supportedState = CharacterSupportedState.SUPPORTED;\r\n            }\r\n        }\r\n\r\n        // Add all supporting constraints to the ground information\r\n        let numTouching = 0;\r\n        for (let i = -0; i < constraints.length; i++) {\r\n            if (output.planeInteractions[i].touched && constraints[i].planeNormal.dot(direction) < -0.08) {\r\n                surfaceInfo.averageSurfaceNormal.addInPlace(constraints[i].planeNormal);\r\n                surfaceInfo.averageSurfaceVelocity.addInPlace(storedVelocities[i]);\r\n                surfaceInfo.averageAngularSurfaceVelocity.addInPlace(constraints[i].angularVelocity);\r\n                numTouching++;\r\n            }\r\n        }\r\n\r\n        if (numTouching > 0) {\r\n            surfaceInfo.averageSurfaceNormal.normalize();\r\n            surfaceInfo.averageSurfaceVelocity.scaleInPlace(1 / numTouching);\r\n            surfaceInfo.averageAngularSurfaceVelocity.scaleInPlace(1 / numTouching);\r\n        }\r\n\r\n        // isSurfaceDynamic update\r\n        if (surfaceInfo.supportedState == CharacterSupportedState.SUPPORTED) {\r\n            for (let i = 0; i < this._manifold.length; i++) {\r\n                const manifold = this._manifold[i];\r\n                const bodyB = manifold.bodyB;\r\n\r\n                if (this._manifold[i].normal.dot(direction) < -0.08 && bodyB.body.getMotionType(0) == PhysicsMotionType.DYNAMIC) {\r\n                    surfaceInfo.isSurfaceDynamic = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    protected _castWithCollectors(startPos: Vector3, endPos: Vector3, castCollector: any /*HP_CollectorId*/, startCollector?: any /*HP_CollectorId*/) {\r\n        const hk = this._scene.getPhysicsEngine()!.getPhysicsPlugin() as HavokPlugin;\r\n        const hknp = hk._hknp;\r\n\r\n        const startNative = [startPos.x, startPos.y, startPos.z];\r\n        const orientation = [this._orientation.x, this._orientation.y, this._orientation.z, this._orientation.w];\r\n        if (startCollector != null) {\r\n            const query /*: ShapeProximityInput*/ = [\r\n                this._shape._pluginData,\r\n                //@ts-ignore\r\n                startNative,\r\n                //@ts-ignore\r\n                orientation,\r\n                this.keepDistance + this.keepContactTolerance, // max distance\r\n                false, // should hit triggers\r\n                [BigInt(0)], // body to ignore //<todo allow for a proxy body!\r\n            ];\r\n            hknp.HP_World_ShapeProximityWithCollector(hk.world, startCollector, query);\r\n        }\r\n\r\n        {\r\n            const query /*: ShapeCastInput*/ = [\r\n                this._shape._pluginData,\r\n                //@ts-ignore\r\n                orientation,\r\n                //@ts-ignore\r\n                startNative,\r\n                [endPos.x, endPos.y, endPos.z],\r\n                false, // should hit triggers\r\n                [BigInt(0)], // body to ignore //<todo allow for proxy body\r\n            ];\r\n            hknp.HP_World_ShapeCastWithCollector(hk.world, castCollector, query);\r\n        }\r\n    }\r\n\r\n    protected _resolveContacts(deltaTime: number, gravity: Vector3) {\r\n        const eps = 1e-12;\r\n        //<todo object interactions out\r\n        for (let i = 0; i < this._manifold.length; i++) {\r\n            const contact = this._manifold[i];\r\n            const bodyB = this._manifold[i].bodyB;\r\n\r\n            //<todo test if bodyB is another character with a proxy body\r\n\r\n            // Skip fixed or keyframed bodies as we won't apply impulses to them\r\n            if (bodyB.body.getMotionType(bodyB.index) != PhysicsMotionType.DYNAMIC) {\r\n                continue;\r\n            }\r\n\r\n            // Calculate and apply impulse on contacted body\r\n            {\r\n                //<todo input/output for callbacks\r\n                let inputObjectMassInv = 0;\r\n                let inputObjectImpulse = 0;\r\n                let outputObjectImpulse = Vector3.Zero();\r\n                const outputImpulsePosition = contact.position;\r\n\r\n                // Calculate relative normal velocity of the contact point in the contacted body\r\n                const pointRelVel = this._tmpVecs[19];\r\n                this._getPointVelocityToRef(bodyB, contact.position, pointRelVel);\r\n                pointRelVel.subtractInPlace(this._velocity);\r\n                const inputProjectedVelocity = pointRelVel.dot(contact.normal);\r\n                const dampFactor = 0.9;\r\n\r\n                // Change velocity\r\n                let deltaVelocity = -inputProjectedVelocity * dampFactor;\r\n\r\n                // Apply an extra impulse if the collision is actually penetrating\r\n                if (contact.distance < 0) {\r\n                    const recoveryTau = 0.4;\r\n                    deltaVelocity += (contact.distance * recoveryTau) / deltaTime;\r\n                }\r\n\r\n                // Apply impulse if required to keep bodies apart\r\n                if (deltaVelocity < 0) {\r\n                    //  Calculate the impulse magnitude\r\n                    const invInertia = this._getInverseInertiaWorld(bodyB);\r\n                    const comWorld = this._tmpVecs[15];\r\n                    this._getComWorldToRef(bodyB, comWorld);\r\n                    const r = this._tmpVecs[16];\r\n                    contact.position.subtractToRef(comWorld, r);\r\n                    const jacAng = this._tmpVecs[17];\r\n                    Vector3.CrossToRef(r, contact.normal, jacAng);\r\n                    const rc = this._tmpVecs[18];\r\n                    Vector3.TransformNormalToRef(jacAng, invInertia, rc);\r\n                    inputObjectMassInv = rc.dot(jacAng) + this._getInvMass(bodyB);\r\n                    inputObjectImpulse = deltaVelocity / inputObjectMassInv;\r\n\r\n                    // Clamp impulse magnitude if required and apply it to the normal direction\r\n                    const maxPushImpulse = -this.characterStrength * deltaTime;\r\n                    if (inputObjectImpulse < maxPushImpulse) {\r\n                        inputObjectImpulse = maxPushImpulse;\r\n                    }\r\n                    outputObjectImpulse = contact.normal.scale(inputObjectImpulse);\r\n                } else {\r\n                    inputObjectImpulse = 0;\r\n                    inputObjectMassInv = this._getInvMass(bodyB);\r\n                }\r\n\r\n                // Add gravity\r\n                {\r\n                    // Calculate effect of gravity on the velocity of the character in the contact normal direction\r\n                    let relVelN = contact.normal.dot(gravity.scale(deltaTime));\r\n                    // If it is a separating contact subtract the separation velocity\r\n                    if (inputProjectedVelocity < 0) {\r\n                        relVelN -= inputProjectedVelocity;\r\n                    }\r\n                    // If the resulting velocity is negative an impulse is applied to stop the character from falling into\r\n                    // the contacted body\r\n                    if (relVelN < -eps) {\r\n                        outputObjectImpulse.addInPlace(contact.normal.scale(this.characterMass * relVelN));\r\n                    }\r\n                }\r\n\r\n                //<todo Fire callback to allow user to change impulse + use the info / play sounds\r\n\r\n                bodyB.body.applyImpulse(outputObjectImpulse, outputImpulsePosition, bodyB.index);\r\n            }\r\n        }\r\n    }\r\n\r\n    protected _getInverseInertiaWorld(body: { body: PhysicsBody; index: number }): DeepImmutableObject<Matrix> {\r\n        const mp = body.body.getMassProperties(body.index);\r\n        if (!mp.inertia || !mp.inertiaOrientation) {\r\n            return Matrix.IdentityReadOnly;\r\n        }\r\n        const invOrientation = Matrix.FromQuaternionToRef(mp.inertiaOrientation, TmpVectors.Matrix[0]).invert();\r\n        const it = TmpVectors.Matrix[1];\r\n\r\n        const ir = invOrientation.getRowToRef(0, TmpVectors.Vector4[0]);\r\n        it.setRowFromFloats(0, mp.inertia.x * ir.x, mp.inertia.x * ir.y, mp.inertia.x * ir.z, 0);\r\n        invOrientation.getRowToRef(1, ir);\r\n        it.setRowFromFloats(0, mp.inertia.y * ir.x, mp.inertia.y * ir.y, mp.inertia.y * ir.z, 0);\r\n        invOrientation.getRowToRef(2, ir);\r\n        it.setRowFromFloats(0, mp.inertia.z * ir.x, mp.inertia.z * ir.y, mp.inertia.z * ir.z, 0);\r\n        invOrientation.multiplyToRef(it, this._tmpMatrix);\r\n        return this._tmpMatrix;\r\n    }\r\n\r\n    protected _getComWorldToRef(body: { body: PhysicsBody; index: number }, result: Vector3) {\r\n        const mp = body.body.getMassProperties(body.index);\r\n        Vector3.TransformCoordinatesToRef(mp.centerOfMass!, body.body.transformNode.getWorldMatrix(), result);\r\n    }\r\n\r\n    protected _getInvMass(body: { body: PhysicsBody; index: number }): number {\r\n        return 1 / body.body.getMassProperties(body.index).mass!;\r\n    }\r\n\r\n    /**\r\n     * Update internal state. Must be called once per frame\r\n     * @param deltaTime frame delta time in seconds. When using scene.deltaTime divide by 1000.0\r\n     * @param surfaceInfo surface information returned by checkSupport\r\n     * @param gravity gravity applied to the character. Can be different that world gravity\r\n     */\r\n    public integrate(deltaTime: number, surfaceInfo: CharacterSurfaceInfo, gravity: Vector3) {\r\n        const hk = this._scene.getPhysicsEngine()!.getPhysicsPlugin() as HavokPlugin;\r\n\r\n        const invDeltaTime = 1 / deltaTime;\r\n        let remainingTime = deltaTime;\r\n        let newVelocity = Vector3.Zero();\r\n\r\n        // If the difference between the cast displacement and the simplex solver output position is less than this\r\n        // value (per component), do not do a second cast to check if it's possible to reach the output position.\r\n        const displacementEps = 1e-4;\r\n        const epsSqrd = 1e-8;\r\n\r\n        // Choose the first cast direction.  If velocity hasn't changed from the previous integrate, guess that the\r\n        // displacement will be the same as last integrate, scaled by relative step length.  Otherwise, guess based\r\n        // on current velocity.\r\n        {\r\n            const tolerance = displacementEps * invDeltaTime;\r\n            if (this._velocity.equalsWithEpsilon(this._lastVelocity, tolerance)) {\r\n                this._lastDisplacement.scaleInPlace(remainingTime * this._lastInvDeltaTime);\r\n            } else {\r\n                const displacementVelocity = this._velocity;\r\n                if (surfaceInfo.supportedState == CharacterSupportedState.SUPPORTED) {\r\n                    const relativeVelocity = this._tmpVecs[28];\r\n                    this._velocity.subtractToRef(surfaceInfo.averageSurfaceVelocity, relativeVelocity);\r\n                    const normalDotVelocity = surfaceInfo.averageSurfaceNormal.dot(relativeVelocity);\r\n                    if (normalDotVelocity < 0) {\r\n                        relativeVelocity.subtractInPlace(surfaceInfo.averageSurfaceNormal.scale(normalDotVelocity));\r\n                        displacementVelocity.copyFrom(relativeVelocity);\r\n                        displacementVelocity.addInPlace(surfaceInfo.averageSurfaceVelocity);\r\n                    }\r\n                }\r\n                this._lastDisplacement.copyFrom(displacementVelocity);\r\n                this._lastDisplacement.scaleInPlace(remainingTime);\r\n            }\r\n            this._lastVelocity.copyFrom(this._velocity);\r\n            this._lastInvDeltaTime = invDeltaTime;\r\n        }\r\n\r\n        // Make sure that contact with bodies that have been removed since the call to checkSupport() are removed from the\r\n        // manifold\r\n        this._validateManifold();\r\n\r\n        for (let iter = 0; iter < this.maxCastIterations && remainingTime > 1e-5; iter++) {\r\n            this._castWithCollectors(this._position, this._position.add(this._lastDisplacement), this._castCollector, this._startCollector);\r\n            const updateResult = this._updateManifold(this._startCollector, this._castCollector, this._lastDisplacement);\r\n\r\n            // Create surface constraints from the manifold contacts.\r\n            const constraints = this._createConstraintsFromManifold(deltaTime, deltaTime - remainingTime);\r\n            const maxSurfaceVelocity = this._tmpVecs[3];\r\n            maxSurfaceVelocity.set(this.maxCharacterSpeedForSolver, this.maxCharacterSpeedForSolver, this.maxCharacterSpeedForSolver);\r\n            const minDeltaTime = this._velocity.lengthSquared() == 0 ? 0.0 : (0.5 * this.keepDistance) / this._velocity.length();\r\n            const solveResults = this._simplexSolverSolve(constraints, this._velocity, remainingTime, minDeltaTime, this.up, maxSurfaceVelocity);\r\n            const newDisplacement = solveResults.position;\r\n            const solverDeltaTime = solveResults.deltaTime;\r\n            newVelocity = solveResults.velocity;\r\n\r\n            this._resolveContacts(deltaTime, gravity);\r\n\r\n            let newContactIndex = -1;\r\n            // todo if (updateResult == hit multiple bodies) ... cast again\r\n\r\n            // If castCollector had hits on different bodies (so we're not sure if some non-closest body could be in our way) OR\r\n            // the simplex has given an output direction different from the cast guess\r\n            // we re-cast to check we can move there. There is no need to get the start points again.\r\n            if (updateResult != 0 || (newDisplacement.lengthSquared() > epsSqrd && !this._lastDisplacement.equalsWithEpsilon(newDisplacement, displacementEps))) {\r\n                this._castWithCollectors(this._position, this._position.add(newDisplacement), this._castCollector, this._startCollector);\r\n                const hknp = hk._hknp;\r\n                const numCastHits = hknp.HP_QueryCollector_GetNumHits(this._castCollector)[1];\r\n                // Find the first contact that isn't already in the manifold\r\n                if (numCastHits > 0) {\r\n                    //<todo sortHits()\r\n                    for (let i = 0; i < numCastHits; i++) {\r\n                        // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n                        const [fraction, _hitLocal, hitWorld] = hknp.HP_QueryCollector_GetShapeCastResult(this._castCollector, i)[1];\r\n                        const newContact = contactFromCast(hk, hitWorld, newDisplacement, fraction, this.keepDistance);\r\n                        if (this._findContact(newContact, this._manifold, 0.1) == -1) {\r\n                            //<todo fireContactAdded\r\n                            newContactIndex = this._manifold.length;\r\n                            this._manifold.push(newContact);\r\n                            //<todo updateTriggersSeen()\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (newContactIndex >= 0) {\r\n                const newContact = this._manifold[newContactIndex];\r\n                const displacementLengthInv = 1.0 / newDisplacement.length();\r\n                const angleBetweenMovementAndSurface = newDisplacement.dot(newContact.normal) * displacementLengthInv;\r\n                const keepDistanceAlongMovement = this.keepDistance / -angleBetweenMovementAndSurface;\r\n                const distance = newContact.fraction;\r\n                let fraction = distance - keepDistanceAlongMovement * displacementLengthInv;\r\n                fraction = Math.min(Math.max(fraction, 0.0), 1.0);\r\n\r\n                const displacement = newDisplacement.scale(fraction);\r\n                this._position.addInPlace(displacement);\r\n                remainingTime -= solverDeltaTime * fraction;\r\n            } else {\r\n                this._position.addInPlace(newDisplacement);\r\n                remainingTime -= solverDeltaTime;\r\n            }\r\n            this._lastDisplacement.copyFrom(newDisplacement);\r\n        }\r\n\r\n        this._velocity.copyFrom(newVelocity);\r\n    }\r\n\r\n    /**\r\n     * Helper function to calculate velocity based on surface informations and current velocity state and target\r\n     * @param deltaTime frame delta time in seconds. When using scene.deltaTime divide by 1000.0\r\n     * @param forwardWorld character forward in world coordinates\r\n     * @param surfaceNormal surface normal direction\r\n     * @param currentVelocity current velocity\r\n     * @param surfaceVelocity velocity induced by the surface\r\n     * @param desiredVelocity desired character velocity\r\n     * @param upWorld up vector in world space\r\n     * @param result resulting velocity vector\r\n     * @returns boolean true if result has been computed\r\n     */\r\n    public calculateMovementToRef(\r\n        deltaTime: number,\r\n        forwardWorld: Vector3,\r\n        surfaceNormal: Vector3,\r\n        currentVelocity: Vector3,\r\n        surfaceVelocity: Vector3,\r\n        desiredVelocity: Vector3,\r\n        upWorld: Vector3,\r\n        result: Vector3\r\n    ): boolean {\r\n        const eps = 1e-5;\r\n        let binorm = forwardWorld.cross(upWorld);\r\n        if (binorm.lengthSquared() < eps) {\r\n            return false;\r\n        }\r\n        binorm.normalize();\r\n        const tangent = binorm.cross(surfaceNormal);\r\n        tangent.normalize();\r\n        binorm = tangent.cross(surfaceNormal);\r\n        binorm.normalize();\r\n\r\n        const surfaceFrame = Matrix.FromValues(\r\n            tangent.x,\r\n            tangent.y,\r\n            tangent.z,\r\n            0,\r\n            binorm.x,\r\n            binorm.y,\r\n            binorm.z,\r\n            0,\r\n            surfaceNormal.x,\r\n            surfaceNormal.y,\r\n            surfaceNormal.z,\r\n            0,\r\n            0,\r\n            0,\r\n            0,\r\n            1\r\n        );\r\n        const invSurfaceFrame = surfaceFrame.clone().invert();\r\n\r\n        currentVelocity.subtractToRef(surfaceVelocity, this._tmpVecs[29]);\r\n        const relative = this._tmpVecs[30];\r\n        Vector3.TransformNormalToRef(this._tmpVecs[29], invSurfaceFrame, relative);\r\n\r\n        const sideVec = upWorld.cross(forwardWorld);\r\n        const fwd = desiredVelocity.dot(forwardWorld);\r\n        const side = desiredVelocity.dot(sideVec);\r\n        const len = desiredVelocity.length();\r\n\r\n        const desiredVelocitySF = this._tmpVecs[4];\r\n        desiredVelocitySF.set(-fwd, side, 0);\r\n        desiredVelocitySF.normalize();\r\n        desiredVelocitySF.scaleInPlace(len);\r\n        const diff = this._tmpVecs[5];\r\n        desiredVelocitySF.subtractToRef(relative, diff);\r\n\r\n        // Clamp it by maxAcceleration and limit it by gain.\r\n        {\r\n            const lenSq = diff.lengthSquared();\r\n            const maxVelocityDelta = this.maxAcceleration * deltaTime;\r\n            let tmp: number;\r\n            if (lenSq * this.acceleration * this.acceleration > maxVelocityDelta * maxVelocityDelta) {\r\n                tmp = maxVelocityDelta / Math.sqrt(lenSq);\r\n            } else {\r\n                tmp = this.acceleration;\r\n            }\r\n            diff.scaleInPlace(tmp);\r\n        }\r\n\r\n        relative.addInPlace(diff);\r\n\r\n        // Transform back to world space and apply\r\n        Vector3.TransformNormalToRef(relative, surfaceFrame, result);\r\n\r\n        // Add back in the surface velocity\r\n        result.addInPlace(surfaceVelocity);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Helper function to calculate velocity based on surface informations and current velocity state and target\r\n     * @param deltaTime frame delta time in seconds. When using scene.deltaTime divide by 1000.0\r\n     * @param forwardWorld character forward in world coordinates\r\n     * @param surfaceNormal surface normal direction\r\n     * @param currentVelocity current velocity\r\n     * @param surfaceVelocity velocity induced by the surface\r\n     * @param desiredVelocity desired character velocity\r\n     * @param upWorld up vector in world space\r\n     * @returns a new velocity vector\r\n     */\r\n    public calculateMovement(\r\n        deltaTime: number,\r\n        forwardWorld: Vector3,\r\n        surfaceNormal: Vector3,\r\n        currentVelocity: Vector3,\r\n        surfaceVelocity: Vector3,\r\n        desiredVelocity: Vector3,\r\n        upWorld: Vector3\r\n    ): Vector3 {\r\n        const result = new Vector3(0, 0, 0);\r\n        this.calculateMovementToRef(deltaTime, forwardWorld, surfaceNormal, currentVelocity, surfaceVelocity, desiredVelocity, upWorld, result);\r\n        return result;\r\n    }\r\n}\r\n"]}