{"version":3,"file":"thinSSRRenderingPipeline.js","sourceRoot":"","sources":["../../../../../../dev/core/src/PostProcesses/RenderPipeline/Pipelines/thinSSRRenderingPipeline.ts"],"names":[],"mappings":"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","sourcesContent":["// eslint-disable-next-line import/no-internal-modules\r\nimport type { Nullable, CubeTexture, Scene, Camera } from \"core/index\";\r\nimport { Vector2 } from \"core/Maths/math.vector\";\r\nimport { ThinSSRPostProcess } from \"core/PostProcesses/thinSSRPostProcess\";\r\nimport { ThinSSRBlurPostProcess } from \"core/PostProcesses/thinSSRBlurPostProcess\";\r\nimport { ThinSSRBlurCombinerPostProcess } from \"core/PostProcesses/thinSSRBlurCombinerPostProcess\";\r\n\r\n/**\r\n * The SSR rendering pipeline is used to generate a reflection based on a flat mirror model.\r\n */\r\nexport class ThinSSRRenderingPipeline {\r\n    /** @internal */\r\n    public readonly _ssrPostProcess: ThinSSRPostProcess;\r\n    /** @internal */\r\n    public readonly _ssrBlurXPostProcess: ThinSSRBlurPostProcess;\r\n    /** @internal */\r\n    public readonly _ssrBlurYPostProcess: ThinSSRBlurPostProcess;\r\n    /** @internal */\r\n    public readonly _ssrBlurCombinerPostProcess: ThinSSRBlurCombinerPostProcess;\r\n\r\n    /**\r\n     * Gets or sets the name of the rendering pipeline\r\n     */\r\n    public name: string;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if the SSR rendering pipeline is supported\r\n     */\r\n    public get isSSRSupported(): boolean {\r\n        return this._ssrPostProcess.isSSRSupported;\r\n    }\r\n\r\n    public set isSSRSupported(supported: boolean) {\r\n        this._ssrPostProcess.isSSRSupported = supported;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the maxDistance used to define how far we look for reflection during the ray-marching on the reflected ray (default: 1000).\r\n     * Note that this value is a view (camera) space distance (not pixels!).\r\n     */\r\n    public get maxDistance() {\r\n        return this._ssrPostProcess.maxDistance;\r\n    }\r\n\r\n    public set maxDistance(distance: number) {\r\n        this._ssrPostProcess.maxDistance = distance;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the step size used to iterate until the effect finds the color of the reflection's pixel. Should be an integer \\>= 1 as it is the number of pixels we advance at each step (default: 1).\r\n     * Use higher values to improve performances (but at the expense of quality).\r\n     */\r\n    public get step() {\r\n        return this._ssrPostProcess.step;\r\n    }\r\n\r\n    public set step(step: number) {\r\n        this._ssrPostProcess.step = step;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the thickness value used as tolerance when computing the intersection between the reflected ray and the scene (default: 0.5).\r\n     * If setting \"enableAutomaticThicknessComputation\" to true, you can use lower values for \"thickness\" (even 0), as the geometry thickness\r\n     * is automatically computed thank to the regular depth buffer + the backface depth buffer\r\n     */\r\n    public get thickness() {\r\n        return this._ssrPostProcess.thickness;\r\n    }\r\n\r\n    public set thickness(thickness: number) {\r\n        this._ssrPostProcess.thickness = thickness;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the current reflection strength. 1.0 is an ideal value but can be increased/decreased for particular results (default: 1).\r\n     */\r\n    public get strength() {\r\n        return this._ssrPostProcess.strength;\r\n    }\r\n\r\n    public set strength(strength: number) {\r\n        this._ssrPostProcess.strength = strength;\r\n        this._ssrBlurCombinerPostProcess.strength = strength;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the falloff exponent used to compute the reflection strength. Higher values lead to fainter reflections (default: 1).\r\n     */\r\n    public get reflectionSpecularFalloffExponent() {\r\n        return this._ssrPostProcess.reflectionSpecularFalloffExponent;\r\n    }\r\n\r\n    public set reflectionSpecularFalloffExponent(exponent: number) {\r\n        this._ssrPostProcess.reflectionSpecularFalloffExponent = exponent;\r\n        this._ssrBlurCombinerPostProcess.reflectionSpecularFalloffExponent = exponent;\r\n    }\r\n\r\n    /**\r\n     * Maximum number of steps during the ray marching process after which we consider an intersection could not be found (default: 1000).\r\n     * Should be an integer value.\r\n     */\r\n    public get maxSteps() {\r\n        return this._ssrPostProcess.maxSteps;\r\n    }\r\n\r\n    public set maxSteps(steps: number) {\r\n        this._ssrPostProcess.maxSteps = steps;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the factor applied when computing roughness. Default value is 0.2.\r\n     * When blurring based on roughness is enabled (meaning blurDispersionStrength \\> 0), roughnessFactor is used as a global roughness factor applied on all objects.\r\n     * If you want to disable this global roughness set it to 0.\r\n     */\r\n    public get roughnessFactor() {\r\n        return this._ssrPostProcess.roughnessFactor;\r\n    }\r\n\r\n    public set roughnessFactor(factor: number) {\r\n        this._ssrPostProcess.roughnessFactor = factor;\r\n    }\r\n\r\n    /**\r\n     * Number of steps to skip at start when marching the ray to avoid self collisions (default: 1)\r\n     * 1 should normally be a good value, depending on the scene you may need to use a higher value (2 or 3)\r\n     */\r\n    public get selfCollisionNumSkip() {\r\n        return this._ssrPostProcess.selfCollisionNumSkip;\r\n    }\r\n\r\n    public set selfCollisionNumSkip(skip: number) {\r\n        this._ssrPostProcess.selfCollisionNumSkip = skip;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the minimum value for one of the reflectivity component of the material to consider it for SSR (default: 0.04).\r\n     * If all r/g/b components of the reflectivity is below or equal this value, the pixel will not be considered reflective and SSR won't be applied.\r\n     */\r\n    public get reflectivityThreshold() {\r\n        return this._ssrPostProcess.reflectivityThreshold;\r\n    }\r\n\r\n    public set reflectivityThreshold(threshold: number) {\r\n        const currentThreshold = this._ssrPostProcess.reflectivityThreshold;\r\n\r\n        if (threshold === currentThreshold) {\r\n            return;\r\n        }\r\n\r\n        this._ssrPostProcess.reflectivityThreshold = threshold;\r\n        this._ssrBlurCombinerPostProcess.reflectivityThreshold = threshold;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the downsample factor used to reduce the size of the texture used to compute the SSR contribution (default: 0).\r\n     * Use 0 to render the SSR contribution at full resolution, 1 to render at half resolution, 2 to render at 1/3 resolution, etc.\r\n     * Note that it is used only when blurring is enabled (blurDispersionStrength \\> 0), because in that mode the SSR contribution is generated in a separate texture.\r\n     */\r\n    public ssrDownsample = 0;\r\n\r\n    /**\r\n     * Gets or sets the blur dispersion strength. Set this value to 0 to disable blurring (default: 0.03)\r\n     * The reflections are blurred based on the roughness of the surface and the distance between the pixel shaded and the reflected pixel: the higher the distance the more blurry the reflection is.\r\n     * blurDispersionStrength allows to increase or decrease this effect.\r\n     */\r\n    public get blurDispersionStrength() {\r\n        return this._ssrBlurXPostProcess.blurStrength;\r\n    }\r\n\r\n    public set blurDispersionStrength(strength: number) {\r\n        if (strength === this._ssrBlurXPostProcess.blurStrength) {\r\n            return;\r\n        }\r\n\r\n        this._ssrPostProcess.useBlur = strength > 0;\r\n\r\n        this._ssrBlurXPostProcess.blurStrength = strength;\r\n        this._ssrBlurYPostProcess.blurStrength = strength;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the downsample factor used to reduce the size of the textures used to blur the reflection effect (default: 0).\r\n     * Use 0 to blur at full resolution, 1 to render at half resolution, 2 to render at 1/3 resolution, etc.\r\n     */\r\n    public blurDownsample = 0;\r\n\r\n    /**\r\n     * Gets or sets whether or not smoothing reflections is enabled (default: false)\r\n     * Enabling smoothing will require more GPU power.\r\n     * Note that this setting has no effect if step = 1: it's only used if step \\> 1.\r\n     */\r\n    public get enableSmoothReflections(): boolean {\r\n        return this._ssrPostProcess.enableSmoothReflections;\r\n    }\r\n\r\n    public set enableSmoothReflections(enabled: boolean) {\r\n        this._ssrPostProcess.enableSmoothReflections = enabled;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the environment cube texture used to define the reflection when the reflected rays of SSR leave the view space or when the maxDistance/maxSteps is reached.\r\n     */\r\n    public get environmentTexture() {\r\n        return this._ssrPostProcess.environmentTexture;\r\n    }\r\n\r\n    public set environmentTexture(texture: Nullable<CubeTexture>) {\r\n        this._ssrPostProcess.environmentTexture = texture;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the boolean defining if the environment texture is a standard cubemap (false) or a probe (true). Default value is false.\r\n     * Note: a probe cube texture is treated differently than an ordinary cube texture because the Y axis is reversed.\r\n     */\r\n    public get environmentTextureIsProbe(): boolean {\r\n        return this._ssrPostProcess.environmentTextureIsProbe;\r\n    }\r\n\r\n    public set environmentTextureIsProbe(isProbe: boolean) {\r\n        this._ssrPostProcess.environmentTextureIsProbe = isProbe;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if the reflections should be attenuated at the screen borders (default: true).\r\n     */\r\n    public get attenuateScreenBorders() {\r\n        return this._ssrPostProcess.attenuateScreenBorders;\r\n    }\r\n\r\n    public set attenuateScreenBorders(attenuate: boolean) {\r\n        this._ssrPostProcess.attenuateScreenBorders = attenuate;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if the reflections should be attenuated according to the distance of the intersection (default: true).\r\n     */\r\n    public get attenuateIntersectionDistance() {\r\n        return this._ssrPostProcess.attenuateIntersectionDistance;\r\n    }\r\n\r\n    public set attenuateIntersectionDistance(attenuate: boolean) {\r\n        this._ssrPostProcess.attenuateIntersectionDistance = attenuate;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if the reflections should be attenuated according to the number of iterations performed to find the intersection (default: true).\r\n     */\r\n    public get attenuateIntersectionIterations() {\r\n        return this._ssrPostProcess.attenuateIntersectionIterations;\r\n    }\r\n\r\n    public set attenuateIntersectionIterations(attenuate: boolean) {\r\n        this._ssrPostProcess.attenuateIntersectionIterations = attenuate;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if the reflections should be attenuated when the reflection ray is facing the camera (the view direction) (default: false).\r\n     */\r\n    public get attenuateFacingCamera() {\r\n        return this._ssrPostProcess.attenuateFacingCamera;\r\n    }\r\n\r\n    public set attenuateFacingCamera(attenuate: boolean) {\r\n        this._ssrPostProcess.attenuateFacingCamera = attenuate;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if the backface reflections should be attenuated (default: false).\r\n     */\r\n    public get attenuateBackfaceReflection() {\r\n        return this._ssrPostProcess.attenuateBackfaceReflection;\r\n    }\r\n\r\n    public set attenuateBackfaceReflection(attenuate: boolean) {\r\n        this._ssrPostProcess.attenuateBackfaceReflection = attenuate;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if the ray should be clipped to the frustum (default: true).\r\n     * You can try to set this parameter to false to save some performances: it may produce some artefacts in some cases, but generally they won't really be visible\r\n     */\r\n    public get clipToFrustum() {\r\n        return this._ssrPostProcess.clipToFrustum;\r\n    }\r\n\r\n    public set clipToFrustum(clip: boolean) {\r\n        this._ssrPostProcess.clipToFrustum = clip;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating whether the blending between the current color pixel and the reflection color should be done with a Fresnel coefficient (default: false).\r\n     * It is more physically accurate to use the Fresnel coefficient (otherwise it uses the reflectivity of the material for blending), but it is also more expensive when you use blur (when blurDispersionStrength \\> 0).\r\n     */\r\n    public get useFresnel() {\r\n        return this._ssrPostProcess.useFresnel;\r\n    }\r\n\r\n    public set useFresnel(fresnel: boolean) {\r\n        this._ssrPostProcess.useFresnel = fresnel;\r\n        this._ssrBlurCombinerPostProcess.useFresnel = fresnel;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean defining if geometry thickness should be computed automatically (default: false).\r\n     * When enabled, a depth renderer is created which will render the back faces of the scene to a depth texture (meaning additional work for the GPU).\r\n     * In that mode, the \"thickness\" property is still used as an offset to compute the ray intersection, but you can typically use a much lower\r\n     * value than when enableAutomaticThicknessComputation is false (it's even possible to use a value of 0 when using low values for \"step\")\r\n     * Note that for performance reasons, this option will only apply to the first camera to which the rendering pipeline is attached!\r\n     */\r\n    public get enableAutomaticThicknessComputation(): boolean {\r\n        return this._ssrPostProcess.enableAutomaticThicknessComputation;\r\n    }\r\n\r\n    public set enableAutomaticThicknessComputation(automatic: boolean) {\r\n        if (this._ssrPostProcess.enableAutomaticThicknessComputation === automatic) {\r\n            return;\r\n        }\r\n\r\n        this._ssrPostProcess.enableAutomaticThicknessComputation = automatic;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean defining if the input color texture is in gamma space (default: true)\r\n     * The SSR effect works in linear space, so if the input texture is in gamma space, we must convert the texture to linear space before applying the effect\r\n     */\r\n    public get inputTextureColorIsInGammaSpace(): boolean {\r\n        return this._ssrPostProcess.inputTextureColorIsInGammaSpace;\r\n    }\r\n\r\n    public set inputTextureColorIsInGammaSpace(gammaSpace: boolean) {\r\n        if (this._ssrPostProcess.inputTextureColorIsInGammaSpace === gammaSpace) {\r\n            return;\r\n        }\r\n\r\n        this._ssrPostProcess.inputTextureColorIsInGammaSpace = gammaSpace;\r\n        this._ssrBlurCombinerPostProcess.inputTextureColorIsInGammaSpace = gammaSpace;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean defining if the output color texture generated by the SSR pipeline should be in gamma space (default: true)\r\n     * If you have a post-process that comes after the SSR and that post-process needs the input to be in a linear space, you must disable generateOutputInGammaSpace\r\n     */\r\n    public get generateOutputInGammaSpace(): boolean {\r\n        return this._ssrPostProcess.generateOutputInGammaSpace;\r\n    }\r\n\r\n    public set generateOutputInGammaSpace(gammaSpace: boolean) {\r\n        if (this._ssrPostProcess.generateOutputInGammaSpace === gammaSpace) {\r\n            return;\r\n        }\r\n\r\n        this._ssrPostProcess.generateOutputInGammaSpace = gammaSpace;\r\n        this._ssrBlurCombinerPostProcess.generateOutputInGammaSpace = gammaSpace;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if the effect should be rendered in debug mode (default: false).\r\n     * In this mode, colors have this meaning:\r\n     *   - blue: the ray hit the max distance (we reached maxDistance)\r\n     *   - red: the ray ran out of steps (we reached maxSteps)\r\n     *   - yellow: the ray went off screen\r\n     *   - green: the ray hit a surface. The brightness of the green color is proportional to the distance between the ray origin and the intersection point: A brighter green means more computation than a darker green.\r\n     * In the first 3 cases, the final color is calculated by mixing the skybox color with the pixel color (if environmentTexture is defined), otherwise the pixel color is not modified\r\n     * You should try to get as few blue/red/yellow pixels as possible, as this means that the ray has gone further than if it had hit a surface.\r\n     */\r\n    public get debug(): boolean {\r\n        return this._ssrPostProcess.debug;\r\n    }\r\n\r\n    public set debug(value: boolean) {\r\n        if (this._ssrPostProcess.debug === value) {\r\n            return;\r\n        }\r\n\r\n        this._ssrPostProcess.debug = value;\r\n        this._ssrBlurCombinerPostProcess.debug = value;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the camera to use to render the reflection\r\n     */\r\n    public get camera() {\r\n        return this._ssrPostProcess.camera;\r\n    }\r\n\r\n    public set camera(camera: Nullable<Camera>) {\r\n        this._ssrPostProcess.camera = camera;\r\n        this._ssrBlurCombinerPostProcess.camera = camera;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if the depth buffer stores screen space depth instead of camera view space depth.\r\n     */\r\n    public get useScreenspaceDepth() {\r\n        return this._ssrPostProcess.useScreenspaceDepth;\r\n    }\r\n\r\n    public set useScreenspaceDepth(use: boolean) {\r\n        this._ssrPostProcess.useScreenspaceDepth = use;\r\n        this._ssrBlurCombinerPostProcess.useScreenspaceDepth = use;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if the normals are in world space (false by default, meaning normals are in camera view space).\r\n     */\r\n    public get normalsAreInWorldSpace() {\r\n        return this._ssrPostProcess.normalsAreInWorldSpace;\r\n    }\r\n\r\n    public set normalsAreInWorldSpace(normalsAreInWorldSpace: boolean) {\r\n        this._ssrPostProcess.normalsAreInWorldSpace = normalsAreInWorldSpace;\r\n        this._ssrBlurCombinerPostProcess.normalsAreInWorldSpace = normalsAreInWorldSpace;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if the normals are encoded as unsigned, that is normalUnsigned = normal*0.5+0.5 (false by default).\r\n     */\r\n    public get normalsAreUnsigned() {\r\n        return this._ssrPostProcess.normalsAreUnsigned;\r\n    }\r\n\r\n    public set normalsAreUnsigned(normalsAreUnsigned: boolean) {\r\n        this._ssrPostProcess.normalsAreUnsigned = normalsAreUnsigned;\r\n        this._ssrBlurCombinerPostProcess.normalsAreUnsigned = normalsAreUnsigned;\r\n    }\r\n\r\n    /**\r\n     * Checks if all the post processes in the pipeline are ready.\r\n     * @returns true if all the post processes in the pipeline are ready\r\n     */\r\n    public isReady(): boolean {\r\n        return this._ssrPostProcess.isReady() && this._ssrBlurXPostProcess.isReady() && this._ssrBlurYPostProcess.isReady() && this._ssrBlurCombinerPostProcess.isReady();\r\n    }\r\n\r\n    private _scene: Scene;\r\n\r\n    /**\r\n     * Constructor of the SSR rendering pipeline\r\n     * @param name The rendering pipeline name\r\n     * @param scene The scene linked to this pipeline\r\n     */\r\n    constructor(name: string, scene: Scene) {\r\n        this.name = name;\r\n        this._scene = scene;\r\n\r\n        this._ssrPostProcess = new ThinSSRPostProcess(this.name, this._scene);\r\n        this._ssrBlurXPostProcess = new ThinSSRBlurPostProcess(this.name + \" BlurX\", this._scene.getEngine(), new Vector2(1, 0));\r\n        this._ssrBlurYPostProcess = new ThinSSRBlurPostProcess(this.name + \" BlurY\", this._scene.getEngine(), new Vector2(0, 1));\r\n        this._ssrBlurCombinerPostProcess = new ThinSSRBlurCombinerPostProcess(this.name + \" BlurCombiner\", this._scene.getEngine());\r\n\r\n        this._ssrPostProcess.useBlur = this._ssrBlurXPostProcess.blurStrength > 0;\r\n    }\r\n\r\n    /**\r\n     * Disposes of the pipeline\r\n     */\r\n    public dispose(): void {\r\n        this._ssrPostProcess?.dispose();\r\n        this._ssrBlurXPostProcess?.dispose();\r\n        this._ssrBlurYPostProcess?.dispose();\r\n        this._ssrBlurCombinerPostProcess?.dispose();\r\n    }\r\n}\r\n"]}