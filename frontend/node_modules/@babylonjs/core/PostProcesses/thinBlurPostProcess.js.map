{"version":3,"file":"thinBlurPostProcess.js","sourceRoot":"","sources":["../../../../dev/core/src/PostProcesses/thinBlurPostProcess.ts"],"names":[],"mappings":"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","sourcesContent":["// eslint-disable-next-line import/no-internal-modules\r\nimport type { Nullable, AbstractEngine, EffectWrapperCreationOptions, Vector2, Effect } from \"core/index\";\r\nimport { EffectWrapper } from \"../Materials/effectRenderer\";\r\nimport { ShaderLanguage } from \"../Materials/shaderLanguage\";\r\nimport { Engine } from \"../Engines/engine\";\r\n\r\n/**\r\n * Post process used to apply a blur effect\r\n */\r\nexport class ThinBlurPostProcess extends EffectWrapper {\r\n    /**\r\n     * The vertex shader url\r\n     */\r\n    public static readonly VertexUrl = \"kernelBlur\";\r\n\r\n    /**\r\n     * The fragment shader url\r\n     */\r\n    public static readonly FragmentUrl = \"kernelBlur\";\r\n\r\n    /**\r\n     * The list of uniforms used by the effect\r\n     */\r\n    public static readonly Uniforms = [\"delta\", \"direction\"];\r\n\r\n    /**\r\n     * The list of samplers used by the effect\r\n     */\r\n    public static readonly Samplers = [\"circleOfConfusionSampler\"];\r\n\r\n    protected override _gatherImports(useWebGPU: boolean, list: Promise<any>[]) {\r\n        if (useWebGPU) {\r\n            this._webGPUReady = true;\r\n            list.push(Promise.all([import(\"../ShadersWGSL/kernelBlur.fragment\"), import(\"../ShadersWGSL/kernelBlur.vertex\")]));\r\n        } else {\r\n            list.push(Promise.all([import(\"../Shaders/kernelBlur.fragment\"), import(\"../Shaders/kernelBlur.vertex\")]));\r\n        }\r\n    }\r\n\r\n    protected _kernel: number;\r\n    protected _idealKernel: number;\r\n    protected _packedFloat: boolean = false;\r\n    private _staticDefines: string = \"\";\r\n\r\n    /**\r\n     * Constructs a new blur post process\r\n     * @param name Name of the effect\r\n     * @param engine Engine to use to render the effect. If not provided, the last created engine will be used\r\n     * @param direction Direction in which to apply the blur\r\n     * @param kernel Kernel size of the blur\r\n     * @param options Options to configure the effect\r\n     */\r\n    constructor(name: string, engine: Nullable<AbstractEngine> = null, direction?: Vector2, kernel?: number, options?: EffectWrapperCreationOptions) {\r\n        const blockCompilationFinal = !!options?.blockCompilation;\r\n        super({\r\n            ...options,\r\n            name,\r\n            engine: engine || Engine.LastCreatedEngine!,\r\n            useShaderStore: true,\r\n            useAsPostProcess: true,\r\n            fragmentShader: ThinBlurPostProcess.FragmentUrl,\r\n            uniforms: ThinBlurPostProcess.Uniforms,\r\n            samplers: ThinBlurPostProcess.Samplers,\r\n            vertexUrl: ThinBlurPostProcess.VertexUrl,\r\n            blockCompilation: true,\r\n        });\r\n\r\n        this.options.blockCompilation = blockCompilationFinal;\r\n\r\n        if (direction !== undefined) {\r\n            this.direction = direction;\r\n        }\r\n        if (kernel !== undefined) {\r\n            this.kernel = kernel;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Width of the texture to apply the blur on\r\n     */\r\n    public textureWidth: number = 0;\r\n\r\n    /**\r\n     * Height of the texture to apply the blur on\r\n     */\r\n    public textureHeight: number = 0;\r\n\r\n    /** The direction in which to blur the image. */\r\n    public direction: Vector2;\r\n\r\n    /**\r\n     * Sets the length in pixels of the blur sample region\r\n     */\r\n    public set kernel(v: number) {\r\n        if (this._idealKernel === v) {\r\n            return;\r\n        }\r\n\r\n        v = Math.max(v, 1);\r\n        this._idealKernel = v;\r\n        this._kernel = this._nearestBestKernel(v);\r\n        if (!this.options.blockCompilation) {\r\n            this._updateParameters();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the length in pixels of the blur sample region\r\n     */\r\n    public get kernel(): number {\r\n        return this._idealKernel;\r\n    }\r\n\r\n    /**\r\n     * Sets whether or not the blur needs to unpack/repack floats\r\n     */\r\n    public set packedFloat(v: boolean) {\r\n        if (this._packedFloat === v) {\r\n            return;\r\n        }\r\n        this._packedFloat = v;\r\n        if (!this.options.blockCompilation) {\r\n            this._updateParameters();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets whether or not the blur is unpacking/repacking floats\r\n     */\r\n    public get packedFloat(): boolean {\r\n        return this._packedFloat;\r\n    }\r\n\r\n    public override bind() {\r\n        super.bind();\r\n        this._drawWrapper.effect!.setFloat2(\"delta\", (1 / this.textureWidth) * this.direction.x, (1 / this.textureHeight) * this.direction.y);\r\n    }\r\n\r\n    /** @internal */\r\n    public _updateParameters(onCompiled?: (effect: Effect) => void, onError?: (effect: Effect, errors: string) => void): void {\r\n        // Generate sampling offsets and weights\r\n        const N = this._kernel;\r\n        const centerIndex = (N - 1) / 2;\r\n\r\n        // Generate Gaussian sampling weights over kernel\r\n        let offsets = [];\r\n        let weights = [];\r\n        let totalWeight = 0;\r\n        for (let i = 0; i < N; i++) {\r\n            const u = i / (N - 1);\r\n            const w = this._gaussianWeight(u * 2.0 - 1);\r\n            offsets[i] = i - centerIndex;\r\n            weights[i] = w;\r\n            totalWeight += w;\r\n        }\r\n\r\n        // Normalize weights\r\n        for (let i = 0; i < weights.length; i++) {\r\n            weights[i] /= totalWeight;\r\n        }\r\n\r\n        // Optimize: combine samples to take advantage of hardware linear sampling\r\n        // Walk from left to center, combining pairs (symmetrically)\r\n        const linearSamplingWeights = [];\r\n        const linearSamplingOffsets = [];\r\n\r\n        const linearSamplingMap = [];\r\n\r\n        for (let i = 0; i <= centerIndex; i += 2) {\r\n            const j = Math.min(i + 1, Math.floor(centerIndex));\r\n\r\n            const singleCenterSample = i === j;\r\n\r\n            if (singleCenterSample) {\r\n                linearSamplingMap.push({ o: offsets[i], w: weights[i] });\r\n            } else {\r\n                const sharedCell = j === centerIndex;\r\n\r\n                const weightLinear = weights[i] + weights[j] * (sharedCell ? 0.5 : 1);\r\n                const offsetLinear = offsets[i] + 1 / (1 + weights[i] / weights[j]);\r\n\r\n                if (offsetLinear === 0) {\r\n                    linearSamplingMap.push({ o: offsets[i], w: weights[i] });\r\n                    linearSamplingMap.push({ o: offsets[i + 1], w: weights[i + 1] });\r\n                } else {\r\n                    linearSamplingMap.push({ o: offsetLinear, w: weightLinear });\r\n                    linearSamplingMap.push({ o: -offsetLinear, w: weightLinear });\r\n                }\r\n            }\r\n        }\r\n\r\n        for (let i = 0; i < linearSamplingMap.length; i++) {\r\n            linearSamplingOffsets[i] = linearSamplingMap[i].o;\r\n            linearSamplingWeights[i] = linearSamplingMap[i].w;\r\n        }\r\n\r\n        // Replace with optimized\r\n        offsets = linearSamplingOffsets;\r\n        weights = linearSamplingWeights;\r\n\r\n        // Generate shaders\r\n        const maxVaryingRows = this.options.engine.getCaps().maxVaryingVectors - (this.options.shaderLanguage === ShaderLanguage.WGSL ? 1 : 0); // Because of the additional builtins\r\n        const freeVaryingVec2 = Math.max(maxVaryingRows, 0) - 1; // Because of sampleCenter\r\n\r\n        let varyingCount = Math.min(offsets.length, freeVaryingVec2);\r\n\r\n        let defines = \"\";\r\n        defines += this._staticDefines;\r\n\r\n        // The DOF fragment should ignore the center pixel when looping as it is handled manually in the fragment shader.\r\n        if (this._staticDefines.indexOf(\"DOF\") != -1) {\r\n            defines += `#define CENTER_WEIGHT ${this._glslFloat(weights[varyingCount - 1])}\\n`;\r\n            varyingCount--;\r\n        }\r\n\r\n        for (let i = 0; i < varyingCount; i++) {\r\n            defines += `#define KERNEL_OFFSET${i} ${this._glslFloat(offsets[i])}\\n`;\r\n            defines += `#define KERNEL_WEIGHT${i} ${this._glslFloat(weights[i])}\\n`;\r\n        }\r\n\r\n        let depCount = 0;\r\n        for (let i = freeVaryingVec2; i < offsets.length; i++) {\r\n            defines += `#define KERNEL_DEP_OFFSET${depCount} ${this._glslFloat(offsets[i])}\\n`;\r\n            defines += `#define KERNEL_DEP_WEIGHT${depCount} ${this._glslFloat(weights[i])}\\n`;\r\n            depCount++;\r\n        }\r\n\r\n        if (this.packedFloat) {\r\n            defines += `#define PACKEDFLOAT 1`;\r\n        }\r\n\r\n        this.options.blockCompilation = false;\r\n\r\n        this.updateEffect(\r\n            defines,\r\n            null,\r\n            null,\r\n            {\r\n                varyingCount: varyingCount,\r\n                depCount: depCount,\r\n            },\r\n            onCompiled,\r\n            onError\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Best kernels are odd numbers that when divided by 2, their integer part is even, so 5, 9 or 13.\r\n     * Other odd kernels optimize correctly but require proportionally more samples, even kernels are\r\n     * possible but will produce minor visual artifacts. Since each new kernel requires a new shader we\r\n     * want to minimize kernel changes, having gaps between physical kernels is helpful in that regard.\r\n     * The gaps between physical kernels are compensated for in the weighting of the samples\r\n     * @param idealKernel Ideal blur kernel.\r\n     * @returns Nearest best kernel.\r\n     */\r\n    protected _nearestBestKernel(idealKernel: number): number {\r\n        const v = Math.round(idealKernel);\r\n        for (const k of [v, v - 1, v + 1, v - 2, v + 2]) {\r\n            if (k % 2 !== 0 && Math.floor(k / 2) % 2 === 0 && k > 0) {\r\n                return Math.max(k, 3);\r\n            }\r\n        }\r\n        return Math.max(v, 3);\r\n    }\r\n\r\n    /**\r\n     * Calculates the value of a Gaussian distribution with sigma 3 at a given point.\r\n     * @param x The point on the Gaussian distribution to sample.\r\n     * @returns the value of the Gaussian function at x.\r\n     */\r\n    protected _gaussianWeight(x: number): number {\r\n        //reference: Engines/ImageProcessingBlur.cpp #dcc760\r\n        // We are evaluating the Gaussian (normal) distribution over a kernel parameter space of [-1,1],\r\n        // so we truncate at three standard deviations by setting stddev (sigma) to 1/3.\r\n        // The choice of 3-sigma truncation is common but arbitrary, and means that the signal is\r\n        // truncated at around 1.3% of peak strength.\r\n\r\n        //the distribution is scaled to account for the difference between the actual kernel size and the requested kernel size\r\n        const sigma = 1 / 3;\r\n        const denominator = Math.sqrt(2.0 * Math.PI) * sigma;\r\n        const exponent = -((x * x) / (2.0 * sigma * sigma));\r\n        const weight = (1.0 / denominator) * Math.exp(exponent);\r\n        return weight;\r\n    }\r\n\r\n    /**\r\n     * Generates a string that can be used as a floating point number in GLSL.\r\n     * @param x Value to print.\r\n     * @param decimalFigures Number of decimal places to print the number to (excluding trailing 0s).\r\n     * @returns GLSL float string.\r\n     */\r\n    protected _glslFloat(x: number, decimalFigures = 8) {\r\n        return x.toFixed(decimalFigures).replace(/0+$/, \"\");\r\n    }\r\n}\r\n"]}