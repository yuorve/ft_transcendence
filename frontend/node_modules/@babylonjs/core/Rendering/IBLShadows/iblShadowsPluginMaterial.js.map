{"version":3,"file":"iblShadowsPluginMaterial.js","sourceRoot":"","sources":["../../../../../dev/core/src/Rendering/IBLShadows/iblShadowsPluginMaterial.ts"],"names":[],"mappings":"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","sourcesContent":["import { MaterialDefines } from \"core/Materials/materialDefines\";\r\nimport { MaterialPluginBase } from \"core/Materials/materialPluginBase\";\r\nimport type { InternalTexture } from \"core/Materials/Textures/internalTexture\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport { Constants } from \"core/Engines/constants\";\r\nimport type { StandardMaterial } from \"core/Materials/standardMaterial\";\r\nimport { PBRBaseMaterial } from \"core/Materials/PBR/pbrBaseMaterial\";\r\nimport type { UniformBuffer } from \"core/Materials/uniformBuffer\";\r\nimport { expandToProperty, serialize } from \"core/Misc/decorators\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\n\r\nimport { ShaderLanguage } from \"core/Materials/shaderLanguage\";\r\n/**\r\n * @internal\r\n */\r\nclass MaterialIBLShadowsRenderDefines extends MaterialDefines {\r\n    public RENDER_WITH_IBL_SHADOWS = false;\r\n    public COLORED_IBL_SHADOWS = false;\r\n}\r\n\r\n/**\r\n * Plugin used to render the contribution from IBL shadows.\r\n */\r\nexport class IBLShadowsPluginMaterial extends MaterialPluginBase {\r\n    /**\r\n     * Defines the name of the plugin.\r\n     */\r\n    public static readonly Name = \"IBLShadowsPluginMaterial\";\r\n\r\n    /**\r\n     * The texture containing the contribution from IBL shadows.\r\n     */\r\n    @serialize()\r\n    public iblShadowsTexture: InternalTexture;\r\n\r\n    /**\r\n     * The opacity of the shadows.\r\n     */\r\n    @serialize()\r\n    public shadowOpacity: number = 1.0;\r\n\r\n    private _isEnabled = false;\r\n    private _isColored = false;\r\n    public get isColored(): boolean {\r\n        return this._isColored;\r\n    }\r\n    public set isColored(value: boolean) {\r\n        if (this._isColored === value) {\r\n            return;\r\n        }\r\n        this._isColored = value;\r\n        this._markAllSubMeshesAsTexturesDirty();\r\n    }\r\n    /**\r\n     * Defines if the plugin is enabled in the material.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public isEnabled = false;\r\n\r\n    protected _markAllSubMeshesAsTexturesDirty(): void {\r\n        this._enable(this._isEnabled);\r\n        this._internalMarkAllSubMeshesAsTexturesDirty();\r\n    }\r\n\r\n    private _internalMarkAllSubMeshesAsTexturesDirty: () => void;\r\n\r\n    /**\r\n     * Gets a boolean indicating that the plugin is compatible with a give shader language.\r\n     * @returns true if the plugin is compatible with the shader language\r\n     */\r\n    public override isCompatible(): boolean {\r\n        return true;\r\n    }\r\n\r\n    constructor(material: Material | StandardMaterial | PBRBaseMaterial) {\r\n        super(material, IBLShadowsPluginMaterial.Name, 310, new MaterialIBLShadowsRenderDefines());\r\n        this._internalMarkAllSubMeshesAsTexturesDirty = material._dirtyCallbacks[Constants.MATERIAL_TextureDirtyFlag];\r\n    }\r\n\r\n    public override prepareDefines(defines: MaterialIBLShadowsRenderDefines) {\r\n        defines.RENDER_WITH_IBL_SHADOWS = this._isEnabled;\r\n        defines.COLORED_IBL_SHADOWS = this.isColored;\r\n    }\r\n\r\n    public override getClassName() {\r\n        return \"IBLShadowsPluginMaterial\";\r\n    }\r\n\r\n    public override getUniforms() {\r\n        return {\r\n            ubo: [\r\n                { name: \"renderTargetSize\", size: 2, type: \"vec2\" },\r\n                { name: \"shadowOpacity\", size: 1, type: \"float\" },\r\n            ],\r\n            fragment: `#ifdef RENDER_WITH_IBL_SHADOWS\r\n                    uniform vec2 renderTargetSize;\r\n                    uniform float shadowOpacity;\r\n                #endif`,\r\n        };\r\n    }\r\n\r\n    public override getSamplers(samplers: string[]) {\r\n        samplers.push(\"iblShadowsTexture\");\r\n    }\r\n\r\n    public override bindForSubMesh(uniformBuffer: UniformBuffer) {\r\n        if (this._isEnabled) {\r\n            uniformBuffer.bindTexture(\"iblShadowsTexture\", this.iblShadowsTexture);\r\n            uniformBuffer.updateFloat2(\"renderTargetSize\", this._material.getScene().getEngine().getRenderWidth(), this._material.getScene().getEngine().getRenderHeight());\r\n            uniformBuffer.updateFloat(\"shadowOpacity\", this.shadowOpacity);\r\n        }\r\n    }\r\n\r\n    public override getCustomCode(shaderType: string, shaderLanguage: ShaderLanguage) {\r\n        let frag: { [name: string]: string };\r\n\r\n        if (shaderLanguage === ShaderLanguage.WGSL) {\r\n            frag = {\r\n                // eslint-disable-next-line @typescript-eslint/naming-convention\r\n                CUSTOM_FRAGMENT_DEFINITIONS: `\r\n                #ifdef RENDER_WITH_IBL_SHADOWS\r\n                    var iblShadowsTextureSampler: sampler;\r\n                    var iblShadowsTexture: texture_2d<f32>;\r\n\r\n                    #ifdef COLORED_IBL_SHADOWS\r\n                        fn computeIndirectShadow() -> vec3f {\r\n                            var uv = fragmentInputs.position.xy / uniforms.renderTargetSize;\r\n                            var shadowValue: vec3f = textureSample(iblShadowsTexture, iblShadowsTextureSampler, uv).rgb;\r\n                            return mix(shadowValue, vec3f(1.0), 1.0 - uniforms.shadowOpacity);\r\n                        }\r\n                    #else\r\n                        fn computeIndirectShadow() -> vec2f {\r\n                            var uv = fragmentInputs.position.xy / uniforms.renderTargetSize;\r\n                            var shadowValue: vec2f = textureSample(iblShadowsTexture, iblShadowsTextureSampler, uv).rg;\r\n                            return mix(shadowValue, vec2f(1.0), 1.0 - uniforms.shadowOpacity);\r\n                        }\r\n                    #endif\r\n                #endif\r\n            `,\r\n            };\r\n\r\n            if (this._material instanceof PBRBaseMaterial) {\r\n                // eslint-disable-next-line @typescript-eslint/naming-convention\r\n                frag[\"CUSTOM_FRAGMENT_BEFORE_FINALCOLORCOMPOSITION\"] = `\r\n                #ifdef RENDER_WITH_IBL_SHADOWS\r\n                    #ifdef REFLECTION\r\n                        #ifdef COLORED_IBL_SHADOWS\r\n                            var shadowValue: vec3f = computeIndirectShadow();\r\n                            finalIrradiance *= shadowValue;\r\n                            finalRadianceScaled *= mix(vec3f(1.0), shadowValue, roughness);\r\n                        #else\r\n                            var shadowValue: vec2f = computeIndirectShadow();\r\n                            finalIrradiance *= vec3f(shadowValue.x);\r\n                            finalRadianceScaled *= vec3f(mix(pow(shadowValue.y, 4.0), shadowValue.x, roughness));\r\n                        #endif\r\n                    #endif\r\n                #endif\r\n            `;\r\n            } else {\r\n                frag[\"CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR\"] = `\r\n                #ifdef RENDER_WITH_IBL_SHADOWS\r\n                    #ifdef COLORED_IBL_SHADOWS\r\n                        var shadowValue: vec3f = computeIndirectShadow();\r\n                        color *= toGammaSpace(vec4f(shadowValue, 1.0f));\r\n                    #else\r\n                        var shadowValue: vec2f = computeIndirectShadow();\r\n                        color *= toGammaSpace(vec4f(shadowValue.x, shadowValue.x, shadowValue.x, 1.0f));\r\n                    #endif\r\n                #endif\r\n            `;\r\n            }\r\n        } else {\r\n            frag = {\r\n                // eslint-disable-next-line @typescript-eslint/naming-convention\r\n                CUSTOM_FRAGMENT_DEFINITIONS: `\r\n                #ifdef RENDER_WITH_IBL_SHADOWS\r\n                    uniform sampler2D iblShadowsTexture;\r\n                #ifdef COLORED_IBL_SHADOWS\r\n                    vec3 computeIndirectShadow() {\r\n                        vec2 uv = gl_FragCoord.xy / renderTargetSize;\r\n                        vec3 shadowValue = texture2D(iblShadowsTexture, uv).rgb;\r\n                        return mix(shadowValue.rgb, vec3(1.0), 1.0 - shadowOpacity);\r\n                    }\r\n                #else\r\n                    vec2 computeIndirectShadow() {\r\n                        vec2 uv = gl_FragCoord.xy / renderTargetSize;\r\n                        vec2 shadowValue = texture2D(iblShadowsTexture, uv).rg;\r\n                        return mix(shadowValue.rg, vec2(1.0), 1.0 - shadowOpacity);\r\n                    }\r\n                #endif\r\n                #endif\r\n            `,\r\n            };\r\n\r\n            if (this._material instanceof PBRBaseMaterial) {\r\n                // eslint-disable-next-line @typescript-eslint/naming-convention\r\n                frag[\"CUSTOM_FRAGMENT_BEFORE_FINALCOLORCOMPOSITION\"] = `\r\n                #ifdef RENDER_WITH_IBL_SHADOWS\r\n                    #ifdef REFLECTION\r\n                        #ifdef COLORED_IBL_SHADOWS\r\n                            vec3 shadowValue = computeIndirectShadow();\r\n                            finalIrradiance.rgb *= shadowValue.rgb;\r\n                            finalRadianceScaled *= mix(vec3(1.0), shadowValue.rgb, roughness);\r\n                        #else\r\n                            vec2 shadowValue = computeIndirectShadow();\r\n                            finalIrradiance *= shadowValue.x;\r\n                            finalRadianceScaled *= mix(pow(shadowValue.y, 4.0), shadowValue.x, roughness);\r\n                        #endif\r\n                    #endif\r\n                #endif\r\n            `;\r\n            } else {\r\n                frag[\"CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR\"] = `\r\n                #ifdef RENDER_WITH_IBL_SHADOWS\r\n                    #ifdef COLORED_IBL_SHADOWS\r\n                        vec3 shadowValue = computeIndirectShadow();\r\n                        color.rgb *= toGammaSpace(shadowValue.rgb);\r\n                    #else\r\n                        vec2 shadowValue = computeIndirectShadow();\r\n                        color.rgb *= toGammaSpace(shadowValue.x);\r\n                    #endif\r\n                #endif\r\n            `;\r\n            }\r\n        }\r\n\r\n        return shaderType === \"vertex\" ? null : frag;\r\n    }\r\n}\r\n\r\nRegisterClass(`BABYLON.IBLShadowsPluginMaterial`, IBLShadowsPluginMaterial);\r\n"]}