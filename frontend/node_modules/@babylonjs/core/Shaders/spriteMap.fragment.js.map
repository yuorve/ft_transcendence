{"version":3,"file":"spriteMap.fragment.js","sourceRoot":"","sources":["../../../../dev/core/src/Shaders/spriteMap.fragment.ts"],"names":[],"mappings":"AAAA,eAAe;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;AACrD,OAAO,yCAAyC,CAAC;AACjD,OAAO,sCAAsC,CAAC;AAC9C,OAAO,mCAAmC,CAAC;AAC3C,OAAO,8BAA8B,CAAC;AAEtC,MAAM,IAAI,GAAG,sBAAsB,CAAC;AACpC,MAAM,MAAM,GAAG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;qBA0CM,CAAC;AACtB,aAAa;AACb,IAAI,CAAC,WAAW,CAAC,YAAY,CAAC,IAAI,CAAC,EAAE,CAAC;IAClC,WAAW,CAAC,YAAY,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAC5C,CAAC;AACD,gBAAgB;AAChB,MAAM,CAAC,MAAM,oBAAoB,GAAG,EAAE,IAAI,EAAE,MAAM,EAAE,CAAC","sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/fogFragmentDeclaration\";\nimport \"./ShadersInclude/logDepthDeclaration\";\nimport \"./ShadersInclude/logDepthFragment\";\nimport \"./ShadersInclude/fogFragment\";\n\nconst name = \"spriteMapPixelShader\";\nconst shader = `#ifdef LOGARITHMICDEPTH\n#extension GL_EXT_frag_depth : enable\n#endif\n#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)\n#define TEXTUREFUNC(s,c,l) texture2DLodEXT(s,c,l)\n#else\n#define TEXTUREFUNC(s,c,b) texture2D(s,c,b)\n#endif\nprecision highp float;varying vec3 vPosition;varying vec2 vUV;varying vec2 tUV;uniform float time;uniform float spriteCount;uniform sampler2D spriteSheet;uniform vec2 spriteMapSize;uniform vec2 outputSize;uniform vec2 stageSize;uniform sampler2D frameMap;uniform sampler2D tileMaps[LAYERS];uniform sampler2D animationMap;uniform vec3 colorMul;\n#include<fogFragmentDeclaration>\n#include<logDepthDeclaration>\nfloat mt;const float fdStep=1.0*0.25;const float aFrameSteps=MAX_ANIMATION_FRAMES==0.0 ? 0.0 : 1.0/MAX_ANIMATION_FRAMES;mat4 getFrameData(float frameID) {float fX=frameID/spriteCount;return mat4(\nTEXTUREFUNC(frameMap,vec2(fX,0.0),0.0),\nTEXTUREFUNC(frameMap,vec2(fX,fdStep*1.0),0.0),\nTEXTUREFUNC(frameMap,vec2(fX,fdStep*2.0),0.0),\nvec4(0.0)\n);}\nvoid main() {vec4 color=vec4(0.0);vec2 tileUV=fract(tUV);vec2 tileID=floor(tUV);vec2 sheetUnits=1.0/spriteMapSize;float spriteUnits=1.0/spriteCount;vec2 stageUnits=1.0/stageSize;for(int i=0; i<LAYERS; i++) {float frameID;\n#define LAYER_ID_SWITCH\nvec4 animationData=TEXTUREFUNC(animationMap,vec2((frameID+0.5)/spriteCount,0.0),0.0);if(animationData.y>0.0) {mt=mod(time*animationData.z,1.0);for(float f=0.0; f<MAX_ANIMATION_FRAMES; f++) {if(animationData.y>mt) {frameID=animationData.x;break;}\nanimationData=TEXTUREFUNC(animationMap,vec2((frameID+0.5)/spriteCount,aFrameSteps*f),0.0);}}\nmat4 frameData=getFrameData(frameID+0.5);vec2 frameSize=(frameData[0].zw)/spriteMapSize;vec2 offset=frameData[0].xy*sheetUnits;vec2 ratio=frameData[2].xy/frameData[0].zw;\n#ifdef FR_CW\nif (frameData[2].z==1.0) {tileUV.xy=tileUV.yx;} else {tileUV.xy=fract(tUV).xy;}\n#ifdef FLIPU\ntileUV.y=1.0-tileUV.y;\n#endif\n#else\nif (frameData[2].z==1.0) {\n#ifdef FLIPU\ntileUV.y=1.0-tileUV.y;\n#endif\ntileUV.xy=tileUV.yx;} else {tileUV.xy=fract(tUV).xy;\n#ifdef FLIPU\ntileUV.y=1.0-tileUV.y;\n#endif\n}\n#endif\nvec4 nc=TEXTUREFUNC(spriteSheet,tileUV*frameSize+offset,0.0);if (i==0) {color=nc;} else {float alpha=min(color.a+nc.a,1.0);vec3 mixed=mix(color.xyz,nc.xyz,nc.a);color=vec4(mixed,alpha);}}\ncolor.xyz*=colorMul;\n#include<logDepthFragment>\n#include<fogFragment>\ngl_FragColor=color;}`;\n// Sideeffect\nif (!ShaderStore.ShadersStore[name]) {\n    ShaderStore.ShadersStore[name] = shader;\n}\n/** @internal */\nexport const spriteMapPixelShader = { name, shader };\n"]}