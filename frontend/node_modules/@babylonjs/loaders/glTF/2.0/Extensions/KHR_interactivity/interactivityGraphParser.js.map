{"version":3,"file":"interactivityGraphParser.js","sourceRoot":"","sources":["../../../../../../../dev/loaders/src/glTF/2.0/Extensions/KHR_interactivity/interactivityGraphParser.ts"],"names":[],"mappings":"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","sourcesContent":["import type { IKHRInteractivity_Graph, IKHRInteractivity_Node, IKHRInteractivity_OutputSocketReference, IKHRInteractivity_Variable } from \"babylonjs-gltf2interface\";\nimport type { IGLTF } from \"../../glTFLoaderInterfaces\";\nimport type { IGLTFToFlowGraphMapping } from \"./declarationMapper\";\nimport { getMappingForDeclaration, getMappingForFullOperationName } from \"./declarationMapper\";\nimport { Logger } from \"core/Misc/logger\";\nimport type { ISerializedFlowGraph, ISerializedFlowGraphBlock, ISerializedFlowGraphConnection, ISerializedFlowGraphContext } from \"core/FlowGraph/typeDefinitions\";\nimport { RandomGUID } from \"core/Misc/guid\";\nimport type { IFlowGraphBlockConfiguration } from \"core/FlowGraph/flowGraphBlock\";\nimport type { FlowGraphBlockNames } from \"core/FlowGraph/Blocks/flowGraphBlockNames\";\nimport { FlowGraphConnectionType } from \"core/FlowGraph/flowGraphConnection\";\nimport { FlowGraphTypes } from \"core/FlowGraph/flowGraphRichTypes\";\nimport type { GLTFLoader } from \"../../glTFLoader\";\n\nexport interface InteractivityEvent {\n    eventId: string;\n    eventData?: {\n        eventData: boolean;\n        id: string;\n        type: string;\n        value?: any;\n    }[];\n}\nexport const gltfTypeToBabylonType: {\n    [key: string]: { length: number; flowGraphType: FlowGraphTypes; elementType: \"number\" | \"boolean\" };\n} = {\n    float: { length: 1, flowGraphType: FlowGraphTypes.Number, elementType: \"number\" },\n    bool: { length: 1, flowGraphType: FlowGraphTypes.Boolean, elementType: \"boolean\" },\n    float2: { length: 2, flowGraphType: FlowGraphTypes.Vector2, elementType: \"number\" },\n    float3: { length: 3, flowGraphType: FlowGraphTypes.Vector3, elementType: \"number\" },\n    float4: { length: 4, flowGraphType: FlowGraphTypes.Vector4, elementType: \"number\" },\n    float4x4: { length: 16, flowGraphType: FlowGraphTypes.Matrix, elementType: \"number\" },\n    float2x2: { length: 4, flowGraphType: FlowGraphTypes.Matrix2D, elementType: \"number\" },\n    float3x3: { length: 9, flowGraphType: FlowGraphTypes.Matrix3D, elementType: \"number\" },\n    int: { length: 1, flowGraphType: FlowGraphTypes.Integer, elementType: \"number\" },\n};\n\nexport class InteractivityGraphToFlowGraphParser {\n    /**\n     * Note - the graph should be rejected if the same type is defined twice.\n     * We currently don't validate that.\n     */\n    private _types: { length: number; flowGraphType: FlowGraphTypes; elementType: \"number\" | \"boolean\" }[] = [];\n    private _mappings: { flowGraphMapping: IGLTFToFlowGraphMapping; fullOperationName: string }[] = [];\n    private _staticVariables: { type: FlowGraphTypes; value: any[] }[] = [];\n    private _events: InteractivityEvent[] = [];\n    private _internalEventsCounter: number = 0;\n    private _nodes: { blocks: ISerializedFlowGraphBlock[]; fullOperationName: string }[] = [];\n\n    constructor(\n        private _interactivityGraph: IKHRInteractivity_Graph,\n        private _gltf: IGLTF,\n        public _loader: GLTFLoader\n    ) {\n        // start with types\n        this._parseTypes();\n        // continue with declarations\n        this._parseDeclarations();\n        this._parseVariables();\n        this._parseEvents();\n        this._parseNodes();\n    }\n\n    public get arrays() {\n        return {\n            types: this._types,\n            mappings: this._mappings,\n            staticVariables: this._staticVariables,\n            events: this._events,\n            nodes: this._nodes,\n        };\n    }\n\n    private _parseTypes() {\n        if (!this._interactivityGraph.types) {\n            return;\n        }\n        for (const type of this._interactivityGraph.types) {\n            this._types.push(gltfTypeToBabylonType[type.signature]);\n        }\n    }\n\n    private _parseDeclarations() {\n        if (!this._interactivityGraph.declarations) {\n            return;\n        }\n        for (const declaration of this._interactivityGraph.declarations) {\n            // make sure we have the mapping for this operation\n            const mapping = getMappingForDeclaration(declaration);\n            // mapping is defined, because we generate an empty mapping if it's not found\n            if (!mapping) {\n                Logger.Error([\"No mapping found for declaration\", declaration]);\n                throw new Error(\"Error parsing declarations\");\n            }\n            this._mappings.push({\n                flowGraphMapping: mapping,\n                fullOperationName: declaration.extension ? declaration.op + \":\" + declaration.extension : declaration.op,\n            });\n        }\n    }\n\n    private _parseVariables() {\n        if (!this._interactivityGraph.variables) {\n            return;\n        }\n        for (const variable of this._interactivityGraph.variables) {\n            const parsed = this._parseVariable(variable);\n            // set the default values here\n            this._staticVariables.push(parsed);\n        }\n    }\n\n    private _parseVariable(variable: IKHRInteractivity_Variable, dataTransform?: (value: any, parser: InteractivityGraphToFlowGraphParser) => any) {\n        const type = this._types[variable.type];\n        if (!type) {\n            Logger.Error([\"No type found for variable\", variable]);\n            throw new Error(\"Error parsing variables\");\n        }\n        if (variable.value) {\n            if (variable.value.length !== type.length) {\n                Logger.Error([\"Invalid value length for variable\", variable, type]);\n                throw new Error(\"Error parsing variables\");\n            }\n        }\n        const value = variable.value || [];\n        if (!value.length) {\n            switch (type.flowGraphType) {\n                case FlowGraphTypes.Boolean:\n                    value.push(false);\n                    break;\n                case FlowGraphTypes.Integer:\n                    value.push(0);\n                    break;\n                case FlowGraphTypes.Number:\n                    value.push(NaN);\n                    break;\n                case FlowGraphTypes.Vector2:\n                    value.push(NaN, NaN);\n                    break;\n                case FlowGraphTypes.Vector3:\n                    value.push(NaN, NaN, NaN);\n                    break;\n                case FlowGraphTypes.Vector4:\n                case FlowGraphTypes.Matrix2D:\n                case FlowGraphTypes.Quaternion:\n                    value.fill(NaN, 0, 4);\n                    break;\n                case FlowGraphTypes.Matrix:\n                    value.fill(NaN, 0, 16);\n                    break;\n                case FlowGraphTypes.Matrix3D:\n                    value.fill(NaN, 0, 9);\n                    break;\n                default:\n                    break;\n            }\n        }\n        return { type: type.flowGraphType, value: dataTransform ? dataTransform(value, this) : value };\n    }\n\n    private _parseEvents() {\n        if (!this._interactivityGraph.events) {\n            return;\n        }\n        for (const event of this._interactivityGraph.events) {\n            const converted: InteractivityEvent = {\n                eventId: event.id || \"internalEvent_\" + this._internalEventsCounter++,\n            };\n            if (event.values) {\n                converted.eventData = Object.keys(event.values).map((key) => {\n                    const eventValue = event.values?.[key];\n                    if (!eventValue) {\n                        Logger.Error([\"No value found for event key\", key]);\n                        throw new Error(\"Error parsing events\");\n                    }\n                    const type = this._types[eventValue.type];\n                    if (!type) {\n                        Logger.Error([\"No type found for event value\", eventValue]);\n                        throw new Error(\"Error parsing events\");\n                    }\n                    const value = typeof eventValue.value !== \"undefined\" ? this._parseVariable(eventValue) : undefined;\n                    return {\n                        id: key,\n                        type: type.flowGraphType,\n                        eventData: true,\n                        value,\n                    };\n                });\n            }\n            this._events.push(converted);\n        }\n    }\n\n    private _parseNodes() {\n        if (!this._interactivityGraph.nodes) {\n            return;\n        }\n        for (const node of this._interactivityGraph.nodes) {\n            // some validation\n            if (typeof node.declaration !== \"number\") {\n                Logger.Error([\"No declaration found for node\", node]);\n                throw new Error(\"Error parsing nodes\");\n            }\n            const mapping = this._mappings[node.declaration];\n            if (!mapping) {\n                Logger.Error([\"No mapping found for node\", node]);\n                throw new Error(\"Error parsing nodes\");\n            }\n            if (mapping.flowGraphMapping.validation) {\n                if (!mapping.flowGraphMapping.validation(node, this._interactivityGraph, this._gltf)) {\n                    throw new Error(`Error validating interactivity node ${node}`);\n                }\n            }\n            const blocks: ISerializedFlowGraphBlock[] = [];\n            // create block(s) for this node using the mapping\n            for (const blockType of mapping.flowGraphMapping.blocks) {\n                const block = this._getEmptyBlock(blockType, mapping.fullOperationName);\n                this._parseNodeConfiguration(node, block, mapping.flowGraphMapping, blockType);\n                blocks.push(block);\n            }\n            this._nodes.push({ blocks, fullOperationName: mapping.fullOperationName });\n        }\n    }\n\n    private _getEmptyBlock(className: string, type: string): ISerializedFlowGraphBlock {\n        const uniqueId = RandomGUID();\n        const dataInputs: ISerializedFlowGraphConnection[] = [];\n        const dataOutputs: ISerializedFlowGraphConnection[] = [];\n        const signalInputs: ISerializedFlowGraphConnection[] = [];\n        const signalOutputs: ISerializedFlowGraphConnection[] = [];\n        const config: IFlowGraphBlockConfiguration = {};\n        const metadata = {};\n        return {\n            uniqueId,\n            className,\n            dataInputs,\n            dataOutputs,\n            signalInputs,\n            signalOutputs,\n            config,\n            type,\n            metadata,\n        };\n    }\n\n    private _parseNodeConfiguration(node: IKHRInteractivity_Node, block: ISerializedFlowGraphBlock, nodeMapping: IGLTFToFlowGraphMapping, blockType: FlowGraphBlockNames | string) {\n        const configuration = block.config;\n        if (node.configuration) {\n            Object.keys(node.configuration).forEach((key) => {\n                const value = node.configuration?.[key];\n                // value is always an array, never a number or string\n                if (!value) {\n                    Logger.Error([\"No value found for node configuration\", key]);\n                    throw new Error(\"Error parsing node configuration\");\n                }\n                const configMapping = nodeMapping.configuration?.[key];\n                const belongsToBlock = configMapping && configMapping.toBlock ? configMapping.toBlock === blockType : nodeMapping.blocks.indexOf(blockType) === 0;\n                if (belongsToBlock) {\n                    // get the right name for the configuration key\n                    const configKey = configMapping?.name || key;\n                    if ((!value || typeof value.value === \"undefined\") && typeof configMapping?.defaultValue !== \"undefined\") {\n                        configuration[configKey] = {\n                            value: configMapping.defaultValue,\n                        };\n                    } else if (value.value.length >= 1) {\n                        // supporting int[] and int/boolean/string\n                        configuration[configKey] = {\n                            value: value.value.length === 1 ? value.value[0] : value.value,\n                        };\n                    } else {\n                        Logger.Warn([\"Invalid value for node configuration\", value]);\n                    }\n                    // make sure we transform the data if needed\n                    if (configMapping && configMapping.dataTransformer) {\n                        configuration[configKey].value = configMapping.dataTransformer([configuration[configKey].value], this)[0];\n                    }\n                }\n            });\n        }\n    }\n\n    private _parseNodeConnections(context: ISerializedFlowGraphContext) {\n        for (let i = 0; i < this._nodes.length; i++) {\n            // get the corresponding gltf node\n            const gltfNode = this._interactivityGraph.nodes?.[i];\n            if (!gltfNode) {\n                // should never happen but let's still check\n                Logger.Error([\"No node found for interactivity node\", this._nodes[i]]);\n                throw new Error(\"Error parsing node connections\");\n            }\n            const flowGraphBlocks = this._nodes[i];\n            const outputMapper = this._mappings[gltfNode.declaration];\n            // validate\n            if (!outputMapper) {\n                Logger.Error([\"No mapping found for node\", gltfNode]);\n                throw new Error(\"Error parsing node connections\");\n            }\n            const flowsFromGLTF = gltfNode.flows || {};\n            const flowsKeys = Object.keys(flowsFromGLTF).sort(); // sorting as some operations require sorted keys\n            // connect the flows\n            for (const flowKey of flowsKeys) {\n                const flow = flowsFromGLTF[flowKey];\n                const flowMapping = outputMapper.flowGraphMapping.outputs?.flows?.[flowKey];\n                const socketOutName = flowMapping?.name || flowKey;\n                // create a serialized socket\n                const socketOut = this._createNewSocketConnection(socketOutName, true);\n                const block = (flowMapping && flowMapping.toBlock && flowGraphBlocks.blocks.find((b) => b.className === flowMapping.toBlock)) || flowGraphBlocks.blocks[0];\n                block.signalOutputs.push(socketOut);\n                // get the input node of this block\n                const inputNodeId = flow.node;\n                const nodeIn = this._nodes[inputNodeId];\n                if (!nodeIn) {\n                    Logger.Error([\"No node found for input node id\", inputNodeId]);\n                    throw new Error(\"Error parsing node connections\");\n                }\n                // get the mapper for the input node - in case it mapped to multiple blocks\n                const inputMapper = getMappingForFullOperationName(nodeIn.fullOperationName);\n                if (!inputMapper) {\n                    Logger.Error([\"No mapping found for input node\", nodeIn]);\n                    throw new Error(\"Error parsing node connections\");\n                }\n                let flowInMapping = inputMapper.inputs?.flows?.[flow.socket || \"in\"];\n                let arrayMapping = false;\n                if (!flowInMapping) {\n                    for (const key in inputMapper.inputs?.flows) {\n                        if (key.startsWith(\"[\") && key.endsWith(\"]\")) {\n                            arrayMapping = true;\n                            flowInMapping = inputMapper.inputs?.flows?.[key];\n                        }\n                    }\n                }\n                const nodeInSocketName = flowInMapping ? (arrayMapping ? flowInMapping.name.replace(\"$1\", flow.socket || \"\") : flowInMapping.name) : flow.socket || \"in\";\n                const inputBlock = (flowInMapping && flowInMapping.toBlock && nodeIn.blocks.find((b) => b.className === flowInMapping.toBlock)) || nodeIn.blocks[0];\n                // in all of the flow graph input connections, find the one with the same name as the socket\n                let socketIn = inputBlock.signalInputs.find((s) => s.name === nodeInSocketName);\n                // if the socket doesn't exist, create the input socket for the connection\n                if (!socketIn) {\n                    socketIn = this._createNewSocketConnection(nodeInSocketName);\n                    inputBlock.signalInputs.push(socketIn);\n                }\n                // connect the sockets\n                socketIn.connectedPointIds.push(socketOut.uniqueId);\n                socketOut.connectedPointIds.push(socketIn.uniqueId);\n            }\n            // connect the values\n            const valuesFromGLTF = gltfNode.values || {};\n            const valuesKeys = Object.keys(valuesFromGLTF);\n            for (const valueKey of valuesKeys) {\n                const value = valuesFromGLTF[valueKey];\n                let valueMapping = outputMapper.flowGraphMapping.inputs?.values?.[valueKey];\n                let arrayMapping = false;\n                if (!valueMapping) {\n                    for (const key in outputMapper.flowGraphMapping.inputs?.values) {\n                        if (key.startsWith(\"[\") && key.endsWith(\"]\")) {\n                            arrayMapping = true;\n                            valueMapping = outputMapper.flowGraphMapping.inputs?.values?.[key];\n                        }\n                    }\n                }\n                const socketInName = valueMapping ? (arrayMapping ? valueMapping.name.replace(\"$1\", valueKey) : valueMapping.name) : valueKey;\n                // create a serialized socket\n                const socketIn = this._createNewSocketConnection(socketInName);\n                const block = (valueMapping && valueMapping.toBlock && flowGraphBlocks.blocks.find((b) => b.className === valueMapping!.toBlock)) || flowGraphBlocks.blocks[0];\n                block.dataInputs.push(socketIn);\n                if ((value as IKHRInteractivity_Variable).value !== undefined) {\n                    const convertedValue = this._parseVariable(value as IKHRInteractivity_Variable, valueMapping && valueMapping.dataTransformer);\n                    context._connectionValues[socketIn.uniqueId] = convertedValue;\n                } else if (typeof (value as IKHRInteractivity_OutputSocketReference).node !== \"undefined\") {\n                    const nodeOutId = (value as IKHRInteractivity_OutputSocketReference).node;\n                    const nodeOutSocketName = (value as IKHRInteractivity_OutputSocketReference).socket || \"value\";\n                    const nodeOut = this._nodes[nodeOutId];\n                    if (!nodeOut) {\n                        Logger.Error([\"No node found for output socket reference\", value]);\n                        throw new Error(\"Error parsing node connections\");\n                    }\n                    const outputMapper = getMappingForFullOperationName(nodeOut.fullOperationName);\n                    if (!outputMapper) {\n                        Logger.Error([\"No mapping found for output socket reference\", value]);\n                        throw new Error(\"Error parsing node connections\");\n                    }\n                    let valueMapping = outputMapper.outputs?.values?.[nodeOutSocketName];\n                    let arrayMapping = false;\n                    // check if there is an array mapping defined\n                    if (!valueMapping) {\n                        // search for a value mapping that has an array mapping\n                        for (const key in outputMapper.outputs?.values) {\n                            if (key.startsWith(\"[\") && key.endsWith(\"]\")) {\n                                arrayMapping = true;\n                                valueMapping = outputMapper.outputs?.values?.[key];\n                            }\n                        }\n                    }\n                    const socketOutName = valueMapping ? (arrayMapping ? valueMapping.name.replace(\"$1\", nodeOutSocketName) : valueMapping?.name) : nodeOutSocketName;\n                    const outBlock = (valueMapping && valueMapping.toBlock && nodeOut.blocks.find((b) => b.className === valueMapping!.toBlock)) || nodeOut.blocks[0];\n                    let socketOut = outBlock.dataOutputs.find((s) => s.name === socketOutName);\n                    // if the socket doesn't exist, create it\n                    if (!socketOut) {\n                        socketOut = this._createNewSocketConnection(socketOutName, true);\n                        outBlock.dataOutputs.push(socketOut);\n                    }\n                    // connect the sockets\n                    socketIn.connectedPointIds.push(socketOut.uniqueId);\n                    socketOut.connectedPointIds.push(socketIn.uniqueId);\n                } else {\n                    Logger.Error([\"Invalid value for value connection\", value]);\n                    throw new Error(\"Error parsing node connections\");\n                }\n            }\n\n            // inter block connections\n            if (outputMapper.flowGraphMapping.interBlockConnectors) {\n                for (const connector of outputMapper.flowGraphMapping.interBlockConnectors) {\n                    const input = connector.input;\n                    const output = connector.output;\n                    const isVariable = connector.isVariable;\n                    this._connectFlowGraphNodes(input, output, flowGraphBlocks.blocks[connector.inputBlockIndex], flowGraphBlocks.blocks[connector.outputBlockIndex], isVariable);\n                }\n            }\n\n            if (outputMapper.flowGraphMapping.extraProcessor) {\n                const declaration = this._interactivityGraph.declarations?.[gltfNode.declaration];\n                if (!declaration) {\n                    Logger.Error([\"No declaration found for extra processor\", gltfNode]);\n                    throw new Error(\"Error parsing node connections\");\n                }\n                flowGraphBlocks.blocks = outputMapper.flowGraphMapping.extraProcessor(\n                    gltfNode,\n                    declaration,\n                    outputMapper.flowGraphMapping,\n                    this,\n                    flowGraphBlocks.blocks,\n                    context,\n                    this._gltf\n                );\n            }\n        }\n    }\n\n    private _createNewSocketConnection(name: string, isOutput?: boolean): ISerializedFlowGraphConnection {\n        return {\n            uniqueId: RandomGUID(),\n            name,\n            _connectionType: isOutput ? FlowGraphConnectionType.Output : FlowGraphConnectionType.Input,\n            connectedPointIds: [],\n        };\n    }\n\n    private _connectFlowGraphNodes(input: string, output: string, serializedInput: ISerializedFlowGraphBlock, serializedOutput: ISerializedFlowGraphBlock, isVariable?: boolean) {\n        const inputArray = isVariable ? serializedInput.dataInputs : serializedInput.signalInputs;\n        const outputArray = isVariable ? serializedOutput.dataOutputs : serializedOutput.signalOutputs;\n        const inputConnection = inputArray.find((s) => s.name === input) || this._createNewSocketConnection(input);\n        const outputConnection = outputArray.find((s) => s.name === output) || this._createNewSocketConnection(output, true);\n        // of not found add it to the array\n        if (!inputArray.find((s) => s.name === input)) {\n            inputArray.push(inputConnection);\n        }\n        if (!outputArray.find((s) => s.name === output)) {\n            outputArray.push(outputConnection);\n        }\n        // connect the sockets\n        inputConnection.connectedPointIds.push(outputConnection.uniqueId);\n        outputConnection.connectedPointIds.push(inputConnection.uniqueId);\n    }\n\n    public getVariableName(index: number) {\n        return \"staticVariable_\" + index;\n    }\n\n    public serializeToFlowGraph(): ISerializedFlowGraph {\n        const context: ISerializedFlowGraphContext = {\n            uniqueId: RandomGUID(),\n            _userVariables: {},\n            _connectionValues: {},\n        };\n        this._parseNodeConnections(context);\n        for (let i = 0; i < this._staticVariables.length; i++) {\n            const variable = this._staticVariables[i];\n            context._userVariables[this.getVariableName(i)] = variable;\n        }\n\n        const allBlocks = this._nodes.reduce((acc, val) => acc.concat(val.blocks), [] as ISerializedFlowGraphBlock[]);\n\n        return {\n            rightHanded: true,\n            allBlocks,\n            executionContexts: [context],\n        };\n    }\n}\n"]}