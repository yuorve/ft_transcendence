{"version":3,"file":"gltfPathToObjectConverter.js","sourceRoot":"","sources":["../../../../../../dev/loaders/src/glTF/2.0/Extensions/gltfPathToObjectConverter.ts"],"names":[],"mappings":"AAIA;;;;;GAKG;AACH,MAAM,OAAO,yBAAyB;IAClC,YACY,KAAY,EACZ,SAAc;QADd,UAAK,GAAL,KAAK,CAAO;QACZ,cAAS,GAAT,SAAS,CAAK;IACvB,CAAC;IAEJ;;;;;;;;;;;;;;;;;;;;;OAqBG;IACI,OAAO,CAAC,IAAY;QACvB,IAAI,UAAU,GAAQ,IAAI,CAAC,KAAK,CAAC;QACjC,IAAI,QAAQ,GAAQ,IAAI,CAAC,SAAS,CAAC;QACnC,IAAI,MAAM,GAAQ,SAAS,CAAC;QAE5B,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,EAAE,CAAC;YACxB,MAAM,IAAI,KAAK,CAAC,0BAA0B,CAAC,CAAC;QAChD,CAAC;QACD,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;QAC9B,KAAK,CAAC,KAAK,EAAE,CAAC;QAEd,sEAAsE;QACtE,IAAI,KAAK,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,QAAQ,CAAC,SAAS,CAAC,EAAE,CAAC;YAC9C,MAAM,QAAQ,GAAG,KAAK,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;YACzC,MAAM,KAAK,GAAG,QAAQ,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;YAClC,KAAK,CAAC,GAAG,EAAE,CAAC;YACZ,KAAK,CAAC,IAAI,CAAC,GAAG,KAAK,CAAC,CAAC;QACzB,CAAC;QAED,IAAI,gBAAgB,GAAG,KAAK,CAAC;QAE7B,KAAK,MAAM,IAAI,IAAI,KAAK,EAAE,CAAC;YACvB,MAAM,QAAQ,GAAG,IAAI,KAAK,QAAQ,CAAC;YACnC,IAAI,QAAQ,IAAI,CAAC,QAAQ,CAAC,SAAS,EAAE,CAAC;gBAClC,MAAM,IAAI,KAAK,CAAC,QAAQ,IAAI,aAAa,CAAC,CAAC;YAC/C,CAAC;YACD,IAAI,QAAQ,CAAC,oBAAoB,EAAE,CAAC;gBAChC,gBAAgB,GAAG,IAAI,CAAC;YAC5B,CAAC;YACD,IAAI,QAAQ,CAAC,SAAS,IAAI,CAAC,QAAQ,EAAE,CAAC;gBAClC,QAAQ,GAAG,QAAQ,CAAC,SAAS,CAAC;YAClC,CAAC;iBAAM,CAAC;gBACJ,QAAQ,GAAG,QAAQ,CAAC,IAAI,CAAC,CAAC;gBAC1B,IAAI,CAAC,QAAQ,EAAE,CAAC;oBACZ,MAAM,IAAI,KAAK,CAAC,QAAQ,IAAI,aAAa,CAAC,CAAC;gBAC/C,CAAC;YACL,CAAC;YACD,IAAI,CAAC,gBAAgB,EAAE,CAAC;gBACpB,IAAI,UAAU,KAAK,SAAS,EAAE,CAAC;oBAC3B,MAAM,IAAI,KAAK,CAAC,QAAQ,IAAI,aAAa,CAAC,CAAC;gBAC/C,CAAC;gBACD,IAAI,CAAC,QAAQ,EAAE,CAAC;oBACZ,UAAU,GAAG,UAAU,EAAE,CAAC,IAAI,CAAC,CAAC;gBACpC,CAAC;YACL,CAAC;YAED,IAAI,QAAQ,CAAC,UAAU,IAAI,QAAQ,EAAE,CAAC;gBAClC,MAAM,GAAG,UAAU,CAAC;YACxB,CAAC;QACL,CAAC;QAED,OAAO;YACH,MAAM,EAAE,MAAM;YACd,IAAI,EAAE,QAAQ;SACjB,CAAC;IACN,CAAC;CACJ","sourcesContent":["import type { IObjectInfo, IPathToObjectConverter } from \"core/ObjectModel/objectModelInterfaces\";\r\nimport type { IGLTF } from \"../glTFLoaderInterfaces\";\r\nimport type { IObjectAccessor } from \"core/FlowGraph/typeDefinitions\";\r\n\r\n/**\r\n * A converter that takes a glTF Object Model JSON Pointer\r\n * and transforms it into an ObjectAccessorContainer, allowing\r\n * objects referenced in the glTF to be associated with their\r\n * respective Babylon.js objects.\r\n */\r\nexport class GLTFPathToObjectConverter<T, BabylonType, BabylonValue> implements IPathToObjectConverter<IObjectAccessor<T, BabylonType, BabylonValue>> {\r\n    public constructor(\r\n        private _gltf: IGLTF,\r\n        private _infoTree: any\r\n    ) {}\r\n\r\n    /**\r\n     * The pointer string is represented by a [JSON pointer](https://datatracker.ietf.org/doc/html/rfc6901).\r\n     * See also https://github.com/KhronosGroup/glTF/blob/main/specification/2.0/ObjectModel.adoc#core-pointers\r\n     * <animationPointer> := /<rootNode>/<assetIndex>/<propertyPath>\r\n     * <rootNode> := \"nodes\" | \"materials\" | \"meshes\" | \"cameras\" | \"extensions\"\r\n     * <assetIndex> := <digit> | <name>\r\n     * <propertyPath> := <extensionPath> | <standardPath>\r\n     * <extensionPath> := \"extensions\"/<name>/<standardPath>\r\n     * <standardPath> := <name> | <name>/<standardPath>\r\n     * <name> := W+\r\n     * <digit> := D+\r\n     *\r\n     * Examples:\r\n     *  - \"/nodes/0/rotation\"\r\n     * - \"/nodes.length\"\r\n     *  - \"/materials/2/emissiveFactor\"\r\n     *  - \"/materials/2/pbrMetallicRoughness/baseColorFactor\"\r\n     *  - \"/materials/2/extensions/KHR_materials_emissive_strength/emissiveStrength\"\r\n     *\r\n     * @param path The path to convert\r\n     * @returns The object and info associated with the path\r\n     */\r\n    public convert(path: string): IObjectInfo<IObjectAccessor<T, BabylonType, BabylonValue>> {\r\n        let objectTree: any = this._gltf;\r\n        let infoTree: any = this._infoTree;\r\n        let target: any = undefined;\r\n\r\n        if (!path.startsWith(\"/\")) {\r\n            throw new Error(\"Path must start with a /\");\r\n        }\r\n        const parts = path.split(\"/\");\r\n        parts.shift();\r\n\r\n        //if the last part has \".length\" in it, separate that as an extra part\r\n        if (parts[parts.length - 1].includes(\".length\")) {\r\n            const lastPart = parts[parts.length - 1];\r\n            const split = lastPart.split(\".\");\r\n            parts.pop();\r\n            parts.push(...split);\r\n        }\r\n\r\n        let ignoreObjectTree = false;\r\n\r\n        for (const part of parts) {\r\n            const isLength = part === \"length\";\r\n            if (isLength && !infoTree.__array__) {\r\n                throw new Error(`Path ${path} is invalid`);\r\n            }\r\n            if (infoTree.__ignoreObjectTree__) {\r\n                ignoreObjectTree = true;\r\n            }\r\n            if (infoTree.__array__ && !isLength) {\r\n                infoTree = infoTree.__array__;\r\n            } else {\r\n                infoTree = infoTree[part];\r\n                if (!infoTree) {\r\n                    throw new Error(`Path ${path} is invalid`);\r\n                }\r\n            }\r\n            if (!ignoreObjectTree) {\r\n                if (objectTree === undefined) {\r\n                    throw new Error(`Path ${path} is invalid`);\r\n                }\r\n                if (!isLength) {\r\n                    objectTree = objectTree?.[part];\r\n                }\r\n            }\r\n\r\n            if (infoTree.__target__ || isLength) {\r\n                target = objectTree;\r\n            }\r\n        }\r\n\r\n        return {\r\n            object: target,\r\n            info: infoTree,\r\n        };\r\n    }\r\n}\r\n"]}