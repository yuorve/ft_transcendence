{"version":3,"file":"objectModelMapping.js","sourceRoot":"","sources":["../../../../../../dev/loaders/src/glTF/2.0/Extensions/objectModelMapping.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\n\nimport type { TransformNode } from \"core/Meshes/transformNode\";\nimport type { IAnimation, ICamera, IGLTF, IKHRLightsPunctual_Light, IMaterial, IMesh, INode } from \"../glTFLoaderInterfaces\";\nimport type { Vector3 } from \"core/Maths/math.vector\";\nimport { Matrix, Quaternion, Vector2 } from \"core/Maths/math.vector\";\nimport { Constants } from \"core/Engines/constants\";\nimport type { Color3 } from \"core/Maths/math.color\";\nimport { Color4 } from \"core/Maths/math.color\";\nimport type { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\nimport type { Light } from \"core/Lights/light\";\nimport type { Nullable } from \"core/types\";\nimport { SpotLight } from \"core/Lights/spotLight\";\nimport type { IEXTLightsImageBased_LightImageBased } from \"babylonjs-gltf2interface\";\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\nimport type { IInterpolationPropertyInfo, IObjectAccessor } from \"core/FlowGraph/typeDefinitions\";\nimport { GLTFPathToObjectConverter } from \"./gltfPathToObjectConverter\";\nimport type { AnimationGroup } from \"core/Animations/animationGroup\";\nimport type { Mesh } from \"core/Meshes/mesh\";\n\nexport interface IGLTFObjectModelTree {\n    cameras: IGLTFObjectModelTreeCamerasObject;\n    nodes: IGLTFObjectModelTreeNodesObject;\n    materials: IGLTFObjectModelTreeMaterialsObject;\n    extensions: IGLTFObjectModelTreeExtensionsObject;\n    animations: {\n        length: IObjectAccessor<IAnimation[], AnimationGroup[], number>;\n        __array__: {};\n    };\n    meshes: {\n        length: IObjectAccessor<IMesh[], (Mesh | undefined)[], number>;\n        __array__: {};\n    };\n}\n\nexport interface IGLTFObjectModelTreeNodesObject<GLTFTargetType = INode, BabylonTargetType = TransformNode> {\n    length: IObjectAccessor<GLTFTargetType[], BabylonTargetType[], number>;\n    __array__: {\n        __target__: boolean;\n        translation: IObjectAccessor<GLTFTargetType, BabylonTargetType, Vector3>;\n        rotation: IObjectAccessor<GLTFTargetType, BabylonTargetType, Quaternion>;\n        scale: IObjectAccessor<GLTFTargetType, BabylonTargetType, Vector3>;\n        matrix: IObjectAccessor<GLTFTargetType, BabylonTargetType, Matrix>;\n        globalMatrix: IObjectAccessor<GLTFTargetType, BabylonTargetType, Matrix>;\n        weights: {\n            length: IObjectAccessor<GLTFTargetType, BabylonTargetType, number>;\n            __array__: { __target__: boolean } & IObjectAccessor<GLTFTargetType, BabylonTargetType, number>;\n        } & IObjectAccessor<GLTFTargetType, BabylonTargetType, number[]>;\n        extensions: {\n            EXT_lights_ies?: {\n                multiplier: IObjectAccessor<INode, Light, number>;\n                color: IObjectAccessor<INode, Light, Color3>;\n            };\n        };\n    };\n}\n\nexport interface IGLTFObjectModelTreeCamerasObject {\n    __array__: {\n        __target__: boolean;\n        orthographic: {\n            xmag: IObjectAccessor<ICamera, ICamera, Vector2>;\n            ymag: IObjectAccessor<ICamera, ICamera, Vector2>;\n            zfar: IObjectAccessor<ICamera, ICamera, number>;\n            znear: IObjectAccessor<ICamera, ICamera, number>;\n        };\n        perspective: {\n            yfov: IObjectAccessor<ICamera, ICamera, number>;\n            zfar: IObjectAccessor<ICamera, ICamera, number>;\n            znear: IObjectAccessor<ICamera, ICamera, number>;\n            aspectRatio: IObjectAccessor<ICamera, ICamera, Nullable<number>>;\n        };\n    };\n}\n\nexport interface IGLTFObjectModelTreeMaterialsObject {\n    __array__: {\n        __target__: boolean;\n        pbrMetallicRoughness: {\n            baseColorFactor: IObjectAccessor<IMaterial, PBRMaterial, Color4>;\n            metallicFactor: IObjectAccessor<IMaterial, PBRMaterial, Nullable<number>>;\n            roughnessFactor: IObjectAccessor<IMaterial, PBRMaterial, Nullable<number>>;\n            baseColorTexture: {\n                extensions: {\n                    KHR_texture_transform: ITextureDefinition;\n                };\n            };\n            metallicRoughnessTexture: {\n                extensions: {\n                    KHR_texture_transform: ITextureDefinition;\n                };\n            };\n        };\n        emissiveFactor: IObjectAccessor<IMaterial, PBRMaterial, Color3>;\n        normalTexture: {\n            scale: IObjectAccessor<IMaterial, PBRMaterial, number>;\n            extensions: {\n                KHR_texture_transform: ITextureDefinition;\n            };\n        };\n        occlusionTexture: {\n            strength: IObjectAccessor<IMaterial, PBRMaterial, number>;\n            extensions: {\n                KHR_texture_transform: ITextureDefinition;\n            };\n        };\n        emissiveTexture: {\n            extensions: {\n                KHR_texture_transform: ITextureDefinition;\n            };\n        };\n        extensions: {\n            KHR_materials_anisotropy: {\n                anisotropyStrength: IObjectAccessor<IMaterial, PBRMaterial, number>;\n                anisotropyRotation: IObjectAccessor<IMaterial, PBRMaterial, number>;\n                anisotropyTexture: {\n                    extensions: {\n                        KHR_texture_transform: ITextureDefinition;\n                    };\n                };\n            };\n            KHR_materials_clearcoat: {\n                clearcoatFactor: IObjectAccessor<IMaterial, PBRMaterial, number>;\n                clearcoatRoughnessFactor: IObjectAccessor<IMaterial, PBRMaterial, number>;\n                clearcoatTexture: {\n                    extensions: {\n                        KHR_texture_transform: ITextureDefinition;\n                    };\n                };\n                clearcoatNormalTexture: {\n                    scale: IObjectAccessor<IMaterial, PBRMaterial, number>;\n                    extensions: {\n                        KHR_texture_transform: ITextureDefinition;\n                    };\n                };\n                clearcoatRoughnessTexture: {\n                    extensions: {\n                        KHR_texture_transform: ITextureDefinition;\n                    };\n                };\n            };\n            KHR_materials_dispersion: {\n                dispersion: IObjectAccessor<IMaterial, PBRMaterial, number>;\n            };\n            KHR_materials_emissive_strength: {\n                emissiveStrength: IObjectAccessor<IMaterial, PBRMaterial, number>;\n            };\n            KHR_materials_ior: {\n                ior: IObjectAccessor<IMaterial, PBRMaterial, number>;\n            };\n            KHR_materials_iridescence: {\n                iridescenceFactor: IObjectAccessor<IMaterial, PBRMaterial, number>;\n                iridescenceIor: IObjectAccessor<IMaterial, PBRMaterial, number>;\n                iridescenceThicknessMinimum: IObjectAccessor<IMaterial, PBRMaterial, number>;\n                iridescenceThicknessMaximum: IObjectAccessor<IMaterial, PBRMaterial, number>;\n                iridescenceTexture: {\n                    extensions: {\n                        KHR_texture_transform: ITextureDefinition;\n                    };\n                };\n                iridescenceThicknessTexture: {\n                    extensions: {\n                        KHR_texture_transform: ITextureDefinition;\n                    };\n                };\n            };\n            KHR_materials_sheen: {\n                sheenColorFactor: IObjectAccessor<IMaterial, PBRMaterial, Color3>;\n                sheenRoughnessFactor: IObjectAccessor<IMaterial, PBRMaterial, number>;\n                sheenColorTexture: {\n                    extensions: {\n                        KHR_texture_transform: ITextureDefinition;\n                    };\n                };\n                sheenRoughnessTexture: {\n                    extensions: {\n                        KHR_texture_transform: ITextureDefinition;\n                    };\n                };\n            };\n            KHR_materials_specular: {\n                specularFactor: IObjectAccessor<IMaterial, PBRMaterial, number>;\n                specularColorFactor: IObjectAccessor<IMaterial, PBRMaterial, Color3>;\n                specularTexture: {\n                    extensions: {\n                        KHR_texture_transform: ITextureDefinition;\n                    };\n                };\n                specularColorTexture: {\n                    extensions: {\n                        KHR_texture_transform: ITextureDefinition;\n                    };\n                };\n            };\n            KHR_materials_transmission: {\n                transmissionFactor: IObjectAccessor<IMaterial, PBRMaterial, number>;\n                transmissionTexture: {\n                    extensions: {\n                        KHR_texture_transform: ITextureDefinition;\n                    };\n                };\n            };\n            KHR_materials_diffuse_transmission: {\n                diffuseTransmissionFactor: IObjectAccessor<IMaterial, PBRMaterial, number>;\n                diffuseTransmissionTexture: {\n                    extensions: {\n                        KHR_texture_transform: ITextureDefinition;\n                    };\n                };\n                diffuseTransmissionColorFactor: IObjectAccessor<IMaterial, PBRMaterial, Nullable<Color3>>;\n                diffuseTransmissionColorTexture: {\n                    extensions: {\n                        KHR_texture_transform: ITextureDefinition;\n                    };\n                };\n            };\n            KHR_materials_volume: {\n                thicknessFactor: IObjectAccessor<IMaterial, PBRMaterial, number>;\n                attenuationColor: IObjectAccessor<IMaterial, PBRMaterial, Color3>;\n                attenuationDistance: IObjectAccessor<IMaterial, PBRMaterial, number>;\n                thicknessTexture: {\n                    extensions: {\n                        KHR_texture_transform: ITextureDefinition;\n                    };\n                };\n            };\n        };\n    };\n}\n\ninterface ITextureDefinition {\n    offset: IObjectAccessor<IMaterial, PBRMaterial, Vector2>;\n    rotation: IObjectAccessor<IMaterial, PBRMaterial, number>;\n    scale: IObjectAccessor<IMaterial, PBRMaterial, Vector2>;\n}\n\nexport interface IGLTFObjectModelTreeMeshesObject {}\n\nexport interface IGLTFObjectModelTreeExtensionsObject {\n    KHR_lights_punctual: {\n        lights: {\n            length: IObjectAccessor<IKHRLightsPunctual_Light[], Light[], number>;\n            __array__: {\n                __target__: boolean;\n                color: IObjectAccessor<IKHRLightsPunctual_Light, Light, Color3>;\n                intensity: IObjectAccessor<IKHRLightsPunctual_Light, Light, number>;\n                range: IObjectAccessor<IKHRLightsPunctual_Light, Light, number>;\n                spot: {\n                    innerConeAngle: IObjectAccessor<IKHRLightsPunctual_Light, Light, number>;\n                    outerConeAngle: IObjectAccessor<IKHRLightsPunctual_Light, Light, number>;\n                };\n            };\n        };\n    };\n    EXT_lights_ies: {\n        lights: {\n            length: IObjectAccessor<IKHRLightsPunctual_Light[], Light[], number>;\n        };\n    };\n    EXT_lights_image_based: {\n        lights: {\n            __array__: {\n                __target__: boolean;\n                intensity: IObjectAccessor<IEXTLightsImageBased_LightImageBased, BaseTexture, number>;\n                rotation: IObjectAccessor<IEXTLightsImageBased_LightImageBased, BaseTexture, Quaternion>;\n            };\n            length: IObjectAccessor<IEXTLightsImageBased_LightImageBased[], BaseTexture[], number>;\n        };\n    };\n}\n\nconst nodesTree: IGLTFObjectModelTreeNodesObject = {\n    length: {\n        type: \"number\",\n        get: (nodes: INode[]) => nodes.length,\n        getTarget: (nodes: INode[]) => nodes.map((node) => node._babylonTransformNode!),\n        getPropertyName: [() => \"length\"],\n    },\n    __array__: {\n        __target__: true,\n        translation: {\n            type: \"Vector3\",\n            get: (node: INode) => node._babylonTransformNode?.position,\n            set: (value: Vector3, node: INode) => node._babylonTransformNode?.position.copyFrom(value),\n            getTarget: (node: INode) => node._babylonTransformNode,\n            getPropertyName: [() => \"position\"],\n        },\n        rotation: {\n            type: \"Quaternion\",\n            get: (node: INode) => node._babylonTransformNode?.rotationQuaternion!,\n            set: (value: Quaternion, node: INode) => node._babylonTransformNode?.rotationQuaternion?.copyFrom(value),\n            getTarget: (node: INode) => node._babylonTransformNode,\n            getPropertyName: [() => \"rotationQuaternion\"],\n        },\n        scale: {\n            type: \"Vector3\",\n            get: (node: INode) => node._babylonTransformNode?.scaling,\n            set: (value: Vector3, node: INode) => node._babylonTransformNode?.scaling.copyFrom(value),\n            getTarget: (node: INode) => node._babylonTransformNode,\n            getPropertyName: [() => \"scaling\"],\n        },\n        weights: {\n            length: {\n                type: \"number\",\n                get: (node: INode) => node._numMorphTargets,\n                getTarget: (node: INode) => node._babylonTransformNode,\n                getPropertyName: [() => \"influence\"],\n            },\n            __array__: {\n                __target__: true,\n                type: \"number\",\n                get: (node: INode, index?: number) => (index !== undefined ? node._primitiveBabylonMeshes?.[0].morphTargetManager?.getTarget(index).influence : undefined),\n                // set: (value: number, node: INode, index?: number) => node._babylonTransformNode?.getMorphTargetManager()?.getTarget(index)?.setInfluence(value),\n                getTarget: (node: INode) => node._babylonTransformNode,\n                getPropertyName: [() => \"influence\"],\n            },\n            type: \"number[]\",\n            get: (node: INode, index?: number) => [0], // TODO: get the weights correctly\n            // set: (value: number, node: INode, index?: number) => node._babylonTransformNode?.getMorphTargetManager()?.getTarget(index)?.setInfluence(value),\n            getTarget: (node: INode) => node._babylonTransformNode,\n            getPropertyName: [() => \"influence\"],\n        },\n        // readonly!\n        matrix: {\n            type: \"Matrix\",\n            get: (node: INode) => Matrix.Compose(node._babylonTransformNode?.scaling!, node._babylonTransformNode?.rotationQuaternion!, node._babylonTransformNode?.position!),\n            getTarget: (node: INode) => node._babylonTransformNode,\n            isReadOnly: true,\n        },\n        globalMatrix: {\n            type: \"Matrix\",\n            get: (node: INode) => {\n                const matrix = Matrix.Identity();\n                // RHS/LHS support\n                let rootNode = node.parent;\n                while (rootNode && rootNode.parent) {\n                    rootNode = rootNode.parent;\n                }\n                const forceUpdate =\n                    node._babylonTransformNode?.position._isDirty || node._babylonTransformNode?.rotationQuaternion?._isDirty || node._babylonTransformNode?.scaling._isDirty;\n                if (rootNode) {\n                    // take the parent root node's world matrix, invert it, and multiply it with the current node's world matrix\n                    // This will provide the global matrix, ignoring the RHS->LHS conversion\n                    const rootMatrix = rootNode._babylonTransformNode?.computeWorldMatrix(true).invert();\n                    if (rootMatrix) {\n                        node._babylonTransformNode?.computeWorldMatrix(forceUpdate)?.multiplyToRef(rootMatrix, matrix);\n                    }\n                } else if (node._babylonTransformNode) {\n                    matrix.copyFrom(node._babylonTransformNode.computeWorldMatrix(forceUpdate));\n                }\n                return matrix;\n            },\n            getTarget: (node: INode) => node._babylonTransformNode,\n            isReadOnly: true,\n        },\n        extensions: {\n            EXT_lights_ies: {\n                multiplier: {\n                    type: \"number\",\n                    get: (node: INode) => {\n                        return node._babylonTransformNode?.getChildren((child) => child instanceof SpotLight, true)[0]?.intensity;\n                    },\n                    getTarget: (node: INode) => node._babylonTransformNode?.getChildren((child) => child instanceof SpotLight, true)[0],\n                    set: (value, node) => {\n                        if (node._babylonTransformNode) {\n                            const light = node._babylonTransformNode.getChildren((child) => child instanceof SpotLight, true)[0];\n                            if (light) {\n                                light.intensity = value;\n                            }\n                        }\n                    },\n                },\n                color: {\n                    type: \"Color3\",\n                    get: (node: INode) => {\n                        return node._babylonTransformNode?.getChildren((child) => child instanceof SpotLight, true)[0]?.diffuse;\n                    },\n                    getTarget: (node: INode) => node._babylonTransformNode?.getChildren((child) => child instanceof SpotLight, true)[0],\n                    set: (value, node: INode) => {\n                        if (node._babylonTransformNode) {\n                            const light = node._babylonTransformNode.getChildren((child) => child instanceof SpotLight, true)[0];\n                            if (light) {\n                                light.diffuse = value;\n                            }\n                        }\n                    },\n                },\n            },\n        },\n    },\n};\n\nconst animationsTree = {\n    length: {\n        type: \"number\",\n        get: (animations: IAnimation[]) => animations.length,\n        getTarget: (animations: IAnimation[]) => animations.map((animation) => animation._babylonAnimationGroup!),\n        getPropertyName: [() => \"length\"],\n    },\n    __array__: {},\n};\n\nconst meshesTree = {\n    length: {\n        type: \"number\",\n        get: (meshes: IMesh[]) => meshes.length,\n        getTarget: (meshes: IMesh[]) => meshes.map((mesh) => mesh.primitives[0]._instanceData?.babylonSourceMesh),\n        getPropertyName: [() => \"length\"],\n    },\n    __array__: {},\n};\n\nconst camerasTree: IGLTFObjectModelTreeCamerasObject = {\n    __array__: {\n        __target__: true,\n        orthographic: {\n            xmag: {\n                componentsCount: 2,\n                type: \"Vector2\",\n                get: (camera) => new Vector2(camera._babylonCamera?.orthoLeft ?? 0, camera._babylonCamera?.orthoRight ?? 0),\n                set: (value, camera) => {\n                    if (camera._babylonCamera) {\n                        camera._babylonCamera.orthoLeft = value.x;\n                        camera._babylonCamera.orthoRight = value.y;\n                    }\n                },\n                getTarget: (camera) => camera,\n                getPropertyName: [() => \"orthoLeft\", () => \"orthoRight\"],\n            },\n            ymag: {\n                componentsCount: 2,\n                type: \"Vector2\",\n                get: (camera: ICamera) => new Vector2(camera._babylonCamera?.orthoBottom ?? 0, camera._babylonCamera?.orthoTop ?? 0),\n                set: (value: Vector2, camera: ICamera) => {\n                    if (camera._babylonCamera) {\n                        camera._babylonCamera.orthoBottom = value.x;\n                        camera._babylonCamera.orthoTop = value.y;\n                    }\n                },\n                getTarget: (camera) => camera,\n                getPropertyName: [() => \"orthoBottom\", () => \"orthoTop\"],\n            },\n            zfar: {\n                type: \"number\",\n                get: (camera: ICamera) => camera._babylonCamera?.maxZ,\n                set: (value: number, camera: ICamera) => {\n                    if (camera._babylonCamera) {\n                        camera._babylonCamera.maxZ = value;\n                    }\n                },\n                getTarget: (camera: ICamera) => camera,\n                getPropertyName: [() => \"maxZ\"],\n            },\n            znear: {\n                type: \"number\",\n                get: (camera: ICamera) => camera._babylonCamera?.minZ,\n                set: (value: number, camera: ICamera) => {\n                    if (camera._babylonCamera) {\n                        camera._babylonCamera.minZ = value;\n                    }\n                },\n                getTarget: (camera: ICamera) => camera,\n                getPropertyName: [() => \"minZ\"],\n            },\n        },\n        perspective: {\n            aspectRatio: {\n                type: \"number\",\n                get: (camera: ICamera) => camera._babylonCamera?.getEngine().getAspectRatio(camera._babylonCamera),\n                getTarget: (camera: ICamera) => camera,\n                getPropertyName: [() => \"aspectRatio\"],\n                isReadOnly: true, // might not be the case for glTF?\n            },\n            yfov: {\n                type: \"number\",\n                get: (camera: ICamera) => camera._babylonCamera?.fov,\n                set: (value: number, camera: ICamera) => {\n                    if (camera._babylonCamera) {\n                        camera._babylonCamera.fov = value;\n                    }\n                },\n                getTarget: (camera: ICamera) => camera,\n                getPropertyName: [() => \"fov\"],\n            },\n            zfar: {\n                type: \"number\",\n                get: (camera: ICamera) => camera._babylonCamera?.maxZ,\n                set: (value: number, camera: ICamera) => {\n                    if (camera._babylonCamera) {\n                        camera._babylonCamera.maxZ = value;\n                    }\n                },\n                getTarget: (camera: ICamera) => camera,\n                getPropertyName: [() => \"maxZ\"],\n            },\n            znear: {\n                type: \"number\",\n                get: (camera: ICamera) => camera._babylonCamera?.minZ,\n                set: (value: number, camera: ICamera) => {\n                    if (camera._babylonCamera) {\n                        camera._babylonCamera.minZ = value;\n                    }\n                },\n                getTarget: (camera: ICamera) => camera,\n                getPropertyName: [() => \"minZ\"],\n            },\n        },\n    },\n};\n\nconst materialsTree: IGLTFObjectModelTreeMaterialsObject = {\n    __array__: {\n        __target__: true,\n        emissiveFactor: {\n            type: \"Color3\",\n            get: (material, index?, payload?) => _GetMaterial(material, index, payload).emissiveColor,\n            set: (value: Color3, material, index?, payload?) => _GetMaterial(material, index, payload).emissiveColor.copyFrom(value),\n            getTarget: (material, index?, payload?) => _GetMaterial(material, index, payload),\n            getPropertyName: [() => \"emissiveColor\"],\n        },\n        emissiveTexture: {\n            extensions: {\n                KHR_texture_transform: _GenerateTextureMap(\"emissiveTexture\"),\n            },\n        },\n        normalTexture: {\n            scale: {\n                type: \"number\",\n                get: (material, index?, payload?) => _GetTexture(material, payload, \"bumpTexture\")?.level,\n                set: (value: number, material, index?, payload?) => {\n                    const texture = _GetTexture(material, payload, \"bumpTexture\");\n                    if (texture) {\n                        texture.level = value;\n                    }\n                },\n                getTarget: (material, index?, payload?) => _GetMaterial(material, index, payload),\n                getPropertyName: [() => \"level\"],\n            },\n            extensions: {\n                KHR_texture_transform: _GenerateTextureMap(\"bumpTexture\"),\n            },\n        },\n        occlusionTexture: {\n            strength: {\n                type: \"number\",\n                get: (material, index?, payload?) => _GetMaterial(material, index, payload).ambientTextureStrength,\n                set: (value: number, material, index?, payload?) => {\n                    const mat = _GetMaterial(material, index, payload);\n                    if (mat) {\n                        mat.ambientTextureStrength = value;\n                    }\n                },\n                getTarget: (material, index?, payload?) => _GetMaterial(material, index, payload),\n                getPropertyName: [() => \"ambientTextureStrength\"],\n            },\n            extensions: {\n                KHR_texture_transform: _GenerateTextureMap(\"ambientTexture\"),\n            },\n        },\n        pbrMetallicRoughness: {\n            baseColorFactor: {\n                type: \"Color4\",\n                get: (material, index?, payload?) => {\n                    const mat = _GetMaterial(material, index, payload);\n                    return Color4.FromColor3(mat.albedoColor, mat.alpha);\n                },\n                set: (value: Color4, material, index?, payload?) => {\n                    const mat = _GetMaterial(material, index, payload);\n                    mat.albedoColor.set(value.r, value.g, value.b);\n                    mat.alpha = value.a;\n                },\n                getTarget: (material, index?, payload?) => _GetMaterial(material, index, payload),\n                // This is correct on the animation level, but incorrect as a single property of a type Color4\n                getPropertyName: [() => \"albedoColor\", () => \"alpha\"],\n            },\n            baseColorTexture: {\n                extensions: {\n                    KHR_texture_transform: _GenerateTextureMap(\"albedoTexture\"),\n                },\n            },\n            metallicFactor: {\n                type: \"number\",\n                get: (material, index?, payload?) => _GetMaterial(material, index, payload).metallic,\n                set: (value, material, index?, payload?) => {\n                    const mat = _GetMaterial(material, index, payload);\n                    if (mat) {\n                        mat.metallic = value;\n                    }\n                },\n                getTarget: (material, index?, payload?) => _GetMaterial(material, index, payload),\n                getPropertyName: [() => \"metallic\"],\n            },\n            roughnessFactor: {\n                type: \"number\",\n                get: (material, index?, payload?) => _GetMaterial(material, index, payload).roughness,\n                set: (value, material, index?, payload?) => {\n                    const mat = _GetMaterial(material, index, payload);\n                    if (mat) {\n                        mat.roughness = value;\n                    }\n                },\n                getTarget: (material, index?, payload?) => _GetMaterial(material, index, payload),\n                getPropertyName: [() => \"roughness\"],\n            },\n            metallicRoughnessTexture: {\n                extensions: {\n                    KHR_texture_transform: _GenerateTextureMap(\"metallicTexture\"),\n                },\n            },\n        },\n        extensions: {\n            KHR_materials_anisotropy: {\n                anisotropyStrength: {\n                    type: \"number\",\n                    get: (material, index?, payload?) => _GetMaterial(material, index, payload).anisotropy.intensity,\n                    set: (value: number, material, index?, payload?) => {\n                        _GetMaterial(material, index, payload).anisotropy.intensity = value;\n                    },\n                    getTarget: (material, index?, payload?) => _GetMaterial(material, index, payload),\n                    getPropertyName: [() => \"anisotropy.intensity\"],\n                },\n                anisotropyRotation: {\n                    type: \"number\",\n                    get: (material, index?, payload?) => _GetMaterial(material, index, payload).anisotropy.angle,\n                    set: (value: number, material, index?, payload?) => {\n                        _GetMaterial(material, index, payload).anisotropy.angle = value;\n                    },\n                    getTarget: (material, index?, payload?) => _GetMaterial(material, index, payload),\n                    getPropertyName: [() => \"anisotropy.angle\"],\n                },\n                anisotropyTexture: {\n                    extensions: {\n                        KHR_texture_transform: _GenerateTextureMap(\"anisotropy\", \"texture\"),\n                    },\n                },\n            },\n            KHR_materials_clearcoat: {\n                clearcoatFactor: {\n                    type: \"number\",\n                    get: (material, index?, payload?) => _GetMaterial(material, index, payload).clearCoat.intensity,\n                    set: (value, material, index?, payload?) => {\n                        _GetMaterial(material, index, payload).clearCoat.intensity = value;\n                    },\n                    getTarget: (material, index?, payload?) => _GetMaterial(material, index, payload),\n                    getPropertyName: [() => \"clearCoat.intensity\"],\n                },\n                clearcoatRoughnessFactor: {\n                    type: \"number\",\n                    get: (material, index?, payload?) => _GetMaterial(material, index, payload).clearCoat.roughness,\n                    set: (value, material, index?, payload?) => {\n                        _GetMaterial(material, index, payload).clearCoat.roughness = value;\n                    },\n                    getTarget: (material, index?, payload?) => _GetMaterial(material, index, payload),\n                    getPropertyName: [() => \"clearCoat.roughness\"],\n                },\n                clearcoatTexture: {\n                    extensions: {\n                        KHR_texture_transform: _GenerateTextureMap(\"clearCoat\", \"texture\"),\n                    },\n                },\n                clearcoatNormalTexture: {\n                    scale: {\n                        type: \"number\",\n                        get: (material, index, payload) => _GetMaterial(material, index, payload).clearCoat.bumpTexture?.level,\n                        getTarget: _GetMaterial,\n                        set: (value, material, index, payload) => (_GetMaterial(material, index, payload).clearCoat.bumpTexture!.level = value),\n                    },\n                    extensions: {\n                        KHR_texture_transform: _GenerateTextureMap(\"clearCoat\", \"bumpTexture\"),\n                    },\n                },\n                clearcoatRoughnessTexture: {\n                    extensions: {\n                        KHR_texture_transform: _GenerateTextureMap(\"clearCoat\", \"textureRoughness\"),\n                    },\n                },\n            },\n            KHR_materials_dispersion: {\n                dispersion: {\n                    type: \"number\",\n                    get: (material, index, payload) => _GetMaterial(material, index, payload).subSurface.dispersion,\n                    getTarget: _GetMaterial,\n                    set: (value, material, index, payload) => (_GetMaterial(material, index, payload).subSurface.dispersion = value),\n                },\n            },\n            KHR_materials_emissive_strength: {\n                emissiveStrength: {\n                    type: \"number\",\n                    get: (material, index, payload) => _GetMaterial(material, index, payload).emissiveIntensity,\n                    getTarget: _GetMaterial,\n                    set: (value, material, index, payload) => (_GetMaterial(material, index, payload).emissiveIntensity = value),\n                },\n            },\n            KHR_materials_ior: {\n                ior: {\n                    type: \"number\",\n                    get: (material, index, payload) => _GetMaterial(material, index, payload).indexOfRefraction,\n                    getTarget: _GetMaterial,\n                    set: (value, material, index, payload) => (_GetMaterial(material, index, payload).indexOfRefraction = value),\n                },\n            },\n            KHR_materials_iridescence: {\n                iridescenceFactor: {\n                    type: \"number\",\n                    get: (material, index, payload) => _GetMaterial(material, index, payload).iridescence.intensity,\n                    getTarget: _GetMaterial,\n                    set: (value, material, index, payload) => (_GetMaterial(material, index, payload).iridescence.intensity = value),\n                },\n                iridescenceIor: {\n                    type: \"number\",\n                    get: (material, index, payload) => _GetMaterial(material, index, payload).iridescence.indexOfRefraction,\n                    getTarget: _GetMaterial,\n                    set: (value, material, index, payload) => (_GetMaterial(material, index, payload).iridescence.indexOfRefraction = value),\n                },\n                iridescenceTexture: {\n                    extensions: {\n                        KHR_texture_transform: _GenerateTextureMap(\"iridescence\", \"texture\"),\n                    },\n                },\n                iridescenceThicknessMaximum: {\n                    type: \"number\",\n                    get: (material, index, payload) => _GetMaterial(material, index, payload).iridescence.maximumThickness,\n                    getTarget: _GetMaterial,\n                    set: (value, material, index, payload) => (_GetMaterial(material, index, payload).iridescence.maximumThickness = value),\n                },\n                iridescenceThicknessMinimum: {\n                    type: \"number\",\n                    get: (material, index, payload) => _GetMaterial(material, index, payload).iridescence.minimumThickness,\n                    getTarget: _GetMaterial,\n                    set: (value, material, index, payload) => (_GetMaterial(material, index, payload).iridescence.minimumThickness = value),\n                },\n                iridescenceThicknessTexture: {\n                    extensions: {\n                        KHR_texture_transform: _GenerateTextureMap(\"iridescence\", \"thicknessTexture\"),\n                    },\n                },\n            },\n            KHR_materials_sheen: {\n                sheenColorFactor: {\n                    type: \"Color3\",\n                    get: (material, index, payload) => _GetMaterial(material, index, payload).sheen.color,\n                    getTarget: _GetMaterial,\n                    set: (value, material, index, payload) => _GetMaterial(material, index, payload).sheen.color.copyFrom(value),\n                },\n                sheenColorTexture: {\n                    extensions: {\n                        KHR_texture_transform: _GenerateTextureMap(\"sheen\", \"texture\"),\n                    },\n                },\n                sheenRoughnessFactor: {\n                    type: \"number\",\n                    get: (material, index, payload) => _GetMaterial(material, index, payload).sheen.intensity,\n                    getTarget: _GetMaterial,\n                    set: (value, material, index, payload) => (_GetMaterial(material, index, payload).sheen.intensity = value),\n                },\n                sheenRoughnessTexture: {\n                    extensions: {\n                        KHR_texture_transform: _GenerateTextureMap(\"sheen\", \"thicknessTexture\"),\n                    },\n                },\n            },\n            KHR_materials_specular: {\n                specularFactor: {\n                    type: \"number\",\n                    get: (material, index, payload) => _GetMaterial(material, index, payload).metallicF0Factor,\n                    getTarget: _GetMaterial,\n                    set: (value, material, index, payload) => (_GetMaterial(material, index, payload).metallicF0Factor = value),\n                    getPropertyName: [() => \"metallicF0Factor\"],\n                },\n                specularColorFactor: {\n                    type: \"Color3\",\n                    get: (material, index, payload) => _GetMaterial(material, index, payload).metallicReflectanceColor,\n                    getTarget: _GetMaterial,\n                    set: (value, material, index, payload) => _GetMaterial(material, index, payload).metallicReflectanceColor.copyFrom(value),\n                    getPropertyName: [() => \"metallicReflectanceColor\"],\n                },\n                specularTexture: {\n                    extensions: {\n                        KHR_texture_transform: _GenerateTextureMap(\"metallicReflectanceTexture\"),\n                    },\n                },\n                specularColorTexture: {\n                    extensions: {\n                        KHR_texture_transform: _GenerateTextureMap(\"reflectanceTexture\"),\n                    },\n                },\n            },\n            KHR_materials_transmission: {\n                transmissionFactor: {\n                    type: \"number\",\n                    get: (material, index, payload) => _GetMaterial(material, index, payload).subSurface.refractionIntensity,\n                    getTarget: _GetMaterial,\n                    set: (value, material, index, payload) => (_GetMaterial(material, index, payload).subSurface.refractionIntensity = value),\n                    getPropertyName: [() => \"subSurface.refractionIntensity\"],\n                },\n                transmissionTexture: {\n                    extensions: {\n                        KHR_texture_transform: _GenerateTextureMap(\"subSurface\", \"refractionIntensityTexture\"),\n                    },\n                },\n            },\n            KHR_materials_diffuse_transmission: {\n                diffuseTransmissionFactor: {\n                    type: \"number\",\n                    get: (material, index, payload) => _GetMaterial(material, index, payload).subSurface.translucencyIntensity,\n                    getTarget: _GetMaterial,\n                    set: (value, material, index, payload) => (_GetMaterial(material, index, payload).subSurface.translucencyIntensity = value),\n                },\n                diffuseTransmissionTexture: {\n                    extensions: {\n                        KHR_texture_transform: _GenerateTextureMap(\"subSurface\", \"translucencyIntensityTexture\"),\n                    },\n                },\n                diffuseTransmissionColorFactor: {\n                    type: \"Color3\",\n                    get: (material, index, payload) => _GetMaterial(material, index, payload).subSurface.translucencyColor,\n                    getTarget: _GetMaterial,\n                    set: (value, material, index, payload) => value && _GetMaterial(material, index, payload).subSurface.translucencyColor?.copyFrom(value),\n                },\n                diffuseTransmissionColorTexture: {\n                    extensions: {\n                        KHR_texture_transform: _GenerateTextureMap(\"subSurface\", \"translucencyColorTexture\"),\n                    },\n                },\n            },\n            KHR_materials_volume: {\n                attenuationColor: {\n                    type: \"Color3\",\n                    get: (material, index, payload) => _GetMaterial(material, index, payload).subSurface.tintColor,\n                    getTarget: _GetMaterial,\n                    set: (value, material, index, payload) => _GetMaterial(material, index, payload).subSurface.tintColor.copyFrom(value),\n                },\n                attenuationDistance: {\n                    type: \"number\",\n                    get: (material, index, payload) => _GetMaterial(material, index, payload).subSurface.tintColorAtDistance,\n                    getTarget: _GetMaterial,\n                    set: (value, material, index, payload) => (_GetMaterial(material, index, payload).subSurface.tintColorAtDistance = value),\n                },\n                thicknessFactor: {\n                    type: \"number\",\n                    get: (material, index, payload) => _GetMaterial(material, index, payload).subSurface.maximumThickness,\n                    getTarget: _GetMaterial,\n                    set: (value, material, index, payload) => (_GetMaterial(material, index, payload).subSurface.maximumThickness = value),\n                },\n                thicknessTexture: {\n                    extensions: {\n                        KHR_texture_transform: _GenerateTextureMap(\"subSurface\", \"thicknessTexture\"),\n                    },\n                },\n            },\n        },\n    },\n};\n\nconst extensionsTree: IGLTFObjectModelTreeExtensionsObject = {\n    KHR_lights_punctual: {\n        lights: {\n            length: {\n                type: \"number\",\n                get: (lights: IKHRLightsPunctual_Light[]) => lights.length,\n                getTarget: (lights: IKHRLightsPunctual_Light[]) => lights.map((light) => light._babylonLight!),\n                getPropertyName: [(_lights: IKHRLightsPunctual_Light[]) => \"length\"],\n            },\n            __array__: {\n                __target__: true,\n                color: {\n                    type: \"Color3\",\n                    get: (light: IKHRLightsPunctual_Light) => light._babylonLight?.diffuse,\n                    set: (value: Color3, light: IKHRLightsPunctual_Light) => light._babylonLight?.diffuse.copyFrom(value),\n                    getTarget: (light: IKHRLightsPunctual_Light) => light._babylonLight,\n                    getPropertyName: [(_light: IKHRLightsPunctual_Light) => \"diffuse\"],\n                },\n                intensity: {\n                    type: \"number\",\n                    get: (light: IKHRLightsPunctual_Light) => light._babylonLight?.intensity,\n                    set: (value: number, light: IKHRLightsPunctual_Light) => (light._babylonLight ? (light._babylonLight.intensity = value) : undefined),\n                    getTarget: (light: IKHRLightsPunctual_Light) => light._babylonLight,\n                    getPropertyName: [(_light: IKHRLightsPunctual_Light) => \"intensity\"],\n                },\n                range: {\n                    type: \"number\",\n                    get: (light: IKHRLightsPunctual_Light) => light._babylonLight?.range,\n                    set: (value: number, light: IKHRLightsPunctual_Light) => (light._babylonLight ? (light._babylonLight.range = value) : undefined),\n                    getTarget: (light: IKHRLightsPunctual_Light) => light._babylonLight,\n                    getPropertyName: [(_light: IKHRLightsPunctual_Light) => \"range\"],\n                },\n                spot: {\n                    innerConeAngle: {\n                        type: \"number\",\n                        get: (light: IKHRLightsPunctual_Light) => (light._babylonLight as SpotLight)?.innerAngle,\n                        set: (value: number, light: IKHRLightsPunctual_Light) => (light._babylonLight ? ((light._babylonLight as SpotLight).innerAngle = value) : undefined),\n                        getTarget: (light: IKHRLightsPunctual_Light) => light._babylonLight,\n                        getPropertyName: [(_light: IKHRLightsPunctual_Light) => \"innerConeAngle\"],\n                    },\n                    outerConeAngle: {\n                        type: \"number\",\n                        get: (light: IKHRLightsPunctual_Light) => (light._babylonLight as SpotLight)?.angle,\n                        set: (value: number, light: IKHRLightsPunctual_Light) => (light._babylonLight ? ((light._babylonLight as SpotLight).angle = value) : undefined),\n                        getTarget: (light: IKHRLightsPunctual_Light) => light._babylonLight,\n                        getPropertyName: [(_light: IKHRLightsPunctual_Light) => \"outerConeAngle\"],\n                    },\n                },\n            },\n        },\n    },\n    EXT_lights_ies: {\n        lights: {\n            length: {\n                type: \"number\",\n                get: (lights: IKHRLightsPunctual_Light[]) => lights.length,\n                getTarget: (lights: IKHRLightsPunctual_Light[]) => lights.map((light) => light._babylonLight!),\n                getPropertyName: [(_lights: IKHRLightsPunctual_Light[]) => \"length\"],\n            },\n        },\n    },\n    EXT_lights_image_based: {\n        lights: {\n            length: {\n                type: \"number\",\n                get: (lights) => lights.length,\n                getTarget: (lights) => lights.map((light) => light._babylonTexture!),\n                getPropertyName: [(_lights) => \"length\"],\n            },\n            __array__: {\n                __target__: true,\n                intensity: {\n                    type: \"number\",\n                    get: (light) => light._babylonTexture?.level,\n                    set: (value, light) => {\n                        if (light._babylonTexture) light._babylonTexture.level = value;\n                    },\n\n                    getTarget: (light) => light._babylonTexture,\n                },\n                rotation: {\n                    type: \"Quaternion\",\n                    get: (light) => light._babylonTexture && Quaternion.FromRotationMatrix(light._babylonTexture?.getReflectionTextureMatrix()),\n                    set: (value, light) => {\n                        if (!light._babylonTexture) return;\n                        // Invert the rotation so that positive rotation is counter-clockwise.\n                        if (!light._babylonTexture.getScene()?.useRightHandedSystem) {\n                            value = Quaternion.Inverse(value);\n                        }\n\n                        Matrix.FromQuaternionToRef(value, light._babylonTexture.getReflectionTextureMatrix());\n                    },\n                    getTarget: (light) => light._babylonTexture,\n                },\n            },\n        },\n    },\n};\n\nfunction _GetTexture(material: IMaterial, payload: any, textureType: keyof PBRMaterial, textureInObject?: string) {\n    const babylonMaterial = _GetMaterial(material, payload);\n    return textureInObject ? babylonMaterial[textureType][textureInObject] : babylonMaterial[textureType];\n}\nfunction _GetMaterial(material: IMaterial, _index?: number, payload?: any) {\n    return material._data?.[payload?.fillMode ?? Constants.MATERIAL_TriangleFillMode]?.babylonMaterial as PBRMaterial;\n}\nfunction _GenerateTextureMap(textureType: keyof PBRMaterial, textureInObject?: string): ITextureDefinition {\n    return {\n        offset: {\n            componentsCount: 2,\n            // assuming two independent values for u and v, and NOT a Vector2\n            type: \"Vector2\",\n            get: (material, _index?, payload?) => {\n                const texture = _GetTexture(material, payload, textureType, textureInObject);\n                return new Vector2(texture?.uOffset, texture?.vOffset);\n            },\n            getTarget: _GetMaterial,\n            set: (value, material, _index?, payload?) => {\n                const texture = _GetTexture(material, payload, textureType, textureInObject);\n                (texture.uOffset = value.x), (texture.vOffset = value.y);\n            },\n            getPropertyName: [\n                () => `${textureType}${textureInObject ? \".\" + textureInObject : \"\"}.uOffset`,\n                () => `${textureType}${textureInObject ? \".\" + textureInObject : \"\"}.vOffset`,\n            ],\n        },\n        rotation: {\n            type: \"number\",\n            get: (material, _index?, payload?) => _GetTexture(material, payload, textureType, textureInObject)?.wAng,\n            getTarget: _GetMaterial,\n            set: (value, material, _index?, payload?) => (_GetTexture(material, payload, textureType, textureInObject).wAng = value),\n            getPropertyName: [() => `${textureType}${textureInObject ? \".\" + textureInObject : \"\"}.wAng`],\n        },\n        scale: {\n            componentsCount: 2,\n            type: \"Vector2\",\n            get: (material, _index?, payload?) => {\n                const texture = _GetTexture(material, payload, textureType, textureInObject);\n                return new Vector2(texture?.uScale, texture?.vScale);\n            },\n            getTarget: _GetMaterial,\n            set: (value, material, index?, payload?) => {\n                const texture = _GetTexture(material, payload, textureType, textureInObject);\n                (texture.uScale = value.x), (texture.vScale = value.y);\n            },\n            getPropertyName: [\n                () => `${textureType}${textureInObject ? \".\" + textureInObject : \"\"}.uScale`,\n                () => `${textureType}${textureInObject ? \".\" + textureInObject : \"\"}.vScale`,\n            ],\n        },\n    };\n}\n\nconst objectModelMapping: IGLTFObjectModelTree = {\n    cameras: camerasTree,\n    nodes: nodesTree,\n    materials: materialsTree,\n    extensions: extensionsTree,\n    animations: animationsTree,\n    meshes: meshesTree,\n};\n\n/**\n * get a path-to-object converter for the given glTF tree\n * @param gltf the glTF tree to use\n * @returns a path-to-object converter for the given glTF tree\n */\nexport function GetPathToObjectConverter(gltf: IGLTF) {\n    return new GLTFPathToObjectConverter(gltf, objectModelMapping);\n}\n\n/**\n * This function will return the object accessor for the given key in the object model\n * If the key is not found, it will return undefined\n * @param key the key to get the mapping for, for example /materials/\\{\\}/emissiveFactor\n * @returns an object accessor for the given key, or undefined if the key is not found\n */\nexport function GetMappingForKey(key: string): IObjectAccessor | undefined {\n    // replace every `{}` in key with __array__ to match the object model\n    const keyParts = key.split(\"/\").map((part) => part.replace(/{}/g, \"__array__\"));\n    let current = objectModelMapping as any;\n    for (const part of keyParts) {\n        // make sure part is not empty\n        if (!part) {\n            continue;\n        }\n        current = current[part];\n    }\n    // validate that current is an object accessor\n    if (current && current.type && current.get) {\n        return current;\n    }\n    return undefined;\n}\n\n/**\n * Set interpolation for a specific key in the object model\n * @param key the key to set, for example /materials/\\{\\}/emissiveFactor\n * @param interpolation the interpolation elements array\n */\nexport function SetInterpolationForKey(key: string, interpolation?: IInterpolationPropertyInfo[]): void {\n    // replace every `{}` in key with __array__ to match the object model\n    const keyParts = key.split(\"/\").map((part) => part.replace(/{}/g, \"__array__\"));\n    let current = objectModelMapping as any;\n    for (const part of keyParts) {\n        // make sure part is not empty\n        if (!part) {\n            continue;\n        }\n        current = current[part];\n    }\n    // validate that the current object is an object accessor\n    if (current && current.type && current.get) {\n        (current as IObjectAccessor).interpolation = interpolation;\n    }\n}\n\n/**\n * This will ad a new object accessor in the object model at the given key.\n * Note that this will NOT change the typescript types. To do that you will need to change the interface itself (extending it in the module that uses it)\n * @param key the key to add the object accessor at. For example /cameras/\\{\\}/perspective/aspectRatio\n * @param accessor the object accessor to add\n */\nexport function AddObjectAccessorToKey<GLTFTargetType = any, BabylonTargetType = any, BabylonValueType = any>(\n    key: string,\n    accessor: IObjectAccessor<GLTFTargetType, BabylonTargetType, BabylonValueType>\n): void {\n    // replace every `{}` in key with __array__ to match the object model\n    const keyParts = key.split(\"/\").map((part) => part.replace(/{}/g, \"__array__\"));\n    let current = objectModelMapping as any;\n    for (const part of keyParts) {\n        // make sure part is not empty\n        if (!part) {\n            continue;\n        }\n        if (!current[part]) {\n            if (part === \"?\") {\n                current.__ignoreObjectTree__ = true;\n                continue;\n            }\n            current[part] = {};\n            // if the part is __array__ then add the __target__ property\n            if (part === \"__array__\") {\n                current[part].__target__ = true;\n            }\n        }\n        current = current[part];\n    }\n    Object.assign(current, accessor);\n}\n"]}