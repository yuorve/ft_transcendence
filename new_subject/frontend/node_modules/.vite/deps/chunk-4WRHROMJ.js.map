{
  "version": 3,
  "sources": ["../../../dev/core/src/Lights/IES/iesLoader.ts", "../../../dev/core/src/Materials/Textures/Loaders/iesTextureLoader.ts"],
  "sourcesContent": ["import { Lerp } from \"core/Maths/math.scalar.functions\";\r\n\r\ninterface IIESData {\r\n    version: string;\r\n    tilt?: {};\r\n    numberOfLights?: number;\r\n    lumensPerLamp?: number;\r\n    candelaMultiplier?: number;\r\n    numberOfVerticalAngles: number;\r\n    numberOfHorizontalAngles: number;\r\n    horizontalAngles: number[];\r\n    verticalAngles: number[];\r\n    photometricType?: number;\r\n    unitsType?: number;\r\n    width?: number;\r\n    length?: number;\r\n    height?: number;\r\n    ballastFactor?: number;\r\n    fileGenerationType?: number;\r\n    inputWatts?: number;\r\n    candelaValues: number[][];\r\n}\r\n\r\ninterface IDataPointer {\r\n    lines: string[];\r\n    index: number;\r\n}\r\n\r\nfunction lineToArray(line: string): number[] {\r\n    return line\r\n        .split(\" \")\r\n        .filter((x) => x !== \"\")\r\n        .map((x) => parseFloat(x));\r\n}\r\n\r\nfunction readArray(dataPointer: IDataPointer, count: number, targetArray: number[]) {\r\n    while (targetArray.length !== count) {\r\n        const line = lineToArray(dataPointer.lines[dataPointer.index++]);\r\n        targetArray.push(...line);\r\n    }\r\n}\r\n\r\nfunction interpolateCandelaValues(data: IIESData, phi: number, theta: number): number {\r\n    let phiIndex = 0;\r\n    let thetaIndex = 0;\r\n    let startTheta = 0;\r\n    let endTheta = 0;\r\n    let startPhi = 0;\r\n    let endPhi = 0;\r\n\r\n    // Check if the angle is outside the range\r\n    for (let index = 0; index < data.numberOfHorizontalAngles - 1; index++) {\r\n        if (theta < data.horizontalAngles[index + 1] || index === data.numberOfHorizontalAngles - 2) {\r\n            thetaIndex = index;\r\n            startTheta = data.horizontalAngles[index];\r\n            endTheta = data.horizontalAngles[index + 1];\r\n\r\n            break;\r\n        }\r\n    }\r\n\r\n    for (let index = 0; index < data.numberOfVerticalAngles - 1; index++) {\r\n        if (phi < data.verticalAngles[index + 1] || index === data.numberOfVerticalAngles - 2) {\r\n            phiIndex = index;\r\n            startPhi = data.verticalAngles[index];\r\n            endPhi = data.verticalAngles[index + 1];\r\n\r\n            break;\r\n        }\r\n    }\r\n\r\n    const deltaTheta = endTheta - startTheta;\r\n    const deltaPhi = endPhi - startPhi;\r\n\r\n    if (deltaPhi === 0) {\r\n        return 0;\r\n    }\r\n\r\n    // Interpolate\r\n    const t1 = deltaTheta === 0 ? 0 : (theta - startTheta) / deltaTheta;\r\n    const t2 = (phi - startPhi) / deltaPhi;\r\n\r\n    const nextThetaIndex = deltaTheta === 0 ? thetaIndex : thetaIndex + 1;\r\n\r\n    const v1 = Lerp(data.candelaValues[thetaIndex][phiIndex], data.candelaValues[nextThetaIndex][phiIndex], t1);\r\n    const v2 = Lerp(data.candelaValues[thetaIndex][phiIndex + 1], data.candelaValues[nextThetaIndex][phiIndex + 1], t1);\r\n    const v = Lerp(v1, v2, t2);\r\n\r\n    return v;\r\n}\r\n/**\r\n * Interface for IES texture data.\r\n */\r\nexport interface IIESTextureData {\r\n    /** The width of the texture */\r\n    width: number;\r\n    /** The height of the texture */\r\n    height: number;\r\n    /** The data of the texture */\r\n    data: Float32Array;\r\n}\r\n\r\n/**\r\n * Generates IES data buffer from a string representing the IES data.\r\n * @param uint8Array defines the IES data\r\n * @returns the IES data buffer\r\n * @see https://ieslibrary.com/browse\r\n * #UQGPDT#1\r\n */\r\nexport function LoadIESData(uint8Array: Uint8Array): IIESTextureData {\r\n    const decoder = new TextDecoder(\"utf-8\");\r\n    const source = decoder.decode(uint8Array);\r\n\r\n    // Read data\r\n    const dataPointer: IDataPointer = {\r\n        lines: source.split(\"\\n\"),\r\n        index: 0,\r\n    };\r\n    const data: IIESData = { version: dataPointer.lines[0], candelaValues: [], horizontalAngles: [], verticalAngles: [], numberOfHorizontalAngles: 0, numberOfVerticalAngles: 0 };\r\n\r\n    // Skip metadata\r\n    dataPointer.index = 1;\r\n    while (dataPointer.lines.length > 0 && !dataPointer.lines[dataPointer.index].includes(\"TILT=\")) {\r\n        dataPointer.index++;\r\n    }\r\n\r\n    // Process tilt data?\r\n    if (dataPointer.lines[dataPointer.index].includes(\"INCLUDE\")) {\r\n        // Not supported yet as I did not manage to find an example :)\r\n    }\r\n    dataPointer.index++;\r\n\r\n    // Header\r\n    const header = lineToArray(dataPointer.lines[dataPointer.index++]);\r\n    data.numberOfLights = header[0];\r\n    data.lumensPerLamp = header[1];\r\n    data.candelaMultiplier = header[2];\r\n    data.numberOfVerticalAngles = header[3];\r\n    data.numberOfHorizontalAngles = header[4];\r\n    data.photometricType = header[5]; // We ignore cylindrical type for now. Will add support later if needed\r\n    data.unitsType = header[6];\r\n    data.width = header[7];\r\n    data.length = header[8];\r\n    data.height = header[9];\r\n\r\n    // Additional data\r\n    const additionalData = lineToArray(dataPointer.lines[dataPointer.index++]);\r\n    data.ballastFactor = additionalData[0];\r\n    data.fileGenerationType = additionalData[1];\r\n    data.inputWatts = additionalData[2];\r\n\r\n    // Prepare arrays\r\n    for (let index = 0; index < data.numberOfHorizontalAngles; index++) {\r\n        data.candelaValues[index] = [];\r\n    }\r\n\r\n    // Vertical angles\r\n    readArray(dataPointer, data.numberOfVerticalAngles, data.verticalAngles);\r\n\r\n    // Horizontal angles\r\n    readArray(dataPointer, data.numberOfHorizontalAngles, data.horizontalAngles);\r\n\r\n    // Candela values\r\n    for (let index = 0; index < data.numberOfHorizontalAngles; index++) {\r\n        readArray(dataPointer, data.numberOfVerticalAngles, data.candelaValues[index]);\r\n    }\r\n\r\n    // Evaluate candela values\r\n    let maxCandela = -1;\r\n    for (let index = 0; index < data.numberOfHorizontalAngles; index++) {\r\n        for (let subIndex = 0; subIndex < data.numberOfVerticalAngles; subIndex++) {\r\n            data.candelaValues[index][subIndex] *= data.candelaValues[index][subIndex] * data.candelaMultiplier * data.ballastFactor * data.fileGenerationType;\r\n            maxCandela = Math.max(maxCandela, data.candelaValues[index][subIndex]);\r\n        }\r\n    }\r\n\r\n    // Normalize candela values\r\n    if (maxCandela > 0) {\r\n        for (let index = 0; index < data.numberOfHorizontalAngles; index++) {\r\n            for (let subIndex = 0; subIndex < data.numberOfVerticalAngles; subIndex++) {\r\n                data.candelaValues[index][subIndex] /= maxCandela;\r\n            }\r\n        }\r\n    }\r\n\r\n    // Create the cylindrical texture\r\n    const height = 180;\r\n    const width = height * 2;\r\n    const size = width * height;\r\n    const arrayBuffer = new Float32Array(width * height);\r\n\r\n    // Fill the texture\r\n    const startTheta = data.horizontalAngles[0];\r\n    const endTheta = data.horizontalAngles[data.numberOfHorizontalAngles - 1];\r\n    for (let index = 0; index < size; index++) {\r\n        let theta = index % width;\r\n        const phi = Math.floor(index / width);\r\n\r\n        // Symmetry\r\n        if (endTheta - startTheta !== 0 && (theta < startTheta || theta >= endTheta)) {\r\n            theta %= endTheta * 2;\r\n            if (theta > endTheta) {\r\n                theta = endTheta * 2 - theta;\r\n            }\r\n        }\r\n\r\n        arrayBuffer[phi + theta * height] = interpolateCandelaValues(data, phi, theta);\r\n    }\r\n\r\n    // So far we only need the first half of the first row of the texture as we only support IES for spot light. We can add support for other types later.\r\n    return {\r\n        width: width / 2,\r\n        height: 1,\r\n        data: arrayBuffer,\r\n    };\r\n}\r\n", "import type { InternalTexture } from \"../internalTexture\";\r\nimport type { IInternalTextureLoader } from \"./internalTextureLoader\";\r\nimport { Constants } from \"../../../Engines/constants\";\r\nimport { LoadIESData } from \"core/Lights/IES/iesLoader\";\r\n\r\n/**\r\n * Implementation of the IES Texture Loader.\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class _IESTextureLoader implements IInternalTextureLoader {\r\n    /**\r\n     * Defines whether the loader supports cascade loading the different faces.\r\n     */\r\n    public readonly supportCascades = false;\r\n\r\n    /**\r\n     * Uploads the cube texture data to the WebGL texture. It has already been bound.\r\n     */\r\n    public loadCubeData(): void {\r\n        // eslint-disable-next-line no-throw-literal\r\n        throw \".ies not supported in Cube.\";\r\n    }\r\n\r\n    /**\r\n     * Uploads the 2D texture data to the WebGL texture. It has already been bound once in the callback.\r\n     * @param data contains the texture data\r\n     * @param texture defines the BabylonJS internal texture\r\n     * @param callback defines the method to call once ready to upload\r\n     */\r\n    public loadData(\r\n        data: ArrayBufferView,\r\n        texture: InternalTexture,\r\n        callback: (width: number, height: number, loadMipmap: boolean, isCompressed: boolean, done: () => void) => void\r\n    ): void {\r\n        const uint8array = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);\r\n\r\n        const textureData = LoadIESData(uint8array);\r\n\r\n        callback(textureData.width, textureData.height, false, false, () => {\r\n            const engine = texture.getEngine();\r\n            texture.type = Constants.TEXTURETYPE_FLOAT;\r\n            texture.format = Constants.TEXTUREFORMAT_R;\r\n            texture._gammaSpace = false;\r\n            engine._uploadDataToTextureDirectly(texture, textureData.data);\r\n        });\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": []
}
