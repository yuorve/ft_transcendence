import {
  GetClass
} from "./chunk-LMH7SWDS.js";
import {
  AbstractEngine,
  EngineFunctionContext,
  IsWindowObjectExist,
  TimingTools,
  _functionContainer
} from "./chunk-C5NISM7M.js";
import {
  Logger
} from "./chunk-OJJXGLTO.js";
import {
  EngineStore,
  Observable
} from "./chunk-RUCF343I.js";

// node_modules/@babylonjs/core/Misc/webRequest.js
function createXMLHttpRequest() {
  if (typeof _native !== "undefined" && _native.XMLHttpRequest) {
    return new _native.XMLHttpRequest();
  } else {
    return new XMLHttpRequest();
  }
}
var WebRequest = class _WebRequest {
  constructor() {
    this._xhr = createXMLHttpRequest();
    this._requestURL = "";
  }
  /**
   * This function can be called to check if there are request modifiers for network requests
   * @returns true if there are any custom requests available
   */
  static get IsCustomRequestAvailable() {
    return Object.keys(_WebRequest.CustomRequestHeaders).length > 0 || _WebRequest.CustomRequestModifiers.length > 0;
  }
  /**
   * Returns the requested URL once open has been called
   */
  get requestURL() {
    return this._requestURL;
  }
  _injectCustomRequestHeaders() {
    if (this._shouldSkipRequestModifications(this._requestURL)) {
      return;
    }
    for (const key in _WebRequest.CustomRequestHeaders) {
      const val = _WebRequest.CustomRequestHeaders[key];
      if (val) {
        this._xhr.setRequestHeader(key, val);
      }
    }
  }
  _shouldSkipRequestModifications(url) {
    return _WebRequest.SkipRequestModificationForBabylonCDN && (url.includes("preview.babylonjs.com") || url.includes("cdn.babylonjs.com"));
  }
  /**
   * Gets or sets a function to be called when loading progress changes
   */
  get onprogress() {
    return this._xhr.onprogress;
  }
  set onprogress(value) {
    this._xhr.onprogress = value;
  }
  /**
   * Returns client's state
   */
  get readyState() {
    return this._xhr.readyState;
  }
  /**
   * Returns client's status
   */
  get status() {
    return this._xhr.status;
  }
  /**
   * Returns client's status as a text
   */
  get statusText() {
    return this._xhr.statusText;
  }
  /**
   * Returns client's response
   */
  get response() {
    return this._xhr.response;
  }
  /**
   * Returns client's response url
   */
  get responseURL() {
    return this._xhr.responseURL;
  }
  /**
   * Returns client's response as text
   */
  get responseText() {
    return this._xhr.responseText;
  }
  /**
   * Gets or sets the expected response type
   */
  get responseType() {
    return this._xhr.responseType;
  }
  set responseType(value) {
    this._xhr.responseType = value;
  }
  /**
   * Gets or sets the timeout value in milliseconds
   */
  get timeout() {
    return this._xhr.timeout;
  }
  set timeout(value) {
    this._xhr.timeout = value;
  }
  addEventListener(type, listener, options) {
    this._xhr.addEventListener(type, listener, options);
  }
  removeEventListener(type, listener, options) {
    this._xhr.removeEventListener(type, listener, options);
  }
  /**
   * Cancels any network activity
   */
  abort() {
    this._xhr.abort();
  }
  /**
   * Initiates the request. The optional argument provides the request body. The argument is ignored if request method is GET or HEAD
   * @param body defines an optional request body
   */
  send(body) {
    if (_WebRequest.CustomRequestHeaders) {
      this._injectCustomRequestHeaders();
    }
    this._xhr.send(body);
  }
  /**
   * Sets the request method, request URL
   * @param method defines the method to use (GET, POST, etc..)
   * @param url defines the url to connect with
   */
  open(method, url) {
    for (const update of _WebRequest.CustomRequestModifiers) {
      if (this._shouldSkipRequestModifications(url)) {
        return;
      }
      url = update(this._xhr, url) || url;
    }
    url = url.replace("file:http:", "http:");
    url = url.replace("file:https:", "https:");
    this._requestURL = url;
    this._xhr.open(method, url, true);
  }
  /**
   * Sets the value of a request header.
   * @param name The name of the header whose value is to be set
   * @param value The value to set as the body of the header
   */
  setRequestHeader(name, value) {
    this._xhr.setRequestHeader(name, value);
  }
  /**
   * Get the string containing the text of a particular header's value.
   * @param name The name of the header
   * @returns The string containing the text of the given header name
   */
  getResponseHeader(name) {
    return this._xhr.getResponseHeader(name);
  }
};
WebRequest.CustomRequestHeaders = {};
WebRequest.CustomRequestModifiers = new Array();
WebRequest.SkipRequestModificationForBabylonCDN = true;

// node_modules/@babylonjs/core/Misc/filesInputStore.js
var FilesInputStore = class {
};
FilesInputStore.FilesToLoad = {};

// node_modules/@babylonjs/core/Misc/retryStrategy.js
var RetryStrategy = class {
  /**
   * Function used to defines an exponential back off strategy
   * @param maxRetries defines the maximum number of retries (3 by default)
   * @param baseInterval defines the interval between retries
   * @returns the strategy function to use
   */
  static ExponentialBackoff(maxRetries = 3, baseInterval = 500) {
    return (url, request, retryIndex) => {
      if (request.status !== 0 || retryIndex >= maxRetries || url.indexOf("file:") !== -1) {
        return -1;
      }
      return Math.pow(2, retryIndex) * baseInterval;
    };
  }
};

// node_modules/@babylonjs/core/Misc/error.js
var BaseError = class extends Error {
};
BaseError._setPrototypeOf = Object.setPrototypeOf || ((o, proto) => {
  o.__proto__ = proto;
  return o;
});
var ErrorCodes = {
  // Mesh errors 0-999
  /** Invalid or empty mesh vertex positions. */
  MeshInvalidPositionsError: 0,
  // Texture errors 1000-1999
  /** Unsupported texture found. */
  UnsupportedTextureError: 1e3,
  // GLTFLoader errors 2000-2999
  /** Unexpected magic number found in GLTF file header. */
  GLTFLoaderUnexpectedMagicError: 2e3,
  // SceneLoader errors 3000-3999
  /** SceneLoader generic error code. Ideally wraps the inner exception. */
  SceneLoaderError: 3e3,
  // File related errors 4000-4999
  /** Load file error */
  LoadFileError: 4e3,
  /** Request file error */
  RequestFileError: 4001,
  /** Read file error */
  ReadFileError: 4002
};
var RuntimeError = class _RuntimeError extends BaseError {
  /**
   * Creates a new RuntimeError
   * @param message defines the message of the error
   * @param errorCode the error code
   * @param innerError the error that caused the outer error
   */
  constructor(message, errorCode, innerError) {
    super(message);
    this.errorCode = errorCode;
    this.innerError = innerError;
    this.name = "RuntimeError";
    BaseError._setPrototypeOf(this, _RuntimeError.prototype);
  }
};
var AbortError = class _AbortError extends BaseError {
  constructor(message = "Operation aborted") {
    super(message);
    this.name = "AbortError";
    BaseError._setPrototypeOf(this, _AbortError.prototype);
  }
};

// node_modules/@babylonjs/core/Misc/stringTools.js
var EndsWith = (str, suffix) => {
  return str.endsWith(suffix);
};
var StartsWith = (str, suffix) => {
  if (!str) {
    return false;
  }
  return str.startsWith(suffix);
};
var Decode = (buffer) => {
  if (typeof TextDecoder !== "undefined") {
    return new TextDecoder().decode(buffer);
  }
  let result = "";
  for (let i = 0; i < buffer.byteLength; i++) {
    result += String.fromCharCode(buffer[i]);
  }
  return result;
};
var EncodeArrayBufferToBase64 = (buffer) => {
  const keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
  let output = "";
  let chr1, chr2, chr3, enc1, enc2, enc3, enc4;
  let i = 0;
  const bytes = ArrayBuffer.isView(buffer) ? new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength) : new Uint8Array(buffer);
  while (i < bytes.length) {
    chr1 = bytes[i++];
    chr2 = i < bytes.length ? bytes[i++] : Number.NaN;
    chr3 = i < bytes.length ? bytes[i++] : Number.NaN;
    enc1 = chr1 >> 2;
    enc2 = (chr1 & 3) << 4 | chr2 >> 4;
    enc3 = (chr2 & 15) << 2 | chr3 >> 6;
    enc4 = chr3 & 63;
    if (isNaN(chr2)) {
      enc3 = enc4 = 64;
    } else if (isNaN(chr3)) {
      enc4 = 64;
    }
    output += keyStr.charAt(enc1) + keyStr.charAt(enc2) + keyStr.charAt(enc3) + keyStr.charAt(enc4);
  }
  return output;
};
var DecodeBase64ToString = (base64Data) => {
  return atob(base64Data);
};
var DecodeBase64ToBinary = (base64Data) => {
  const decodedString = DecodeBase64ToString(base64Data);
  const bufferLength = decodedString.length;
  const bufferView = new Uint8Array(new ArrayBuffer(bufferLength));
  for (let i = 0; i < bufferLength; i++) {
    bufferView[i] = decodedString.charCodeAt(i);
  }
  return bufferView.buffer;
};
var PadNumber = (num, length) => {
  let str = String(num);
  while (str.length < length) {
    str = "0" + str;
  }
  return str;
};
var StringTools = {
  EndsWith,
  StartsWith,
  Decode,
  EncodeArrayBufferToBase64,
  DecodeBase64ToString,
  DecodeBase64ToBinary,
  PadNumber
};

// node_modules/@babylonjs/core/Misc/guid.js
function RandomGUID() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
    const r = Math.random() * 16 | 0, v = c === "x" ? r : r & 3 | 8;
    return v.toString(16);
  });
}
var GUID = {
  /**
   * Implementation from http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#answer-2117523
   * Be aware Math.random() could cause collisions, but:
   * "All but 6 of the 128 bits of the ID are randomly generated, which means that for any two ids, there's a 1 in 2^^122 (or 5.3x10^^36) chance they'll collide"
   * @returns a pseudo random id
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  RandomId: RandomGUID
};

// node_modules/@babylonjs/core/Misc/fileTools.js
var Base64DataUrlRegEx = new RegExp(/^data:([^,]+\/[^,]+)?;base64,/i);
var LoadFileError = class _LoadFileError extends RuntimeError {
  /**
   * Creates a new LoadFileError
   * @param message defines the message of the error
   * @param object defines the optional web request
   */
  constructor(message, object) {
    super(message, ErrorCodes.LoadFileError);
    this.name = "LoadFileError";
    BaseError._setPrototypeOf(this, _LoadFileError.prototype);
    if (object instanceof WebRequest) {
      this.request = object;
    } else {
      this.file = object;
    }
  }
};
var RequestFileError = class _RequestFileError extends RuntimeError {
  /**
   * Creates a new LoadFileError
   * @param message defines the message of the error
   * @param request defines the optional web request
   */
  constructor(message, request) {
    super(message, ErrorCodes.RequestFileError);
    this.request = request;
    this.name = "RequestFileError";
    BaseError._setPrototypeOf(this, _RequestFileError.prototype);
  }
};
var ReadFileError = class _ReadFileError extends RuntimeError {
  /**
   * Creates a new ReadFileError
   * @param message defines the message of the error
   * @param file defines the optional file
   */
  constructor(message, file) {
    super(message, ErrorCodes.ReadFileError);
    this.file = file;
    this.name = "ReadFileError";
    BaseError._setPrototypeOf(this, _ReadFileError.prototype);
  }
};
var CleanUrl = (url) => {
  url = url.replace(/#/gm, "%23");
  return url;
};
var FileToolsOptions = {
  /**
   * Gets or sets the retry strategy to apply when an error happens while loading an asset.
   * When defining this function, return the wait time before trying again or return -1 to
   * stop retrying and error out.
   */
  DefaultRetryStrategy: RetryStrategy.ExponentialBackoff(),
  /**
   * Gets or sets the base URL to use to load assets
   */
  BaseUrl: "",
  /**
   * Default behaviour for cors in the application.
   * It can be a string if the expected behavior is identical in the entire app.
   * Or a callback to be able to set it per url or on a group of them (in case of Video source for instance)
   */
  CorsBehavior: "anonymous",
  /**
   * Gets or sets a function used to pre-process url before using them to load assets
   * @param url
   * @returns the processed url
   */
  PreprocessUrl: (url) => url,
  /**
   * Gets or sets the base URL to use to load scripts
   * Used for both JS and WASM
   */
  ScriptBaseUrl: "",
  /**
   * Gets or sets a function used to pre-process script url before using them to load.
   * Used for both JS and WASM
   * @param url defines the url to process
   * @returns the processed url
   */
  ScriptPreprocessUrl: (url) => url,
  /**
   * Gets or sets a function used to clean the url before using it to load assets
   * @param url defines the url to clean
   * @returns the cleaned url
   */
  CleanUrl
};
var SetCorsBehavior = (url, element) => {
  if (url && url.indexOf("data:") === 0) {
    return;
  }
  if (FileToolsOptions.CorsBehavior) {
    if (typeof FileToolsOptions.CorsBehavior === "string" || FileToolsOptions.CorsBehavior instanceof String) {
      element.crossOrigin = FileToolsOptions.CorsBehavior;
    } else {
      const result = FileToolsOptions.CorsBehavior(url);
      if (result) {
        element.crossOrigin = result;
      }
    }
  }
};
var LoadImageConfiguration = {
  getRequiredSize: null
};
var LoadImage = (input, onLoad, onError, offlineProvider, mimeType = "", imageBitmapOptions) => {
  const engine = EngineStore.LastCreatedEngine;
  if (typeof HTMLImageElement === "undefined" && !(engine == null ? void 0 : engine._features.forceBitmapOverHTMLImageElement)) {
    onError("LoadImage is only supported in web or BabylonNative environments.");
    return null;
  }
  let url;
  let usingObjectURL = false;
  if (input instanceof ArrayBuffer || ArrayBuffer.isView(input)) {
    if (typeof Blob !== "undefined" && typeof URL !== "undefined") {
      url = URL.createObjectURL(new Blob([input], { type: mimeType }));
      usingObjectURL = true;
    } else {
      url = `data:${mimeType};base64,` + EncodeArrayBufferToBase64(input);
    }
  } else if (input instanceof Blob) {
    url = URL.createObjectURL(input);
    usingObjectURL = true;
  } else {
    url = FileToolsOptions.CleanUrl(input);
    url = FileToolsOptions.PreprocessUrl(url);
  }
  const onErrorHandler = (exception) => {
    if (onError) {
      const inputText = url || input.toString();
      onError(`Error while trying to load image: ${inputText.indexOf("http") === 0 || inputText.length <= 128 ? inputText : inputText.slice(0, 128) + "..."}`, exception);
    }
  };
  if (engine == null ? void 0 : engine._features.forceBitmapOverHTMLImageElement) {
    LoadFile(url, (data) => {
      engine.createImageBitmap(new Blob([data], { type: mimeType }), { premultiplyAlpha: "none", ...imageBitmapOptions }).then((imgBmp) => {
        onLoad(imgBmp);
        if (usingObjectURL) {
          URL.revokeObjectURL(url);
        }
      }).catch((reason) => {
        if (onError) {
          onError("Error while trying to load image: " + input, reason);
        }
      });
    }, void 0, offlineProvider || void 0, true, (request, exception) => {
      onErrorHandler(exception);
    });
    return null;
  }
  const img = new Image();
  if (LoadImageConfiguration.getRequiredSize) {
    const size = LoadImageConfiguration.getRequiredSize(input);
    if (size.width) {
      img.width = size.width;
    }
    if (size.height) {
      img.height = size.height;
    }
  }
  SetCorsBehavior(url, img);
  const handlersList = [];
  const loadHandlersList = () => {
    handlersList.forEach((handler) => {
      handler.target.addEventListener(handler.name, handler.handler);
    });
  };
  const unloadHandlersList = () => {
    handlersList.forEach((handler) => {
      handler.target.removeEventListener(handler.name, handler.handler);
    });
    handlersList.length = 0;
  };
  const loadHandler = () => {
    unloadHandlersList();
    onLoad(img);
    if (usingObjectURL && img.src) {
      URL.revokeObjectURL(img.src);
    }
  };
  const errorHandler = (err) => {
    unloadHandlersList();
    onErrorHandler(err);
    if (usingObjectURL && img.src) {
      URL.revokeObjectURL(img.src);
    }
  };
  const cspHandler = (err) => {
    if (err.blockedURI !== img.src || err.disposition === "report") {
      return;
    }
    unloadHandlersList();
    const cspException = new Error(`CSP violation of policy ${err.effectiveDirective} ${err.blockedURI}. Current policy is ${err.originalPolicy}`);
    EngineStore.UseFallbackTexture = false;
    onErrorHandler(cspException);
    if (usingObjectURL && img.src) {
      URL.revokeObjectURL(img.src);
    }
    img.src = "";
  };
  handlersList.push({ target: img, name: "load", handler: loadHandler });
  handlersList.push({ target: img, name: "error", handler: errorHandler });
  handlersList.push({ target: document, name: "securitypolicyviolation", handler: cspHandler });
  loadHandlersList();
  const fromBlob = url.substring(0, 5) === "blob:";
  const fromData = url.substring(0, 5) === "data:";
  const noOfflineSupport = () => {
    if (fromBlob || fromData || !WebRequest.IsCustomRequestAvailable) {
      img.src = url;
    } else {
      LoadFile(url, (data, _, contentType) => {
        const type = !mimeType && contentType ? contentType : mimeType;
        const blob = new Blob([data], { type });
        const url2 = URL.createObjectURL(blob);
        usingObjectURL = true;
        img.src = url2;
      }, void 0, offlineProvider || void 0, true, (_request, exception) => {
        onErrorHandler(exception);
      });
    }
  };
  const loadFromOfflineSupport = () => {
    if (offlineProvider) {
      offlineProvider.loadImage(url, img);
    }
  };
  if (!fromBlob && !fromData && offlineProvider && offlineProvider.enableTexturesOffline) {
    offlineProvider.open(loadFromOfflineSupport, noOfflineSupport);
  } else {
    if (url.indexOf("file:") !== -1) {
      const textureName = decodeURIComponent(url.substring(5).toLowerCase());
      if (FilesInputStore.FilesToLoad[textureName] && typeof URL !== "undefined") {
        try {
          let blobURL;
          try {
            blobURL = URL.createObjectURL(FilesInputStore.FilesToLoad[textureName]);
          } catch (ex) {
            blobURL = URL.createObjectURL(FilesInputStore.FilesToLoad[textureName]);
          }
          img.src = blobURL;
          usingObjectURL = true;
        } catch (e) {
          img.src = "";
        }
        return img;
      }
    }
    noOfflineSupport();
  }
  return img;
};
var ReadFile = (file, onSuccess, onProgress, useArrayBuffer, onError) => {
  const reader = new FileReader();
  const fileRequest = {
    onCompleteObservable: new Observable(),
    abort: () => reader.abort()
  };
  reader.onloadend = () => fileRequest.onCompleteObservable.notifyObservers(fileRequest);
  if (onError) {
    reader.onerror = () => {
      onError(new ReadFileError(`Unable to read ${file.name}`, file));
    };
  }
  reader.onload = (e) => {
    onSuccess(e.target["result"]);
  };
  if (onProgress) {
    reader.onprogress = onProgress;
  }
  if (!useArrayBuffer) {
    reader.readAsText(file);
  } else {
    reader.readAsArrayBuffer(file);
  }
  return fileRequest;
};
var LoadFile = (fileOrUrl, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError, onOpened) => {
  if (fileOrUrl.name) {
    return ReadFile(fileOrUrl, onSuccess, onProgress, useArrayBuffer, onError ? (error) => {
      onError(void 0, error);
    } : void 0);
  }
  const url = fileOrUrl;
  if (url.indexOf("file:") !== -1) {
    let fileName = decodeURIComponent(url.substring(5).toLowerCase());
    if (fileName.indexOf("./") === 0) {
      fileName = fileName.substring(2);
    }
    const file = FilesInputStore.FilesToLoad[fileName];
    if (file) {
      return ReadFile(file, onSuccess, onProgress, useArrayBuffer, onError ? (error) => onError(void 0, new LoadFileError(error.message, error.file)) : void 0);
    }
  }
  const { match, type } = TestBase64DataUrl(url);
  if (match) {
    const fileRequest = {
      onCompleteObservable: new Observable(),
      abort: () => () => {
      }
    };
    try {
      const data = useArrayBuffer ? DecodeBase64UrlToBinary(url) : DecodeBase64UrlToString(url);
      onSuccess(data, void 0, type);
    } catch (error) {
      if (onError) {
        onError(void 0, error);
      } else {
        Logger.Error(error.message || "Failed to parse the Data URL");
      }
    }
    TimingTools.SetImmediate(() => {
      fileRequest.onCompleteObservable.notifyObservers(fileRequest);
    });
    return fileRequest;
  }
  return RequestFile(url, (data, request) => {
    onSuccess(data, request == null ? void 0 : request.responseURL, request == null ? void 0 : request.getResponseHeader("content-type"));
  }, onProgress, offlineProvider, useArrayBuffer, onError ? (error) => {
    onError(error.request, new LoadFileError(error.message, error.request));
  } : void 0, onOpened);
};
var RequestFile = (url, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError, onOpened) => {
  url = FileToolsOptions.CleanUrl(url);
  url = FileToolsOptions.PreprocessUrl(url);
  const loadUrl = FileToolsOptions.BaseUrl + url;
  let aborted = false;
  const fileRequest = {
    onCompleteObservable: new Observable(),
    abort: () => aborted = true
  };
  const requestFile = () => {
    let request = new WebRequest();
    let retryHandle = null;
    let onReadyStateChange;
    const unbindEvents = () => {
      if (!request) {
        return;
      }
      if (onProgress) {
        request.removeEventListener("progress", onProgress);
      }
      if (onReadyStateChange) {
        request.removeEventListener("readystatechange", onReadyStateChange);
      }
      request.removeEventListener("loadend", onLoadEnd);
    };
    let onLoadEnd = () => {
      unbindEvents();
      fileRequest.onCompleteObservable.notifyObservers(fileRequest);
      fileRequest.onCompleteObservable.clear();
      onProgress = void 0;
      onReadyStateChange = null;
      onLoadEnd = null;
      onError = void 0;
      onOpened = void 0;
      onSuccess = void 0;
    };
    fileRequest.abort = () => {
      aborted = true;
      if (onLoadEnd) {
        onLoadEnd();
      }
      if (request && request.readyState !== (XMLHttpRequest.DONE || 4)) {
        request.abort();
      }
      if (retryHandle !== null) {
        clearTimeout(retryHandle);
        retryHandle = null;
      }
      request = null;
    };
    const handleError = (error) => {
      const message = error.message || "Unknown error";
      if (onError && request) {
        onError(new RequestFileError(message, request));
      } else {
        Logger.Error(message);
      }
    };
    const retryLoop = (retryIndex) => {
      if (!request) {
        return;
      }
      request.open("GET", loadUrl);
      if (onOpened) {
        try {
          onOpened(request);
        } catch (e) {
          handleError(e);
          return;
        }
      }
      if (useArrayBuffer) {
        request.responseType = "arraybuffer";
      }
      if (onProgress) {
        request.addEventListener("progress", onProgress);
      }
      if (onLoadEnd) {
        request.addEventListener("loadend", onLoadEnd);
      }
      onReadyStateChange = () => {
        if (aborted || !request) {
          return;
        }
        if (request.readyState === (XMLHttpRequest.DONE || 4)) {
          if (onReadyStateChange) {
            request.removeEventListener("readystatechange", onReadyStateChange);
          }
          if (request.status >= 200 && request.status < 300 || request.status === 0 && (!IsWindowObjectExist() || IsFileURL())) {
            const data = useArrayBuffer ? request.response : request.responseText;
            if (data !== null) {
              try {
                if (onSuccess) {
                  onSuccess(data, request);
                }
              } catch (e) {
                handleError(e);
              }
              return;
            }
          }
          const retryStrategy = FileToolsOptions.DefaultRetryStrategy;
          if (retryStrategy) {
            const waitTime = retryStrategy(loadUrl, request, retryIndex);
            if (waitTime !== -1) {
              unbindEvents();
              request = new WebRequest();
              retryHandle = setTimeout(() => retryLoop(retryIndex + 1), waitTime);
              return;
            }
          }
          const error = new RequestFileError("Error status: " + request.status + " " + request.statusText + " - Unable to load " + loadUrl, request);
          if (onError) {
            onError(error);
          }
        }
      };
      request.addEventListener("readystatechange", onReadyStateChange);
      request.send();
    };
    retryLoop(0);
  };
  if (offlineProvider && offlineProvider.enableSceneOffline) {
    const noOfflineSupport = (request) => {
      if (request && request.status > 400) {
        if (onError) {
          onError(request);
        }
      } else {
        requestFile();
      }
    };
    const loadFromOfflineSupport = () => {
      if (offlineProvider) {
        offlineProvider.loadFile(FileToolsOptions.BaseUrl + url, (data) => {
          if (!aborted && onSuccess) {
            onSuccess(data);
          }
          fileRequest.onCompleteObservable.notifyObservers(fileRequest);
        }, onProgress ? (event) => {
          if (!aborted && onProgress) {
            onProgress(event);
          }
        } : void 0, noOfflineSupport, useArrayBuffer);
      }
    };
    offlineProvider.open(loadFromOfflineSupport, noOfflineSupport);
  } else {
    requestFile();
  }
  return fileRequest;
};
var IsFileURL = () => {
  return typeof location !== "undefined" && location.protocol === "file:";
};
var IsBase64DataUrl = (uri) => {
  return Base64DataUrlRegEx.test(uri);
};
var TestBase64DataUrl = (uri) => {
  const results = Base64DataUrlRegEx.exec(uri);
  if (results === null || results.length === 0) {
    return { match: false, type: "" };
  } else {
    const type = results[0].replace("data:", "").replace("base64,", "");
    return { match: true, type };
  }
};
function DecodeBase64UrlToBinary(uri) {
  return DecodeBase64ToBinary(uri.split(",")[1]);
}
var DecodeBase64UrlToString = (uri) => {
  return DecodeBase64ToString(uri.split(",")[1]);
};
var initSideEffects = () => {
  AbstractEngine._FileToolsLoadImage = LoadImage;
  EngineFunctionContext.loadFile = LoadFile;
  _functionContainer.loadFile = LoadFile;
};
initSideEffects();
var FileTools;
var _injectLTSFileTools = (DecodeBase64UrlToBinary2, DecodeBase64UrlToString2, FileToolsOptions2, IsBase64DataUrl2, IsFileURL2, LoadFile2, LoadImage2, ReadFile2, RequestFile2, SetCorsBehavior2) => {
  FileTools = {
    DecodeBase64UrlToBinary: DecodeBase64UrlToBinary2,
    DecodeBase64UrlToString: DecodeBase64UrlToString2,
    DefaultRetryStrategy: FileToolsOptions2.DefaultRetryStrategy,
    BaseUrl: FileToolsOptions2.BaseUrl,
    CorsBehavior: FileToolsOptions2.CorsBehavior,
    PreprocessUrl: FileToolsOptions2.PreprocessUrl,
    IsBase64DataUrl: IsBase64DataUrl2,
    IsFileURL: IsFileURL2,
    LoadFile: LoadFile2,
    LoadImage: LoadImage2,
    ReadFile: ReadFile2,
    RequestFile: RequestFile2,
    SetCorsBehavior: SetCorsBehavior2
  };
  Object.defineProperty(FileTools, "DefaultRetryStrategy", {
    get: function() {
      return FileToolsOptions2.DefaultRetryStrategy;
    },
    set: function(value) {
      FileToolsOptions2.DefaultRetryStrategy = value;
    }
  });
  Object.defineProperty(FileTools, "BaseUrl", {
    get: function() {
      return FileToolsOptions2.BaseUrl;
    },
    set: function(value) {
      FileToolsOptions2.BaseUrl = value;
    }
  });
  Object.defineProperty(FileTools, "PreprocessUrl", {
    get: function() {
      return FileToolsOptions2.PreprocessUrl;
    },
    set: function(value) {
      FileToolsOptions2.PreprocessUrl = value;
    }
  });
  Object.defineProperty(FileTools, "CorsBehavior", {
    get: function() {
      return FileToolsOptions2.CorsBehavior;
    },
    set: function(value) {
      FileToolsOptions2.CorsBehavior = value;
    }
  });
};
_injectLTSFileTools(DecodeBase64UrlToBinary, DecodeBase64UrlToString, FileToolsOptions, IsBase64DataUrl, IsFileURL, LoadFile, LoadImage, ReadFile, RequestFile, SetCorsBehavior);

// node_modules/@babylonjs/core/Misc/instantiationTools.js
var InstantiationTools = class {
  /**
   * Tries to instantiate a new object from a given class name
   * @param className defines the class name to instantiate
   * @returns the new object or null if the system was not able to do the instantiation
   */
  static Instantiate(className) {
    if (this.RegisteredExternalClasses && this.RegisteredExternalClasses[className]) {
      return this.RegisteredExternalClasses[className];
    }
    const internalClass = GetClass(className);
    if (internalClass) {
      return internalClass;
    }
    Logger.Warn(className + " not found, you may have missed an import.");
    const arr = className.split(".");
    let fn = window || this;
    for (let i = 0, len = arr.length; i < len; i++) {
      fn = fn[arr[i]];
    }
    if (typeof fn !== "function") {
      return null;
    }
    return fn;
  }
};
InstantiationTools.RegisteredExternalClasses = {};

export {
  WebRequest,
  FilesInputStore,
  RetryStrategy,
  BaseError,
  ErrorCodes,
  RuntimeError,
  AbortError,
  EndsWith,
  StartsWith,
  Decode,
  EncodeArrayBufferToBase64,
  DecodeBase64ToString,
  DecodeBase64ToBinary,
  PadNumber,
  StringTools,
  RandomGUID,
  GUID,
  InstantiationTools,
  LoadFileError,
  RequestFileError,
  ReadFileError,
  FileToolsOptions,
  SetCorsBehavior,
  LoadImageConfiguration,
  LoadImage,
  ReadFile,
  LoadFile,
  RequestFile,
  IsFileURL,
  IsBase64DataUrl,
  TestBase64DataUrl,
  DecodeBase64UrlToBinary,
  DecodeBase64UrlToString,
  FileTools,
  _injectLTSFileTools
};
//# sourceMappingURL=chunk-QBZFZ5NT.js.map
