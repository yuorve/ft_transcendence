{"version":3,"file":"nodeRenderGraphBlockConnectionPoint.js","sourceRoot":"","sources":["../../../../../dev/core/src/FrameGraph/Node/nodeRenderGraphBlockConnectionPoint.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\r\n    Nullable,\r\n    NodeRenderGraphBlock,\r\n    NodeRenderGraphBlockConnectionPointValueType,\r\n    NodeRenderGraphInputBlock,\r\n    IShadowLight,\r\n    FrameGraphShadowGeneratorTask,\r\n    // eslint-disable-next-line import/no-internal-modules\r\n} from \"core/index\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport { NodeRenderGraphBlockConnectionPointTypes, NodeRenderGraphConnectionPointCompatibilityStates, NodeRenderGraphConnectionPointDirection } from \"./Types/nodeRenderGraphTypes\";\r\n\r\n/**\r\n * Defines a connection point for a block\r\n */\r\nexport class NodeRenderGraphConnectionPoint {\r\n    private readonly _ownerBlock: NodeRenderGraphBlock;\r\n    private _connectedPoint: Nullable<NodeRenderGraphConnectionPoint> = null;\r\n\r\n    /** @internal */\r\n    public _acceptedConnectionPointType: Nullable<NodeRenderGraphConnectionPoint> = null;\r\n\r\n    private _endpoints = new Array<NodeRenderGraphConnectionPoint>();\r\n    private readonly _direction: NodeRenderGraphConnectionPointDirection;\r\n    private _type = NodeRenderGraphBlockConnectionPointTypes.Undefined;\r\n\r\n    /** @internal */\r\n    public _linkedConnectionSource: Nullable<NodeRenderGraphConnectionPoint> = null;\r\n\r\n    /** @internal */\r\n    public _isMainLinkSource = false;\r\n\r\n    /** @internal */\r\n    public _typeConnectionSource: Nullable<NodeRenderGraphConnectionPoint | (() => NodeRenderGraphConnectionPoint)> = null;\r\n\r\n    /** @internal */\r\n    public _defaultConnectionPointType: Nullable<NodeRenderGraphBlockConnectionPointTypes> = null;\r\n\r\n    /** Gets the direction of the point */\r\n    public get direction() {\r\n        return this._direction;\r\n    }\r\n\r\n    /**\r\n     * Checks if the value is a texture handle\r\n     * @param value The value to check\r\n     * @returns True if the value is a texture handle\r\n     */\r\n    public static IsTextureHandle(value: NodeRenderGraphBlockConnectionPointValueType | undefined): boolean {\r\n        return value !== undefined && Number.isFinite(value);\r\n    }\r\n\r\n    /**\r\n     * Checks if the value is a shadow generator task\r\n     * @param value The value to check\r\n     * @returns True if the value is a shadow generator\r\n     */\r\n    public static IsShadowGenerator(value: NodeRenderGraphBlockConnectionPointValueType | undefined): boolean {\r\n        return value !== undefined && (value as FrameGraphShadowGeneratorTask).mapSize !== undefined;\r\n    }\r\n\r\n    /**\r\n     * Checks if the value is a shadow light\r\n     * @param value The value to check\r\n     * @returns True if the value is a shadow light\r\n     */\r\n    public static IsShadowLight(value: NodeRenderGraphBlockConnectionPointValueType | undefined): boolean {\r\n        return value !== undefined && (value as IShadowLight).setShadowProjectionMatrix !== undefined;\r\n    }\r\n\r\n    /**\r\n     * The value stored in this connection point\r\n     */\r\n    public value: NodeRenderGraphBlockConnectionPointValueType | undefined;\r\n\r\n    /** Indicates that this connection point needs dual validation before being connected to another point */\r\n    public needDualDirectionValidation: boolean = false;\r\n\r\n    /**\r\n     * Gets or sets the additional types supported by this connection point\r\n     */\r\n    public acceptedConnectionPointTypes: NodeRenderGraphBlockConnectionPointTypes[] = [];\r\n\r\n    /**\r\n     * Gets or sets the additional types excluded by this connection point\r\n     */\r\n    public excludedConnectionPointTypes: NodeRenderGraphBlockConnectionPointTypes[] = [];\r\n\r\n    /**\r\n     * Observable triggered when this point is connected\r\n     */\r\n    public onConnectionObservable = new Observable<NodeRenderGraphConnectionPoint>();\r\n\r\n    /**\r\n     * Observable triggered when this point is disconnected\r\n     */\r\n    public onDisconnectionObservable = new Observable<NodeRenderGraphConnectionPoint>();\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that this connection point is exposed on a frame\r\n     */\r\n    public isExposedOnFrame: boolean = false;\r\n\r\n    /**\r\n     * Gets or sets number indicating the position that the port is exposed to on a frame\r\n     */\r\n    public exposedPortPosition: number = -1;\r\n\r\n    /**\r\n     * Gets or sets the connection point type (default is Undefined)\r\n     */\r\n    public get type(): NodeRenderGraphBlockConnectionPointTypes {\r\n        if (this._type === NodeRenderGraphBlockConnectionPointTypes.AutoDetect) {\r\n            if (this._ownerBlock.isInput) {\r\n                return (this._ownerBlock as NodeRenderGraphInputBlock).type;\r\n            }\r\n\r\n            if (this._connectedPoint) {\r\n                return this._connectedPoint.type;\r\n            }\r\n\r\n            if (this._linkedConnectionSource) {\r\n                if (this._linkedConnectionSource.isConnected) {\r\n                    return this._linkedConnectionSource.type;\r\n                }\r\n                if (this._linkedConnectionSource._defaultConnectionPointType) {\r\n                    return this._linkedConnectionSource._defaultConnectionPointType;\r\n                }\r\n            }\r\n\r\n            if (this._defaultConnectionPointType) {\r\n                return this._defaultConnectionPointType;\r\n            }\r\n        }\r\n\r\n        if (this._type === NodeRenderGraphBlockConnectionPointTypes.BasedOnInput) {\r\n            if (this._typeConnectionSource) {\r\n                const typeConnectionSource = typeof this._typeConnectionSource === \"function\" ? this._typeConnectionSource() : this._typeConnectionSource;\r\n                if (!typeConnectionSource.isConnected) {\r\n                    return this._defaultConnectionPointType ?? typeConnectionSource.type;\r\n                }\r\n                return typeConnectionSource._connectedPoint!.type;\r\n            } else if (this._defaultConnectionPointType) {\r\n                return this._defaultConnectionPointType;\r\n            }\r\n        }\r\n\r\n        return this._type;\r\n    }\r\n\r\n    public set type(value: NodeRenderGraphBlockConnectionPointTypes) {\r\n        this._type = value;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the connection point name\r\n     */\r\n    public name: string;\r\n\r\n    /**\r\n     * Gets or sets the connection point display name\r\n     */\r\n    public displayName: string;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that this connection point can be omitted\r\n     */\r\n    public isOptional: boolean;\r\n\r\n    /**\r\n     * Gets a boolean indicating that the current point is connected to another NodeRenderGraphBlock\r\n     */\r\n    public get isConnected(): boolean {\r\n        return this.connectedPoint !== null || this.hasEndpoints;\r\n    }\r\n\r\n    /** Get the other side of the connection (if any) */\r\n    public get connectedPoint(): Nullable<NodeRenderGraphConnectionPoint> {\r\n        return this._connectedPoint;\r\n    }\r\n\r\n    /** Get the block that owns this connection point */\r\n    public get ownerBlock(): NodeRenderGraphBlock {\r\n        return this._ownerBlock;\r\n    }\r\n\r\n    /** Get the block connected on the other side of this connection (if any) */\r\n    public get sourceBlock(): Nullable<NodeRenderGraphBlock> {\r\n        if (!this._connectedPoint) {\r\n            return null;\r\n        }\r\n\r\n        return this._connectedPoint.ownerBlock;\r\n    }\r\n\r\n    /** Get the block connected on the endpoints of this connection (if any) */\r\n    public get connectedBlocks(): Array<NodeRenderGraphBlock> {\r\n        if (this._endpoints.length === 0) {\r\n            return [];\r\n        }\r\n\r\n        return this._endpoints.map((e) => e.ownerBlock);\r\n    }\r\n\r\n    /** Gets the list of connected endpoints */\r\n    public get endpoints() {\r\n        return this._endpoints;\r\n    }\r\n\r\n    /** Gets a boolean indicating if that output point is connected to at least one input */\r\n    public get hasEndpoints(): boolean {\r\n        return this._endpoints && this._endpoints.length > 0;\r\n    }\r\n\r\n    /** Get the inner type (ie AutoDetect for instance instead of the inferred one) */\r\n    public get innerType() {\r\n        if (this._linkedConnectionSource && !this._isMainLinkSource && this._linkedConnectionSource.isConnected) {\r\n            return this.type;\r\n        }\r\n        return this._type;\r\n    }\r\n\r\n    /**\r\n     * Creates a block suitable to be used as an input for this input point.\r\n     * If null is returned, a block based on the point type will be created.\r\n     * @returns The returned string parameter is the name of the output point of NodeRenderGraphBlock (first parameter of the returned array) that can be connected to the input\r\n     */\r\n    public createCustomInputBlock(): Nullable<[NodeRenderGraphBlock, string]> {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Creates a new connection point\r\n     * @param name defines the connection point name\r\n     * @param ownerBlock defines the block hosting this connection point\r\n     * @param direction defines the direction of the connection point\r\n     */\r\n    public constructor(name: string, ownerBlock: NodeRenderGraphBlock, direction: NodeRenderGraphConnectionPointDirection) {\r\n        this._ownerBlock = ownerBlock;\r\n        this.name = name;\r\n        this._direction = direction;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name e.g. \"NodeRenderGraphConnectionPoint\"\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"NodeRenderGraphConnectionPoint\";\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if the current point can be connected to another point\r\n     * @param connectionPoint defines the other connection point\r\n     * @returns a boolean\r\n     */\r\n    public canConnectTo(connectionPoint: NodeRenderGraphConnectionPoint) {\r\n        return this.checkCompatibilityState(connectionPoint) === NodeRenderGraphConnectionPointCompatibilityStates.Compatible;\r\n    }\r\n\r\n    /**\r\n     * Gets a number indicating if the current point can be connected to another point\r\n     * @param connectionPoint defines the other connection point\r\n     * @returns a number defining the compatibility state\r\n     */\r\n    public checkCompatibilityState(connectionPoint: NodeRenderGraphConnectionPoint): NodeRenderGraphConnectionPointCompatibilityStates {\r\n        const ownerBlock = this._ownerBlock;\r\n        const otherBlock = connectionPoint.ownerBlock;\r\n\r\n        if (this.type !== connectionPoint.type && connectionPoint.innerType !== NodeRenderGraphBlockConnectionPointTypes.AutoDetect) {\r\n            // Accepted types\r\n            if (connectionPoint.acceptedConnectionPointTypes && connectionPoint.acceptedConnectionPointTypes.indexOf(this.type) !== -1) {\r\n                return NodeRenderGraphConnectionPointCompatibilityStates.Compatible;\r\n            } else {\r\n                return NodeRenderGraphConnectionPointCompatibilityStates.TypeIncompatible;\r\n            }\r\n        }\r\n\r\n        // Excluded\r\n        if (connectionPoint.excludedConnectionPointTypes && connectionPoint.excludedConnectionPointTypes.indexOf(this.type) !== -1) {\r\n            return NodeRenderGraphConnectionPointCompatibilityStates.TypeIncompatible;\r\n        }\r\n\r\n        // Check hierarchy\r\n        let targetBlock = otherBlock;\r\n        let sourceBlock = ownerBlock;\r\n        if (this.direction === NodeRenderGraphConnectionPointDirection.Input) {\r\n            targetBlock = ownerBlock;\r\n            sourceBlock = otherBlock;\r\n        }\r\n\r\n        if (targetBlock.isAnAncestorOf(sourceBlock)) {\r\n            return NodeRenderGraphConnectionPointCompatibilityStates.HierarchyIssue;\r\n        }\r\n\r\n        return NodeRenderGraphConnectionPointCompatibilityStates.Compatible;\r\n    }\r\n\r\n    /**\r\n     * Connect this point to another connection point\r\n     * @param connectionPoint defines the other connection point\r\n     * @param ignoreConstraints defines if the system will ignore connection type constraints (default is false)\r\n     * @returns the current connection point\r\n     */\r\n    public connectTo(connectionPoint: NodeRenderGraphConnectionPoint, ignoreConstraints = false): NodeRenderGraphConnectionPoint {\r\n        if (!ignoreConstraints && !this.canConnectTo(connectionPoint)) {\r\n            // eslint-disable-next-line no-throw-literal\r\n            throw \"Cannot connect these two connectors.\";\r\n        }\r\n\r\n        this._endpoints.push(connectionPoint);\r\n        connectionPoint._connectedPoint = this;\r\n\r\n        this.onConnectionObservable.notifyObservers(connectionPoint);\r\n        connectionPoint.onConnectionObservable.notifyObservers(this);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Disconnect this point from one of his endpoint\r\n     * @param endpoint defines the other connection point\r\n     * @returns the current connection point\r\n     */\r\n    public disconnectFrom(endpoint: NodeRenderGraphConnectionPoint): NodeRenderGraphConnectionPoint {\r\n        const index = this._endpoints.indexOf(endpoint);\r\n\r\n        if (index === -1) {\r\n            return this;\r\n        }\r\n\r\n        this._endpoints.splice(index, 1);\r\n        endpoint._connectedPoint = null;\r\n\r\n        this.onDisconnectionObservable.notifyObservers(endpoint);\r\n        endpoint.onDisconnectionObservable.notifyObservers(this);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Fills the list of excluded connection point types with all types other than those passed in the parameter\r\n     * @param mask Types (ORed values of NodeRenderGraphBlockConnectionPointTypes) that are allowed, and thus will not be pushed to the excluded list\r\n     */\r\n    public addExcludedConnectionPointFromAllowedTypes(mask: number): void {\r\n        let bitmask = 0;\r\n        let val = 2 ** bitmask;\r\n        // Note: don't use 1 << bitmask instead of 2 ** bitmask, as it will cause an infinite loop because 1 << 31 is negative!\r\n        while (val < NodeRenderGraphBlockConnectionPointTypes.All) {\r\n            if (!(mask & val)) {\r\n                this.excludedConnectionPointTypes.push(val);\r\n            }\r\n            bitmask++;\r\n            val = 2 ** bitmask;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds accepted connection point types\r\n     * @param mask Types (ORed values of NodeRenderGraphBlockConnectionPointTypes) that are allowed to connect to this point\r\n     */\r\n    public addAcceptedConnectionPointTypes(mask: number): void {\r\n        let bitmask = 0;\r\n        let val = 2 ** bitmask;\r\n        // Note: don't use 1 << bitmask instead of 2 ** bitmask, as it will cause an infinite loop because 1 << 31 is negative!\r\n        while (val < NodeRenderGraphBlockConnectionPointTypes.All) {\r\n            if (mask & val && this.acceptedConnectionPointTypes.indexOf(val) === -1) {\r\n                this.acceptedConnectionPointTypes.push(val);\r\n            }\r\n            bitmask++;\r\n            val = 2 ** bitmask;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Serializes this point in a JSON representation\r\n     * @param isInput defines if the connection point is an input (default is true)\r\n     * @returns the serialized point object\r\n     */\r\n    public serialize(isInput = true): any {\r\n        const serializationObject: any = {};\r\n\r\n        serializationObject.name = this.name;\r\n        serializationObject.displayName = this.displayName;\r\n\r\n        if (isInput && this.connectedPoint) {\r\n            serializationObject.inputName = this.name;\r\n            serializationObject.targetBlockId = this.connectedPoint.ownerBlock.uniqueId;\r\n            serializationObject.targetConnectionName = this.connectedPoint.name;\r\n            serializationObject.isExposedOnFrame = true;\r\n            serializationObject.exposedPortPosition = this.exposedPortPosition;\r\n        }\r\n\r\n        if (this.isExposedOnFrame || this.exposedPortPosition >= 0) {\r\n            serializationObject.isExposedOnFrame = true;\r\n            serializationObject.exposedPortPosition = this.exposedPortPosition;\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Release resources\r\n     */\r\n    public dispose() {\r\n        this.onConnectionObservable.clear();\r\n        this.onDisconnectionObservable.clear();\r\n    }\r\n}\r\n"]}