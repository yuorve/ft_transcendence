{"version":3,"file":"dracoCompression.js","sourceRoot":"","sources":["../../../../../dev/core/src/Meshes/Compression/dracoCompression.ts"],"names":[],"mappings":"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","sourcesContent":["import { _GetDefaultNumWorkers, _IsConfigurationAvailable } from \"./dracoCodec\";\r\nimport type { IDracoCodecConfiguration } from \"./dracoCodec\";\r\nimport { DracoDecoder } from \"./dracoDecoder\";\r\nimport type { MeshData } from \"./dracoDecoder.types\";\r\nimport { VertexBuffer } from \"../buffer\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport type { Nullable } from \"core/types\";\r\nimport type { Geometry } from \"../geometry\";\r\nimport type { BoundingInfo } from \"../../Culling/boundingInfo\";\r\nimport type { Scene } from \"../../scene\";\r\n\r\n/**\r\n * Configuration for Draco compression\r\n */\r\nexport interface IDracoCompressionConfiguration {\r\n    /**\r\n     * Configuration for the decoder.\r\n     */\r\n    decoder: IDracoCodecConfiguration;\r\n}\r\n\r\n/**\r\n * Options for Draco compression\r\n */\r\nexport interface IDracoCompressionOptions extends Pick<IDracoCodecConfiguration, \"numWorkers\" | \"wasmBinary\" | \"workerPool\"> {}\r\n\r\n/**\r\n * Draco compression (https://google.github.io/draco/)\r\n *\r\n * This class wraps the Draco module.\r\n *\r\n * **Encoder**\r\n *\r\n * The encoder is not currently implemented.\r\n *\r\n * **Decoder**\r\n *\r\n * By default, the configuration points to a copy of the Draco decoder files for glTF from the babylon.js cdn https://cdn.babylonjs.com/draco_wasm_wrapper_gltf.js.\r\n * The configuration is shared with the DracoDecoder class.\r\n *\r\n * To update the configuration, use the following code:\r\n * ```javascript\r\n *     DracoCompression.Configuration = {\r\n *         decoder: {\r\n *             wasmUrl: \"<url to the WebAssembly library>\",\r\n *             wasmBinaryUrl: \"<url to the WebAssembly binary>\",\r\n *             fallbackUrl: \"<url to the fallback JavaScript library>\",\r\n *         }\r\n *     };\r\n * ```\r\n *\r\n * Draco has two versions, one for WebAssembly and one for JavaScript. The decoder configuration can be set to only support WebAssembly or only support the JavaScript version.\r\n * Decoding will automatically fallback to the JavaScript version if WebAssembly version is not configured or if WebAssembly is not supported by the browser.\r\n * Use `DracoCompression.DecoderAvailable` to determine if the decoder configuration is available for the current context.\r\n *\r\n * To decode Draco compressed data, get the default DracoCompression object and call decodeMeshToGeometryAsync:\r\n * ```javascript\r\n *     var geometry = await DracoCompression.Default.decodeMeshToGeometryAsync(data);\r\n * ```\r\n *\r\n * @see https://playground.babylonjs.com/#DMZIBD#0\r\n */\r\nexport class DracoCompression {\r\n    private _decoder: DracoDecoder;\r\n\r\n    /**\r\n     * The configuration. Defaults to the following urls:\r\n     * - wasmUrl: \"https://cdn.babylonjs.com/draco_wasm_wrapper_gltf.js\"\r\n     * - wasmBinaryUrl: \"https://cdn.babylonjs.com/draco_decoder_gltf.wasm\"\r\n     * - fallbackUrl: \"https://cdn.babylonjs.com/draco_decoder_gltf.js\"\r\n     */\r\n    public static get Configuration(): IDracoCompressionConfiguration {\r\n        return {\r\n            get decoder() {\r\n                return DracoDecoder.DefaultConfiguration;\r\n            },\r\n            set decoder(value: IDracoCodecConfiguration) {\r\n                DracoDecoder.DefaultConfiguration = value;\r\n            },\r\n        };\r\n    }\r\n    public static set Configuration(value: IDracoCompressionConfiguration) {\r\n        DracoDecoder.DefaultConfiguration = value.decoder;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the decoder configuration is available.\r\n     */\r\n    public static get DecoderAvailable(): boolean {\r\n        return _IsConfigurationAvailable(DracoDecoder.DefaultConfiguration);\r\n    }\r\n\r\n    /**\r\n     * Default number of workers to create when creating the draco compression object.\r\n     */\r\n    public static DefaultNumWorkers = _GetDefaultNumWorkers();\r\n\r\n    protected static _Default: Nullable<DracoCompression> = null;\r\n    /**\r\n     * Default instance for the DracoCompression.\r\n     */\r\n    public static get Default(): DracoCompression {\r\n        DracoCompression._Default ??= new DracoCompression();\r\n        return DracoCompression._Default;\r\n    }\r\n\r\n    /**\r\n     * Reset the default draco compression object to null and disposing the removed default instance.\r\n     * Note that if the workerPool is a member of the static Configuration object it is recommended not to run dispose,\r\n     * unless the static worker pool is no longer needed.\r\n     * @param skipDispose set to true to not dispose the removed default instance\r\n     */\r\n    public static ResetDefault(skipDispose?: boolean): void {\r\n        if (DracoCompression._Default) {\r\n            if (!skipDispose) {\r\n                DracoCompression._Default.dispose();\r\n            }\r\n            DracoCompression._Default = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a new DracoCompression object.\r\n     * @param numWorkersOrOptions Overrides for the Configuration. Either:\r\n     * - The number of workers for async operations or a config object. Specify `0` to disable web workers and run synchronously in the current context.\r\n     * - An options object\r\n     */\r\n    constructor(numWorkersOrOptions: number | IDracoCompressionOptions = DracoCompression.DefaultNumWorkers) {\r\n        const configuration =\r\n            typeof numWorkersOrOptions === \"number\"\r\n                ? { ...DracoDecoder.DefaultConfiguration, numWorkers: numWorkersOrOptions }\r\n                : { ...DracoDecoder.DefaultConfiguration, ...numWorkersOrOptions };\r\n        this._decoder = new DracoDecoder(configuration);\r\n    }\r\n\r\n    /**\r\n     * Stop all async operations and release resources.\r\n     */\r\n    public dispose(): void {\r\n        this._decoder.dispose();\r\n    }\r\n\r\n    /**\r\n     * Returns a promise that resolves when ready. Call this manually to ensure draco compression is ready before use.\r\n     * @returns a promise that resolves when ready\r\n     */\r\n    public async whenReadyAsync(): Promise<void> {\r\n        return this._decoder.whenReadyAsync();\r\n    }\r\n\r\n    /**\r\n     * Decode Draco compressed mesh data to mesh data.\r\n     * @param data The ArrayBuffer or ArrayBufferView for the Draco compression data\r\n     * @param attributes A map of attributes from vertex buffer kinds to Draco unique ids\r\n     * @param gltfNormalizedOverride A map of attributes from vertex buffer kinds to normalized flags to override the Draco normalization\r\n     * @returns A promise that resolves with the decoded mesh data\r\n     */\r\n    public decodeMeshToMeshDataAsync(\r\n        data: ArrayBuffer | ArrayBufferView,\r\n        attributes?: { [kind: string]: number },\r\n        gltfNormalizedOverride?: { [kind: string]: boolean }\r\n    ): Promise<MeshData> {\r\n        return this._decoder.decodeMeshToMeshDataAsync(data, attributes, gltfNormalizedOverride);\r\n    }\r\n\r\n    /**\r\n     * Decode Draco compressed mesh data to Babylon geometry.\r\n     * @param name The name to use when creating the geometry\r\n     * @param scene The scene to use when creating the geometry\r\n     * @param data The ArrayBuffer or ArrayBufferView for the Draco compression data\r\n     * @param attributes A map of attributes from vertex buffer kinds to Draco unique ids\r\n     * @returns A promise that resolves with the decoded geometry\r\n     */\r\n    public async decodeMeshToGeometryAsync(name: string, scene: Scene, data: ArrayBuffer | ArrayBufferView, attributes?: { [kind: string]: number }): Promise<Geometry> {\r\n        return this._decoder.decodeMeshToGeometryAsync(name, scene, data, attributes);\r\n    }\r\n\r\n    /** @internal */\r\n    public async _decodeMeshToGeometryForGltfAsync(\r\n        name: string,\r\n        scene: Scene,\r\n        data: ArrayBuffer | ArrayBufferView,\r\n        attributes: { [kind: string]: number },\r\n        gltfNormalizedOverride: { [kind: string]: boolean },\r\n        boundingInfo: Nullable<BoundingInfo>\r\n    ): Promise<Geometry> {\r\n        return this._decoder._decodeMeshToGeometryForGltfAsync(name, scene, data, attributes, gltfNormalizedOverride, boundingInfo);\r\n    }\r\n\r\n    /**\r\n     * Decode Draco compressed mesh data to Babylon vertex data.\r\n     * @param data The ArrayBuffer or ArrayBufferView for the Draco compression data\r\n     * @param attributes A map of attributes from vertex buffer kinds to Draco unique ids\r\n     * @returns A promise that resolves with the decoded vertex data\r\n     * @deprecated Use {@link decodeMeshToGeometryAsync} for better performance in some cases\r\n     */\r\n    public async decodeMeshAsync(data: ArrayBuffer | ArrayBufferView, attributes?: { [kind: string]: number }): Promise<VertexData> {\r\n        const meshData = await this._decoder.decodeMeshToMeshDataAsync(data, attributes);\r\n        const vertexData = new VertexData();\r\n        if (meshData.indices) {\r\n            vertexData.indices = meshData.indices;\r\n        }\r\n        for (const attribute of meshData.attributes) {\r\n            const floatData = VertexBuffer.GetFloatData(\r\n                attribute.data,\r\n                attribute.size,\r\n                VertexBuffer.GetDataType(attribute.data),\r\n                attribute.byteOffset,\r\n                attribute.byteStride,\r\n                attribute.normalized,\r\n                meshData.totalVertices\r\n            );\r\n\r\n            vertexData.set(floatData, attribute.kind);\r\n        }\r\n        return vertexData;\r\n    }\r\n}\r\n"]}