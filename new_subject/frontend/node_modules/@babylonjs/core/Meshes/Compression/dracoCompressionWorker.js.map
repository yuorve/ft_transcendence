{"version":3,"file":"dracoCompressionWorker.js","sourceRoot":"","sources":["../../../../../dev/core/src/Meshes/Compression/dracoCompressionWorker.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Nullable, TypedArray, TypedArrayConstructor } from \"core/types\";\r\nimport type { EncoderMessage, IDracoAttributeData, IDracoEncodedMeshData, IDracoEncoderOptions } from \"./dracoEncoder.types\";\r\nimport type { DecoderMessage } from \"./dracoDecoder.types\";\r\nimport type { DecoderBuffer, Decoder, Mesh, PointCloud, Status, DecoderModule, EncoderModule, MeshBuilder, Encoder, DracoInt8Array } from \"draco3dgltf\";\r\nimport { DracoDecoderModule } from \"draco3dgltf\";\r\nimport type { VertexDataTypedArray } from \"core/Buffers/bufferUtils\";\r\n\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\ndeclare let DracoDecoderModule: DracoDecoderModule;\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\ndeclare let DracoEncoderModule: (props: { wasmBinary?: ArrayBuffer }) => Promise<EncoderModule>;\r\n\r\ninterface InitDoneMessage {\r\n    id: \"initDone\";\r\n}\r\n\r\n// WorkerGlobalScope\r\ndeclare function importScripts(...urls: string[]): void;\r\ndeclare function postMessage(message: InitDoneMessage | DecoderMessage | EncoderMessage, transfer?: ArrayBufferLike[]): void;\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function EncodeMesh(\r\n    module: unknown /** EncoderModule */,\r\n    attributes: Array<IDracoAttributeData>,\r\n    indices: Nullable<Uint16Array | Uint32Array>,\r\n    options: IDracoEncoderOptions\r\n): Nullable<IDracoEncodedMeshData> {\r\n    const encoderModule = module as EncoderModule;\r\n    let encoder: Nullable<Encoder> = null;\r\n    let meshBuilder: Nullable<MeshBuilder> = null;\r\n    let mesh: Nullable<Mesh> = null;\r\n    let encodedNativeBuffer: Nullable<DracoInt8Array> = null;\r\n    const attributeIDs: Record<string, number> = {}; // Babylon kind -> Draco unique id\r\n\r\n    // Double-check that at least a position attribute is provided\r\n    const positionAttribute = attributes.find((a) => a.dracoName === \"POSITION\");\r\n    if (!positionAttribute) {\r\n        throw new Error(\"Position attribute is required for Draco encoding\");\r\n    }\r\n\r\n    // If no indices are provided, assume mesh is unindexed. Let's generate them, since Draco meshes require them.\r\n    // TODO: This may be the POINT_CLOUD case, but need to investigate. Should work for now-- just less efficient.\r\n    if (!indices) {\r\n        // Assume position attribute is the largest attribute.\r\n        const positionVerticesCount = positionAttribute.data.length / positionAttribute.size;\r\n        indices = new (positionVerticesCount > 65535 ? Uint32Array : Uint16Array)(positionVerticesCount);\r\n        for (let i = 0; i < positionVerticesCount; i++) {\r\n            indices[i] = i;\r\n        }\r\n    }\r\n\r\n    try {\r\n        encoder = new encoderModule.Encoder();\r\n        meshBuilder = new encoderModule.MeshBuilder();\r\n        mesh = new encoderModule.Mesh();\r\n\r\n        // Add the faces\r\n        meshBuilder.AddFacesToMesh(mesh, indices.length / 3, indices);\r\n\r\n        const addAttributeMap = new Map<\r\n            Function,\r\n            (builder: MeshBuilder, mesh: Mesh, attr: any, count: number, size: number, data: Exclude<VertexDataTypedArray, Uint8ClampedArray>) => number\r\n        >([\r\n            [Float32Array, (mb, m, a, c, s, d) => mb.AddFloatAttribute(m, a, c, s, d)],\r\n            [Uint32Array, (mb, m, a, c, s, d) => mb.AddUInt32Attribute(m, a, c, s, d)],\r\n            [Uint16Array, (mb, m, a, c, s, d) => mb.AddUInt16Attribute(m, a, c, s, d)],\r\n            [Uint8Array, (mb, m, a, c, s, d) => mb.AddUInt8Attribute(m, a, c, s, d)],\r\n            [Int32Array, (mb, m, a, c, s, d) => mb.AddInt32Attribute(m, a, c, s, d)],\r\n            [Int16Array, (mb, m, a, c, s, d) => mb.AddInt16Attribute(m, a, c, s, d)],\r\n            [Int8Array, (mb, m, a, c, s, d) => mb.AddInt8Attribute(m, a, c, s, d)],\r\n        ]);\r\n\r\n        // Add the attributes\r\n        for (const attribute of attributes) {\r\n            if (attribute.data instanceof Uint8ClampedArray) {\r\n                attribute.data = new Uint8Array(attribute.data); // Draco does not support Uint8ClampedArray\r\n            }\r\n            const addAttribute = addAttributeMap.get(attribute.data.constructor)!;\r\n            const verticesCount = attribute.data.length / attribute.size;\r\n            attributeIDs[attribute.kind] = addAttribute(meshBuilder, mesh, encoderModule[attribute.dracoName], verticesCount, attribute.size, attribute.data);\r\n            if (options.quantizationBits && options.quantizationBits[attribute.dracoName]) {\r\n                encoder.SetAttributeQuantization(encoderModule[attribute.dracoName], options.quantizationBits[attribute.dracoName]);\r\n            }\r\n        }\r\n\r\n        // Set the options\r\n        if (options.method) {\r\n            encoder.SetEncodingMethod(encoderModule[options.method]);\r\n        }\r\n        if (options.encodeSpeed !== undefined && options.decodeSpeed !== undefined) {\r\n            encoder.SetSpeedOptions(options.encodeSpeed, options.decodeSpeed);\r\n        }\r\n\r\n        // Encode to native buffer\r\n        encodedNativeBuffer = new encoderModule.DracoInt8Array();\r\n        const encodedLength = encoder.EncodeMeshToDracoBuffer(mesh, encodedNativeBuffer);\r\n        if (encodedLength <= 0) {\r\n            throw new Error(\"Draco encoding failed.\");\r\n        }\r\n\r\n        // Copy the native buffer data to worker heap\r\n        const encodedData = new Int8Array(encodedLength);\r\n        for (let i = 0; i < encodedLength; i++) {\r\n            encodedData[i] = encodedNativeBuffer.GetValue(i);\r\n        }\r\n\r\n        return { data: encodedData, attributeIDs: attributeIDs };\r\n    } finally {\r\n        if (mesh) {\r\n            encoderModule.destroy(mesh);\r\n        }\r\n        if (meshBuilder) {\r\n            encoderModule.destroy(meshBuilder);\r\n        }\r\n        if (encoder) {\r\n            encoderModule.destroy(encoder);\r\n        }\r\n        if (encodedNativeBuffer) {\r\n            encoderModule.destroy(encodedNativeBuffer);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * The worker function that gets converted to a blob url to pass into a worker.\r\n * To be used if a developer wants to create their own worker instance and inject it instead of using the default worker.\r\n */\r\nexport function EncoderWorkerFunction(): void {\r\n    let encoderPromise: PromiseLike<EncoderModule> | undefined;\r\n\r\n    onmessage = (event) => {\r\n        const message = event.data;\r\n        switch (message.id) {\r\n            case \"init\": {\r\n                // if URL is provided then load the script. Otherwise expect the script to be loaded already\r\n                if (message.url) {\r\n                    importScripts(message.url);\r\n                }\r\n                const initEncoderObject = message.wasmBinary ? { wasmBinary: message.wasmBinary } : {};\r\n                encoderPromise = DracoEncoderModule(initEncoderObject);\r\n                postMessage({ id: \"initDone\" });\r\n                break;\r\n            }\r\n            case \"encodeMesh\": {\r\n                if (!encoderPromise) {\r\n                    throw new Error(\"Draco encoder module is not available\");\r\n                }\r\n                encoderPromise.then((encoder) => {\r\n                    const result = EncodeMesh(encoder, message.attributes, message.indices, message.options);\r\n                    postMessage({ id: \"encodeMeshDone\", encodedMeshData: result }, result ? [result.data.buffer] : undefined);\r\n                });\r\n                break;\r\n            }\r\n        }\r\n    };\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function DecodeMesh(\r\n    module: unknown /** DecoderModule */,\r\n    data: Int8Array,\r\n    attributeIDs: Record<string, number> | undefined,\r\n    onIndicesData: (indices: Uint16Array | Uint32Array) => void,\r\n    onAttributeData: (kind: string, data: ArrayBufferView, size: number, offset: number, stride: number, normalized: boolean) => void\r\n): number {\r\n    const decoderModule = module as DecoderModule;\r\n    let decoder: Nullable<Decoder> = null;\r\n    let buffer: Nullable<DecoderBuffer> = null;\r\n    let geometry: Nullable<Mesh | PointCloud> = null;\r\n\r\n    try {\r\n        decoder = new decoderModule.Decoder();\r\n\r\n        buffer = new decoderModule.DecoderBuffer();\r\n        buffer.Init(data, data.byteLength);\r\n\r\n        let status: Status;\r\n        const type = decoder.GetEncodedGeometryType(buffer);\r\n        switch (type) {\r\n            case decoderModule.TRIANGULAR_MESH: {\r\n                const mesh = new decoderModule.Mesh();\r\n                status = decoder.DecodeBufferToMesh(buffer, mesh);\r\n                if (!status.ok() || mesh.ptr === 0) {\r\n                    throw new Error(status.error_msg());\r\n                }\r\n\r\n                const numFaces = mesh.num_faces();\r\n                const numIndices = numFaces * 3;\r\n                const byteLength = numIndices * 4;\r\n\r\n                const ptr = decoderModule._malloc(byteLength);\r\n                try {\r\n                    decoder.GetTrianglesUInt32Array(mesh, byteLength, ptr);\r\n                    const indices = new Uint32Array(numIndices);\r\n                    indices.set(new Uint32Array(decoderModule.HEAPF32.buffer, ptr, numIndices));\r\n                    onIndicesData(indices);\r\n                } finally {\r\n                    decoderModule._free(ptr);\r\n                }\r\n\r\n                geometry = mesh as Mesh;\r\n                break;\r\n            }\r\n            case decoderModule.POINT_CLOUD: {\r\n                const pointCloud = new decoderModule.PointCloud();\r\n                status = decoder.DecodeBufferToPointCloud(buffer, pointCloud);\r\n                if (!status.ok() || !pointCloud.ptr) {\r\n                    throw new Error(status.error_msg());\r\n                }\r\n\r\n                geometry = pointCloud as PointCloud;\r\n                break;\r\n            }\r\n            default: {\r\n                throw new Error(`Invalid geometry type ${type}`);\r\n            }\r\n        }\r\n\r\n        const numPoints = geometry.num_points();\r\n\r\n        const processAttribute = (decoder: Decoder, geometry: Mesh | PointCloud, kind: string, attribute: any /** Attribute */) => {\r\n            const dataType = attribute.data_type();\r\n            const numComponents = attribute.num_components();\r\n            const normalized = attribute.normalized();\r\n            const byteStride = attribute.byte_stride();\r\n            const byteOffset = attribute.byte_offset();\r\n\r\n            const dataTypeInfo: Record<number, { typedArrayConstructor: TypedArrayConstructor; heap: TypedArray }> = {\r\n                [decoderModule.DT_FLOAT32]: { typedArrayConstructor: Float32Array, heap: decoderModule.HEAPF32 },\r\n                [decoderModule.DT_INT8]: { typedArrayConstructor: Int8Array, heap: decoderModule.HEAP8 },\r\n                [decoderModule.DT_INT16]: { typedArrayConstructor: Int16Array, heap: decoderModule.HEAP16 },\r\n                [decoderModule.DT_INT32]: { typedArrayConstructor: Int32Array, heap: decoderModule.HEAP32 },\r\n                [decoderModule.DT_UINT8]: { typedArrayConstructor: Uint8Array, heap: decoderModule.HEAPU8 },\r\n                [decoderModule.DT_UINT16]: { typedArrayConstructor: Uint16Array, heap: decoderModule.HEAPU16 },\r\n                [decoderModule.DT_UINT32]: { typedArrayConstructor: Uint32Array, heap: decoderModule.HEAPU32 },\r\n            };\r\n\r\n            const info = dataTypeInfo[dataType];\r\n            if (!info) {\r\n                throw new Error(`Invalid data type ${dataType}`);\r\n            }\r\n\r\n            const numValues = numPoints * numComponents;\r\n            const byteLength = numValues * info.typedArrayConstructor.BYTES_PER_ELEMENT;\r\n\r\n            const ptr = decoderModule._malloc(byteLength);\r\n            try {\r\n                decoder.GetAttributeDataArrayForAllPoints(geometry, attribute, dataType, byteLength, ptr);\r\n                const data = new info.typedArrayConstructor(info.heap.buffer, ptr, numValues);\r\n                onAttributeData(kind, data.slice(), numComponents, byteOffset, byteStride, normalized);\r\n            } finally {\r\n                decoderModule._free(ptr);\r\n            }\r\n        };\r\n\r\n        if (attributeIDs) {\r\n            for (const kind in attributeIDs) {\r\n                const id = attributeIDs[kind];\r\n                const attribute = decoder.GetAttributeByUniqueId(geometry, id);\r\n                processAttribute(decoder, geometry, kind, attribute);\r\n            }\r\n        } else {\r\n            const dracoAttributeTypes: Record<string, number> = {\r\n                position: decoderModule.POSITION,\r\n                normal: decoderModule.NORMAL,\r\n                color: decoderModule.COLOR,\r\n                uv: decoderModule.TEX_COORD,\r\n            };\r\n\r\n            for (const kind in dracoAttributeTypes) {\r\n                const id = decoder.GetAttributeId(geometry, dracoAttributeTypes[kind]);\r\n                if (id !== -1) {\r\n                    const attribute = decoder.GetAttribute(geometry, id);\r\n                    processAttribute(decoder, geometry, kind, attribute);\r\n                }\r\n            }\r\n        }\r\n\r\n        return numPoints;\r\n    } finally {\r\n        if (geometry) {\r\n            decoderModule.destroy(geometry);\r\n        }\r\n\r\n        if (buffer) {\r\n            decoderModule.destroy(buffer);\r\n        }\r\n\r\n        if (decoder) {\r\n            decoderModule.destroy(decoder);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * The worker function that gets converted to a blob url to pass into a worker.\r\n * To be used if a developer wants to create their own worker instance and inject it instead of using the default worker.\r\n */\r\nexport function DecoderWorkerFunction(): void {\r\n    let decoderPromise: PromiseLike<DecoderModule> | undefined;\r\n\r\n    onmessage = (event) => {\r\n        const message = event.data;\r\n        switch (message.id) {\r\n            case \"init\": {\r\n                // if URL is provided then load the script. Otherwise expect the script to be loaded already\r\n                if (message.url) {\r\n                    importScripts(message.url);\r\n                }\r\n                const initDecoderObject = message.wasmBinary ? { wasmBinary: message.wasmBinary } : {};\r\n                decoderPromise = DracoDecoderModule(initDecoderObject);\r\n                postMessage({ id: \"initDone\" });\r\n                break;\r\n            }\r\n            case \"decodeMesh\": {\r\n                if (!decoderPromise) {\r\n                    throw new Error(\"Draco decoder module is not available\");\r\n                }\r\n                decoderPromise.then((decoder) => {\r\n                    const numPoints = DecodeMesh(\r\n                        decoder,\r\n                        message.dataView,\r\n                        message.attributes,\r\n                        (indices) => {\r\n                            postMessage({ id: \"indices\", data: indices }, [indices.buffer]);\r\n                        },\r\n                        (kind, data, size, offset, stride, normalized) => {\r\n                            postMessage({ id: \"attribute\", kind, data, size, byteOffset: offset, byteStride: stride, normalized }, [data.buffer]);\r\n                        }\r\n                    );\r\n                    postMessage({ id: \"decodeMeshDone\", totalVertices: numPoints });\r\n                });\r\n                break;\r\n            }\r\n        }\r\n    };\r\n}\r\n\r\n// For backwards compatibility\r\nexport { DecoderWorkerFunction as workerFunction };\r\n\r\n/**\r\n * Initializes a worker that was created for the draco agent pool\r\n * @param worker  The worker to initialize\r\n * @param wasmBinary The wasm binary to load into the worker\r\n * @param moduleUrl The url to the draco decoder module (optional)\r\n * @returns A promise that resolves when the worker is initialized\r\n */\r\nexport function initializeWebWorker(worker: Worker, wasmBinary?: ArrayBuffer, moduleUrl?: string): Promise<Worker> {\r\n    return new Promise<Worker>((resolve, reject) => {\r\n        const onError = (error: ErrorEvent) => {\r\n            worker.removeEventListener(\"error\", onError);\r\n            worker.removeEventListener(\"message\", onMessage);\r\n            reject(error);\r\n        };\r\n\r\n        const onMessage = (event: MessageEvent<InitDoneMessage>) => {\r\n            if (event.data.id === \"initDone\") {\r\n                worker.removeEventListener(\"error\", onError);\r\n                worker.removeEventListener(\"message\", onMessage);\r\n                resolve(worker);\r\n            }\r\n        };\r\n\r\n        worker.addEventListener(\"error\", onError);\r\n        worker.addEventListener(\"message\", onMessage);\r\n\r\n        // Load with either JS-only or WASM version\r\n        if (!wasmBinary) {\r\n            worker.postMessage({\r\n                id: \"init\",\r\n                url: moduleUrl,\r\n            });\r\n        } else {\r\n            // clone the array buffer to make it transferable\r\n            const clone = wasmBinary.slice(0);\r\n            worker.postMessage(\r\n                {\r\n                    id: \"init\",\r\n                    url: moduleUrl,\r\n                    wasmBinary: clone,\r\n                },\r\n                [clone]\r\n            );\r\n        }\r\n        // note: no transfer list as the ArrayBuffer is shared across main thread and pool workers\r\n    });\r\n}\r\n"]}