{"version":3,"file":"copyTextureToTexture.js","sourceRoot":"","sources":["../../../../dev/core/src/Misc/copyTextureToTexture.ts"],"names":[],"mappings":"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","sourcesContent":["import type { AbstractEngine } from \"core/Engines/abstractEngine\";\r\nimport type { InternalTexture } from \"../Materials/Textures/internalTexture\";\r\nimport { EffectRenderer, EffectWrapper } from \"../Materials/effectRenderer\";\r\nimport type { IRenderTargetTexture, RenderTargetWrapper } from \"../Engines/renderTargetWrapper\";\r\nimport type { ThinTexture } from \"../Materials/Textures/thinTexture\";\r\nimport { Constants } from \"core/Engines/constants\";\r\nimport type { Nullable } from \"core/types\";\r\n\r\nimport { ShaderLanguage } from \"core/Materials/shaderLanguage\";\r\n\r\n/**\r\n * Conversion modes available when copying a texture into another one\r\n */\r\nexport const enum ConversionMode {\r\n    None = 0,\r\n    ToLinearSpace = 1,\r\n    ToGammaSpace = 2,\r\n}\r\n\r\n/**\r\n * Class used for fast copy from one texture to another\r\n */\r\nexport class CopyTextureToTexture {\r\n    private _engine: AbstractEngine;\r\n    private _isDepthTexture: boolean;\r\n    private _renderer: EffectRenderer;\r\n    private _effectWrapper: EffectWrapper;\r\n    private _source: InternalTexture | ThinTexture;\r\n    private _conversion: number;\r\n\r\n    /** Shader language used */\r\n    protected _shaderLanguage = ShaderLanguage.GLSL;\r\n\r\n    /**\r\n     * Gets the shader language\r\n     */\r\n    public get shaderLanguage(): ShaderLanguage {\r\n        return this._shaderLanguage;\r\n    }\r\n\r\n    private _textureIsInternal(texture: InternalTexture | ThinTexture): texture is InternalTexture {\r\n        return (texture as ThinTexture).getInternalTexture === undefined;\r\n    }\r\n\r\n    /**\r\n     * Constructs a new instance of the class\r\n     * @param engine The engine to use for the copy\r\n     * @param isDepthTexture True means that we should write (using gl_FragDepth) into the depth texture attached to the destination (default: false)\r\n     */\r\n    constructor(engine: AbstractEngine, isDepthTexture = false) {\r\n        this._engine = engine;\r\n        this._isDepthTexture = isDepthTexture;\r\n\r\n        this._renderer = new EffectRenderer(engine);\r\n\r\n        this._initShaderSourceAsync(isDepthTexture);\r\n    }\r\n\r\n    private _shadersLoaded = false;\r\n    private async _initShaderSourceAsync(isDepthTexture: boolean) {\r\n        const engine = this._engine;\r\n\r\n        if (engine.isWebGPU) {\r\n            this._shaderLanguage = ShaderLanguage.WGSL;\r\n\r\n            await import(\"../ShadersWGSL/copyTextureToTexture.fragment\");\r\n        } else {\r\n            await import(\"../Shaders/copyTextureToTexture.fragment\");\r\n        }\r\n\r\n        this._shadersLoaded = true;\r\n\r\n        this._effectWrapper = new EffectWrapper({\r\n            engine: engine,\r\n            name: \"CopyTextureToTexture\",\r\n            fragmentShader: \"copyTextureToTexture\",\r\n            useShaderStore: true,\r\n            uniformNames: [\"conversion\"],\r\n            samplerNames: [\"textureSampler\"],\r\n            defines: isDepthTexture ? [\"#define DEPTH_TEXTURE\"] : [],\r\n            shaderLanguage: this._shaderLanguage,\r\n        });\r\n\r\n        this._effectWrapper.onApplyObservable.add(() => {\r\n            if (isDepthTexture) {\r\n                engine.setState(false);\r\n                engine.setDepthBuffer(true);\r\n                engine.depthCullingState.depthMask = true;\r\n                engine.depthCullingState.depthFunc = Constants.ALWAYS;\r\n            } else {\r\n                engine.depthCullingState.depthMask = false;\r\n                // other states are already set by EffectRenderer.applyEffectWrapper\r\n            }\r\n\r\n            if (this._textureIsInternal(this._source)) {\r\n                this._effectWrapper.effect._bindTexture(\"textureSampler\", this._source);\r\n            } else {\r\n                this._effectWrapper.effect.setTexture(\"textureSampler\", this._source);\r\n            }\r\n            this._effectWrapper.effect.setFloat(\"conversion\", this._conversion);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Indicates if the effect is ready to be used for the copy\r\n     * @returns true if \"copy\" can be called without delay, else false\r\n     */\r\n    public isReady(): boolean {\r\n        return this._shadersLoaded && !!this._effectWrapper?.effect?.isReady();\r\n    }\r\n\r\n    /**\r\n     * Copy one texture into another\r\n     * @param source The source texture\r\n     * @param destination The destination texture. If null, copy the source to the currently bound framebuffer\r\n     * @param conversion The conversion mode that should be applied when copying\r\n     * @returns\r\n     */\r\n    public copy(source: InternalTexture | ThinTexture, destination: Nullable<RenderTargetWrapper | IRenderTargetTexture> = null, conversion = ConversionMode.None): boolean {\r\n        if (!this.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        this._source = source;\r\n        this._conversion = conversion;\r\n\r\n        const engineDepthFunc = this._engine.getDepthFunction();\r\n        const engineDepthMask = this._engine.getDepthWrite(); // for some reasons, depthWrite is not restored by EffectRenderer.restoreStates\r\n\r\n        this._renderer.render(this._effectWrapper, destination);\r\n\r\n        this._engine.setDepthWrite(engineDepthMask);\r\n\r\n        if (this._isDepthTexture && engineDepthFunc) {\r\n            this._engine.setDepthFunction(engineDepthFunc);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Releases all the resources used by the class\r\n     */\r\n    public dispose(): void {\r\n        this._effectWrapper?.dispose();\r\n        this._renderer.dispose();\r\n    }\r\n}\r\n"]}