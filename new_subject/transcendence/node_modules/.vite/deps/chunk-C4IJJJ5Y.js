import {
  DataBuffer
} from "./chunk-I2PO3XEU.js";
import {
  Logger
} from "./chunk-OJJXGLTO.js";

// node_modules/@babylonjs/core/Buffers/bufferUtils.js
function GetFloatValue(dataView, type, byteOffset, normalized) {
  switch (type) {
    case 5120: {
      let value = dataView.getInt8(byteOffset);
      if (normalized) {
        value = Math.max(value / 127, -1);
      }
      return value;
    }
    case 5121: {
      let value = dataView.getUint8(byteOffset);
      if (normalized) {
        value = value / 255;
      }
      return value;
    }
    case 5122: {
      let value = dataView.getInt16(byteOffset, true);
      if (normalized) {
        value = Math.max(value / 32767, -1);
      }
      return value;
    }
    case 5123: {
      let value = dataView.getUint16(byteOffset, true);
      if (normalized) {
        value = value / 65535;
      }
      return value;
    }
    case 5124: {
      return dataView.getInt32(byteOffset, true);
    }
    case 5125: {
      return dataView.getUint32(byteOffset, true);
    }
    case 5126: {
      return dataView.getFloat32(byteOffset, true);
    }
    default: {
      throw new Error(`Invalid component type ${type}`);
    }
  }
}
function SetFloatValue(dataView, type, byteOffset, normalized, value) {
  switch (type) {
    case 5120: {
      if (normalized) {
        value = Math.round(value * 127);
      }
      dataView.setInt8(byteOffset, value);
      break;
    }
    case 5121: {
      if (normalized) {
        value = Math.round(value * 255);
      }
      dataView.setUint8(byteOffset, value);
      break;
    }
    case 5122: {
      if (normalized) {
        value = Math.round(value * 32767);
      }
      dataView.setInt16(byteOffset, value, true);
      break;
    }
    case 5123: {
      if (normalized) {
        value = Math.round(value * 65535);
      }
      dataView.setUint16(byteOffset, value, true);
      break;
    }
    case 5124: {
      dataView.setInt32(byteOffset, value, true);
      break;
    }
    case 5125: {
      dataView.setUint32(byteOffset, value, true);
      break;
    }
    case 5126: {
      dataView.setFloat32(byteOffset, value, true);
      break;
    }
    default: {
      throw new Error(`Invalid component type ${type}`);
    }
  }
}
function GetTypeByteLength(type) {
  switch (type) {
    case 5120:
    case 5121:
      return 1;
    case 5122:
    case 5123:
      return 2;
    case 5124:
    case 5125:
    case 5126:
      return 4;
    default:
      throw new Error(`Invalid type '${type}'`);
  }
}
function GetTypedArrayConstructor(componentType) {
  switch (componentType) {
    case 5120:
      return Int8Array;
    case 5121:
      return Uint8Array;
    case 5122:
      return Int16Array;
    case 5123:
      return Uint16Array;
    case 5124:
      return Int32Array;
    case 5125:
      return Uint32Array;
    case 5126:
      return Float32Array;
    default:
      throw new Error(`Invalid component type '${componentType}'`);
  }
}
function EnumerateFloatValues(data, byteOffset, byteStride, componentCount, componentType, count, normalized, callback) {
  const oldValues = new Array(componentCount);
  const newValues = new Array(componentCount);
  if (data instanceof Array) {
    let offset = byteOffset / 4;
    const stride = byteStride / 4;
    for (let index = 0; index < count; index += componentCount) {
      for (let componentIndex = 0; componentIndex < componentCount; componentIndex++) {
        oldValues[componentIndex] = newValues[componentIndex] = data[offset + componentIndex];
      }
      callback(newValues, index);
      for (let componentIndex = 0; componentIndex < componentCount; componentIndex++) {
        if (oldValues[componentIndex] !== newValues[componentIndex]) {
          data[offset + componentIndex] = newValues[componentIndex];
        }
      }
      offset += stride;
    }
  } else {
    const dataView = !ArrayBuffer.isView(data) ? new DataView(data) : new DataView(data.buffer, data.byteOffset, data.byteLength);
    const componentByteLength = GetTypeByteLength(componentType);
    for (let index = 0; index < count; index += componentCount) {
      for (let componentIndex = 0, componentByteOffset = byteOffset; componentIndex < componentCount; componentIndex++, componentByteOffset += componentByteLength) {
        oldValues[componentIndex] = newValues[componentIndex] = GetFloatValue(dataView, componentType, componentByteOffset, normalized);
      }
      callback(newValues, index);
      for (let componentIndex = 0, componentByteOffset = byteOffset; componentIndex < componentCount; componentIndex++, componentByteOffset += componentByteLength) {
        if (oldValues[componentIndex] !== newValues[componentIndex]) {
          SetFloatValue(dataView, componentType, componentByteOffset, normalized, newValues[componentIndex]);
        }
      }
      byteOffset += byteStride;
    }
  }
}
function GetFloatData(data, size, type, byteOffset, byteStride, normalized, totalVertices, forceCopy) {
  const tightlyPackedByteStride = size * GetTypeByteLength(type);
  const count = totalVertices * size;
  if (type !== 5126 || byteStride !== tightlyPackedByteStride) {
    const copy = new Float32Array(count);
    EnumerateFloatValues(data, byteOffset, byteStride, size, type, count, normalized, (values, index) => {
      for (let i = 0; i < size; i++) {
        copy[index + i] = values[i];
      }
    });
    return copy;
  }
  if (!(data instanceof Array || data instanceof Float32Array) || byteOffset !== 0 || data.length !== count) {
    if (data instanceof Array) {
      const offset = byteOffset / 4;
      return data.slice(offset, offset + count);
    } else if (data instanceof ArrayBuffer) {
      return new Float32Array(data, byteOffset, count);
    } else {
      const offset = data.byteOffset + byteOffset;
      if ((offset & 3) !== 0) {
        Logger.Warn("Float array must be aligned to 4-bytes border");
        forceCopy = true;
      }
      if (forceCopy) {
        return new Float32Array(data.buffer.slice(offset, offset + count * Float32Array.BYTES_PER_ELEMENT));
      } else {
        return new Float32Array(data.buffer, offset, count);
      }
    }
  }
  if (forceCopy) {
    return data.slice();
  }
  return data;
}
function GetTypedArrayData(data, size, type, byteOffset, byteStride, normalized, totalVertices, forceCopy) {
  const typeByteLength = GetTypeByteLength(type);
  const constructor = GetTypedArrayConstructor(type);
  const count = totalVertices * size;
  if (Array.isArray(data)) {
    if ((byteOffset & 3) !== 0 || (byteStride & 3) !== 0) {
      throw new Error("byteOffset and byteStride must be a multiple of 4 for number[] data.");
    }
    const offset = byteOffset / 4;
    const stride = byteStride / 4;
    const lastIndex = offset + (totalVertices - 1) * stride + size;
    if (lastIndex > data.length) {
      throw new Error("Last accessed index is out of bounds.");
    }
    if (stride < size) {
      throw new Error("Data stride cannot be smaller than the component size.");
    }
    if (stride !== size) {
      const copy = new constructor(count);
      EnumerateFloatValues(data, byteOffset, byteStride, size, type, count, normalized, (values, index) => {
        for (let i = 0; i < size; i++) {
          copy[index + i] = values[i];
        }
      });
      return copy;
    }
    return new constructor(data.slice(offset, offset + count));
  }
  let buffer;
  let adjustedByteOffset = byteOffset;
  if (data instanceof ArrayBuffer) {
    buffer = data;
  } else {
    buffer = data.buffer;
    adjustedByteOffset += data.byteOffset;
  }
  const lastByteOffset = adjustedByteOffset + (totalVertices - 1) * byteStride + size * typeByteLength;
  if (lastByteOffset > buffer.byteLength) {
    throw new Error("Last accessed byte is out of bounds.");
  }
  const tightlyPackedByteStride = size * typeByteLength;
  if (byteStride < tightlyPackedByteStride) {
    throw new Error("Byte stride cannot be smaller than the component's byte size.");
  }
  if (byteStride !== tightlyPackedByteStride) {
    const copy = new constructor(count);
    EnumerateFloatValues(buffer, adjustedByteOffset, byteStride, size, type, count, normalized, (values, index) => {
      for (let i = 0; i < size; i++) {
        copy[index + i] = values[i];
      }
    });
    return copy;
  }
  if (typeByteLength !== 1 && (adjustedByteOffset & typeByteLength - 1) !== 0) {
    Logger.Warn("Array must be aligned to border of element size. Data will be copied.");
    forceCopy = true;
  }
  if (forceCopy) {
    return new constructor(buffer.slice(adjustedByteOffset, adjustedByteOffset + count * typeByteLength));
  }
  return new constructor(buffer, adjustedByteOffset, count);
}
function CopyFloatData(input, size, type, byteOffset, byteStride, normalized, totalVertices, output) {
  const tightlyPackedByteStride = size * GetTypeByteLength(type);
  const count = totalVertices * size;
  if (output.length !== count) {
    throw new Error("Output length is not valid");
  }
  if (type !== 5126 || byteStride !== tightlyPackedByteStride) {
    EnumerateFloatValues(input, byteOffset, byteStride, size, type, count, normalized, (values, index) => {
      for (let i = 0; i < size; i++) {
        output[index + i] = values[i];
      }
    });
    return;
  }
  if (input instanceof Array) {
    const offset = byteOffset / 4;
    output.set(input, offset);
  } else if (input instanceof ArrayBuffer) {
    const floatData = new Float32Array(input, byteOffset, count);
    output.set(floatData);
  } else {
    const offset = input.byteOffset + byteOffset;
    if ((offset & 3) !== 0) {
      Logger.Warn("Float array must be aligned to 4-bytes border");
      output.set(new Float32Array(input.buffer.slice(offset, offset + count * Float32Array.BYTES_PER_ELEMENT)));
      return;
    }
    const floatData = new Float32Array(input.buffer, offset, count);
    output.set(floatData);
  }
}
function AreIndices32Bits(indices, count) {
  if (indices) {
    if (indices instanceof Array) {
      return indices.some((value) => value >= 65536);
    }
    return indices.BYTES_PER_ELEMENT === 4;
  }
  return count >= 65536;
}

// node_modules/@babylonjs/core/Buffers/buffer.js
var Buffer = class {
  /**
   * Gets a boolean indicating if the Buffer is disposed
   */
  get isDisposed() {
    return this._isDisposed;
  }
  /**
   * Constructor
   * @param engine the engine
   * @param data the data to use for this buffer
   * @param updatable whether the data is updatable
   * @param stride the stride (optional)
   * @param postponeInternalCreation whether to postpone creating the internal WebGL buffer (optional)
   * @param instanced whether the buffer is instanced (optional)
   * @param useBytes set to true if the stride in in bytes (optional)
   * @param divisor sets an optional divisor for instances (1 by default)
   * @param label defines the label of the buffer (for debug purpose)
   */
  constructor(engine, data, updatable, stride = 0, postponeInternalCreation = false, instanced = false, useBytes = false, divisor, label) {
    this._isAlreadyOwned = false;
    this._isDisposed = false;
    if (engine && engine.getScene) {
      this._engine = engine.getScene().getEngine();
    } else {
      this._engine = engine;
    }
    this._updatable = updatable;
    this._instanced = instanced;
    this._divisor = divisor || 1;
    this._label = label;
    if (data instanceof DataBuffer) {
      this._data = null;
      this._buffer = data;
    } else {
      this._data = data;
      this._buffer = null;
    }
    this.byteStride = useBytes ? stride : stride * Float32Array.BYTES_PER_ELEMENT;
    if (!postponeInternalCreation) {
      this.create();
    }
  }
  /**
   * Create a new VertexBuffer based on the current buffer
   * @param kind defines the vertex buffer kind (position, normal, etc.)
   * @param offset defines offset in the buffer (0 by default)
   * @param size defines the size in floats of attributes (position is 3 for instance)
   * @param stride defines the stride size in floats in the buffer (the offset to apply to reach next value when data is interleaved)
   * @param instanced defines if the vertex buffer contains indexed data
   * @param useBytes defines if the offset and stride are in bytes     *
   * @param divisor sets an optional divisor for instances (1 by default)
   * @returns the new vertex buffer
   */
  createVertexBuffer(kind, offset, size, stride, instanced, useBytes = false, divisor) {
    const byteOffset = useBytes ? offset : offset * Float32Array.BYTES_PER_ELEMENT;
    const byteStride = stride ? useBytes ? stride : stride * Float32Array.BYTES_PER_ELEMENT : this.byteStride;
    return new VertexBuffer(this._engine, this, kind, this._updatable, true, byteStride, instanced === void 0 ? this._instanced : instanced, byteOffset, size, void 0, void 0, true, this._divisor || divisor);
  }
  // Properties
  /**
   * Gets a boolean indicating if the Buffer is updatable?
   * @returns true if the buffer is updatable
   */
  isUpdatable() {
    return this._updatable;
  }
  /**
   * Gets current buffer's data
   * @returns a DataArray or null
   */
  getData() {
    return this._data;
  }
  /**
   * Gets underlying native buffer
   * @returns underlying native buffer
   */
  getBuffer() {
    return this._buffer;
  }
  /**
   * Gets the stride in float32 units (i.e. byte stride / 4).
   * May not be an integer if the byte stride is not divisible by 4.
   * @returns the stride in float32 units
   * @deprecated Please use byteStride instead.
   */
  getStrideSize() {
    return this.byteStride / Float32Array.BYTES_PER_ELEMENT;
  }
  // Methods
  /**
   * Store data into the buffer. Creates the buffer if not used already.
   * If the buffer was already used, it will be updated only if it is updatable, otherwise it will do nothing.
   * @param data defines the data to store
   */
  create(data = null) {
    if (!data && this._buffer) {
      return;
    }
    data = data || this._data;
    if (!data) {
      return;
    }
    if (!this._buffer) {
      if (this._updatable) {
        this._buffer = this._engine.createDynamicVertexBuffer(data, this._label);
        this._data = data;
      } else {
        this._buffer = this._engine.createVertexBuffer(data, void 0, this._label);
      }
    } else if (this._updatable) {
      this._engine.updateDynamicVertexBuffer(this._buffer, data);
      this._data = data;
    }
  }
  /** @internal */
  _rebuild() {
    if (!this._data) {
      if (!this._buffer) {
        return;
      }
      if (this._buffer.capacity > 0) {
        if (this._updatable) {
          this._buffer = this._engine.createDynamicVertexBuffer(this._buffer.capacity, this._label);
        } else {
          this._buffer = this._engine.createVertexBuffer(this._buffer.capacity, void 0, this._label);
        }
        return;
      }
      Logger.Warn(`Missing data for buffer "${this._label}" ${this._buffer ? "(uniqueId: " + this._buffer.uniqueId + ")" : ""}. Buffer reconstruction failed.`);
      this._buffer = null;
    } else {
      this._buffer = null;
      this.create(this._data);
    }
  }
  /**
   * Update current buffer data
   * @param data defines the data to store
   */
  update(data) {
    this.create(data);
  }
  /**
   * Updates the data directly.
   * @param data the new data
   * @param offset the new offset
   * @param vertexCount the vertex count (optional)
   * @param useBytes set to true if the offset is in bytes
   */
  updateDirectly(data, offset, vertexCount, useBytes = false) {
    if (!this._buffer) {
      return;
    }
    if (this._updatable) {
      this._engine.updateDynamicVertexBuffer(this._buffer, data, useBytes ? offset : offset * Float32Array.BYTES_PER_ELEMENT, vertexCount ? vertexCount * this.byteStride : void 0);
      if (offset === 0 && vertexCount === void 0) {
        this._data = data;
      } else {
        this._data = null;
      }
    }
  }
  /** @internal */
  _increaseReferences() {
    if (!this._buffer) {
      return;
    }
    if (!this._isAlreadyOwned) {
      this._isAlreadyOwned = true;
      return;
    }
    this._buffer.references++;
  }
  /**
   * Release all resources
   */
  dispose() {
    if (!this._buffer) {
      return;
    }
    if (this._engine._releaseBuffer(this._buffer)) {
      this._isDisposed = true;
      this._data = null;
      this._buffer = null;
    }
  }
};
var VertexBuffer = class _VertexBuffer {
  /**
   * Gets a boolean indicating if the Buffer is disposed
   */
  get isDisposed() {
    return this._isDisposed;
  }
  /**
   * Gets or sets the instance divisor when in instanced mode
   */
  get instanceDivisor() {
    return this._instanceDivisor;
  }
  set instanceDivisor(value) {
    const isInstanced = value != 0;
    this._instanceDivisor = value;
    if (isInstanced !== this._instanced) {
      this._instanced = isInstanced;
      this._computeHashCode();
    }
  }
  /**
   * Gets the max possible amount of vertices stored within the current vertex buffer.
   * We do not have the end offset or count so this will be too big for concatenated vertex buffers.
   * @internal
   */
  get _maxVerticesCount() {
    const data = this.getData();
    if (!data) {
      return 0;
    }
    if (Array.isArray(data)) {
      return data.length / (this.byteStride / 4) - this.byteOffset / 4;
    }
    return (data.byteLength - this.byteOffset) / this.byteStride;
  }
  /** @internal */
  constructor(engine, data, kind, updatableOrOptions, postponeInternalCreation, stride, instanced, offset, size, type, normalized = false, useBytes = false, divisor = 1, takeBufferOwnership = false) {
    this._isDisposed = false;
    let updatable = false;
    this.engine = engine;
    if (typeof updatableOrOptions === "object" && updatableOrOptions !== null) {
      updatable = updatableOrOptions.updatable ?? false;
      postponeInternalCreation = updatableOrOptions.postponeInternalCreation;
      stride = updatableOrOptions.stride;
      instanced = updatableOrOptions.instanced;
      offset = updatableOrOptions.offset;
      size = updatableOrOptions.size;
      type = updatableOrOptions.type;
      normalized = updatableOrOptions.normalized ?? false;
      useBytes = updatableOrOptions.useBytes ?? false;
      divisor = updatableOrOptions.divisor ?? 1;
      takeBufferOwnership = updatableOrOptions.takeBufferOwnership ?? false;
      this._label = updatableOrOptions.label;
    } else {
      updatable = !!updatableOrOptions;
    }
    if (data instanceof Buffer) {
      this._buffer = data;
      this._ownsBuffer = takeBufferOwnership;
    } else {
      this._buffer = new Buffer(engine, data, updatable, stride, postponeInternalCreation, instanced, useBytes, divisor, this._label);
      this._ownsBuffer = true;
    }
    this.uniqueId = _VertexBuffer._Counter++;
    this._kind = kind;
    if (type === void 0) {
      const vertexData = this.getData();
      this.type = vertexData ? _VertexBuffer.GetDataType(vertexData) : _VertexBuffer.FLOAT;
    } else {
      this.type = type;
    }
    const typeByteLength = GetTypeByteLength(this.type);
    if (useBytes) {
      this._size = size || (stride ? stride / typeByteLength : _VertexBuffer.DeduceStride(kind));
      this.byteStride = stride || this._buffer.byteStride || this._size * typeByteLength;
      this.byteOffset = offset || 0;
    } else {
      this._size = size || stride || _VertexBuffer.DeduceStride(kind);
      this.byteStride = stride ? stride * typeByteLength : this._buffer.byteStride || this._size * typeByteLength;
      this.byteOffset = (offset || 0) * typeByteLength;
    }
    this.normalized = normalized;
    this._instanced = instanced !== void 0 ? instanced : false;
    this._instanceDivisor = instanced ? divisor : 0;
    this._alignBuffer();
    this._computeHashCode();
  }
  _computeHashCode() {
    this.hashCode = (this.type - 5120 << 0) + ((this.normalized ? 1 : 0) << 3) + (this._size << 4) + ((this._instanced ? 1 : 0) << 6) + /* keep 5 bits free */
    (this.byteStride << 12);
  }
  /** @internal */
  _rebuild() {
    var _a;
    (_a = this._buffer) == null ? void 0 : _a._rebuild();
  }
  /**
   * Returns the kind of the VertexBuffer (string)
   * @returns a string
   */
  getKind() {
    return this._kind;
  }
  // Properties
  /**
   * Gets a boolean indicating if the VertexBuffer is updatable?
   * @returns true if the buffer is updatable
   */
  isUpdatable() {
    return this._buffer.isUpdatable();
  }
  /**
   * Gets current buffer's data
   * @returns a DataArray or null
   */
  getData() {
    return this._buffer.getData();
  }
  /**
   * Gets current buffer's data as a float array. Float data is constructed if the vertex buffer data cannot be returned directly.
   * @param totalVertices number of vertices in the buffer to take into account
   * @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it
   * @returns a float array containing vertex data
   */
  getFloatData(totalVertices, forceCopy) {
    const data = this.getData();
    if (!data) {
      return null;
    }
    return GetFloatData(data, this._size, this.type, this.byteOffset, this.byteStride, this.normalized, totalVertices, forceCopy);
  }
  /**
   * Gets underlying native buffer
   * @returns underlying native buffer
   */
  getBuffer() {
    return this._buffer.getBuffer();
  }
  /**
   * Gets the Buffer instance that wraps the native GPU buffer
   * @returns the wrapper buffer
   */
  getWrapperBuffer() {
    return this._buffer;
  }
  /**
   * Gets the stride in float32 units (i.e. byte stride / 4).
   * May not be an integer if the byte stride is not divisible by 4.
   * @returns the stride in float32 units
   * @deprecated Please use byteStride instead.
   */
  getStrideSize() {
    return this.byteStride / GetTypeByteLength(this.type);
  }
  /**
   * Returns the offset as a multiple of the type byte length.
   * @returns the offset in bytes
   * @deprecated Please use byteOffset instead.
   */
  getOffset() {
    return this.byteOffset / GetTypeByteLength(this.type);
  }
  /**
   * Returns the number of components or the byte size per vertex attribute
   * @param sizeInBytes If true, returns the size in bytes or else the size in number of components of the vertex attribute (default: false)
   * @returns the number of components
   */
  getSize(sizeInBytes = false) {
    return sizeInBytes ? this._size * GetTypeByteLength(this.type) : this._size;
  }
  /**
   * Gets a boolean indicating is the internal buffer of the VertexBuffer is instanced
   * @returns true if this buffer is instanced
   */
  getIsInstanced() {
    return this._instanced;
  }
  /**
   * Returns the instancing divisor, zero for non-instanced (integer).
   * @returns a number
   */
  getInstanceDivisor() {
    return this._instanceDivisor;
  }
  // Methods
  /**
   * Store data into the buffer. If the buffer was already used it will be either recreated or updated depending on isUpdatable property
   * @param data defines the data to store
   */
  create(data) {
    this._buffer.create(data);
    this._alignBuffer();
  }
  /**
   * Updates the underlying buffer according to the passed numeric array or Float32Array.
   * This function will create a new buffer if the current one is not updatable
   * @param data defines the data to store
   */
  update(data) {
    this._buffer.update(data);
    this._alignBuffer();
  }
  /**
   * Updates directly the underlying WebGLBuffer according to the passed numeric array or Float32Array.
   * Returns the directly updated WebGLBuffer.
   * @param data the new data
   * @param offset the new offset
   * @param useBytes set to true if the offset is in bytes
   */
  updateDirectly(data, offset, useBytes = false) {
    this._buffer.updateDirectly(data, offset, void 0, useBytes);
    this._alignBuffer();
  }
  /**
   * Disposes the VertexBuffer and the underlying WebGLBuffer.
   */
  dispose() {
    if (this._ownsBuffer) {
      this._buffer.dispose();
    }
    this._isDisposed = true;
  }
  /**
   * Enumerates each value of this vertex buffer as numbers.
   * @param count the number of values to enumerate
   * @param callback the callback function called for each value
   */
  forEach(count, callback) {
    EnumerateFloatValues(this._buffer.getData(), this.byteOffset, this.byteStride, this._size, this.type, count, this.normalized, (values, index) => {
      for (let i = 0; i < this._size; i++) {
        callback(values[i], index + i);
      }
    });
  }
  /** @internal */
  _alignBuffer() {
  }
  /**
   * Deduces the stride given a kind.
   * @param kind The kind string to deduce
   * @returns The deduced stride
   */
  static DeduceStride(kind) {
    switch (kind) {
      case _VertexBuffer.UVKind:
      case _VertexBuffer.UV2Kind:
      case _VertexBuffer.UV3Kind:
      case _VertexBuffer.UV4Kind:
      case _VertexBuffer.UV5Kind:
      case _VertexBuffer.UV6Kind:
        return 2;
      case _VertexBuffer.NormalKind:
      case _VertexBuffer.PositionKind:
        return 3;
      case _VertexBuffer.ColorKind:
      case _VertexBuffer.ColorInstanceKind:
      case _VertexBuffer.MatricesIndicesKind:
      case _VertexBuffer.MatricesIndicesExtraKind:
      case _VertexBuffer.MatricesWeightsKind:
      case _VertexBuffer.MatricesWeightsExtraKind:
      case _VertexBuffer.TangentKind:
        return 4;
      default:
        throw new Error("Invalid kind '" + kind + "'");
    }
  }
  /**
   * Gets the vertex buffer type of the given data array.
   * @param data the data array
   * @returns the vertex buffer type
   */
  static GetDataType(data) {
    if (data instanceof Int8Array) {
      return _VertexBuffer.BYTE;
    } else if (data instanceof Uint8Array) {
      return _VertexBuffer.UNSIGNED_BYTE;
    } else if (data instanceof Int16Array) {
      return _VertexBuffer.SHORT;
    } else if (data instanceof Uint16Array) {
      return _VertexBuffer.UNSIGNED_SHORT;
    } else if (data instanceof Int32Array) {
      return _VertexBuffer.INT;
    } else if (data instanceof Uint32Array) {
      return _VertexBuffer.UNSIGNED_INT;
    } else {
      return _VertexBuffer.FLOAT;
    }
  }
  /**
   * Gets the byte length of the given type.
   * @param type the type
   * @returns the number of bytes
   * @deprecated Use `getTypeByteLength` from `bufferUtils` instead
   */
  static GetTypeByteLength(type) {
    return GetTypeByteLength(type);
  }
  /**
   * Enumerates each value of the given parameters as numbers.
   * @param data the data to enumerate
   * @param byteOffset the byte offset of the data
   * @param byteStride the byte stride of the data
   * @param componentCount the number of components per element
   * @param componentType the type of the component
   * @param count the number of values to enumerate
   * @param normalized whether the data is normalized
   * @param callback the callback function called for each value
   * @deprecated Use `EnumerateFloatValues` from `bufferUtils` instead
   */
  static ForEach(data, byteOffset, byteStride, componentCount, componentType, count, normalized, callback) {
    EnumerateFloatValues(data, byteOffset, byteStride, componentCount, componentType, count, normalized, (values, index) => {
      for (let componentIndex = 0; componentIndex < componentCount; componentIndex++) {
        callback(values[componentIndex], index + componentIndex);
      }
    });
  }
  /**
   * Gets the given data array as a float array. Float data is constructed if the data array cannot be returned directly.
   * @param data the input data array
   * @param size the number of components
   * @param type the component type
   * @param byteOffset the byte offset of the data
   * @param byteStride the byte stride of the data
   * @param normalized whether the data is normalized
   * @param totalVertices number of vertices in the buffer to take into account
   * @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it
   * @returns a float array containing vertex data
   * @deprecated Use `GetFloatData` from `bufferUtils` instead
   */
  static GetFloatData(data, size, type, byteOffset, byteStride, normalized, totalVertices, forceCopy) {
    return GetFloatData(data, size, type, byteOffset, byteStride, normalized, totalVertices, forceCopy);
  }
};
VertexBuffer._Counter = 0;
VertexBuffer.BYTE = 5120;
VertexBuffer.UNSIGNED_BYTE = 5121;
VertexBuffer.SHORT = 5122;
VertexBuffer.UNSIGNED_SHORT = 5123;
VertexBuffer.INT = 5124;
VertexBuffer.UNSIGNED_INT = 5125;
VertexBuffer.FLOAT = 5126;
VertexBuffer.PositionKind = `position`;
VertexBuffer.NormalKind = `normal`;
VertexBuffer.TangentKind = `tangent`;
VertexBuffer.UVKind = `uv`;
VertexBuffer.UV2Kind = `uv2`;
VertexBuffer.UV3Kind = `uv3`;
VertexBuffer.UV4Kind = `uv4`;
VertexBuffer.UV5Kind = `uv5`;
VertexBuffer.UV6Kind = `uv6`;
VertexBuffer.ColorKind = `color`;
VertexBuffer.ColorInstanceKind = `instanceColor`;
VertexBuffer.MatricesIndicesKind = `matricesIndices`;
VertexBuffer.MatricesWeightsKind = `matricesWeights`;
VertexBuffer.MatricesIndicesExtraKind = `matricesIndicesExtra`;
VertexBuffer.MatricesWeightsExtraKind = `matricesWeightsExtra`;

export {
  GetTypeByteLength,
  GetTypedArrayConstructor,
  EnumerateFloatValues,
  GetFloatData,
  GetTypedArrayData,
  CopyFloatData,
  AreIndices32Bits,
  Buffer,
  VertexBuffer
};
//# sourceMappingURL=chunk-C4IJJJ5Y.js.map
