{"version":3,"file":"bufferUtils.js","sourceRoot":"","sources":["../../../../dev/core/src/Buffers/bufferUtils.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,SAAS,EAAE,MAAM,sBAAsB,CAAC;AACjD,OAAO,EAAE,MAAM,EAAE,MAAM,gBAAgB,CAAC;AAkBxC,SAAS,aAAa,CAAC,QAAkB,EAAE,IAAY,EAAE,UAAkB,EAAE,UAAmB;IAC5F,QAAQ,IAAI,EAAE,CAAC;QACX,KAAK,SAAS,CAAC,IAAI,CAAC,CAAC,CAAC;YAClB,IAAI,KAAK,GAAG,QAAQ,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC;YACzC,IAAI,UAAU,EAAE,CAAC;gBACb,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,GAAG,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC;YACtC,CAAC;YACD,OAAO,KAAK,CAAC;QACjB,CAAC;QACD,KAAK,SAAS,CAAC,aAAa,CAAC,CAAC,CAAC;YAC3B,IAAI,KAAK,GAAG,QAAQ,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC;YAC1C,IAAI,UAAU,EAAE,CAAC;gBACb,KAAK,GAAG,KAAK,GAAG,GAAG,CAAC;YACxB,CAAC;YACD,OAAO,KAAK,CAAC;QACjB,CAAC;QACD,KAAK,SAAS,CAAC,KAAK,CAAC,CAAC,CAAC;YACnB,IAAI,KAAK,GAAG,QAAQ,CAAC,QAAQ,CAAC,UAAU,EAAE,IAAI,CAAC,CAAC;YAChD,IAAI,UAAU,EAAE,CAAC;gBACb,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,GAAG,KAAK,EAAE,CAAC,CAAC,CAAC,CAAC;YACxC,CAAC;YACD,OAAO,KAAK,CAAC;QACjB,CAAC;QACD,KAAK,SAAS,CAAC,cAAc,CAAC,CAAC,CAAC;YAC5B,IAAI,KAAK,GAAG,QAAQ,CAAC,SAAS,CAAC,UAAU,EAAE,IAAI,CAAC,CAAC;YACjD,IAAI,UAAU,EAAE,CAAC;gBACb,KAAK,GAAG,KAAK,GAAG,KAAK,CAAC;YAC1B,CAAC;YACD,OAAO,KAAK,CAAC;QACjB,CAAC;QACD,KAAK,SAAS,CAAC,GAAG,CAAC,CAAC,CAAC;YACjB,OAAO,QAAQ,CAAC,QAAQ,CAAC,UAAU,EAAE,IAAI,CAAC,CAAC;QAC/C,CAAC;QACD,KAAK,SAAS,CAAC,YAAY,CAAC,CAAC,CAAC;YAC1B,OAAO,QAAQ,CAAC,SAAS,CAAC,UAAU,EAAE,IAAI,CAAC,CAAC;QAChD,CAAC;QACD,KAAK,SAAS,CAAC,KAAK,CAAC,CAAC,CAAC;YACnB,OAAO,QAAQ,CAAC,UAAU,CAAC,UAAU,EAAE,IAAI,CAAC,CAAC;QACjD,CAAC;QACD,OAAO,CAAC,CAAC,CAAC;YACN,MAAM,IAAI,KAAK,CAAC,0BAA0B,IAAI,EAAE,CAAC,CAAC;QACtD,CAAC;IACL,CAAC;AACL,CAAC;AAED,SAAS,aAAa,CAAC,QAAkB,EAAE,IAAY,EAAE,UAAkB,EAAE,UAAmB,EAAE,KAAa;IAC3G,QAAQ,IAAI,EAAE,CAAC;QACX,KAAK,SAAS,CAAC,IAAI,CAAC,CAAC,CAAC;YAClB,IAAI,UAAU,EAAE,CAAC;gBACb,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,GAAG,KAAK,CAAC,CAAC;YACtC,CAAC;YACD,QAAQ,CAAC,OAAO,CAAC,UAAU,EAAE,KAAK,CAAC,CAAC;YACpC,MAAM;QACV,CAAC;QACD,KAAK,SAAS,CAAC,aAAa,CAAC,CAAC,CAAC;YAC3B,IAAI,UAAU,EAAE,CAAC;gBACb,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,GAAG,GAAG,CAAC,CAAC;YACpC,CAAC;YACD,QAAQ,CAAC,QAAQ,CAAC,UAAU,EAAE,KAAK,CAAC,CAAC;YACrC,MAAM;QACV,CAAC;QACD,KAAK,SAAS,CAAC,KAAK,CAAC,CAAC,CAAC;YACnB,IAAI,UAAU,EAAE,CAAC;gBACb,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,GAAG,KAAK,CAAC,CAAC;YACtC,CAAC;YACD,QAAQ,CAAC,QAAQ,CAAC,UAAU,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC;YAC3C,MAAM;QACV,CAAC;QACD,KAAK,SAAS,CAAC,cAAc,CAAC,CAAC,CAAC;YAC5B,IAAI,UAAU,EAAE,CAAC;gBACb,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,GAAG,KAAK,CAAC,CAAC;YACtC,CAAC;YACD,QAAQ,CAAC,SAAS,CAAC,UAAU,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC;YAC5C,MAAM;QACV,CAAC;QACD,KAAK,SAAS,CAAC,GAAG,CAAC,CAAC,CAAC;YACjB,QAAQ,CAAC,QAAQ,CAAC,UAAU,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC;YAC3C,MAAM;QACV,CAAC;QACD,KAAK,SAAS,CAAC,YAAY,CAAC,CAAC,CAAC;YAC1B,QAAQ,CAAC,SAAS,CAAC,UAAU,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC;YAC5C,MAAM;QACV,CAAC;QACD,KAAK,SAAS,CAAC,KAAK,CAAC,CAAC,CAAC;YACnB,QAAQ,CAAC,UAAU,CAAC,UAAU,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC;YAC7C,MAAM;QACV,CAAC;QACD,OAAO,CAAC,CAAC,CAAC;YACN,MAAM,IAAI,KAAK,CAAC,0BAA0B,IAAI,EAAE,CAAC,CAAC;QACtD,CAAC;IACL,CAAC;AACL,CAAC;AAED;;;;GAIG;AACH,MAAM,UAAU,iBAAiB,CAAC,IAAY;IAC1C,QAAQ,IAAI,EAAE,CAAC;QACX,KAAK,SAAS,CAAC,IAAI,CAAC;QACpB,KAAK,SAAS,CAAC,aAAa;YACxB,OAAO,CAAC,CAAC;QACb,KAAK,SAAS,CAAC,KAAK,CAAC;QACrB,KAAK,SAAS,CAAC,cAAc;YACzB,OAAO,CAAC,CAAC;QACb,KAAK,SAAS,CAAC,GAAG,CAAC;QACnB,KAAK,SAAS,CAAC,YAAY,CAAC;QAC5B,KAAK,SAAS,CAAC,KAAK;YAChB,OAAO,CAAC,CAAC;QACb;YACI,MAAM,IAAI,KAAK,CAAC,iBAAiB,IAAI,GAAG,CAAC,CAAC;IAClD,CAAC;AACL,CAAC;AAED;;;;GAIG;AACH,MAAM,UAAU,wBAAwB,CAAC,aAAqB;IAC1D,QAAQ,aAAa,EAAE,CAAC;QACpB,KAAK,SAAS,CAAC,IAAI;YACf,OAAO,SAAS,CAAC;QACrB,KAAK,SAAS,CAAC,aAAa;YACxB,OAAO,UAAU,CAAC;QACtB,KAAK,SAAS,CAAC,KAAK;YAChB,OAAO,UAAU,CAAC;QACtB,KAAK,SAAS,CAAC,cAAc;YACzB,OAAO,WAAW,CAAC;QACvB,KAAK,SAAS,CAAC,GAAG;YACd,OAAO,UAAU,CAAC;QACtB,KAAK,SAAS,CAAC,YAAY;YACvB,OAAO,WAAW,CAAC;QACvB,KAAK,SAAS,CAAC,KAAK;YAChB,OAAO,YAAY,CAAC;QACxB;YACI,MAAM,IAAI,KAAK,CAAC,2BAA2B,aAAa,GAAG,CAAC,CAAC;IACrE,CAAC;AACL,CAAC;AAED;;;;;;;;;;GAUG;AACH,MAAM,UAAU,oBAAoB,CAChC,IAAe,EACf,UAAkB,EAClB,UAAkB,EAClB,cAAsB,EACtB,aAAqB,EACrB,KAAa,EACb,UAAmB,EACnB,QAAmD;IAEnD,MAAM,SAAS,GAAG,IAAI,KAAK,CAAS,cAAc,CAAC,CAAC;IACpD,MAAM,SAAS,GAAG,IAAI,KAAK,CAAS,cAAc,CAAC,CAAC;IAEpD,IAAI,IAAI,YAAY,KAAK,EAAE,CAAC;QACxB,IAAI,MAAM,GAAG,UAAU,GAAG,CAAC,CAAC;QAC5B,MAAM,MAAM,GAAG,UAAU,GAAG,CAAC,CAAC;QAC9B,KAAK,IAAI,KAAK,GAAG,CAAC,EAAE,KAAK,GAAG,KAAK,EAAE,KAAK,IAAI,cAAc,EAAE,CAAC;YACzD,KAAK,IAAI,cAAc,GAAG,CAAC,EAAE,cAAc,GAAG,cAAc,EAAE,cAAc,EAAE,EAAE,CAAC;gBAC7E,SAAS,CAAC,cAAc,CAAC,GAAG,SAAS,CAAC,cAAc,CAAC,GAAG,IAAI,CAAC,MAAM,GAAG,cAAc,CAAC,CAAC;YAC1F,CAAC;YAED,QAAQ,CAAC,SAAS,EAAE,KAAK,CAAC,CAAC;YAE3B,KAAK,IAAI,cAAc,GAAG,CAAC,EAAE,cAAc,GAAG,cAAc,EAAE,cAAc,EAAE,EAAE,CAAC;gBAC7E,IAAI,SAAS,CAAC,cAAc,CAAC,KAAK,SAAS,CAAC,cAAc,CAAC,EAAE,CAAC;oBAC1D,IAAI,CAAC,MAAM,GAAG,cAAc,CAAC,GAAG,SAAS,CAAC,cAAc,CAAC,CAAC;gBAC9D,CAAC;YACL,CAAC;YAED,MAAM,IAAI,MAAM,CAAC;QACrB,CAAC;IACL,CAAC;SAAM,CAAC;QACJ,MAAM,QAAQ,GAAG,CAAC,WAAW,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,IAAI,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,IAAI,QAAQ,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,UAAU,EAAE,IAAI,CAAC,UAAU,CAAC,CAAC;QAC9H,MAAM,mBAAmB,GAAG,iBAAiB,CAAC,aAAa,CAAC,CAAC;QAC7D,KAAK,IAAI,KAAK,GAAG,CAAC,EAAE,KAAK,GAAG,KAAK,EAAE,KAAK,IAAI,cAAc,EAAE,CAAC;YACzD,KAAK,IAAI,cAAc,GAAG,CAAC,EAAE,mBAAmB,GAAG,UAAU,EAAE,cAAc,GAAG,cAAc,EAAE,cAAc,EAAE,EAAE,mBAAmB,IAAI,mBAAmB,EAAE,CAAC;gBAC3J,SAAS,CAAC,cAAc,CAAC,GAAG,SAAS,CAAC,cAAc,CAAC,GAAG,aAAa,CAAC,QAAQ,EAAE,aAAa,EAAE,mBAAmB,EAAE,UAAU,CAAC,CAAC;YACpI,CAAC;YAED,QAAQ,CAAC,SAAS,EAAE,KAAK,CAAC,CAAC;YAE3B,KAAK,IAAI,cAAc,GAAG,CAAC,EAAE,mBAAmB,GAAG,UAAU,EAAE,cAAc,GAAG,cAAc,EAAE,cAAc,EAAE,EAAE,mBAAmB,IAAI,mBAAmB,EAAE,CAAC;gBAC3J,IAAI,SAAS,CAAC,cAAc,CAAC,KAAK,SAAS,CAAC,cAAc,CAAC,EAAE,CAAC;oBAC1D,aAAa,CAAC,QAAQ,EAAE,aAAa,EAAE,mBAAmB,EAAE,UAAU,EAAE,SAAS,CAAC,cAAc,CAAC,CAAC,CAAC;gBACvG,CAAC;YACL,CAAC;YAED,UAAU,IAAI,UAAU,CAAC;QAC7B,CAAC;IACL,CAAC;AACL,CAAC;AAED;;;;;;;;;;;GAWG;AACH,MAAM,UAAU,YAAY,CACxB,IAAe,EACf,IAAY,EACZ,IAAY,EACZ,UAAkB,EAClB,UAAkB,EAClB,UAAmB,EACnB,aAAqB,EACrB,SAAmB;IAEnB,MAAM,uBAAuB,GAAG,IAAI,GAAG,iBAAiB,CAAC,IAAI,CAAC,CAAC;IAC/D,MAAM,KAAK,GAAG,aAAa,GAAG,IAAI,CAAC;IAEnC,IAAI,IAAI,KAAK,SAAS,CAAC,KAAK,IAAI,UAAU,KAAK,uBAAuB,EAAE,CAAC;QACrE,MAAM,IAAI,GAAG,IAAI,YAAY,CAAC,KAAK,CAAC,CAAC;QACrC,oBAAoB,CAAC,IAAI,EAAE,UAAU,EAAE,UAAU,EAAE,IAAI,EAAE,IAAI,EAAE,KAAK,EAAE,UAAU,EAAE,CAAC,MAAM,EAAE,KAAK,EAAE,EAAE;YAChG,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,EAAE,CAAC,EAAE,EAAE,CAAC;gBAC5B,IAAI,CAAC,KAAK,GAAG,CAAC,CAAC,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;YAChC,CAAC;QACL,CAAC,CAAC,CAAC;QACH,OAAO,IAAI,CAAC;IAChB,CAAC;IAED,IAAI,CAAC,CAAC,IAAI,YAAY,KAAK,IAAI,IAAI,YAAY,YAAY,CAAC,IAAI,UAAU,KAAK,CAAC,IAAI,IAAI,CAAC,MAAM,KAAK,KAAK,EAAE,CAAC;QACxG,IAAI,IAAI,YAAY,KAAK,EAAE,CAAC;YACxB,MAAM,MAAM,GAAG,UAAU,GAAG,CAAC,CAAC;YAC9B,OAAO,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE,MAAM,GAAG,KAAK,CAAC,CAAC;QAC9C,CAAC;aAAM,IAAI,IAAI,YAAY,WAAW,EAAE,CAAC;YACrC,OAAO,IAAI,YAAY,CAAC,IAAI,EAAE,UAAU,EAAE,KAAK,CAAC,CAAC;QACrD,CAAC;aAAM,CAAC;YACJ,MAAM,MAAM,GAAG,IAAI,CAAC,UAAU,GAAG,UAAU,CAAC;YAC5C,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,KAAK,CAAC,EAAE,CAAC;gBACrB,MAAM,CAAC,IAAI,CAAC,+CAA+C,CAAC,CAAC;gBAC7D,SAAS,GAAG,IAAI,CAAC;YACrB,CAAC;YAED,IAAI,SAAS,EAAE,CAAC;gBACZ,OAAO,IAAI,YAAY,CAAC,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,MAAM,EAAE,MAAM,GAAG,KAAK,GAAG,YAAY,CAAC,iBAAiB,CAAC,CAAC,CAAC;YACxG,CAAC;iBAAM,CAAC;gBACJ,OAAO,IAAI,YAAY,CAAC,IAAI,CAAC,MAAM,EAAE,MAAM,EAAE,KAAK,CAAC,CAAC;YACxD,CAAC;QACL,CAAC;IACL,CAAC;IAED,IAAI,SAAS,EAAE,CAAC;QACZ,OAAO,IAAI,CAAC,KAAK,EAAE,CAAC;IACxB,CAAC;IAED,OAAO,IAAI,CAAC;AAChB,CAAC;AAED;;;;;;;;;;;;GAYG;AACH,MAAM,UAAU,iBAAiB,CAC7B,IAAe,EACf,IAAY,EACZ,IAAY,EACZ,UAAkB,EAClB,UAAkB,EAClB,UAAmB,EACnB,aAAqB,EACrB,SAAmB;IAEnB,MAAM,cAAc,GAAG,iBAAiB,CAAC,IAAI,CAAC,CAAC;IAC/C,MAAM,WAAW,GAAG,wBAAwB,CAAC,IAAI,CAAC,CAAC;IACnD,MAAM,KAAK,GAAG,aAAa,GAAG,IAAI,CAAC;IAEnC,kBAAkB;IAClB,IAAI,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE,CAAC;QACtB,IAAI,CAAC,UAAU,GAAG,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,UAAU,GAAG,CAAC,CAAC,KAAK,CAAC,EAAE,CAAC;YACnD,MAAM,IAAI,KAAK,CAAC,sEAAsE,CAAC,CAAC;QAC5F,CAAC;QAED,MAAM,MAAM,GAAG,UAAU,GAAG,CAAC,CAAC;QAC9B,MAAM,MAAM,GAAG,UAAU,GAAG,CAAC,CAAC;QAE9B,MAAM,SAAS,GAAG,MAAM,GAAG,CAAC,aAAa,GAAG,CAAC,CAAC,GAAG,MAAM,GAAG,IAAI,CAAC;QAC/D,IAAI,SAAS,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC;YAC1B,MAAM,IAAI,KAAK,CAAC,uCAAuC,CAAC,CAAC;QAC7D,CAAC;QAED,IAAI,MAAM,GAAG,IAAI,EAAE,CAAC;YAChB,MAAM,IAAI,KAAK,CAAC,wDAAwD,CAAC,CAAC;QAC9E,CAAC;QACD,IAAI,MAAM,KAAK,IAAI,EAAE,CAAC;YAClB,MAAM,IAAI,GAAG,IAAI,WAAW,CAAC,KAAK,CAAC,CAAC;YACpC,oBAAoB,CAAC,IAAI,EAAE,UAAU,EAAE,UAAU,EAAE,IAAI,EAAE,IAAI,EAAE,KAAK,EAAE,UAAU,EAAE,CAAC,MAAM,EAAE,KAAK,EAAE,EAAE;gBAChG,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,EAAE,CAAC,EAAE,EAAE,CAAC;oBAC5B,IAAI,CAAC,KAAK,GAAG,CAAC,CAAC,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;gBAChC,CAAC;YACL,CAAC,CAAC,CAAC;YACH,OAAO,IAAI,CAAC;QAChB,CAAC;QAED,OAAO,IAAI,WAAW,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE,MAAM,GAAG,KAAK,CAAC,CAAC,CAAC;IAC/D,CAAC;IAED,yCAAyC;IACzC,IAAI,MAAmB,CAAC;IACxB,IAAI,kBAAkB,GAAG,UAAU,CAAC;IAEpC,IAAI,IAAI,YAAY,WAAW,EAAE,CAAC;QAC9B,MAAM,GAAG,IAAI,CAAC;IAClB,CAAC;SAAM,CAAC;QACJ,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC;QACrB,kBAAkB,IAAI,IAAI,CAAC,UAAU,CAAC;IAC1C,CAAC;IAED,MAAM,cAAc,GAAG,kBAAkB,GAAG,CAAC,aAAa,GAAG,CAAC,CAAC,GAAG,UAAU,GAAG,IAAI,GAAG,cAAc,CAAC;IACrG,IAAI,cAAc,GAAG,MAAM,CAAC,UAAU,EAAE,CAAC;QACrC,MAAM,IAAI,KAAK,CAAC,sCAAsC,CAAC,CAAC;IAC5D,CAAC;IAED,MAAM,uBAAuB,GAAG,IAAI,GAAG,cAAc,CAAC;IACtD,IAAI,UAAU,GAAG,uBAAuB,EAAE,CAAC;QACvC,MAAM,IAAI,KAAK,CAAC,+DAA+D,CAAC,CAAC;IACrF,CAAC;IACD,IAAI,UAAU,KAAK,uBAAuB,EAAE,CAAC;QACzC,MAAM,IAAI,GAAG,IAAI,WAAW,CAAC,KAAK,CAAC,CAAC;QACpC,oBAAoB,CAAC,MAAM,EAAE,kBAAkB,EAAE,UAAU,EAAE,IAAI,EAAE,IAAI,EAAE,KAAK,EAAE,UAAU,EAAE,CAAC,MAAM,EAAE,KAAK,EAAE,EAAE;YAC1G,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,EAAE,CAAC,EAAE,EAAE,CAAC;gBAC5B,IAAI,CAAC,KAAK,GAAG,CAAC,CAAC,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;YAChC,CAAC;QACL,CAAC,CAAC,CAAC;QACH,OAAO,IAAI,CAAC;IAChB,CAAC;IAED,IAAI,cAAc,KAAK,CAAC,IAAI,CAAC,kBAAkB,GAAG,CAAC,cAAc,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC,EAAE,CAAC;QAC5E,MAAM,CAAC,IAAI,CAAC,uEAAuE,CAAC,CAAC;QACrF,SAAS,GAAG,IAAI,CAAC;IACrB,CAAC;IAED,IAAI,SAAS,EAAE,CAAC;QACZ,OAAO,IAAI,WAAW,CAAC,MAAM,CAAC,KAAK,CAAC,kBAAkB,EAAE,kBAAkB,GAAG,KAAK,GAAG,cAAc,CAAC,CAAC,CAAC;IAC1G,CAAC;IAED,OAAO,IAAI,WAAW,CAAC,MAAM,EAAE,kBAAkB,EAAE,KAAK,CAAC,CAAC;AAC9D,CAAC;AAED;;;;;;;;;;GAUG;AACH,MAAM,UAAU,aAAa,CACzB,KAAgB,EAChB,IAAY,EACZ,IAAY,EACZ,UAAkB,EAClB,UAAkB,EAClB,UAAmB,EACnB,aAAqB,EACrB,MAAoB;IAEpB,MAAM,uBAAuB,GAAG,IAAI,GAAG,iBAAiB,CAAC,IAAI,CAAC,CAAC;IAC/D,MAAM,KAAK,GAAG,aAAa,GAAG,IAAI,CAAC;IAEnC,IAAI,MAAM,CAAC,MAAM,KAAK,KAAK,EAAE,CAAC;QAC1B,MAAM,IAAI,KAAK,CAAC,4BAA4B,CAAC,CAAC;IAClD,CAAC;IAED,IAAI,IAAI,KAAK,SAAS,CAAC,KAAK,IAAI,UAAU,KAAK,uBAAuB,EAAE,CAAC;QACrE,oBAAoB,CAAC,KAAK,EAAE,UAAU,EAAE,UAAU,EAAE,IAAI,EAAE,IAAI,EAAE,KAAK,EAAE,UAAU,EAAE,CAAC,MAAM,EAAE,KAAK,EAAE,EAAE;YACjG,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,EAAE,CAAC,EAAE,EAAE,CAAC;gBAC5B,MAAM,CAAC,KAAK,GAAG,CAAC,CAAC,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;YAClC,CAAC;QACL,CAAC,CAAC,CAAC;QACH,OAAO;IACX,CAAC;IAED,IAAI,KAAK,YAAY,KAAK,EAAE,CAAC;QACzB,MAAM,MAAM,GAAG,UAAU,GAAG,CAAC,CAAC;QAC9B,MAAM,CAAC,GAAG,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC;IAC9B,CAAC;SAAM,IAAI,KAAK,YAAY,WAAW,EAAE,CAAC;QACtC,MAAM,SAAS,GAAG,IAAI,YAAY,CAAC,KAAK,EAAE,UAAU,EAAE,KAAK,CAAC,CAAC;QAC7D,MAAM,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;IAC1B,CAAC;SAAM,CAAC;QACJ,MAAM,MAAM,GAAG,KAAK,CAAC,UAAU,GAAG,UAAU,CAAC;QAC7C,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,KAAK,CAAC,EAAE,CAAC;YACrB,MAAM,CAAC,IAAI,CAAC,+CAA+C,CAAC,CAAC;YAC7D,MAAM,CAAC,GAAG,CAAC,IAAI,YAAY,CAAC,KAAK,CAAC,MAAM,CAAC,KAAK,CAAC,MAAM,EAAE,MAAM,GAAG,KAAK,GAAG,YAAY,CAAC,iBAAiB,CAAC,CAAC,CAAC,CAAC;YAC1G,OAAO;QACX,CAAC;QAED,MAAM,SAAS,GAAG,IAAI,YAAY,CAAC,KAAK,CAAC,MAAM,EAAE,MAAM,EAAE,KAAK,CAAC,CAAC;QAChE,MAAM,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;IAC1B,CAAC;AACL,CAAC;AAED;;;;;GAKG;AACH,MAAM,UAAU,gBAAgB,CAAC,OAA+B,EAAE,KAAa;IAC3E,IAAI,OAAO,EAAE,CAAC;QACV,IAAI,OAAO,YAAY,KAAK,EAAE,CAAC;YAC3B,OAAO,OAAO,CAAC,IAAI,CAAC,CAAC,KAAK,EAAE,EAAE,CAAC,KAAK,IAAI,KAAK,CAAC,CAAC;QACnD,CAAC;QACD,OAAO,OAAO,CAAC,iBAAiB,KAAK,CAAC,CAAC;IAC3C,CAAC;IACD,OAAO,KAAK,IAAI,KAAK,CAAC;AAC1B,CAAC","sourcesContent":["import { Constants } from \"../Engines/constants\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport type { DataArray, FloatArray, IndicesArray, Nullable, TypedArray } from \"../types\";\r\n\r\n/**\r\n * Union of TypedArrays that can be used for vertex data.\r\n */\r\nexport type VertexDataTypedArray = Exclude<TypedArray, Float64Array | BigInt64Array | BigUint64Array>;\r\n\r\n/**\r\n * Interface for a constructor of a TypedArray.\r\n */\r\nexport interface TypedArrayConstructor<T extends TypedArray = TypedArray> {\r\n    new (length: number): T;\r\n    new (elements: Iterable<number>): T;\r\n    new (buffer: ArrayBuffer, byteOffset?: number, length?: number): T;\r\n    readonly BYTES_PER_ELEMENT: number;\r\n}\r\n\r\nfunction GetFloatValue(dataView: DataView, type: number, byteOffset: number, normalized: boolean): number {\r\n    switch (type) {\r\n        case Constants.BYTE: {\r\n            let value = dataView.getInt8(byteOffset);\r\n            if (normalized) {\r\n                value = Math.max(value / 127, -1);\r\n            }\r\n            return value;\r\n        }\r\n        case Constants.UNSIGNED_BYTE: {\r\n            let value = dataView.getUint8(byteOffset);\r\n            if (normalized) {\r\n                value = value / 255;\r\n            }\r\n            return value;\r\n        }\r\n        case Constants.SHORT: {\r\n            let value = dataView.getInt16(byteOffset, true);\r\n            if (normalized) {\r\n                value = Math.max(value / 32767, -1);\r\n            }\r\n            return value;\r\n        }\r\n        case Constants.UNSIGNED_SHORT: {\r\n            let value = dataView.getUint16(byteOffset, true);\r\n            if (normalized) {\r\n                value = value / 65535;\r\n            }\r\n            return value;\r\n        }\r\n        case Constants.INT: {\r\n            return dataView.getInt32(byteOffset, true);\r\n        }\r\n        case Constants.UNSIGNED_INT: {\r\n            return dataView.getUint32(byteOffset, true);\r\n        }\r\n        case Constants.FLOAT: {\r\n            return dataView.getFloat32(byteOffset, true);\r\n        }\r\n        default: {\r\n            throw new Error(`Invalid component type ${type}`);\r\n        }\r\n    }\r\n}\r\n\r\nfunction SetFloatValue(dataView: DataView, type: number, byteOffset: number, normalized: boolean, value: number): void {\r\n    switch (type) {\r\n        case Constants.BYTE: {\r\n            if (normalized) {\r\n                value = Math.round(value * 127.0);\r\n            }\r\n            dataView.setInt8(byteOffset, value);\r\n            break;\r\n        }\r\n        case Constants.UNSIGNED_BYTE: {\r\n            if (normalized) {\r\n                value = Math.round(value * 255);\r\n            }\r\n            dataView.setUint8(byteOffset, value);\r\n            break;\r\n        }\r\n        case Constants.SHORT: {\r\n            if (normalized) {\r\n                value = Math.round(value * 32767);\r\n            }\r\n            dataView.setInt16(byteOffset, value, true);\r\n            break;\r\n        }\r\n        case Constants.UNSIGNED_SHORT: {\r\n            if (normalized) {\r\n                value = Math.round(value * 65535);\r\n            }\r\n            dataView.setUint16(byteOffset, value, true);\r\n            break;\r\n        }\r\n        case Constants.INT: {\r\n            dataView.setInt32(byteOffset, value, true);\r\n            break;\r\n        }\r\n        case Constants.UNSIGNED_INT: {\r\n            dataView.setUint32(byteOffset, value, true);\r\n            break;\r\n        }\r\n        case Constants.FLOAT: {\r\n            dataView.setFloat32(byteOffset, value, true);\r\n            break;\r\n        }\r\n        default: {\r\n            throw new Error(`Invalid component type ${type}`);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Gets the byte length of the given type.\r\n * @param type the type\r\n * @returns the number of bytes\r\n */\r\nexport function GetTypeByteLength(type: number): number {\r\n    switch (type) {\r\n        case Constants.BYTE:\r\n        case Constants.UNSIGNED_BYTE:\r\n            return 1;\r\n        case Constants.SHORT:\r\n        case Constants.UNSIGNED_SHORT:\r\n            return 2;\r\n        case Constants.INT:\r\n        case Constants.UNSIGNED_INT:\r\n        case Constants.FLOAT:\r\n            return 4;\r\n        default:\r\n            throw new Error(`Invalid type '${type}'`);\r\n    }\r\n}\r\n\r\n/**\r\n * Gets the appropriate TypedArray constructor for the given component type.\r\n * @param componentType the component type\r\n * @returns the constructor object\r\n */\r\nexport function GetTypedArrayConstructor(componentType: number): TypedArrayConstructor<VertexDataTypedArray> {\r\n    switch (componentType) {\r\n        case Constants.BYTE:\r\n            return Int8Array;\r\n        case Constants.UNSIGNED_BYTE:\r\n            return Uint8Array;\r\n        case Constants.SHORT:\r\n            return Int16Array;\r\n        case Constants.UNSIGNED_SHORT:\r\n            return Uint16Array;\r\n        case Constants.INT:\r\n            return Int32Array;\r\n        case Constants.UNSIGNED_INT:\r\n            return Uint32Array;\r\n        case Constants.FLOAT:\r\n            return Float32Array;\r\n        default:\r\n            throw new Error(`Invalid component type '${componentType}'`);\r\n    }\r\n}\r\n\r\n/**\r\n * Enumerates each value of the data array and calls the given callback.\r\n * @param data the data to enumerate\r\n * @param byteOffset the byte offset of the data\r\n * @param byteStride the byte stride of the data\r\n * @param componentCount the number of components per element\r\n * @param componentType the type of the component\r\n * @param count the number of values to enumerate\r\n * @param normalized whether the data is normalized\r\n * @param callback the callback function called for each group of component values\r\n */\r\nexport function EnumerateFloatValues(\r\n    data: DataArray,\r\n    byteOffset: number,\r\n    byteStride: number,\r\n    componentCount: number,\r\n    componentType: number,\r\n    count: number,\r\n    normalized: boolean,\r\n    callback: (values: number[], index: number) => void\r\n): void {\r\n    const oldValues = new Array<number>(componentCount);\r\n    const newValues = new Array<number>(componentCount);\r\n\r\n    if (data instanceof Array) {\r\n        let offset = byteOffset / 4;\r\n        const stride = byteStride / 4;\r\n        for (let index = 0; index < count; index += componentCount) {\r\n            for (let componentIndex = 0; componentIndex < componentCount; componentIndex++) {\r\n                oldValues[componentIndex] = newValues[componentIndex] = data[offset + componentIndex];\r\n            }\r\n\r\n            callback(newValues, index);\r\n\r\n            for (let componentIndex = 0; componentIndex < componentCount; componentIndex++) {\r\n                if (oldValues[componentIndex] !== newValues[componentIndex]) {\r\n                    data[offset + componentIndex] = newValues[componentIndex];\r\n                }\r\n            }\r\n\r\n            offset += stride;\r\n        }\r\n    } else {\r\n        const dataView = !ArrayBuffer.isView(data) ? new DataView(data) : new DataView(data.buffer, data.byteOffset, data.byteLength);\r\n        const componentByteLength = GetTypeByteLength(componentType);\r\n        for (let index = 0; index < count; index += componentCount) {\r\n            for (let componentIndex = 0, componentByteOffset = byteOffset; componentIndex < componentCount; componentIndex++, componentByteOffset += componentByteLength) {\r\n                oldValues[componentIndex] = newValues[componentIndex] = GetFloatValue(dataView, componentType, componentByteOffset, normalized);\r\n            }\r\n\r\n            callback(newValues, index);\r\n\r\n            for (let componentIndex = 0, componentByteOffset = byteOffset; componentIndex < componentCount; componentIndex++, componentByteOffset += componentByteLength) {\r\n                if (oldValues[componentIndex] !== newValues[componentIndex]) {\r\n                    SetFloatValue(dataView, componentType, componentByteOffset, normalized, newValues[componentIndex]);\r\n                }\r\n            }\r\n\r\n            byteOffset += byteStride;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Gets the given data array as a float array. Float data is constructed if the data array cannot be returned directly.\r\n * @param data the input data array\r\n * @param size the number of components\r\n * @param type the component type\r\n * @param byteOffset the byte offset of the data\r\n * @param byteStride the byte stride of the data\r\n * @param normalized whether the data is normalized\r\n * @param totalVertices number of vertices in the buffer to take into account\r\n * @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it\r\n * @returns a float array containing vertex data\r\n */\r\nexport function GetFloatData(\r\n    data: DataArray,\r\n    size: number,\r\n    type: number,\r\n    byteOffset: number,\r\n    byteStride: number,\r\n    normalized: boolean,\r\n    totalVertices: number,\r\n    forceCopy?: boolean\r\n): FloatArray {\r\n    const tightlyPackedByteStride = size * GetTypeByteLength(type);\r\n    const count = totalVertices * size;\r\n\r\n    if (type !== Constants.FLOAT || byteStride !== tightlyPackedByteStride) {\r\n        const copy = new Float32Array(count);\r\n        EnumerateFloatValues(data, byteOffset, byteStride, size, type, count, normalized, (values, index) => {\r\n            for (let i = 0; i < size; i++) {\r\n                copy[index + i] = values[i];\r\n            }\r\n        });\r\n        return copy;\r\n    }\r\n\r\n    if (!(data instanceof Array || data instanceof Float32Array) || byteOffset !== 0 || data.length !== count) {\r\n        if (data instanceof Array) {\r\n            const offset = byteOffset / 4;\r\n            return data.slice(offset, offset + count);\r\n        } else if (data instanceof ArrayBuffer) {\r\n            return new Float32Array(data, byteOffset, count);\r\n        } else {\r\n            const offset = data.byteOffset + byteOffset;\r\n            if ((offset & 3) !== 0) {\r\n                Logger.Warn(\"Float array must be aligned to 4-bytes border\");\r\n                forceCopy = true;\r\n            }\r\n\r\n            if (forceCopy) {\r\n                return new Float32Array(data.buffer.slice(offset, offset + count * Float32Array.BYTES_PER_ELEMENT));\r\n            } else {\r\n                return new Float32Array(data.buffer, offset, count);\r\n            }\r\n        }\r\n    }\r\n\r\n    if (forceCopy) {\r\n        return data.slice();\r\n    }\r\n\r\n    return data;\r\n}\r\n\r\n/**\r\n * Gets the given data array as a typed array that matches the component type. If the data cannot be used directly, a copy is made to support the new typed array.\r\n * If the data is number[], byteOffset and byteStride must be a multiple of 4, as data will be treated like a list of floats.\r\n * @param data the input data array\r\n * @param size the number of components\r\n * @param type the component type\r\n * @param byteOffset the byte offset of the data\r\n * @param byteStride the byte stride of the data\r\n * @param normalized whether the data is normalized\r\n * @param totalVertices number of vertices in the buffer to take into account\r\n * @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it\r\n * @returns a typed array containing vertex data\r\n */\r\nexport function GetTypedArrayData(\r\n    data: DataArray,\r\n    size: number,\r\n    type: number,\r\n    byteOffset: number,\r\n    byteStride: number,\r\n    normalized: boolean,\r\n    totalVertices: number,\r\n    forceCopy?: boolean\r\n): VertexDataTypedArray {\r\n    const typeByteLength = GetTypeByteLength(type);\r\n    const constructor = GetTypedArrayConstructor(type);\r\n    const count = totalVertices * size;\r\n\r\n    // Handle number[]\r\n    if (Array.isArray(data)) {\r\n        if ((byteOffset & 3) !== 0 || (byteStride & 3) !== 0) {\r\n            throw new Error(\"byteOffset and byteStride must be a multiple of 4 for number[] data.\");\r\n        }\r\n\r\n        const offset = byteOffset / 4;\r\n        const stride = byteStride / 4;\r\n\r\n        const lastIndex = offset + (totalVertices - 1) * stride + size;\r\n        if (lastIndex > data.length) {\r\n            throw new Error(\"Last accessed index is out of bounds.\");\r\n        }\r\n\r\n        if (stride < size) {\r\n            throw new Error(\"Data stride cannot be smaller than the component size.\");\r\n        }\r\n        if (stride !== size) {\r\n            const copy = new constructor(count);\r\n            EnumerateFloatValues(data, byteOffset, byteStride, size, type, count, normalized, (values, index) => {\r\n                for (let i = 0; i < size; i++) {\r\n                    copy[index + i] = values[i];\r\n                }\r\n            });\r\n            return copy;\r\n        }\r\n\r\n        return new constructor(data.slice(offset, offset + count));\r\n    }\r\n\r\n    // Handle ArrayBuffer and ArrayBufferView\r\n    let buffer: ArrayBuffer;\r\n    let adjustedByteOffset = byteOffset;\r\n\r\n    if (data instanceof ArrayBuffer) {\r\n        buffer = data;\r\n    } else {\r\n        buffer = data.buffer;\r\n        adjustedByteOffset += data.byteOffset;\r\n    }\r\n\r\n    const lastByteOffset = adjustedByteOffset + (totalVertices - 1) * byteStride + size * typeByteLength;\r\n    if (lastByteOffset > buffer.byteLength) {\r\n        throw new Error(\"Last accessed byte is out of bounds.\");\r\n    }\r\n\r\n    const tightlyPackedByteStride = size * typeByteLength;\r\n    if (byteStride < tightlyPackedByteStride) {\r\n        throw new Error(\"Byte stride cannot be smaller than the component's byte size.\");\r\n    }\r\n    if (byteStride !== tightlyPackedByteStride) {\r\n        const copy = new constructor(count);\r\n        EnumerateFloatValues(buffer, adjustedByteOffset, byteStride, size, type, count, normalized, (values, index) => {\r\n            for (let i = 0; i < size; i++) {\r\n                copy[index + i] = values[i];\r\n            }\r\n        });\r\n        return copy;\r\n    }\r\n\r\n    if (typeByteLength !== 1 && (adjustedByteOffset & (typeByteLength - 1)) !== 0) {\r\n        Logger.Warn(\"Array must be aligned to border of element size. Data will be copied.\");\r\n        forceCopy = true;\r\n    }\r\n\r\n    if (forceCopy) {\r\n        return new constructor(buffer.slice(adjustedByteOffset, adjustedByteOffset + count * typeByteLength));\r\n    }\r\n\r\n    return new constructor(buffer, adjustedByteOffset, count);\r\n}\r\n\r\n/**\r\n * Copies the given data array to the given float array.\r\n * @param input the input data array\r\n * @param size the number of components\r\n * @param type the component type\r\n * @param byteOffset the byte offset of the data\r\n * @param byteStride the byte stride of the data\r\n * @param normalized whether the data is normalized\r\n * @param totalVertices number of vertices in the buffer to take into account\r\n * @param output the output float array\r\n */\r\nexport function CopyFloatData(\r\n    input: DataArray,\r\n    size: number,\r\n    type: number,\r\n    byteOffset: number,\r\n    byteStride: number,\r\n    normalized: boolean,\r\n    totalVertices: number,\r\n    output: Float32Array\r\n): void {\r\n    const tightlyPackedByteStride = size * GetTypeByteLength(type);\r\n    const count = totalVertices * size;\r\n\r\n    if (output.length !== count) {\r\n        throw new Error(\"Output length is not valid\");\r\n    }\r\n\r\n    if (type !== Constants.FLOAT || byteStride !== tightlyPackedByteStride) {\r\n        EnumerateFloatValues(input, byteOffset, byteStride, size, type, count, normalized, (values, index) => {\r\n            for (let i = 0; i < size; i++) {\r\n                output[index + i] = values[i];\r\n            }\r\n        });\r\n        return;\r\n    }\r\n\r\n    if (input instanceof Array) {\r\n        const offset = byteOffset / 4;\r\n        output.set(input, offset);\r\n    } else if (input instanceof ArrayBuffer) {\r\n        const floatData = new Float32Array(input, byteOffset, count);\r\n        output.set(floatData);\r\n    } else {\r\n        const offset = input.byteOffset + byteOffset;\r\n        if ((offset & 3) !== 0) {\r\n            Logger.Warn(\"Float array must be aligned to 4-bytes border\");\r\n            output.set(new Float32Array(input.buffer.slice(offset, offset + count * Float32Array.BYTES_PER_ELEMENT)));\r\n            return;\r\n        }\r\n\r\n        const floatData = new Float32Array(input.buffer, offset, count);\r\n        output.set(floatData);\r\n    }\r\n}\r\n\r\n/**\r\n * Utility function to determine if an IndicesArray is an Uint32Array.\r\n * @param indices The IndicesArray to check. If null, count is used instead.\r\n * @param count The number of indices\r\n * @returns True if the indices use 32 bits\r\n */\r\nexport function AreIndices32Bits(indices: Nullable<IndicesArray>, count: number): boolean {\r\n    if (indices) {\r\n        if (indices instanceof Array) {\r\n            return indices.some((value) => value >= 65536);\r\n        }\r\n        return indices.BYTES_PER_ELEMENT === 4;\r\n    }\r\n    return count >= 65536;\r\n}\r\n"]}