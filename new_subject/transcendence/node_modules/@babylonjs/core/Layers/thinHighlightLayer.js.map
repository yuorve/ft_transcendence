{"version":3,"file":"thinHighlightLayer.js","sourceRoot":"","sources":["../../../../dev/core/src/Layers/thinHighlightLayer.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\r\n    Observer,\r\n    Nullable,\r\n    Scene,\r\n    SubMesh,\r\n    AbstractMesh,\r\n    Mesh,\r\n    Effect,\r\n    IThinEffectLayerOptions,\r\n    Color3,\r\n    EffectWrapper,\r\n    // eslint-disable-next-line import/no-internal-modules\r\n} from \"core/index\";\r\nimport { Vector2 } from \"../Maths/math.vector\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { Material } from \"../Materials/material\";\r\nimport { ThinPassPostProcess } from \"../PostProcesses/thinPassPostProcess\";\r\nimport { ThinEffectLayer, ThinGlowBlurPostProcess } from \"./thinEffectLayer\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { Color4 } from \"../Maths/math.color\";\r\nimport { ShaderLanguage } from \"core/Materials/shaderLanguage\";\r\nimport { ThinBlurPostProcess } from \"core/PostProcesses/thinBlurPostProcess\";\r\n\r\ninterface IBlurPostProcess extends EffectWrapper {\r\n    kernel: number;\r\n}\r\n\r\n/**\r\n * Highlight layer options. This helps customizing the behaviour\r\n * of the highlight layer.\r\n */\r\nexport interface IThinHighlightLayerOptions extends IThinEffectLayerOptions {\r\n    /**\r\n     * Multiplication factor apply to the main texture size in the first step of the blur to reduce the size\r\n     * of the picture to blur (the smaller the faster). Default: 0.5\r\n     */\r\n    blurTextureSizeRatio?: number;\r\n\r\n    /**\r\n     * How big in texel of the blur texture is the vertical blur. Default: 1\r\n     */\r\n    blurVerticalSize?: number;\r\n\r\n    /**\r\n     * How big in texel of the blur texture is the horizontal blur. Default: 1\r\n     */\r\n    blurHorizontalSize?: number;\r\n\r\n    /**\r\n     * Should we display highlight as a solid stroke? Default: false\r\n     */\r\n    isStroke?: boolean;\r\n\r\n    /**\r\n     * Use the GLSL code generation for the shader (even on WebGPU). Default is false\r\n     */\r\n    forceGLSL?: boolean;\r\n}\r\n\r\n/**\r\n * Storage interface grouping all the information required for glowing a mesh.\r\n */\r\ninterface IHighlightLayerMesh {\r\n    /**\r\n     * The glowy mesh\r\n     */\r\n    mesh: Mesh;\r\n    /**\r\n     * The color of the glow\r\n     */\r\n    color: Color3;\r\n    /**\r\n     * The mesh render callback use to insert stencil information\r\n     */\r\n    observerHighlight: Nullable<Observer<Mesh>>;\r\n    /**\r\n     * The mesh render callback use to come to the default behavior\r\n     */\r\n    observerDefault: Nullable<Observer<Mesh>>;\r\n    /**\r\n     * If it exists, the emissive color of the material will be used to generate the glow.\r\n     * Else it falls back to the current color.\r\n     */\r\n    glowEmissiveOnly: boolean;\r\n}\r\n\r\n/**\r\n * Storage interface grouping all the information required for an excluded mesh.\r\n */\r\ninterface IHighlightLayerExcludedMesh {\r\n    /**\r\n     * The glowy mesh\r\n     */\r\n    mesh: Mesh;\r\n    /**\r\n     * The mesh render callback use to prevent stencil use\r\n     */\r\n    beforeBind: Nullable<Observer<Mesh>>;\r\n    /**\r\n     * The mesh render callback use to restore previous stencil use\r\n     */\r\n    afterRender: Nullable<Observer<Mesh>>;\r\n    /**\r\n     * Current stencil state of the engine\r\n     */\r\n    stencilState: boolean;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport class ThinHighlightLayer extends ThinEffectLayer {\r\n    /**\r\n     * Effect Name of the highlight layer.\r\n     */\r\n    public static readonly EffectName = \"HighlightLayer\";\r\n\r\n    /**\r\n     * The neutral color used during the preparation of the glow effect.\r\n     * This is black by default as the blend operation is a blend operation.\r\n     */\r\n    public static NeutralColor: Color4 = new Color4(0, 0, 0, 0);\r\n\r\n    /**\r\n     * Stencil value used for glowing meshes.\r\n     */\r\n    public static GlowingMeshStencilReference = 0x02;\r\n\r\n    /**\r\n     * Stencil value used for the other meshes in the scene.\r\n     */\r\n    public static NormalMeshStencilReference = 0x01;\r\n\r\n    /**\r\n     * Specifies whether or not the inner glow is ACTIVE in the layer.\r\n     */\r\n    public innerGlow: boolean = true;\r\n\r\n    /**\r\n     * Specifies whether or not the outer glow is ACTIVE in the layer.\r\n     */\r\n    public outerGlow: boolean = true;\r\n\r\n    /**\r\n     * Specifies the horizontal size of the blur.\r\n     */\r\n    public set blurHorizontalSize(value: number) {\r\n        this._horizontalBlurPostprocess.kernel = value;\r\n        this._options.blurHorizontalSize = value;\r\n    }\r\n\r\n    /**\r\n     * Specifies the vertical size of the blur.\r\n     */\r\n    public set blurVerticalSize(value: number) {\r\n        this._verticalBlurPostprocess.kernel = value;\r\n        this._options.blurVerticalSize = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the horizontal size of the blur.\r\n     */\r\n    public get blurHorizontalSize(): number {\r\n        return this._horizontalBlurPostprocess.kernel;\r\n    }\r\n\r\n    /**\r\n     * Gets the vertical size of the blur.\r\n     */\r\n    public get blurVerticalSize(): number {\r\n        return this._verticalBlurPostprocess.kernel;\r\n    }\r\n\r\n    private _instanceGlowingMeshStencilReference = ThinHighlightLayer.GlowingMeshStencilReference++;\r\n\r\n    /** @internal */\r\n    public override _options: Required<IThinHighlightLayerOptions>;\r\n\r\n    private _downSamplePostprocess: ThinPassPostProcess;\r\n    private _horizontalBlurPostprocess: IBlurPostProcess;\r\n    private _verticalBlurPostprocess: IBlurPostProcess;\r\n\r\n    /** @internal */\r\n    public _meshes: Nullable<{ [id: string]: Nullable<IHighlightLayerMesh> }> = {};\r\n    /** @internal */\r\n    public _excludedMeshes: Nullable<{ [id: string]: Nullable<IHighlightLayerExcludedMesh> }> = {};\r\n\r\n    /** @internal */\r\n    public _mainObjectRendererRenderPassId = -1;\r\n\r\n    /**\r\n     * Instantiates a new highlight Layer and references it to the scene..\r\n     * @param name The name of the layer\r\n     * @param scene The scene to use the layer in\r\n     * @param options Sets of none mandatory options to use with the layer (see IHighlightLayerOptions for more information)\r\n     * @param dontCheckIfReady Specifies if the layer should disable checking whether all the post processes are ready (default: false). To save performance, this should be set to true and you should call `isReady` manually before rendering to the layer.\r\n     */\r\n    constructor(name: string, scene?: Scene, options?: Partial<IThinHighlightLayerOptions>, dontCheckIfReady = false) {\r\n        super(name, scene, options !== undefined ? !!options.forceGLSL : false);\r\n\r\n        this.neutralColor = ThinHighlightLayer.NeutralColor;\r\n\r\n        // Adapt options\r\n        this._options = {\r\n            mainTextureRatio: 0.5,\r\n            blurTextureSizeRatio: 0.5,\r\n            mainTextureFixedSize: 0,\r\n            blurHorizontalSize: 1.0,\r\n            blurVerticalSize: 1.0,\r\n            alphaBlendingMode: Constants.ALPHA_COMBINE,\r\n            camera: null,\r\n            renderingGroupId: -1,\r\n            forceGLSL: false,\r\n            mainTextureType: Constants.TEXTURETYPE_UNSIGNED_BYTE,\r\n            isStroke: false,\r\n            ...options,\r\n        };\r\n\r\n        // Initialize the layer\r\n        this._init(this._options);\r\n\r\n        // Do not render as long as no meshes have been added\r\n        this._shouldRender = false;\r\n\r\n        if (dontCheckIfReady) {\r\n            // When dontCheckIfReady is true, we are in the new ThinXXX layer mode, so we must call _createTextureAndPostProcesses ourselves (it is called by EffectLayer otherwise)\r\n            this._createTextureAndPostProcesses();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the effect layer\r\n     * @returns the string with the class name of the effect layer\r\n     */\r\n    public getClassName(): string {\r\n        return \"HighlightLayer\";\r\n    }\r\n\r\n    protected override async _importShadersAsync() {\r\n        if (this._shaderLanguage === ShaderLanguage.WGSL) {\r\n            await Promise.all([\r\n                import(\"../ShadersWGSL/glowMapMerge.fragment\"),\r\n                import(\"../ShadersWGSL/glowMapMerge.vertex\"),\r\n                import(\"../ShadersWGSL/glowBlurPostProcess.fragment\"),\r\n            ]);\r\n        } else {\r\n            await Promise.all([import(\"../Shaders/glowMapMerge.fragment\"), import(\"../Shaders/glowMapMerge.vertex\"), import(\"../Shaders/glowBlurPostProcess.fragment\")]);\r\n        }\r\n\r\n        await super._importShadersAsync();\r\n    }\r\n\r\n    public override getEffectName(): string {\r\n        return ThinHighlightLayer.EffectName;\r\n    }\r\n\r\n    public override _numInternalDraws(): number {\r\n        return 2; // we need two rendering, one for the inner glow and the other for the outer glow\r\n    }\r\n\r\n    public override _createMergeEffect(): Effect {\r\n        return this._engine.createEffect(\r\n            \"glowMapMerge\",\r\n            [VertexBuffer.PositionKind],\r\n            [\"offset\"],\r\n            [\"textureSampler\"],\r\n            this._options.isStroke ? \"#define STROKE \\n\" : undefined,\r\n            undefined,\r\n            undefined,\r\n            undefined,\r\n            undefined,\r\n            this._shaderLanguage,\r\n            this._shadersLoaded\r\n                ? undefined\r\n                : async () => {\r\n                      await this._importShadersAsync();\r\n                      this._shadersLoaded = true;\r\n                  }\r\n        );\r\n    }\r\n\r\n    public override _createTextureAndPostProcesses(): void {\r\n        if (this._options.alphaBlendingMode === Constants.ALPHA_COMBINE) {\r\n            this._downSamplePostprocess = new ThinPassPostProcess(\"HighlightLayerPPP\", this._scene.getEngine());\r\n            this._horizontalBlurPostprocess = new ThinGlowBlurPostProcess(\"HighlightLayerHBP\", this._scene.getEngine(), new Vector2(1.0, 0), this._options.blurHorizontalSize);\r\n            this._verticalBlurPostprocess = new ThinGlowBlurPostProcess(\"HighlightLayerVBP\", this._scene.getEngine(), new Vector2(0, 1.0), this._options.blurVerticalSize);\r\n            this._postProcesses = [this._downSamplePostprocess, this._horizontalBlurPostprocess, this._verticalBlurPostprocess];\r\n        } else {\r\n            this._horizontalBlurPostprocess = new ThinBlurPostProcess(\"HighlightLayerHBP\", this._scene.getEngine(), new Vector2(1.0, 0), this._options.blurHorizontalSize / 2);\r\n            this._verticalBlurPostprocess = new ThinBlurPostProcess(\"HighlightLayerVBP\", this._scene.getEngine(), new Vector2(0, 1.0), this._options.blurVerticalSize / 2);\r\n            this._postProcesses = [this._horizontalBlurPostprocess, this._verticalBlurPostprocess];\r\n        }\r\n    }\r\n\r\n    public override needStencil(): boolean {\r\n        return true;\r\n    }\r\n\r\n    public override isReady(subMesh: SubMesh, useInstances: boolean): boolean {\r\n        const material = subMesh.getMaterial();\r\n        const mesh = subMesh.getRenderingMesh();\r\n\r\n        if (!material || !mesh || !this._meshes) {\r\n            return false;\r\n        }\r\n\r\n        let emissiveTexture: Nullable<any> = null;\r\n        const highlightLayerMesh = this._meshes[mesh.uniqueId];\r\n\r\n        if (highlightLayerMesh && highlightLayerMesh.glowEmissiveOnly && material) {\r\n            emissiveTexture = (<any>material).emissiveTexture;\r\n        }\r\n        return super._isSubMeshReady(subMesh, useInstances, emissiveTexture);\r\n    }\r\n\r\n    public override _canRenderMesh(_mesh: AbstractMesh, _material: Material): boolean {\r\n        // all meshes can be rendered in the highlight layer, even transparent ones\r\n        return true;\r\n    }\r\n\r\n    public override _internalCompose(effect: Effect, renderIndex: number): void {\r\n        // Texture\r\n        this.bindTexturesForCompose(effect);\r\n\r\n        // Cache\r\n        const engine = this._engine;\r\n        engine.cacheStencilState();\r\n\r\n        // Stencil operations\r\n        engine.setStencilOperationPass(Constants.REPLACE);\r\n        engine.setStencilOperationFail(Constants.KEEP);\r\n        engine.setStencilOperationDepthFail(Constants.KEEP);\r\n\r\n        // Draw order\r\n        engine.setStencilMask(0x00);\r\n        engine.setStencilBuffer(true);\r\n        engine.setStencilFunctionReference(this._instanceGlowingMeshStencilReference);\r\n\r\n        // 2 passes inner outer\r\n        if (this.outerGlow && renderIndex === 0) {\r\n            // the outer glow is rendered the first time _internalRender is called, so when renderIndex == 0 (and only if outerGlow is enabled)\r\n            effect.setFloat(\"offset\", 0);\r\n            engine.setStencilFunction(Constants.NOTEQUAL);\r\n            engine.drawElementsType(Material.TriangleFillMode, 0, 6);\r\n        }\r\n        if (this.innerGlow && renderIndex === 1) {\r\n            // the inner glow is rendered the second time _internalRender is called, so when renderIndex == 1 (and only if innerGlow is enabled)\r\n            effect.setFloat(\"offset\", 1);\r\n            engine.setStencilFunction(Constants.EQUAL);\r\n            engine.drawElementsType(Material.TriangleFillMode, 0, 6);\r\n        }\r\n\r\n        // Restore Cache\r\n        engine.restoreStencilState();\r\n    }\r\n\r\n    public override _setEmissiveTextureAndColor(mesh: Mesh, _subMesh: SubMesh, material: Material): void {\r\n        const highlightLayerMesh = this._meshes![mesh.uniqueId];\r\n        if (highlightLayerMesh) {\r\n            this._emissiveTextureAndColor.color.set(highlightLayerMesh.color.r, highlightLayerMesh.color.g, highlightLayerMesh.color.b, 1.0);\r\n        } else {\r\n            this._emissiveTextureAndColor.color.set(this.neutralColor.r, this.neutralColor.g, this.neutralColor.b, this.neutralColor.a);\r\n        }\r\n\r\n        if (highlightLayerMesh && highlightLayerMesh.glowEmissiveOnly && material) {\r\n            this._emissiveTextureAndColor.texture = (<any>material).emissiveTexture;\r\n            this._emissiveTextureAndColor.color.set(1.0, 1.0, 1.0, 1.0);\r\n        } else {\r\n            this._emissiveTextureAndColor.texture = null;\r\n        }\r\n    }\r\n\r\n    public override shouldRender(): boolean {\r\n        return this._meshes && super.shouldRender() ? true : false;\r\n    }\r\n\r\n    public override _shouldRenderMesh(mesh: Mesh): boolean {\r\n        if (this._excludedMeshes && this._excludedMeshes[mesh.uniqueId]) {\r\n            return false;\r\n        }\r\n\r\n        return super.hasMesh(mesh);\r\n    }\r\n\r\n    public override _addCustomEffectDefines(defines: string[]): void {\r\n        defines.push(\"#define HIGHLIGHT\");\r\n    }\r\n\r\n    /**\r\n     * Add a mesh in the exclusion list to prevent it to impact or being impacted by the highlight layer.\r\n     * @param mesh The mesh to exclude from the highlight layer\r\n     */\r\n    public addExcludedMesh(mesh: Mesh) {\r\n        if (!this._excludedMeshes) {\r\n            return;\r\n        }\r\n\r\n        const meshExcluded = this._excludedMeshes[mesh.uniqueId];\r\n        if (!meshExcluded) {\r\n            const obj: IHighlightLayerExcludedMesh = {\r\n                mesh: mesh,\r\n                beforeBind: null,\r\n                afterRender: null,\r\n                stencilState: false,\r\n            };\r\n\r\n            obj.beforeBind = mesh.onBeforeBindObservable.add((mesh: Mesh) => {\r\n                if (this._mainObjectRendererRenderPassId !== -1 && this._mainObjectRendererRenderPassId !== this._engine.currentRenderPassId) {\r\n                    return;\r\n                }\r\n                obj.stencilState = mesh.getEngine().getStencilBuffer();\r\n                mesh.getEngine().setStencilBuffer(false);\r\n            });\r\n\r\n            obj.afterRender = mesh.onAfterRenderObservable.add((mesh: Mesh) => {\r\n                if (this._mainObjectRendererRenderPassId !== -1 && this._mainObjectRendererRenderPassId !== this._engine.currentRenderPassId) {\r\n                    return;\r\n                }\r\n                mesh.getEngine().setStencilBuffer(obj.stencilState);\r\n            });\r\n\r\n            this._excludedMeshes[mesh.uniqueId] = obj;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove a mesh from the exclusion list to let it impact or being impacted by the highlight layer.\r\n     * @param mesh The mesh to highlight\r\n     */\r\n    public removeExcludedMesh(mesh: Mesh) {\r\n        if (!this._excludedMeshes) {\r\n            return;\r\n        }\r\n\r\n        const meshExcluded = this._excludedMeshes[mesh.uniqueId];\r\n        if (meshExcluded) {\r\n            if (meshExcluded.beforeBind) {\r\n                mesh.onBeforeBindObservable.remove(meshExcluded.beforeBind);\r\n            }\r\n\r\n            if (meshExcluded.afterRender) {\r\n                mesh.onAfterRenderObservable.remove(meshExcluded.afterRender);\r\n            }\r\n        }\r\n\r\n        this._excludedMeshes[mesh.uniqueId] = null;\r\n    }\r\n\r\n    public override hasMesh(mesh: AbstractMesh): boolean {\r\n        if (!this._meshes || !super.hasMesh(mesh)) {\r\n            return false;\r\n        }\r\n\r\n        return !!this._meshes[mesh.uniqueId];\r\n    }\r\n\r\n    /**\r\n     * Add a mesh in the highlight layer in order to make it glow with the chosen color.\r\n     * @param mesh The mesh to highlight\r\n     * @param color The color of the highlight\r\n     * @param glowEmissiveOnly Extract the glow from the emissive texture\r\n     */\r\n    public addMesh(mesh: Mesh, color: Color3, glowEmissiveOnly = false) {\r\n        if (!this._meshes) {\r\n            return;\r\n        }\r\n\r\n        const meshHighlight = this._meshes[mesh.uniqueId];\r\n        if (meshHighlight) {\r\n            meshHighlight.color = color;\r\n        } else {\r\n            this._meshes[mesh.uniqueId] = {\r\n                mesh: mesh,\r\n                color: color,\r\n                // Lambda required for capture due to Observable this context\r\n                observerHighlight: mesh.onBeforeBindObservable.add((mesh: Mesh) => {\r\n                    if (this._mainObjectRendererRenderPassId !== -1 && this._mainObjectRendererRenderPassId !== this._engine.currentRenderPassId) {\r\n                        return;\r\n                    }\r\n                    if (this.isEnabled) {\r\n                        if (this._excludedMeshes && this._excludedMeshes[mesh.uniqueId]) {\r\n                            this._defaultStencilReference(mesh);\r\n                        } else {\r\n                            mesh.getScene().getEngine().setStencilFunctionReference(this._instanceGlowingMeshStencilReference);\r\n                        }\r\n                    }\r\n                }),\r\n                observerDefault: mesh.onAfterRenderObservable.add((mesh: Mesh) => {\r\n                    if (this._mainObjectRendererRenderPassId !== -1 && this._mainObjectRendererRenderPassId !== this._engine.currentRenderPassId) {\r\n                        return;\r\n                    }\r\n                    if (this.isEnabled) {\r\n                        this._defaultStencilReference(mesh);\r\n                    }\r\n                }),\r\n                glowEmissiveOnly: glowEmissiveOnly,\r\n            };\r\n\r\n            mesh.onDisposeObservable.add(() => {\r\n                this._disposeMesh(mesh);\r\n            });\r\n        }\r\n\r\n        this._shouldRender = true;\r\n    }\r\n\r\n    /**\r\n     * Remove a mesh from the highlight layer in order to make it stop glowing.\r\n     * @param mesh The mesh to highlight\r\n     */\r\n    public removeMesh(mesh: Mesh) {\r\n        if (!this._meshes) {\r\n            return;\r\n        }\r\n\r\n        const meshHighlight = this._meshes[mesh.uniqueId];\r\n        if (meshHighlight) {\r\n            if (meshHighlight.observerHighlight) {\r\n                mesh.onBeforeBindObservable.remove(meshHighlight.observerHighlight);\r\n            }\r\n\r\n            if (meshHighlight.observerDefault) {\r\n                mesh.onAfterRenderObservable.remove(meshHighlight.observerDefault);\r\n            }\r\n            delete this._meshes[mesh.uniqueId];\r\n        }\r\n\r\n        this._shouldRender = false;\r\n        for (const meshHighlightToCheck in this._meshes) {\r\n            if (this._meshes[meshHighlightToCheck]) {\r\n                this._shouldRender = true;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove all the meshes currently referenced in the highlight layer\r\n     */\r\n    public removeAllMeshes(): void {\r\n        if (!this._meshes) {\r\n            return;\r\n        }\r\n\r\n        for (const uniqueId in this._meshes) {\r\n            if (Object.prototype.hasOwnProperty.call(this._meshes, uniqueId)) {\r\n                const mesh = this._meshes[uniqueId];\r\n                if (mesh) {\r\n                    this.removeMesh(mesh.mesh);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private _defaultStencilReference(mesh: Mesh) {\r\n        mesh.getScene().getEngine().setStencilFunctionReference(ThinHighlightLayer.NormalMeshStencilReference);\r\n    }\r\n\r\n    public _disposeMesh(mesh: Mesh): void {\r\n        this.removeMesh(mesh);\r\n        this.removeExcludedMesh(mesh);\r\n    }\r\n\r\n    public override dispose(): void {\r\n        if (this._meshes) {\r\n            // Clean mesh references\r\n            for (const id in this._meshes) {\r\n                const meshHighlight = this._meshes[id];\r\n                if (meshHighlight && meshHighlight.mesh) {\r\n                    if (meshHighlight.observerHighlight) {\r\n                        meshHighlight.mesh.onBeforeBindObservable.remove(meshHighlight.observerHighlight);\r\n                    }\r\n\r\n                    if (meshHighlight.observerDefault) {\r\n                        meshHighlight.mesh.onAfterRenderObservable.remove(meshHighlight.observerDefault);\r\n                    }\r\n                }\r\n            }\r\n            this._meshes = null;\r\n        }\r\n\r\n        if (this._excludedMeshes) {\r\n            for (const id in this._excludedMeshes) {\r\n                const meshHighlight = this._excludedMeshes[id];\r\n                if (meshHighlight) {\r\n                    if (meshHighlight.beforeBind) {\r\n                        meshHighlight.mesh.onBeforeBindObservable.remove(meshHighlight.beforeBind);\r\n                    }\r\n\r\n                    if (meshHighlight.afterRender) {\r\n                        meshHighlight.mesh.onAfterRenderObservable.remove(meshHighlight.afterRender);\r\n                    }\r\n                }\r\n            }\r\n            this._excludedMeshes = null;\r\n        }\r\n\r\n        super.dispose();\r\n    }\r\n}\r\n"]}