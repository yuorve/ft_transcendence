{"version":3,"file":"dracoCodec.js","sourceRoot":"","sources":["../../../../../dev/core/src/Meshes/Compression/dracoCodec.ts"],"names":[],"mappings":"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","sourcesContent":["import { Tools } from \"../../Misc/tools\";\r\nimport { AutoReleaseWorkerPool } from \"../../Misc/workerPool\";\r\nimport type { WorkerPool } from \"../../Misc/workerPool\";\r\nimport type { IDisposable } from \"../../scene\";\r\nimport { initializeWebWorker } from \"./dracoCompressionWorker\";\r\n\r\n/**\r\n * Configuration for using a Draco codec.\r\n */\r\nexport interface IDracoCodecConfiguration {\r\n    /**\r\n     * The url to the WebAssembly module.\r\n     */\r\n    wasmUrl?: string;\r\n\r\n    /**\r\n     * The url to the WebAssembly binary.\r\n     */\r\n    wasmBinaryUrl?: string;\r\n\r\n    /**\r\n     * The url to the fallback JavaScript module.\r\n     */\r\n    fallbackUrl?: string;\r\n\r\n    /**\r\n     * The number of workers for async operations. Specify `0` to disable web workers and run synchronously in the current context.\r\n     */\r\n    numWorkers?: number;\r\n\r\n    /**\r\n     * Optional worker pool to use for async encoding/decoding.\r\n     * If provided, the worker pool will be used as is: no Draco scripts will be loaded, and numWorkers will be ignored.\r\n     */\r\n    workerPool?: WorkerPool;\r\n\r\n    /**\r\n     * Optional ArrayBuffer of the WebAssembly binary.\r\n     * If provided it will be used instead of loading the binary from wasmBinaryUrl.\r\n     */\r\n    wasmBinary?: ArrayBuffer;\r\n\r\n    /**\r\n     * The codec module if already available.\r\n     */\r\n    jsModule?: unknown /* DracoDecoderModule | DracoEncoderModule */;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function _GetDefaultNumWorkers(): number {\r\n    if (typeof navigator !== \"object\" || !navigator.hardwareConcurrency) {\r\n        return 1;\r\n    }\r\n\r\n    // Use 50% of the available logical processors but capped at 4.\r\n    return Math.min(Math.floor(navigator.hardwareConcurrency * 0.5), 4);\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function _IsConfigurationAvailable(config: IDracoCodecConfiguration): boolean {\r\n    return !!((config.wasmUrl && (config.wasmBinary || config.wasmBinaryUrl) && typeof WebAssembly === \"object\") || config.fallbackUrl);\r\n    // TODO: Account for jsModule\r\n}\r\n\r\n/**\r\n * Base class for a Draco codec.\r\n * @internal\r\n */\r\nexport abstract class DracoCodec implements IDisposable {\r\n    protected _workerPoolPromise?: Promise<WorkerPool>;\r\n    protected _modulePromise?: Promise<{ module: unknown /** DecoderModule | EncoderModule */ }>;\r\n\r\n    /**\r\n     * Checks if the default codec JS module is in scope.\r\n     */\r\n    protected abstract _isModuleAvailable(): boolean;\r\n\r\n    /**\r\n     * Creates the JS Module for the corresponding wasm.\r\n     */\r\n    protected abstract _createModuleAsync(\r\n        wasmBinary?: ArrayBuffer,\r\n        jsModule?: unknown /** DracoDecoderModule | DracoEncoderModule */\r\n    ): Promise<{ module: unknown /** DecoderModule | EncoderModule */ }>;\r\n\r\n    /**\r\n     * Returns the worker content.\r\n     */\r\n    protected abstract _getWorkerContent(): string;\r\n\r\n    /**\r\n     * Constructor\r\n     * @param configuration The configuration for the DracoCodec instance.\r\n     */\r\n    constructor(configuration: IDracoCodecConfiguration) {\r\n        // check if the codec binary and worker pool was injected\r\n        // Note - it is expected that the developer checked if WebWorker, WebAssembly and the URL object are available\r\n        if (configuration.workerPool) {\r\n            // Set the promise accordingly\r\n            this._workerPoolPromise = Promise.resolve(configuration.workerPool);\r\n            return;\r\n        }\r\n\r\n        // to avoid making big changes to the code here, if wasmBinary is provided use it in the wasmBinaryPromise\r\n        const wasmBinaryProvided = configuration.wasmBinary;\r\n        const numberOfWorkers = configuration.numWorkers ?? _GetDefaultNumWorkers();\r\n        const useWorkers = numberOfWorkers && typeof Worker === \"function\" && typeof URL === \"function\";\r\n        const urlNeeded = useWorkers || !configuration.jsModule;\r\n        // code maintained here for back-compat with no changes\r\n\r\n        const codecInfo: { url: string | undefined; wasmBinaryPromise: Promise<ArrayBuffer | undefined> } =\r\n            configuration.wasmUrl && configuration.wasmBinaryUrl && typeof WebAssembly === \"object\"\r\n                ? {\r\n                      url: urlNeeded ? Tools.GetBabylonScriptURL(configuration.wasmUrl, true) : \"\",\r\n                      wasmBinaryPromise: wasmBinaryProvided\r\n                          ? Promise.resolve(wasmBinaryProvided)\r\n                          : Tools.LoadFileAsync(Tools.GetBabylonScriptURL(configuration.wasmBinaryUrl, true)),\r\n                  }\r\n                : {\r\n                      url: urlNeeded ? Tools.GetBabylonScriptURL(configuration.fallbackUrl!) : \"\",\r\n                      wasmBinaryPromise: Promise.resolve(undefined),\r\n                  };\r\n        // If using workers, initialize a worker pool with either the wasm or url?\r\n        if (useWorkers) {\r\n            this._workerPoolPromise = codecInfo.wasmBinaryPromise.then((wasmBinary) => {\r\n                const workerContent = this._getWorkerContent();\r\n                const workerBlobUrl = URL.createObjectURL(new Blob([workerContent], { type: \"application/javascript\" }));\r\n\r\n                return new AutoReleaseWorkerPool(numberOfWorkers as number, () => {\r\n                    const worker = new Worker(workerBlobUrl);\r\n                    return initializeWebWorker(worker, wasmBinary, codecInfo.url);\r\n                });\r\n            });\r\n        } else {\r\n            this._modulePromise = codecInfo.wasmBinaryPromise.then(async (wasmBinary) => {\r\n                if (!this._isModuleAvailable()) {\r\n                    if (!configuration.jsModule) {\r\n                        if (!codecInfo.url) {\r\n                            throw new Error(\"Draco codec module is not available\");\r\n                        }\r\n                        await Tools.LoadBabylonScriptAsync(codecInfo.url);\r\n                    }\r\n                }\r\n                return this._createModuleAsync(wasmBinary as ArrayBuffer, configuration.jsModule);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns a promise that resolves when ready. Call this manually to ensure the draco codec is ready before use.\r\n     * @returns a promise that resolves when ready\r\n     */\r\n    public async whenReadyAsync(): Promise<void> {\r\n        if (this._workerPoolPromise) {\r\n            await this._workerPoolPromise;\r\n            return;\r\n        }\r\n\r\n        if (this._modulePromise) {\r\n            await this._modulePromise;\r\n            return;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Stop all async operations and release resources.\r\n     */\r\n    public dispose(): void {\r\n        if (this._workerPoolPromise) {\r\n            this._workerPoolPromise.then((workerPool) => {\r\n                workerPool.dispose();\r\n            });\r\n        }\r\n\r\n        delete this._workerPoolPromise;\r\n        delete this._modulePromise;\r\n    }\r\n}\r\n"]}