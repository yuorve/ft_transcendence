{"version":3,"file":"lattice.material.js","sourceRoot":"","sources":["../../../../dev/core/src/Meshes/lattice.material.ts"],"names":[],"mappings":"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","sourcesContent":["import { RawTexture3D } from \"core/Materials/Textures/rawTexture3D\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport { MaterialPluginBase } from \"core/Materials/materialPluginBase\";\r\nimport type { Lattice } from \"./lattice\";\r\nimport type { Nullable } from \"core/types\";\r\nimport { Constants } from \"core/Engines/constants\";\r\nimport { ShaderLanguage } from \"core/Materials/shaderLanguage\";\r\nimport type { UniformBuffer } from \"core/Materials/uniformBuffer\";\r\n\r\n/**\r\n * Material plugin to add hardware accelerated lattice support\r\n * #HBZD72#5 - webgl2\r\n * #HBZD72#6 - webgpu\r\n */\r\nexport class LatticePluginMaterial extends MaterialPluginBase {\r\n    private _lattice: Lattice;\r\n    private _latticeDataTexture: Nullable<RawTexture3D>;\r\n    private _latticeData: Float32Array;\r\n    private _code: string;\r\n\r\n    /**\r\n     * Create a new LatticePluginMaterial\r\n     * @param lattice defines the lattice this plugin is associated with\r\n     * @param material defines the material this plugin is associated with\r\n     */\r\n    constructor(lattice: Lattice, material: Material) {\r\n        super(material, \"Lattice\", 200);\r\n\r\n        this._lattice = lattice;\r\n\r\n        this.refreshData();\r\n\r\n        // let's enable it by default\r\n        this._enable(true);\r\n    }\r\n\r\n    /**\r\n     * Get the class name of the plugin\r\n     * @returns the string \"LatticePluginMaterial\"\r\n     */\r\n    public override getClassName() {\r\n        return \"LatticePluginMaterial\";\r\n    }\r\n\r\n    /**\r\n     * Defines if the plugin supports the specified shader language\r\n     * @param shaderLanguage defines the shader language to check\r\n     * @returns true if supported, false otherwise\r\n     */\r\n    public override isCompatible(shaderLanguage: ShaderLanguage) {\r\n        switch (shaderLanguage) {\r\n            case ShaderLanguage.GLSL:\r\n            case ShaderLanguage.WGSL:\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Must be called when the lattice data was updated\r\n     */\r\n    public refreshData() {\r\n        const length = this._lattice.resolutionX * this._lattice.resolutionY * this._lattice.resolutionZ * 4;\r\n        if (!this._latticeData || this._latticeData.length !== length) {\r\n            this._latticeData = new Float32Array(length);\r\n        }\r\n\r\n        for (let i = 0; i < this._lattice.resolutionX; i++) {\r\n            for (let j = 0; j < this._lattice.resolutionY; j++) {\r\n                for (let k = 0; k < this._lattice.resolutionZ; k++) {\r\n                    const control = this._lattice.data[i][j][k];\r\n                    const index = i + this._lattice.resolutionX * (j + this._lattice.resolutionY * k);\r\n                    control.toArray(this._latticeData, index * 4);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (\r\n            !this._latticeDataTexture ||\r\n            this._latticeDataTexture.width !== this._lattice.resolutionX ||\r\n            this._latticeDataTexture.height !== this._lattice.resolutionY ||\r\n            this._latticeDataTexture.depth !== this._lattice.resolutionZ\r\n        ) {\r\n            if (this._latticeDataTexture) {\r\n                this._latticeDataTexture.dispose();\r\n            }\r\n\r\n            this._latticeDataTexture = new RawTexture3D(\r\n                this._latticeData,\r\n                this._lattice.resolutionX,\r\n                this._lattice.resolutionY,\r\n                this._lattice.resolutionZ,\r\n                Constants.TEXTUREFORMAT_RGBA,\r\n                this._material.getScene(),\r\n                false,\r\n                false,\r\n                Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n                Constants.TEXTURETYPE_FLOAT\r\n            );\r\n        } else {\r\n            this._latticeDataTexture.update(this._latticeData);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the description of the uniforms to add to the ubo (if engine supports ubos) or to inject directly in the vertex/fragment shaders (if engine does not support ubos)\r\n     * @param shaderLanguage The shader language to use.\r\n     * @returns the description of the uniforms\r\n     */\r\n    public override getUniforms(shaderLanguage: ShaderLanguage = ShaderLanguage.GLSL): {\r\n        ubo: { name: string; size: number; type: string; arraySize?: number }[];\r\n        vertex?: string;\r\n        fragment?: string;\r\n    } {\r\n        if (shaderLanguage === ShaderLanguage.WGSL) {\r\n            // For webgpu we only define the UBO with the correct type and size.\r\n            return {\r\n                ubo: [\r\n                    { name: \"lattice_cellSize\", size: 3, type: \"vec3\" },\r\n                    { name: \"lattice_min\", size: 3, type: \"vec3\" },\r\n                    { name: \"lattice_max\", size: 3, type: \"vec3\" },\r\n                    { name: \"lattice_resolution\", size: 3, type: \"vec3\" },\r\n                    { name: \"lattice_position\", size: 3, type: \"vec3\" },\r\n                ],\r\n            };\r\n        }\r\n        return {\r\n            // first, define the UBO with the correct type and size.\r\n            ubo: [\r\n                { name: \"lattice_cellSize\", size: 3, type: \"vec3\" },\r\n                { name: \"lattice_min\", size: 3, type: \"vec3\" },\r\n                { name: \"lattice_max\", size: 3, type: \"vec3\" },\r\n                { name: \"lattice_resolution\", size: 3, type: \"vec3\" },\r\n                { name: \"lattice_position\", size: 3, type: \"vec3\" },\r\n            ],\r\n            // now, on the vertex shader, add the uniform itself in case uniform buffers are not supported by the engine\r\n            vertex: `\r\n                    uniform vec3 lattice_cellSize;\r\n                    uniform vec3 lattice_min;\r\n                    uniform vec3 lattice_max;\r\n                    uniform vec3 lattice_resolution;\r\n                    uniform vec3 lattice_position;\r\n                    `,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Binds the material data.\r\n     * @param uniformBuffer defines the Uniform buffer to fill in.\r\n     */\r\n    public override bindForSubMesh(uniformBuffer: UniformBuffer) {\r\n        this._lattice.updateInternals();\r\n\r\n        uniformBuffer.updateVector3(\"lattice_cellSize\", this._lattice.cellSize);\r\n        uniformBuffer.updateVector3(\"lattice_min\", this._lattice.min);\r\n        uniformBuffer.updateVector3(\"lattice_max\", this._lattice.max);\r\n        uniformBuffer.updateFloat3(\"lattice_resolution\", this._lattice.resolutionX, this._lattice.resolutionY, this._lattice.resolutionZ);\r\n        uniformBuffer.updateVector3(\"lattice_position\", this._lattice.position);\r\n\r\n        uniformBuffer.setTexture(\"latticeData\", this._latticeDataTexture);\r\n    }\r\n\r\n    /**\r\n     * Gets the samplers used by the plugin.\r\n     * @param samplers list that the sampler names should be added to.\r\n     */\r\n    public override getSamplers(samplers: string[]): void {\r\n        samplers.push(\"latticeData\");\r\n    }\r\n\r\n    private _prepareCode(shaderLanguage = ShaderLanguage.GLSL) {\r\n        if (this._code) {\r\n            return this._code;\r\n        }\r\n\r\n        let code = `\r\n            if (positionUpdated.x >= lattice_min.x && positionUpdated.x <= lattice_max.x &&\r\n                positionUpdated.y >= lattice_min.y && positionUpdated.y <= lattice_max.y &&\r\n                positionUpdated.z >= lattice_min.z && positionUpdated.z <= lattice_max.z) {\r\n\r\n                // Map vertex position to lattice local coordinates\r\n                vec3d localPos = vec3c((positionUpdated.x - lattice_min.x) / lattice_cellSize.x, (positionUpdated.y - lattice_min.y) / lattice_cellSize.y, (positionUpdated.z - lattice_min.z) / lattice_cellSize.z);\r\n\r\n                // Get integer lattice indices\r\n                intd i0 = intc(floor(localPos.x));\r\n                intd j0 = intc(floor(localPos.y));\r\n                intd k0 = intc(floor(localPos.z));\r\n\r\n                intd resX = intc(lattice_resolution.x) - 1;\r\n                intd resY = intc(lattice_resolution.y) - 1;\r\n                intd resZ = intc(lattice_resolution.z) - 1;\r\n\r\n                intd i1 = min(i0 + 1, resX);\r\n                intd j1 = min(j0 + 1, resY);\r\n                intd k1 = min(k0 + 1, resZ);\r\n\r\n                // Compute interpolation weights\r\n                floatd tx = localPos.x - floatc(i0);\r\n                floatd ty = localPos.y - floatc(j0);\r\n                floatd tz = localPos.z - floatc(k0);\r\n\r\n                // Ensure indices are within bounds\r\n                intd ii0 = clamp(i0, 0, resX);\r\n                intd jj0 = clamp(j0, 0, resY);\r\n                intd kk0 = clamp(k0, 0, resZ);\r\n                intd ii1 = clamp(i1, 0, resX);\r\n                intd jj1 = clamp(j1, 0, resY);\r\n                intd kk1 = clamp(k1, 0, resZ);\r\n\r\n                // Get lattice control points\r\n                vec3d p000 = texelFetch(latticeData, ivec3c(ii0, jj0, kk0), 0).rgb;\r\n                vec3d p100 = texelFetch(latticeData, ivec3c(ii1, jj0, kk0), 0).rgb;\r\n                vec3d p010 = texelFetch(latticeData, ivec3c(ii0, jj1, kk0), 0).rgb;\r\n                vec3d p110 = texelFetch(latticeData, ivec3c(ii1, jj1, kk0), 0).rgb;\r\n                vec3d p001 = texelFetch(latticeData, ivec3c(ii0, jj0, kk1), 0).rgb;\r\n                vec3d p101 = texelFetch(latticeData, ivec3c(ii1, jj0, kk1), 0).rgb;\r\n                vec3d p011 = texelFetch(latticeData, ivec3c(ii0, jj1, kk1), 0).rgb;\r\n                vec3d p111 = texelFetch(latticeData, ivec3c(ii1, jj1, kk1), 0).rgb;\r\n\r\n                // Trilinear interpolation\r\n                vec3d p00 = mix(p000, p100, tx);\r\n                vec3d p01 = mix(p001, p101, tx);\r\n                vec3d p10 = mix(p010, p110, tx);\r\n                vec3d p11 = mix(p011, p111, tx);\r\n\r\n                vec3d p0 = mix(p00, p10, ty);\r\n                vec3d p1 = mix(p01, p11, ty);\r\n\r\n                vec3d deformedPos = mix(p0, p1, tz);\r\n                positionUpdated = deformedPos + lattice_position;\r\n            };\r\n        `;\r\n\r\n        if (shaderLanguage === ShaderLanguage.WGSL) {\r\n            code =\r\n                `\r\n                let lattice_min = uniforms.lattice_min;\r\n                let lattice_max = uniforms.lattice_max;\r\n                let lattice_resolution = uniforms.lattice_resolution;\r\n                let lattice_position = uniforms.lattice_position;\r\n                let lattice_cellSize = uniforms.lattice_cellSize;\r\n            ` + code;\r\n\r\n            code = code.replace(/ivec3c/g, \"vec3i\");\r\n            code = code.replace(/vec3d/g, \"var\");\r\n            code = code.replace(/vec3c/g, \"vec3f\");\r\n            code = code.replace(/intd/g, \"var\");\r\n            code = code.replace(/intc/g, \"i32\");\r\n            code = code.replace(/floatd/g, \"var\");\r\n            code = code.replace(/floatc/g, \"f32\");\r\n            code = code.replace(/texelFetch/g, \"textureLoad\");\r\n        } else {\r\n            code = code.replace(/ivec3c/g, \"ivec3\");\r\n            code = code.replace(/vec3d/g, \"vec3\");\r\n            code = code.replace(/vec3c/g, \"vec3\");\r\n            code = code.replace(/intd/g, \"int\");\r\n            code = code.replace(/intc/g, \"int\");\r\n            code = code.replace(/floatd/g, \"float\");\r\n            code = code.replace(/floatc/g, \"float\");\r\n        }\r\n        this._code = code;\r\n\r\n        return this._code;\r\n    }\r\n\r\n    /**\r\n     * Returns a list of custom shader code fragments to customize the shader.\r\n     * @param shaderType \"vertex\" or \"fragment\"\r\n     * @param shaderLanguage The shader language to use.\r\n     * @returns null if no code to be added, or a list of pointName =\\> code.\r\n     */\r\n    public override getCustomCode(shaderType: string, shaderLanguage = ShaderLanguage.GLSL) {\r\n        if (shaderType === \"vertex\") {\r\n            // we're adding this specific code at the end of the main() function\r\n            if (shaderLanguage === ShaderLanguage.WGSL) {\r\n                return {\r\n                    CUSTOM_VERTEX_DEFINITIONS: `\r\n                        var latticeData: texture_3d<f32>;\r\n                    `,\r\n                    CUSTOM_VERTEX_UPDATE_POSITION: this._prepareCode(shaderLanguage),\r\n                };\r\n            }\r\n\r\n            return {\r\n                CUSTOM_VERTEX_DEFINITIONS: `\r\n                    precision highp sampler3D;\r\n                    uniform sampler3D latticeData;\r\n                `,\r\n                CUSTOM_VERTEX_UPDATE_POSITION: this._prepareCode(shaderLanguage),\r\n            };\r\n        }\r\n        // for other shader types we're not doing anything, return null\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Disposes the resources of the material.\r\n     */\r\n    public override dispose(): void {\r\n        if (this._latticeDataTexture) {\r\n            this._latticeDataTexture.dispose();\r\n            this._latticeDataTexture = null;\r\n        }\r\n    }\r\n}\r\n"]}