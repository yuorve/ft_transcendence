{"version":3,"file":"greasedLine.vertex.js","sourceRoot":"","sources":["../../../../dev/core/src/ShadersWGSL/greasedLine.vertex.ts"],"names":[],"mappings":"AAAA,eAAe;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;AACrD,OAAO,uCAAuC,CAAC;AAC/C,OAAO,sCAAsC,CAAC;AAC9C,OAAO,qCAAqC,CAAC;AAC7C,OAAO,kCAAkC,CAAC;AAE1C,MAAM,IAAI,GAAG,yBAAyB,CAAC;AACvC,MAAM,MAAM,GAAG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAwCd,CAAC;AACF,aAAa;AACb,WAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAC5C,gBAAgB;AAChB,MAAM,CAAC,MAAM,2BAA2B,GAAG,EAAE,IAAI,EAAE,MAAM,EAAE,CAAC","sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/instancesDeclaration\";\nimport \"./ShadersInclude/sceneUboDeclaration\";\nimport \"./ShadersInclude/meshUboDeclaration\";\nimport \"./ShadersInclude/instancesVertex\";\n\nconst name = \"greasedLineVertexShader\";\nconst shader = `#include<instancesDeclaration>\n#include<sceneUboDeclaration>\n#include<meshUboDeclaration>\nattribute grl_widths: f32;\n#ifdef GREASED_LINE_USE_OFFSETS\nattribute grl_offsets: vec3f; \n#endif\nattribute grl_colorPointers: f32;attribute position: vec3f;varying grlCounters: f32;varying grlColorPointer: f32;\n#ifdef GREASED_LINE_CAMERA_FACING\nattribute grl_nextAndCounters: vec4f;attribute grl_previousAndSide: vec4f;uniform grlResolution: vec2f;uniform grlAspect: f32;uniform grlWidth: f32;uniform grlSizeAttenuation: f32;fn grlFix(i: vec4f,aspect: f32)->vec2f {var res=i.xy/i.w;res.x*=aspect;return res;}\n#else\nattribute grl_slopes: vec3f;attribute grl_counters: f32;\n#endif\n#define CUSTOM_VERTEX_DEFINITIONS\n@vertex\nfn main(input : VertexInputs)->FragmentInputs {\n#define CUSTOM_VERTEX_MAIN_BEGIN\n#include<instancesVertex>\nvertexOutputs.grlColorPointer=input.grl_colorPointers;let grlMatrix: mat4x4f=scene.viewProjection*mesh.world ;\n#ifdef GREASED_LINE_CAMERA_FACING\nlet grlBaseWidth: f32=uniforms.grlWidth;let grlPrevious: vec3f=input.grl_previousAndSide.xyz;let grlSide: f32=input.grl_previousAndSide.w;let grlNext: vec3f=input.grl_nextAndCounters.xyz;vertexOutputs.grlCounters=input.grl_nextAndCounters.w;\n#ifdef GREASED_LINE_USE_OFFSETS\nvar grlPositionOffset: vec3f=input.grl_offsets;\n#else\nvar grlPositionOffset=vec3f(0.);\n#endif\nlet grlFinalPosition: vec4f=grlMatrix*vec4f(vertexInputs.position+grlPositionOffset ,1.0);let grlPrevPos: vec4f=grlMatrix*vec4f(grlPrevious+grlPositionOffset,1.0);let grlNextPos: vec4f=grlMatrix*vec4f(grlNext+grlPositionOffset,1.0);let grlCurrentP: vec2f=grlFix(grlFinalPosition,uniforms.grlAspect);let grlPrevP: vec2f=grlFix(grlPrevPos,uniforms.grlAspect);let grlNextP: vec2f= grlFix(grlNextPos,uniforms.grlAspect);let grlWidth:f32=grlBaseWidth*input.grl_widths;var grlDir: vec2f;if (all(grlNextP==grlCurrentP)) {grlDir=normalize(grlCurrentP-grlPrevP);} else if (all(grlPrevP==grlCurrentP)) {grlDir=normalize(grlNextP-grlCurrentP);} else {let grlDir1: vec2f=normalize(grlCurrentP-grlPrevP);let grlDir2: vec2f=normalize(grlNextP-grlCurrentP);grlDir=normalize(grlDir1+grlDir2);}\nvar grlNormal: vec4f=vec4f(-grlDir.y,grlDir.x,0.0,1.0);let grlHalfWidth: f32=0.5*grlWidth;\n#if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\ngrlNormal.x*=-grlHalfWidth;grlNormal.y*=-grlHalfWidth;\n#else\ngrlNormal.x*=grlHalfWidth;grlNormal.y*=grlHalfWidth;\n#endif\ngrlNormal*=scene.projection;if (uniforms.grlSizeAttenuation==1.) {grlNormal.x*=grlFinalPosition.w;grlNormal.y*=grlFinalPosition.w;let pr=vec4f(uniforms.grlResolution,0.0,1.0)*scene.projection;grlNormal.x/=pr.x;grlNormal.y/=pr.y;}\nvertexOutputs.position=vec4f(grlFinalPosition.xy+grlNormal.xy*grlSide,grlFinalPosition.z,grlFinalPosition.w);\n#else\nvertexOutputs.grlCounters=input.grl_counters;vertexOutputs.position=grlMatrix*vec4f((vertexInputs.position+input.grl_offsets)+input.grl_slopes*input.grl_widths,1.0) ;\n#endif\n#define CUSTOM_VERTEX_MAIN_END\n}\n`;\n// Sideeffect\nShaderStore.ShadersStoreWGSL[name] = shader;\n/** @internal */\nexport const greasedLineVertexShaderWGSL = { name, shader };\n"]}