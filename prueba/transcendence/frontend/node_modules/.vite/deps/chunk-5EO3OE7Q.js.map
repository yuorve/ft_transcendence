{
  "version": 3,
  "sources": ["../../../dev/core/src/Misc/bitArray.ts", "../../../dev/core/src/Meshes/mesh.vertexData.functions.ts"],
  "sourcesContent": ["function getByteIndex(bitIndex: number): number {\r\n    return Math.floor(bitIndex / 8);\r\n}\r\n\r\nfunction getBitMask(bitIndex: number): number {\r\n    return 1 << bitIndex % 8;\r\n}\r\n\r\n/**\r\n * An fixed size array that effectively stores boolean values where each value is a single bit of backing data.\r\n * @remarks\r\n * All bits are initialized to false.\r\n */\r\nexport class BitArray {\r\n    private readonly _byteArray: Uint8Array;\r\n\r\n    /**\r\n     * Creates a new bit array with a fixed size.\r\n     * @param size The number of bits to store.\r\n     */\r\n    public constructor(public readonly size: number) {\r\n        this._byteArray = new Uint8Array(Math.ceil(this.size / 8));\r\n    }\r\n\r\n    /**\r\n     * Gets the current value at the specified index.\r\n     * @param bitIndex The index to get the value from.\r\n     * @returns The value at the specified index.\r\n     */\r\n    public get(bitIndex: number): boolean {\r\n        if (bitIndex >= this.size) {\r\n            throw new RangeError(\"Bit index out of range\");\r\n        }\r\n        const byteIndex = getByteIndex(bitIndex);\r\n        const bitMask = getBitMask(bitIndex);\r\n        return (this._byteArray[byteIndex] & bitMask) !== 0;\r\n    }\r\n\r\n    /**\r\n     * Sets the value at the specified index.\r\n     * @param bitIndex The index to set the value at.\r\n     * @param value The value to set.\r\n     */\r\n    public set(bitIndex: number, value: boolean): void {\r\n        if (bitIndex >= this.size) {\r\n            throw new RangeError(\"Bit index out of range\");\r\n        }\r\n        const byteIndex = getByteIndex(bitIndex);\r\n        const bitMask = getBitMask(bitIndex);\r\n        if (value) {\r\n            this._byteArray[byteIndex] |= bitMask;\r\n        } else {\r\n            this._byteArray[byteIndex] &= ~bitMask;\r\n        }\r\n    }\r\n}\r\n", "import type { IndicesArray } from \"core/types\";\r\nimport { BitArray } from \"core/Misc/bitArray\";\r\n\r\n/**\r\n * Sort (in place) the index array so that faces with common indices are close\r\n * @param indices the array of indices to sort\r\n */\r\nexport function OptimizeIndices(indices: IndicesArray) {\r\n    const faces: Array<Array<number>> = [];\r\n    const faceCount = indices.length / 3;\r\n\r\n    // Step 1: Break the indices array into faces\r\n    for (let i = 0; i < faceCount; i++) {\r\n        faces.push([indices[i * 3], indices[i * 3 + 1], indices[i * 3 + 2]]);\r\n    }\r\n\r\n    // Step 2: Build a graph connecting faces sharing a vertex\r\n    const vertexToFaceMap = new Map<number, number[]>();\r\n    faces.forEach((face, faceIndex) => {\r\n        face.forEach((vertex) => {\r\n            let face = vertexToFaceMap.get(vertex);\r\n            if (!face) {\r\n                vertexToFaceMap.set(vertex, (face = []));\r\n            }\r\n            face.push(faceIndex);\r\n        });\r\n    });\r\n\r\n    // Step 3: Traverse faces using DFS to ensure connected faces are close\r\n    const visited = new BitArray(faceCount);\r\n    const sortedFaces: Array<number[]> = [];\r\n\r\n    // Using a stack and not a recursive version to avoid call stack overflow\r\n    const deepFirstSearchStack = (startFaceIndex: number) => {\r\n        const stack: Array<number> = [startFaceIndex];\r\n\r\n        while (stack.length > 0) {\r\n            const currentFaceIndex = stack.pop()!;\r\n\r\n            if (visited.get(currentFaceIndex)) {\r\n                continue;\r\n            }\r\n            visited.set(currentFaceIndex, true);\r\n            sortedFaces.push(faces[currentFaceIndex]);\r\n\r\n            // Push unvisited neighbors (faces sharing a vertex) onto the stack\r\n            faces[currentFaceIndex].forEach((vertex) => {\r\n                const neighbors = vertexToFaceMap.get(vertex);\r\n\r\n                if (!neighbors) {\r\n                    return;\r\n                }\r\n\r\n                neighbors.forEach((neighborFaceIndex) => {\r\n                    if (!visited.get(neighborFaceIndex)) {\r\n                        stack.push(neighborFaceIndex);\r\n                    }\r\n                });\r\n            });\r\n        }\r\n    };\r\n\r\n    // Start DFS from the first face\r\n    for (let i = 0; i < faceCount; i++) {\r\n        if (!visited.get(i)) {\r\n            deepFirstSearchStack(i);\r\n        }\r\n    }\r\n\r\n    // Step 4: Flatten the sorted faces back into an array\r\n    let index = 0;\r\n    sortedFaces.forEach((face) => {\r\n        indices[index++] = face[0];\r\n        indices[index++] = face[1];\r\n        indices[index++] = face[2];\r\n    });\r\n}\r\n"],
  "mappings": ";AAAA,SAAS,aAAa,UAAgB;AAClC,SAAO,KAAK,MAAM,WAAW,CAAC;AAClC;AAEA,SAAS,WAAW,UAAgB;AAChC,SAAO,KAAK,WAAW;AAC3B;AAOM,IAAO,WAAP,MAAe;;;;;EAOjB,YAAmC,MAAY;AAAZ,SAAA,OAAA;AAC/B,SAAK,aAAa,IAAI,WAAW,KAAK,KAAK,KAAK,OAAO,CAAC,CAAC;EAC7D;;;;;;EAOO,IAAI,UAAgB;AACvB,QAAI,YAAY,KAAK,MAAM;AACvB,YAAM,IAAI,WAAW,wBAAwB;IACjD;AACA,UAAM,YAAY,aAAa,QAAQ;AACvC,UAAM,UAAU,WAAW,QAAQ;AACnC,YAAQ,KAAK,WAAW,SAAS,IAAI,aAAa;EACtD;;;;;;EAOO,IAAI,UAAkB,OAAc;AACvC,QAAI,YAAY,KAAK,MAAM;AACvB,YAAM,IAAI,WAAW,wBAAwB;IACjD;AACA,UAAM,YAAY,aAAa,QAAQ;AACvC,UAAM,UAAU,WAAW,QAAQ;AACnC,QAAI,OAAO;AACP,WAAK,WAAW,SAAS,KAAK;IAClC,OAAO;AACH,WAAK,WAAW,SAAS,KAAK,CAAC;IACnC;EACJ;;;;AC/CE,SAAU,gBAAgB,SAAqB;AACjD,QAAM,QAA8B,CAAA;AACpC,QAAM,YAAY,QAAQ,SAAS;AAGnC,WAAS,IAAI,GAAG,IAAI,WAAW,KAAK;AAChC,UAAM,KAAK,CAAC,QAAQ,IAAI,CAAC,GAAG,QAAQ,IAAI,IAAI,CAAC,GAAG,QAAQ,IAAI,IAAI,CAAC,CAAC,CAAC;EACvE;AAGA,QAAM,kBAAkB,oBAAI,IAAG;AAC/B,QAAM,QAAQ,CAAC,MAAM,cAAa;AAC9B,SAAK,QAAQ,CAAC,WAAU;AACpB,UAAIA,QAAO,gBAAgB,IAAI,MAAM;AACrC,UAAI,CAACA,OAAM;AACP,wBAAgB,IAAI,QAASA,QAAO,CAAA,CAAG;MAC3C;AACA,MAAAA,MAAK,KAAK,SAAS;IACvB,CAAC;EACL,CAAC;AAGD,QAAM,UAAU,IAAI,SAAS,SAAS;AACtC,QAAM,cAA+B,CAAA;AAGrC,QAAM,uBAAuB,CAAC,mBAA0B;AACpD,UAAM,QAAuB,CAAC,cAAc;AAE5C,WAAO,MAAM,SAAS,GAAG;AACrB,YAAM,mBAAmB,MAAM,IAAG;AAElC,UAAI,QAAQ,IAAI,gBAAgB,GAAG;AAC/B;MACJ;AACA,cAAQ,IAAI,kBAAkB,IAAI;AAClC,kBAAY,KAAK,MAAM,gBAAgB,CAAC;AAGxC,YAAM,gBAAgB,EAAE,QAAQ,CAAC,WAAU;AACvC,cAAM,YAAY,gBAAgB,IAAI,MAAM;AAE5C,YAAI,CAAC,WAAW;AACZ;QACJ;AAEA,kBAAU,QAAQ,CAAC,sBAAqB;AACpC,cAAI,CAAC,QAAQ,IAAI,iBAAiB,GAAG;AACjC,kBAAM,KAAK,iBAAiB;UAChC;QACJ,CAAC;MACL,CAAC;IACL;EACJ;AAGA,WAAS,IAAI,GAAG,IAAI,WAAW,KAAK;AAChC,QAAI,CAAC,QAAQ,IAAI,CAAC,GAAG;AACjB,2BAAqB,CAAC;IAC1B;EACJ;AAGA,MAAI,QAAQ;AACZ,cAAY,QAAQ,CAAC,SAAQ;AACzB,YAAQ,OAAO,IAAI,KAAK,CAAC;AACzB,YAAQ,OAAO,IAAI,KAAK,CAAC;AACzB,YAAQ,OAAO,IAAI,KAAK,CAAC;EAC7B,CAAC;AACL;",
  "names": ["face"]
}
