import {
  VertexBuffer
} from "./chunk-4NAEY6NG.js";
import {
  Effect,
  TimingTools
} from "./chunk-3EDTXWHH.js";
import {
  Observable
} from "./chunk-RUCF343I.js";

// node_modules/@babylonjs/core/Maths/math.viewport.js
var Viewport = class _Viewport {
  /**
   * Creates a Viewport object located at (x, y) and sized (width, height)
   * @param x defines viewport left coordinate
   * @param y defines viewport top coordinate
   * @param width defines the viewport width
   * @param height defines the viewport height
   */
  constructor(x, y, width, height) {
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
  }
  /**
   * Creates a new viewport using absolute sizing (from 0-> width, 0-> height instead of 0->1)
   * @param renderWidth defines the rendering width
   * @param renderHeight defines the rendering height
   * @returns a new Viewport
   */
  toGlobal(renderWidth, renderHeight) {
    return new _Viewport(this.x * renderWidth, this.y * renderHeight, this.width * renderWidth, this.height * renderHeight);
  }
  /**
   * Stores absolute viewport value into a target viewport (from 0-> width, 0-> height instead of 0->1)
   * @param renderWidth defines the rendering width
   * @param renderHeight defines the rendering height
   * @param ref defines the target viewport
   * @returns the current viewport
   */
  toGlobalToRef(renderWidth, renderHeight, ref) {
    ref.x = this.x * renderWidth;
    ref.y = this.y * renderHeight;
    ref.width = this.width * renderWidth;
    ref.height = this.height * renderHeight;
    return this;
  }
  /**
   * Returns a new Viewport copied from the current one
   * @returns a new Viewport
   */
  clone() {
    return new _Viewport(this.x, this.y, this.width, this.height);
  }
};

// node_modules/@babylonjs/core/Materials/drawWrapper.js
var DrawWrapper = class {
  static GetEffect(effect) {
    return effect.getPipelineContext === void 0 ? effect.effect : effect;
  }
  constructor(engine, createMaterialContext = true) {
    this._wasPreviouslyReady = false;
    this._forceRebindOnNextCall = true;
    this._wasPreviouslyUsingInstances = null;
    this.effect = null;
    this.defines = null;
    this.drawContext = engine.createDrawContext();
    if (createMaterialContext) {
      this.materialContext = engine.createMaterialContext();
    }
  }
  setEffect(effect, defines, resetContext = true) {
    var _a;
    this.effect = effect;
    if (defines !== void 0) {
      this.defines = defines;
    }
    if (resetContext) {
      (_a = this.drawContext) == null ? void 0 : _a.reset();
    }
  }
  /**
   * Dispose the effect wrapper and its resources
   * @param immediate if the effect should be disposed immediately or on the next frame.
   * If dispose() is not called during a scene or engine dispose, we want to delay the dispose of the underlying effect. Mostly to give a chance to user code to reuse the effect in some way.
   */
  dispose(immediate = false) {
    var _a;
    if (this.effect) {
      const effect = this.effect;
      if (immediate) {
        effect.dispose();
      } else {
        TimingTools.SetImmediate(() => {
          effect.getEngine().onEndFrameObservable.addOnce(() => {
            effect.dispose();
          });
        });
      }
      this.effect = null;
    }
    (_a = this.drawContext) == null ? void 0 : _a.dispose();
  }
};

// node_modules/@babylonjs/core/Materials/effectRenderer.js
var defaultOptions = {
  positions: [1, 1, -1, 1, -1, -1, 1, -1],
  indices: [0, 1, 2, 0, 2, 3]
};
var EffectRenderer = class {
  /**
   * Creates an effect renderer
   * @param engine the engine to use for rendering
   * @param options defines the options of the effect renderer
   */
  constructor(engine, options = defaultOptions) {
    this._fullscreenViewport = new Viewport(0, 0, 1, 1);
    const positions = options.positions ?? defaultOptions.positions;
    const indices = options.indices ?? defaultOptions.indices;
    this.engine = engine;
    this._vertexBuffers = {
      [VertexBuffer.PositionKind]: new VertexBuffer(engine, positions, VertexBuffer.PositionKind, false, false, 2)
    };
    this._indexBuffer = engine.createIndexBuffer(indices);
    this._onContextRestoredObserver = engine.onContextRestoredObservable.add(() => {
      this._indexBuffer = engine.createIndexBuffer(indices);
      for (const key in this._vertexBuffers) {
        const vertexBuffer = this._vertexBuffers[key];
        vertexBuffer._rebuild();
      }
    });
  }
  /**
   * Sets the current viewport in normalized coordinates 0-1
   * @param viewport Defines the viewport to set (defaults to 0 0 1 1)
   */
  setViewport(viewport = this._fullscreenViewport) {
    this.engine.setViewport(viewport);
  }
  /**
   * Binds the embedded attributes buffer to the effect.
   * @param effect Defines the effect to bind the attributes for
   */
  bindBuffers(effect) {
    this.engine.bindBuffers(this._vertexBuffers, this._indexBuffer, effect);
  }
  /**
   * Sets the current effect wrapper to use during draw.
   * The effect needs to be ready before calling this api.
   * This also sets the default full screen position attribute.
   * @param effectWrapper Defines the effect to draw with
   */
  applyEffectWrapper(effectWrapper) {
    this.engine.setState(true);
    this.engine.depthCullingState.depthTest = false;
    this.engine.stencilState.stencilTest = false;
    this.engine.enableEffect(effectWrapper.drawWrapper);
    this.bindBuffers(effectWrapper.effect);
    effectWrapper.onApplyObservable.notifyObservers({});
  }
  /**
   * Saves engine states
   */
  saveStates() {
    this._savedStateDepthTest = this.engine.depthCullingState.depthTest;
    this._savedStateStencilTest = this.engine.stencilState.stencilTest;
  }
  /**
   * Restores engine states
   */
  restoreStates() {
    this.engine.depthCullingState.depthTest = this._savedStateDepthTest;
    this.engine.stencilState.stencilTest = this._savedStateStencilTest;
  }
  /**
   * Draws a full screen quad.
   */
  draw() {
    this.engine.drawElementsType(0, 0, 6);
  }
  _isRenderTargetTexture(texture) {
    return texture.renderTarget !== void 0;
  }
  /**
   * renders one or more effects to a specified texture
   * @param effectWrapper the effect to renderer
   * @param outputTexture texture to draw to, if null it will render to the currently bound frame buffer
   */
  render(effectWrapper, outputTexture = null) {
    if (!effectWrapper.effect.isReady()) {
      return;
    }
    this.saveStates();
    this.setViewport();
    const out = outputTexture === null ? null : this._isRenderTargetTexture(outputTexture) ? outputTexture.renderTarget : outputTexture;
    if (out) {
      this.engine.bindFramebuffer(out);
    }
    this.applyEffectWrapper(effectWrapper);
    this.draw();
    if (out) {
      this.engine.unBindFramebuffer(out);
    }
    this.restoreStates();
  }
  /**
   * Disposes of the effect renderer
   */
  dispose() {
    const vertexBuffer = this._vertexBuffers[VertexBuffer.PositionKind];
    if (vertexBuffer) {
      vertexBuffer.dispose();
      delete this._vertexBuffers[VertexBuffer.PositionKind];
    }
    if (this._indexBuffer) {
      this.engine._releaseBuffer(this._indexBuffer);
    }
    if (this._onContextRestoredObserver) {
      this.engine.onContextRestoredObservable.remove(this._onContextRestoredObserver);
      this._onContextRestoredObserver = null;
    }
  }
};
var EffectWrapper = class _EffectWrapper {
  /**
   * Registers a shader code processing with an effect wrapper name.
   * @param effectWrapperName name of the effect wrapper. Use null for the fallback shader code processing. This is the shader code processing that will be used in case no specific shader code processing has been associated to an effect wrapper name
   * @param customShaderCodeProcessing shader code processing to associate to the effect wrapper name
   */
  static RegisterShaderCodeProcessing(effectWrapperName, customShaderCodeProcessing) {
    if (!customShaderCodeProcessing) {
      delete _EffectWrapper._CustomShaderCodeProcessing[effectWrapperName ?? ""];
      return;
    }
    _EffectWrapper._CustomShaderCodeProcessing[effectWrapperName ?? ""] = customShaderCodeProcessing;
  }
  static _GetShaderCodeProcessing(effectWrapperName) {
    return _EffectWrapper._CustomShaderCodeProcessing[effectWrapperName] ?? _EffectWrapper._CustomShaderCodeProcessing[""];
  }
  /**
   * Gets or sets the name of the effect wrapper
   */
  get name() {
    return this.options.name;
  }
  set name(value) {
    this.options.name = value;
  }
  /**
   * Get a value indicating if the effect is ready to be used
   * @returns true if the post-process is ready (shader is compiled)
   */
  isReady() {
    var _a;
    return ((_a = this._drawWrapper.effect) == null ? void 0 : _a.isReady()) ?? false;
  }
  /**
   * Get the draw wrapper associated with the effect wrapper
   * @returns the draw wrapper associated with the effect wrapper
   */
  get drawWrapper() {
    return this._drawWrapper;
  }
  /**
   * The underlying effect
   */
  get effect() {
    return this._drawWrapper.effect;
  }
  set effect(effect) {
    this._drawWrapper.effect = effect;
  }
  /**
   * Creates an effect to be rendered
   * @param creationOptions options to create the effect
   */
  constructor(creationOptions) {
    this.alphaMode = 0;
    this.onEffectCreatedObservable = new Observable(void 0, true);
    this.onApplyObservable = new Observable();
    this._shadersLoaded = false;
    this._webGPUReady = false;
    this._importPromises = [];
    this.options = {
      ...creationOptions,
      name: creationOptions.name || "effectWrapper",
      engine: creationOptions.engine,
      uniforms: creationOptions.uniforms || creationOptions.uniformNames || [],
      uniformNames: void 0,
      samplers: creationOptions.samplers || creationOptions.samplerNames || [],
      samplerNames: void 0,
      attributeNames: creationOptions.attributeNames || ["position"],
      uniformBuffers: creationOptions.uniformBuffers || [],
      defines: creationOptions.defines || "",
      useShaderStore: creationOptions.useShaderStore || false,
      vertexUrl: creationOptions.vertexUrl || creationOptions.vertexShader || "postprocess",
      vertexShader: void 0,
      fragmentShader: creationOptions.fragmentShader || "pass",
      indexParameters: creationOptions.indexParameters,
      blockCompilation: creationOptions.blockCompilation || false,
      shaderLanguage: creationOptions.shaderLanguage || 0,
      onCompiled: creationOptions.onCompiled || void 0,
      extraInitializations: creationOptions.extraInitializations || void 0,
      extraInitializationsAsync: creationOptions.extraInitializationsAsync || void 0,
      useAsPostProcess: creationOptions.useAsPostProcess ?? false
    };
    this.options.uniformNames = this.options.uniforms;
    this.options.samplerNames = this.options.samplers;
    this.options.vertexShader = this.options.vertexUrl;
    if (this.options.useAsPostProcess) {
      if (this.options.samplers.indexOf("textureSampler") === -1) {
        this.options.samplers.push("textureSampler");
      }
      if (this.options.uniforms.indexOf("scale") === -1) {
        this.options.uniforms.push("scale");
      }
    }
    if (creationOptions.vertexUrl || creationOptions.vertexShader) {
      this._shaderPath = {
        vertexSource: this.options.vertexShader
      };
    } else {
      if (!this.options.useAsPostProcess) {
        this.options.uniforms.push("scale");
        this.onApplyObservable.add(() => {
          this.effect.setFloat2("scale", 1, 1);
        });
      }
      this._shaderPath = {
        vertex: this.options.vertexShader
      };
    }
    this._shaderPath.fragmentSource = this.options.fragmentShader;
    this._shaderPath.spectorName = this.options.name;
    if (this.options.useShaderStore) {
      this._shaderPath.fragment = this._shaderPath.fragmentSource;
      if (!this._shaderPath.vertex) {
        this._shaderPath.vertex = this._shaderPath.vertexSource;
      }
      delete this._shaderPath.fragmentSource;
      delete this._shaderPath.vertexSource;
    }
    this.onApplyObservable.add(() => {
      this.bind();
    });
    if (!this.options.useShaderStore) {
      this._onContextRestoredObserver = this.options.engine.onContextRestoredObservable.add(() => {
        this.effect._pipelineContext = null;
        this.effect._prepareEffect();
      });
    }
    this._drawWrapper = new DrawWrapper(this.options.engine);
    this._webGPUReady = this.options.shaderLanguage === 1;
    const defines = Array.isArray(this.options.defines) ? this.options.defines.join("\n") : this.options.defines;
    this._postConstructor(this.options.blockCompilation, defines, this.options.extraInitializations);
  }
  _gatherImports(useWebGPU = false, list) {
    if (!this.options.useAsPostProcess) {
      return;
    }
    if (useWebGPU && this._webGPUReady) {
      list.push(Promise.all([import("./postprocess.vertex-JSLOVXCT.js")]));
    } else {
      list.push(Promise.all([import("./postprocess.vertex-FEWKDRQQ.js")]));
    }
  }
  /** @internal */
  _postConstructor(blockCompilation, defines = null, extraInitializations, importPromises) {
    this._importPromises.length = 0;
    if (importPromises) {
      this._importPromises.push(...importPromises);
    }
    const useWebGPU = this.options.engine.isWebGPU && !_EffectWrapper.ForceGLSL;
    this._gatherImports(useWebGPU, this._importPromises);
    if (extraInitializations !== void 0) {
      extraInitializations(useWebGPU, this._importPromises);
    }
    if (useWebGPU && this._webGPUReady) {
      this.options.shaderLanguage = 1;
    }
    if (!blockCompilation) {
      this.updateEffect(defines);
    }
  }
  /**
   * Updates the effect with the current effect wrapper compile time values and recompiles the shader.
   * @param defines Define statements that should be added at the beginning of the shader. (default: null)
   * @param uniforms Set of uniform variables that will be passed to the shader. (default: null)
   * @param samplers Set of Texture2D variables that will be passed to the shader. (default: null)
   * @param indexParameters The index parameters to be used for babylons include syntax "#include<kernelBlurVaryingDeclaration>[0..varyingCount]". (default: undefined) See usage in babylon.blurPostProcess.ts and kernelBlur.vertex.fx
   * @param onCompiled Called when the shader has been compiled.
   * @param onError Called if there is an error when compiling a shader.
   * @param vertexUrl The url of the vertex shader to be used (default: the one given at construction time)
   * @param fragmentUrl The url of the fragment shader to be used (default: the one given at construction time)
   */
  updateEffect(defines = null, uniforms = null, samplers = null, indexParameters, onCompiled, onError, vertexUrl, fragmentUrl) {
    const customShaderCodeProcessing = _EffectWrapper._GetShaderCodeProcessing(this.name);
    if (customShaderCodeProcessing == null ? void 0 : customShaderCodeProcessing.defineCustomBindings) {
      const newUniforms = (uniforms == null ? void 0 : uniforms.slice()) ?? [];
      newUniforms.push(...this.options.uniforms);
      const newSamplers = (samplers == null ? void 0 : samplers.slice()) ?? [];
      newSamplers.push(...this.options.samplers);
      defines = customShaderCodeProcessing.defineCustomBindings(this.name, defines, newUniforms, newSamplers);
      uniforms = newUniforms;
      samplers = newSamplers;
    }
    this.options.defines = defines || "";
    const waitImportsLoaded = this._shadersLoaded || this._importPromises.length === 0 ? void 0 : async () => {
      await Promise.all(this._importPromises);
      this._shadersLoaded = true;
    };
    let extraInitializationsAsync;
    if (this.options.extraInitializationsAsync) {
      extraInitializationsAsync = async () => {
        waitImportsLoaded == null ? void 0 : waitImportsLoaded();
        await this.options.extraInitializationsAsync;
      };
    } else {
      extraInitializationsAsync = waitImportsLoaded;
    }
    if (this.options.useShaderStore) {
      this._drawWrapper.effect = this.options.engine.createEffect({ vertex: vertexUrl ?? this._shaderPath.vertex, fragment: fragmentUrl ?? this._shaderPath.fragment }, {
        attributes: this.options.attributeNames,
        uniformsNames: uniforms || this.options.uniforms,
        uniformBuffersNames: this.options.uniformBuffers,
        samplers: samplers || this.options.samplers,
        defines: defines !== null ? defines : "",
        fallbacks: null,
        onCompiled: onCompiled ?? this.options.onCompiled,
        onError: onError ?? null,
        indexParameters: indexParameters || this.options.indexParameters,
        processCodeAfterIncludes: (customShaderCodeProcessing == null ? void 0 : customShaderCodeProcessing.processCodeAfterIncludes) ? (shaderType, code) => customShaderCodeProcessing.processCodeAfterIncludes(this.name, shaderType, code) : null,
        processFinalCode: (customShaderCodeProcessing == null ? void 0 : customShaderCodeProcessing.processFinalCode) ? (shaderType, code) => customShaderCodeProcessing.processFinalCode(this.name, shaderType, code) : null,
        shaderLanguage: this.options.shaderLanguage,
        extraInitializationsAsync
      }, this.options.engine);
    } else {
      this._drawWrapper.effect = new Effect(this._shaderPath, this.options.attributeNames, uniforms || this.options.uniforms, samplers || this.options.samplerNames, this.options.engine, defines, void 0, onCompiled || this.options.onCompiled, void 0, void 0, void 0, this.options.shaderLanguage, extraInitializationsAsync);
    }
    this.onEffectCreatedObservable.notifyObservers(this._drawWrapper.effect);
  }
  /**
   * Binds the data to the effect.
   */
  bind() {
    var _a, _b;
    if (this.options.useAsPostProcess) {
      this.options.engine.setAlphaMode(this.alphaMode);
      this.drawWrapper.effect.setFloat2("scale", 1, 1);
    }
    (_b = (_a = _EffectWrapper._GetShaderCodeProcessing(this.name)) == null ? void 0 : _a.bindCustomBindings) == null ? void 0 : _b.call(_a, this.name, this._drawWrapper.effect);
  }
  /**
   * Disposes of the effect wrapper
   * @param _ignored kept for backward compatibility
   */
  dispose(_ignored = false) {
    if (this._onContextRestoredObserver) {
      this.effect.getEngine().onContextRestoredObservable.remove(this._onContextRestoredObserver);
      this._onContextRestoredObserver = null;
    }
    this.onEffectCreatedObservable.clear();
    this._drawWrapper.dispose(true);
  }
};
EffectWrapper.ForceGLSL = false;
EffectWrapper._CustomShaderCodeProcessing = {};

export {
  Viewport,
  DrawWrapper,
  EffectRenderer,
  EffectWrapper
};
//# sourceMappingURL=chunk-NUWLHR3Y.js.map
