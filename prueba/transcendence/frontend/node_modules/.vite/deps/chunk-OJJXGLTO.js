// node_modules/@babylonjs/core/Misc/logger.js
var Logger = class _Logger {
  static _CheckLimit(message, limit) {
    let entry = _Logger._LogLimitOutputs[message];
    if (!entry) {
      entry = { limit, current: 1 };
      _Logger._LogLimitOutputs[message] = entry;
    } else {
      entry.current++;
    }
    return entry.current <= entry.limit;
  }
  static _GenerateLimitMessage(message, level = 1) {
    const entry = _Logger._LogLimitOutputs[message];
    if (!entry || !_Logger.MessageLimitReached) {
      return;
    }
    const type = this._Levels[level];
    if (entry.current === entry.limit) {
      _Logger[type.name](_Logger.MessageLimitReached.replace(/%LIMIT%/g, "" + entry.limit).replace(/%TYPE%/g, type.name ?? ""));
    }
  }
  static _AddLogEntry(entry) {
    _Logger._LogCache = entry + _Logger._LogCache;
    if (_Logger.OnNewCacheEntry) {
      _Logger.OnNewCacheEntry(entry);
    }
  }
  static _FormatMessage(message) {
    const padStr = (i) => i < 10 ? "0" + i : "" + i;
    const date = /* @__PURE__ */ new Date();
    return "[" + padStr(date.getHours()) + ":" + padStr(date.getMinutes()) + ":" + padStr(date.getSeconds()) + "]: " + message;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  static _LogDisabled(message, limit) {
  }
  static _LogEnabled(level = 1, message, limit) {
    const msg = Array.isArray(message) ? message[0] : message;
    if (limit !== void 0 && !_Logger._CheckLimit(msg, limit)) {
      return;
    }
    const formattedMessage = _Logger._FormatMessage(msg);
    const type = this._Levels[level];
    const optionals = Array.isArray(message) ? message.slice(1) : [];
    type.logFunc && type.logFunc("BJS - " + formattedMessage, ...optionals);
    const entry = `<div style='color:${type.color}'>${formattedMessage}</div><br>`;
    _Logger._AddLogEntry(entry);
    _Logger._GenerateLimitMessage(msg, level);
  }
  /**
   * Gets current log cache (list of logs)
   */
  static get LogCache() {
    return _Logger._LogCache;
  }
  /**
   * Clears the log cache
   */
  static ClearLogCache() {
    _Logger._LogCache = "";
    _Logger._LogLimitOutputs = {};
    _Logger.errorsCount = 0;
  }
  /**
   * Sets the current log level. This property is a bit field, allowing you to combine different levels (MessageLogLevel / WarningLogLevel / ErrorLogLevel).
   * Use NoneLogLevel to disable logging and AllLogLevel for a quick way to enable all levels.
   */
  static set LogLevels(level) {
    _Logger.Log = _Logger._LogDisabled;
    _Logger.Warn = _Logger._LogDisabled;
    _Logger.Error = _Logger._LogDisabled;
    [_Logger.MessageLogLevel, _Logger.WarningLogLevel, _Logger.ErrorLogLevel].forEach((l) => {
      if ((level & l) === l) {
        const type = this._Levels[l];
        _Logger[type.name] = _Logger._LogEnabled.bind(_Logger, l);
      }
    });
  }
};
Logger.NoneLogLevel = 0;
Logger.MessageLogLevel = 1;
Logger.WarningLogLevel = 2;
Logger.ErrorLogLevel = 4;
Logger.AllLogLevel = 7;
Logger.MessageLimitReached = "Too many %TYPE%s (%LIMIT%), no more %TYPE%s will be reported for this message.";
Logger._LogCache = "";
Logger._LogLimitOutputs = {};
Logger._Levels = [
  {},
  { color: "white", logFunc: console.log, name: "Log" },
  { color: "orange", logFunc: console.warn, name: "Warn" },
  {},
  { color: "red", logFunc: console.error, name: "Error" }
];
Logger.errorsCount = 0;
Logger.Log = Logger._LogEnabled.bind(Logger, Logger.MessageLogLevel);
Logger.Warn = Logger._LogEnabled.bind(Logger, Logger.WarningLogLevel);
Logger.Error = Logger._LogEnabled.bind(Logger, Logger.ErrorLogLevel);

export {
  Logger
};
//# sourceMappingURL=chunk-OJJXGLTO.js.map
