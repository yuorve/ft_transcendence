{
  "version": 3,
  "sources": ["../../../dev/core/src/Misc/khronosTextureContainer.ts", "../../../dev/core/src/Misc/workerPool.ts", "../../../dev/core/src/Materials/Textures/ktx2decoderTypes.ts", "../../../dev/core/src/Misc/khronosTextureContainer2Worker.ts", "../../../dev/core/src/Misc/khronosTextureContainer2.ts", "../../../dev/core/src/Materials/Textures/Loaders/ktxTextureLoader.ts"],
  "sourcesContent": ["/* eslint-disable @typescript-eslint/naming-convention */\r\nimport { Logger } from \"../Misc/logger\";\r\nimport type { InternalTexture } from \"../Materials/Textures/internalTexture\";\r\n\r\n/**\r\n * for description see https://www.khronos.org/opengles/sdk/tools/KTX/\r\n * for file layout see https://www.khronos.org/opengles/sdk/tools/KTX/file_format_spec/\r\n */\r\nexport class KhronosTextureContainer {\r\n    private static HEADER_LEN = 12 + 13 * 4; // identifier + header elements (not including key value meta-data pairs)\r\n\r\n    // load types\r\n    private static COMPRESSED_2D = 0; // uses a gl.compressedTexImage2D()\r\n    private static COMPRESSED_3D = 1; // uses a gl.compressedTexImage3D()\r\n    private static TEX_2D = 2; // uses a gl.texImage2D()\r\n    private static TEX_3D = 3; // uses a gl.texImage3D()\r\n\r\n    // elements of the header\r\n    /**\r\n     * Gets the openGL type\r\n     */\r\n    public glType: number;\r\n    /**\r\n     * Gets the openGL type size\r\n     */\r\n    public glTypeSize: number;\r\n    /**\r\n     * Gets the openGL format\r\n     */\r\n    public glFormat: number;\r\n    /**\r\n     * Gets the openGL internal format\r\n     */\r\n    public glInternalFormat: number;\r\n    /**\r\n     * Gets the base internal format\r\n     */\r\n    public glBaseInternalFormat: number;\r\n    /**\r\n     * Gets image width in pixel\r\n     */\r\n    public pixelWidth: number;\r\n    /**\r\n     * Gets image height in pixel\r\n     */\r\n    public pixelHeight: number;\r\n    /**\r\n     * Gets image depth in pixels\r\n     */\r\n    public pixelDepth: number;\r\n    /**\r\n     * Gets the number of array elements\r\n     */\r\n    public numberOfArrayElements: number;\r\n    /**\r\n     * Gets the number of faces\r\n     */\r\n    public numberOfFaces: number;\r\n    /**\r\n     * Gets the number of mipmap levels\r\n     */\r\n    public numberOfMipmapLevels: number;\r\n    /**\r\n     * Gets the bytes of key value data\r\n     */\r\n    public bytesOfKeyValueData: number;\r\n    /**\r\n     * Gets the load type\r\n     */\r\n    public loadType: number;\r\n    /**\r\n     * If the container has been made invalid (eg. constructor failed to correctly load array buffer)\r\n     */\r\n    public isInvalid = false;\r\n\r\n    /**\r\n     * Creates a new KhronosTextureContainer\r\n     * @param data contents of the KTX container file\r\n     * @param facesExpected should be either 1 or 6, based whether a cube texture or or\r\n     */\r\n    public constructor(\r\n        /** contents of the KTX container file */\r\n        public data: ArrayBufferView,\r\n        facesExpected: number\r\n    ) {\r\n        if (!KhronosTextureContainer.IsValid(data)) {\r\n            this.isInvalid = true;\r\n            Logger.Error(\"texture missing KTX identifier\");\r\n            return;\r\n        }\r\n\r\n        // load the reset of the header in native 32 bit uint\r\n        const dataSize = Uint32Array.BYTES_PER_ELEMENT;\r\n        const headerDataView = new DataView(this.data.buffer, this.data.byteOffset + 12, 13 * dataSize);\r\n        const endianness = headerDataView.getUint32(0, true);\r\n        const littleEndian = endianness === 0x04030201;\r\n\r\n        this.glType = headerDataView.getUint32(1 * dataSize, littleEndian); // must be 0 for compressed textures\r\n        this.glTypeSize = headerDataView.getUint32(2 * dataSize, littleEndian); // must be 1 for compressed textures\r\n        this.glFormat = headerDataView.getUint32(3 * dataSize, littleEndian); // must be 0 for compressed textures\r\n        this.glInternalFormat = headerDataView.getUint32(4 * dataSize, littleEndian); // the value of arg passed to gl.compressedTexImage2D(,,x,,,,)\r\n        this.glBaseInternalFormat = headerDataView.getUint32(5 * dataSize, littleEndian); // specify GL_RGB, GL_RGBA, GL_ALPHA, etc (un-compressed only)\r\n        this.pixelWidth = headerDataView.getUint32(6 * dataSize, littleEndian); // level 0 value of arg passed to gl.compressedTexImage2D(,,,x,,,)\r\n        this.pixelHeight = headerDataView.getUint32(7 * dataSize, littleEndian); // level 0 value of arg passed to gl.compressedTexImage2D(,,,,x,,)\r\n        this.pixelDepth = headerDataView.getUint32(8 * dataSize, littleEndian); // level 0 value of arg passed to gl.compressedTexImage3D(,,,,,x,,)\r\n        this.numberOfArrayElements = headerDataView.getUint32(9 * dataSize, littleEndian); // used for texture arrays\r\n        this.numberOfFaces = headerDataView.getUint32(10 * dataSize, littleEndian); // used for cubemap textures, should either be 1 or 6\r\n        this.numberOfMipmapLevels = headerDataView.getUint32(11 * dataSize, littleEndian); // number of levels; disregard possibility of 0 for compressed textures\r\n        this.bytesOfKeyValueData = headerDataView.getUint32(12 * dataSize, littleEndian); // the amount of space after the header for meta-data\r\n\r\n        // Make sure we have a compressed type.  Not only reduces work, but probably better to let dev know they are not compressing.\r\n        if (this.glType !== 0) {\r\n            Logger.Error(\"only compressed formats currently supported\");\r\n            this.isInvalid = true;\r\n            return;\r\n        } else {\r\n            // value of zero is an indication to generate mipmaps @ runtime.  Not usually allowed for compressed, so disregard.\r\n            this.numberOfMipmapLevels = Math.max(1, this.numberOfMipmapLevels);\r\n        }\r\n\r\n        if (this.pixelHeight === 0 || this.pixelDepth !== 0) {\r\n            Logger.Error(\"only 2D textures currently supported\");\r\n            this.isInvalid = true;\r\n            return;\r\n        }\r\n\r\n        if (this.numberOfArrayElements !== 0) {\r\n            Logger.Error(\"texture arrays not currently supported\");\r\n            this.isInvalid = true;\r\n            return;\r\n        }\r\n\r\n        if (this.numberOfFaces !== facesExpected) {\r\n            Logger.Error(\"number of faces expected\" + facesExpected + \", but found \" + this.numberOfFaces);\r\n            this.isInvalid = true;\r\n            return;\r\n        }\r\n\r\n        // we now have a completely validated file, so could use existence of loadType as success\r\n        // would need to make this more elaborate & adjust checks above to support more than one load type\r\n        this.loadType = KhronosTextureContainer.COMPRESSED_2D;\r\n    }\r\n\r\n    /**\r\n     * Uploads KTX content to a Babylon Texture.\r\n     * It is assumed that the texture has already been created & is currently bound\r\n     * @internal\r\n     */\r\n    public uploadLevels(texture: InternalTexture, loadMipmaps: boolean): void {\r\n        switch (this.loadType) {\r\n            case KhronosTextureContainer.COMPRESSED_2D:\r\n                this._upload2DCompressedLevels(texture, loadMipmaps);\r\n                break;\r\n\r\n            case KhronosTextureContainer.TEX_2D:\r\n            case KhronosTextureContainer.COMPRESSED_3D:\r\n            case KhronosTextureContainer.TEX_3D:\r\n        }\r\n    }\r\n\r\n    private _upload2DCompressedLevels(texture: InternalTexture, loadMipmaps: boolean): void {\r\n        // initialize width & height for level 1\r\n        let dataOffset = KhronosTextureContainer.HEADER_LEN + this.bytesOfKeyValueData;\r\n        let width = this.pixelWidth;\r\n        let height = this.pixelHeight;\r\n\r\n        const mipmapCount = loadMipmaps ? this.numberOfMipmapLevels : 1;\r\n        for (let level = 0; level < mipmapCount; level++) {\r\n            const imageSize = new Int32Array(this.data.buffer, this.data.byteOffset + dataOffset, 1)[0]; // size per face, since not supporting array cubemaps\r\n            dataOffset += 4; //image data starts from next multiple of 4 offset. Each face refers to same imagesize field above.\r\n            for (let face = 0; face < this.numberOfFaces; face++) {\r\n                const byteArray = new Uint8Array(this.data.buffer, this.data.byteOffset + dataOffset, imageSize);\r\n\r\n                const engine = texture.getEngine();\r\n                engine._uploadCompressedDataToTextureDirectly(texture, texture.format, width, height, byteArray, face, level);\r\n\r\n                dataOffset += imageSize; // add size of the image for the next face/mipmap\r\n                dataOffset += 3 - ((imageSize + 3) % 4); // add padding for odd sized image\r\n            }\r\n            width = Math.max(1.0, width * 0.5);\r\n            height = Math.max(1.0, height * 0.5);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks if the given data starts with a KTX file identifier.\r\n     * @param data the data to check\r\n     * @returns true if the data is a KTX file or false otherwise\r\n     */\r\n    public static IsValid(data: ArrayBufferView): boolean {\r\n        if (data.byteLength >= 12) {\r\n            // '«', 'K', 'T', 'X', ' ', '1', '1', '»', '\\r', '\\n', '\\x1A', '\\n'\r\n            const identifier = new Uint8Array(data.buffer, data.byteOffset, 12);\r\n            if (\r\n                identifier[0] === 0xab &&\r\n                identifier[1] === 0x4b &&\r\n                identifier[2] === 0x54 &&\r\n                identifier[3] === 0x58 &&\r\n                identifier[4] === 0x20 &&\r\n                identifier[5] === 0x31 &&\r\n                identifier[6] === 0x31 &&\r\n                identifier[7] === 0xbb &&\r\n                identifier[8] === 0x0d &&\r\n                identifier[9] === 0x0a &&\r\n                identifier[10] === 0x1a &&\r\n                identifier[11] === 0x0a\r\n            ) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n}\r\n", "import type { IDisposable } from \"../scene\";\r\n\r\n/** @ignore */\r\ninterface WorkerInfo {\r\n    workerPromise: Promise<Worker>;\r\n    idle: boolean;\r\n    timeoutId?: ReturnType<typeof setTimeout>;\r\n}\r\n\r\n/**\r\n * Helper class to push actions to a pool of workers.\r\n */\r\nexport class WorkerPool implements IDisposable {\r\n    protected _workerInfos: Array<WorkerInfo>;\r\n    protected _pendingActions = new Array<(worker: Worker, onComplete: () => void) => void>();\r\n\r\n    /**\r\n     * Constructor\r\n     * @param workers Array of workers to use for actions\r\n     */\r\n    constructor(workers: Array<Worker>) {\r\n        this._workerInfos = workers.map((worker) => ({\r\n            workerPromise: Promise.resolve(worker),\r\n            idle: true,\r\n        }));\r\n    }\r\n\r\n    /**\r\n     * Terminates all workers and clears any pending actions.\r\n     */\r\n    public dispose(): void {\r\n        for (const workerInfo of this._workerInfos) {\r\n            workerInfo.workerPromise.then((worker) => {\r\n                worker.terminate();\r\n            });\r\n        }\r\n\r\n        this._workerInfos.length = 0;\r\n        this._pendingActions.length = 0;\r\n    }\r\n\r\n    /**\r\n     * Pushes an action to the worker pool. If all the workers are active, the action will be\r\n     * pended until a worker has completed its action.\r\n     * @param action The action to perform. Call onComplete when the action is complete.\r\n     */\r\n    public push(action: (worker: Worker, onComplete: () => void) => void): void {\r\n        if (!this._executeOnIdleWorker(action)) {\r\n            this._pendingActions.push(action);\r\n        }\r\n    }\r\n\r\n    protected _executeOnIdleWorker(action: (worker: Worker, onComplete: () => void) => void): boolean {\r\n        for (const workerInfo of this._workerInfos) {\r\n            if (workerInfo.idle) {\r\n                this._execute(workerInfo, action);\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    protected _execute(workerInfo: WorkerInfo, action: (worker: Worker, onComplete: () => void) => void): void {\r\n        workerInfo.idle = false;\r\n        workerInfo.workerPromise.then((worker) => {\r\n            action(worker, () => {\r\n                const nextAction = this._pendingActions.shift();\r\n                if (nextAction) {\r\n                    this._execute(workerInfo, nextAction);\r\n                } else {\r\n                    workerInfo.idle = true;\r\n                }\r\n            });\r\n        });\r\n    }\r\n}\r\n\r\n/**\r\n * Options for AutoReleaseWorkerPool\r\n */\r\nexport interface AutoReleaseWorkerPoolOptions {\r\n    /**\r\n     * Idle time elapsed before workers are terminated.\r\n     */\r\n    idleTimeElapsedBeforeRelease: number;\r\n}\r\n\r\n/**\r\n * Similar to the WorkerPool class except it creates and destroys workers automatically with a maximum of `maxWorkers` workers.\r\n * Workers are terminated when it is idle for at least `idleTimeElapsedBeforeRelease` milliseconds.\r\n */\r\nexport class AutoReleaseWorkerPool extends WorkerPool {\r\n    /**\r\n     * Default options for the constructor.\r\n     * Override to change the defaults.\r\n     */\r\n    public static DefaultOptions: AutoReleaseWorkerPoolOptions = {\r\n        idleTimeElapsedBeforeRelease: 1000,\r\n    };\r\n\r\n    private readonly _maxWorkers: number;\r\n    private readonly _createWorkerAsync: () => Promise<Worker>;\r\n    private readonly _options: AutoReleaseWorkerPoolOptions;\r\n\r\n    constructor(maxWorkers: number, createWorkerAsync: () => Promise<Worker>, options = AutoReleaseWorkerPool.DefaultOptions) {\r\n        super([]);\r\n\r\n        this._maxWorkers = maxWorkers;\r\n        this._createWorkerAsync = createWorkerAsync;\r\n        this._options = options;\r\n    }\r\n\r\n    public override push(action: (worker: Worker, onComplete: () => void) => void): void {\r\n        if (!this._executeOnIdleWorker(action)) {\r\n            if (this._workerInfos.length < this._maxWorkers) {\r\n                const workerInfo: WorkerInfo = {\r\n                    workerPromise: this._createWorkerAsync(),\r\n                    idle: false,\r\n                };\r\n                this._workerInfos.push(workerInfo);\r\n                this._execute(workerInfo, action);\r\n            } else {\r\n                this._pendingActions.push(action);\r\n            }\r\n        }\r\n    }\r\n\r\n    protected override _execute(workerInfo: WorkerInfo, action: (worker: Worker, onComplete: () => void) => void): void {\r\n        // Reset the idle timeout.\r\n        if (workerInfo.timeoutId) {\r\n            clearTimeout(workerInfo.timeoutId);\r\n            delete workerInfo.timeoutId;\r\n        }\r\n\r\n        super._execute(workerInfo, (worker, onComplete) => {\r\n            action(worker, () => {\r\n                onComplete();\r\n\r\n                if (workerInfo.idle) {\r\n                    // Schedule the worker to be terminated after the elapsed time.\r\n                    workerInfo.timeoutId = setTimeout(() => {\r\n                        workerInfo.workerPromise.then((worker) => {\r\n                            worker.terminate();\r\n                        });\r\n\r\n                        const indexOf = this._workerInfos.indexOf(workerInfo);\r\n                        if (indexOf !== -1) {\r\n                            this._workerInfos.splice(indexOf, 1);\r\n                        }\r\n                    }, this._options.idleTimeElapsedBeforeRelease);\r\n                }\r\n            });\r\n        });\r\n    }\r\n}\r\n", "export enum SourceTextureFormat {\r\n    ETC1S,\r\n    UASTC4x4,\r\n}\r\n\r\nexport enum TranscodeTarget {\r\n    ASTC_4X4_RGBA,\r\n    BC7_RGBA,\r\n    BC3_RGBA,\r\n    BC1_RGB,\r\n    PVRTC1_4_RGBA,\r\n    PVRTC1_4_RGB,\r\n    ETC2_RGBA,\r\n    ETC1_RGB,\r\n    RGBA32,\r\n    R8,\r\n    RG8,\r\n}\r\n\r\nexport const enum EngineFormat {\r\n    COMPRESSED_RGBA_BPTC_UNORM_EXT = 0x8e8c,\r\n    COMPRESSED_RGBA_ASTC_4X4_KHR = 0x93b0,\r\n    COMPRESSED_RGB_S3TC_DXT1_EXT = 0x83f0,\r\n    COMPRESSED_RGBA_S3TC_DXT5_EXT = 0x83f3,\r\n    COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 0x8c02,\r\n    COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 0x8c00,\r\n    COMPRESSED_RGBA8_ETC2_EAC = 0x9278,\r\n    COMPRESSED_RGB8_ETC2 = 0x9274,\r\n    COMPRESSED_RGB_ETC1_WEBGL = 0x8d64,\r\n    RGBA8Format = 0x8058,\r\n    R8Format = 0x8229,\r\n    RG8Format = 0x822b,\r\n}\r\n\r\n/**\r\n * Leaf node of a decision tree\r\n * It defines the transcoding format to use to transcode the texture as well as the corresponding format to use at the engine level when creating the texture\r\n */\r\nexport interface ILeaf {\r\n    /**\r\n     * The format to transcode to\r\n     */\r\n    transcodeFormat: TranscodeTarget;\r\n\r\n    /**\r\n     * The format to use when creating the texture at the engine level after it has been transcoded to transcodeFormat\r\n     */\r\n    engineFormat: EngineFormat;\r\n\r\n    /**\r\n     * Whether the texture must be rounded to a multiple of 4 (should normally be the case for all compressed formats). Default: true\r\n     */\r\n    roundToMultiple4?: boolean;\r\n}\r\n\r\n/**\r\n * Regular node of a decision tree\r\n *\r\n * Each property (except for \"yes\" and \"no\"), if not empty, will be checked in order to determine the next node to select.\r\n * If all checks are successful, the \"yes\" node will be selected, else the \"no\" node will be selected.\r\n */\r\nexport interface INode {\r\n    /**\r\n     * The name of the capability to check. Can be one of the following:\r\n     *      astc\r\n     *      bptc\r\n     *      s3tc\r\n     *      pvrtc\r\n     *      etc2\r\n     *      etc1\r\n     */\r\n    cap?: string;\r\n\r\n    /**\r\n     * The name of the option to check from the options object passed to the KTX2 decode function. {@link IKTX2DecoderOptions}\r\n     */\r\n    option?: string;\r\n\r\n    /**\r\n     * Checks if alpha is present in the texture\r\n     */\r\n    alpha?: boolean;\r\n\r\n    /**\r\n     * Checks the currently selected transcoding format.\r\n     */\r\n    transcodeFormat?: TranscodeTarget | TranscodeTarget[];\r\n\r\n    /**\r\n     * Checks that the texture is a power of two\r\n     */\r\n    needsPowerOfTwo?: boolean;\r\n\r\n    /**\r\n     * The node to select if all checks are successful\r\n     */\r\n    yes?: INode | ILeaf;\r\n\r\n    /**\r\n     * The node to select if at least one check is not successful\r\n     */\r\n    no?: INode | ILeaf;\r\n}\r\n\r\n/**\r\n * Decision tree used to determine the transcoding format to use for a given source texture format\r\n */\r\nexport interface IDecisionTree {\r\n    /**\r\n     * textureFormat can be either UASTC or ETC1S\r\n     */\r\n    [textureFormat: string]: INode;\r\n}\r\n\r\n/**\r\n * Result of the KTX2 decode function\r\n */\r\nexport interface IDecodedData {\r\n    /**\r\n     * Width of the texture\r\n     */\r\n    width: number;\r\n\r\n    /**\r\n     * Height of the texture\r\n     */\r\n    height: number;\r\n\r\n    /**\r\n     * The format to use when creating the texture at the engine level\r\n     * This corresponds to the engineFormat property of the leaf node of the decision tree\r\n     */\r\n    transcodedFormat: number;\r\n\r\n    /**\r\n     * List of mipmap levels.\r\n     * The first element is the base level, the last element is the smallest mipmap level (if more than one mipmap level is present)\r\n     */\r\n    mipmaps: Array<IMipmap>;\r\n\r\n    /**\r\n     * Whether the texture data is in gamma space or not\r\n     */\r\n    isInGammaSpace: boolean;\r\n\r\n    /**\r\n     * Whether the texture has an alpha channel or not\r\n     */\r\n    hasAlpha: boolean;\r\n\r\n    /**\r\n     * The name of the transcoder used to transcode the texture\r\n     */\r\n    transcoderName: string;\r\n\r\n    /**\r\n     * The errors (if any) encountered during the decoding process\r\n     */\r\n    errors?: string;\r\n}\r\n\r\n/**\r\n * Defines a mipmap level\r\n */\r\nexport interface IMipmap {\r\n    /**\r\n     * The data of the mipmap level\r\n     */\r\n    data: Uint8Array | null;\r\n\r\n    /**\r\n     * The width of the mipmap level\r\n     */\r\n    width: number;\r\n\r\n    /**\r\n     * The height of the mipmap level\r\n     */\r\n    height: number;\r\n}\r\n\r\n/**\r\n * The compressed texture formats supported by the browser\r\n */\r\nexport interface ICompressedFormatCapabilities {\r\n    /**\r\n     * Whether the browser supports ASTC\r\n     */\r\n    astc?: boolean;\r\n\r\n    /**\r\n     * Whether the browser supports BPTC\r\n     */\r\n    bptc?: boolean;\r\n\r\n    /**\r\n     * Whether the browser supports S3TC\r\n     */\r\n    s3tc?: boolean;\r\n\r\n    /**\r\n     * Whether the browser supports PVRTC\r\n     */\r\n    pvrtc?: boolean;\r\n\r\n    /**\r\n     * Whether the browser supports ETC2\r\n     */\r\n    etc2?: boolean;\r\n\r\n    /**\r\n     * Whether the browser supports ETC1\r\n     */\r\n    etc1?: boolean;\r\n}\r\n\r\n/**\r\n * Options passed to the KTX2 decode function\r\n */\r\nexport interface IKTX2DecoderOptions {\r\n    /** use RGBA format if ASTC and BC7 are not available as transcoded format */\r\n    useRGBAIfASTCBC7NotAvailableWhenUASTC?: boolean;\r\n\r\n    /** force to always use (uncompressed) RGBA for transcoded format */\r\n    forceRGBA?: boolean;\r\n\r\n    /** force to always use (uncompressed) R8 for transcoded format */\r\n    forceR8?: boolean;\r\n\r\n    /** force to always use (uncompressed) RG8 for transcoded format */\r\n    forceRG8?: boolean;\r\n\r\n    /**\r\n     * list of transcoders to bypass when looking for a suitable transcoder. The available transcoders are:\r\n     *      UniversalTranscoder_UASTC_ASTC\r\n     *      UniversalTranscoder_UASTC_BC7\r\n     *      UniversalTranscoder_UASTC_RGBA_UNORM\r\n     *      UniversalTranscoder_UASTC_RGBA_SRGB\r\n     *      UniversalTranscoder_UASTC_R8_UNORM\r\n     *      UniversalTranscoder_UASTC_RG8_UNORM\r\n     *      MSCTranscoder\r\n     */\r\n    bypassTranscoders?: string[];\r\n\r\n    /**\r\n     * Custom decision tree to apply after the default decision tree has selected a transcoding format.\r\n     * Allows the user to override the default decision tree selection.\r\n     * The decision tree can use the INode.transcodeFormat property to base its decision on the transcoding format selected by the default decision tree.\r\n     */\r\n    transcodeFormatDecisionTree?: IDecisionTree;\r\n}\r\n", "import type { IDecodedData } from \"core/Materials/Textures/ktx2decoderTypes\";\r\n\r\n/* eslint-disable @typescript-eslint/naming-convention */\r\nexport type AllowedKeys =\r\n    | \"wasmUASTCToASTC\"\r\n    | \"wasmUASTCToBC7\"\r\n    | \"wasmUASTCToRGBA_UNORM\"\r\n    | \"wasmUASTCToRGBA_SRGB\"\r\n    | \"wasmUASTCToR8_UNORM\"\r\n    | \"wasmUASTCToRG8_UNORM\"\r\n    | \"wasmMSCTranscoder\"\r\n    | \"wasmZSTDDecoder\"\r\n    | \"jsDecoderModule\"\r\n    | \"jsMSCTranscoder\";\r\n\r\ndeclare function importScripts(...urls: string[]): void;\r\ndeclare function postMessage(message: any, transfer?: any[]): void;\r\ndeclare let KTX2DECODER: any;\r\n\r\nexport function applyConfig(urls?: { [key in AllowedKeys]: string }, binariesAndModulesContainer?: { [key in AllowedKeys]: ArrayBuffer | any }): void {\r\n    const KTX2DecoderModule = binariesAndModulesContainer?.jsDecoderModule || KTX2DECODER;\r\n    if (urls) {\r\n        if (urls.wasmUASTCToASTC) {\r\n            KTX2DecoderModule.LiteTranscoder_UASTC_ASTC.WasmModuleURL = urls.wasmUASTCToASTC;\r\n        }\r\n\r\n        if (urls.wasmUASTCToBC7) {\r\n            KTX2DecoderModule.LiteTranscoder_UASTC_BC7.WasmModuleURL = urls.wasmUASTCToBC7;\r\n        }\r\n\r\n        if (urls.wasmUASTCToRGBA_UNORM) {\r\n            KTX2DecoderModule.LiteTranscoder_UASTC_RGBA_UNORM.WasmModuleURL = urls.wasmUASTCToRGBA_UNORM;\r\n        }\r\n\r\n        if (urls.wasmUASTCToRGBA_SRGB) {\r\n            KTX2DecoderModule.LiteTranscoder_UASTC_RGBA_SRGB.WasmModuleURL = urls.wasmUASTCToRGBA_SRGB;\r\n        }\r\n\r\n        if (urls.wasmUASTCToR8_UNORM) {\r\n            KTX2DecoderModule.LiteTranscoder_UASTC_R8_UNORM.WasmModuleURL = urls.wasmUASTCToR8_UNORM;\r\n        }\r\n\r\n        if (urls.wasmUASTCToRG8_UNORM) {\r\n            KTX2DecoderModule.LiteTranscoder_UASTC_RG8_UNORM.WasmModuleURL = urls.wasmUASTCToRG8_UNORM;\r\n        }\r\n\r\n        if (urls.jsMSCTranscoder) {\r\n            KTX2DecoderModule.MSCTranscoder.JSModuleURL = urls.jsMSCTranscoder;\r\n        }\r\n\r\n        if (urls.wasmMSCTranscoder) {\r\n            KTX2DecoderModule.MSCTranscoder.WasmModuleURL = urls.wasmMSCTranscoder;\r\n        }\r\n\r\n        if (urls.wasmZSTDDecoder) {\r\n            KTX2DecoderModule.ZSTDDecoder.WasmModuleURL = urls.wasmZSTDDecoder;\r\n        }\r\n    }\r\n    if (binariesAndModulesContainer) {\r\n        if (binariesAndModulesContainer.wasmUASTCToASTC) {\r\n            KTX2DecoderModule.LiteTranscoder_UASTC_ASTC.WasmBinary = binariesAndModulesContainer.wasmUASTCToASTC;\r\n        }\r\n        if (binariesAndModulesContainer.wasmUASTCToBC7) {\r\n            KTX2DecoderModule.LiteTranscoder_UASTC_BC7.WasmBinary = binariesAndModulesContainer.wasmUASTCToBC7;\r\n        }\r\n        if (binariesAndModulesContainer.wasmUASTCToRGBA_UNORM) {\r\n            KTX2DecoderModule.LiteTranscoder_UASTC_RGBA_UNORM.WasmBinary = binariesAndModulesContainer.wasmUASTCToRGBA_UNORM;\r\n        }\r\n        if (binariesAndModulesContainer.wasmUASTCToRGBA_SRGB) {\r\n            KTX2DecoderModule.LiteTranscoder_UASTC_RGBA_SRGB.WasmBinary = binariesAndModulesContainer.wasmUASTCToRGBA_SRGB;\r\n        }\r\n        if (binariesAndModulesContainer.wasmUASTCToR8_UNORM) {\r\n            KTX2DecoderModule.LiteTranscoder_UASTC_R8_UNORM.WasmBinary = binariesAndModulesContainer.wasmUASTCToR8_UNORM;\r\n        }\r\n        if (binariesAndModulesContainer.wasmUASTCToRG8_UNORM) {\r\n            KTX2DecoderModule.LiteTranscoder_UASTC_RG8_UNORM.WasmBinary = binariesAndModulesContainer.wasmUASTCToRG8_UNORM;\r\n        }\r\n        if (binariesAndModulesContainer.jsMSCTranscoder) {\r\n            KTX2DecoderModule.MSCTranscoder.JSModule = binariesAndModulesContainer.jsMSCTranscoder;\r\n        }\r\n        if (binariesAndModulesContainer.wasmMSCTranscoder) {\r\n            KTX2DecoderModule.MSCTranscoder.WasmBinary = binariesAndModulesContainer.wasmMSCTranscoder;\r\n        }\r\n        if (binariesAndModulesContainer.wasmZSTDDecoder) {\r\n            KTX2DecoderModule.ZSTDDecoder.WasmBinary = binariesAndModulesContainer.wasmZSTDDecoder;\r\n        }\r\n    }\r\n}\r\n\r\nexport function workerFunction(KTX2DecoderModule: any): void {\r\n    if (typeof KTX2DecoderModule === \"undefined\" && typeof KTX2DECODER !== \"undefined\") {\r\n        KTX2DecoderModule = KTX2DECODER;\r\n    }\r\n    let ktx2Decoder: any;\r\n\r\n    onmessage = (event) => {\r\n        if (!event.data) {\r\n            return;\r\n        }\r\n        switch (event.data.action) {\r\n            case \"init\": {\r\n                const urls = event.data.urls;\r\n                if (urls) {\r\n                    if (urls.jsDecoderModule && typeof KTX2DecoderModule === \"undefined\") {\r\n                        importScripts(urls.jsDecoderModule);\r\n                        // assuming global namespace populated by the script (UMD pattern)\r\n                        KTX2DecoderModule = KTX2DECODER;\r\n                    }\r\n                    applyConfig(urls);\r\n                }\r\n                if (event.data.wasmBinaries) {\r\n                    applyConfig(undefined, { ...event.data.wasmBinaries, jsDecoderModule: KTX2DecoderModule });\r\n                }\r\n                ktx2Decoder = new KTX2DecoderModule.KTX2Decoder();\r\n                postMessage({ action: \"init\" });\r\n                break;\r\n            }\r\n            case \"setDefaultDecoderOptions\": {\r\n                KTX2DecoderModule.KTX2Decoder.DefaultDecoderOptions = event.data.options;\r\n                break;\r\n            }\r\n            case \"decode\":\r\n                ktx2Decoder\r\n                    .decode(event.data.data, event.data.caps, event.data.options)\r\n                    .then((data: IDecodedData) => {\r\n                        const buffers = [];\r\n                        for (let mip = 0; mip < data.mipmaps.length; ++mip) {\r\n                            const mipmap = data.mipmaps[mip];\r\n                            if (mipmap && mipmap.data) {\r\n                                buffers.push(mipmap.data.buffer);\r\n                            }\r\n                        }\r\n                        postMessage({ action: \"decoded\", success: true, decodedData: data }, buffers);\r\n                    })\r\n                    .catch((reason: any) => {\r\n                        postMessage({ action: \"decoded\", success: false, msg: reason });\r\n                    });\r\n                break;\r\n        }\r\n    };\r\n}\r\n\r\nexport function initializeWebWorker(worker: Worker, wasmBinaries?: { [key in AllowedKeys]?: ArrayBuffer }, urls?: { [key in AllowedKeys]: string }): Promise<Worker> {\r\n    return new Promise((resolve, reject) => {\r\n        const onError = (error: ErrorEvent) => {\r\n            worker.removeEventListener(\"error\", onError);\r\n            worker.removeEventListener(\"message\", onMessage);\r\n            reject(error);\r\n        };\r\n\r\n        const onMessage = (message: MessageEvent) => {\r\n            if (message.data.action === \"init\") {\r\n                worker.removeEventListener(\"error\", onError);\r\n                worker.removeEventListener(\"message\", onMessage);\r\n                resolve(worker);\r\n            }\r\n        };\r\n\r\n        worker.addEventListener(\"error\", onError);\r\n        worker.addEventListener(\"message\", onMessage);\r\n\r\n        worker.postMessage({\r\n            action: \"init\",\r\n            urls,\r\n            wasmBinaries,\r\n        });\r\n    });\r\n}\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { InternalTexture } from \"../Materials/Textures/internalTexture\";\r\nimport type { AbstractEngine } from \"../Engines/abstractEngine\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { AutoReleaseWorkerPool } from \"./workerPool\";\r\nimport { Tools } from \"./tools\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { ICompressedFormatCapabilities, IDecodedData, IKTX2DecoderOptions } from \"core/Materials/Textures/ktx2decoderTypes\";\r\nimport { EngineFormat, TranscodeTarget } from \"core/Materials/Textures/ktx2decoderTypes\";\r\nimport type { AllowedKeys } from \"./khronosTextureContainer2Worker\";\r\nimport { applyConfig, initializeWebWorker, workerFunction } from \"./khronosTextureContainer2Worker\";\r\n\r\ndeclare let KTX2DECODER: any;\r\n\r\n/**\r\n * Class that defines the default KTX2 decoder options.\r\n *\r\n * This class is useful for providing options to the KTX2 decoder to control how the source data is transcoded.\r\n */\r\nexport class DefaultKTX2DecoderOptions {\r\n    private _isDirty = true;\r\n\r\n    /**\r\n     * Gets the dirty flag\r\n     */\r\n    public get isDirty() {\r\n        return this._isDirty;\r\n    }\r\n\r\n    private _useRGBAIfASTCBC7NotAvailableWhenUASTC?: boolean;\r\n    /**\r\n     * force a (uncompressed) RGBA transcoded format if transcoding a UASTC source format and ASTC + BC7 are not available as a compressed transcoded format\r\n     */\r\n    public get useRGBAIfASTCBC7NotAvailableWhenUASTC() {\r\n        return this._useRGBAIfASTCBC7NotAvailableWhenUASTC;\r\n    }\r\n\r\n    public set useRGBAIfASTCBC7NotAvailableWhenUASTC(value: boolean | undefined) {\r\n        if (this._useRGBAIfASTCBC7NotAvailableWhenUASTC === value) {\r\n            return;\r\n        }\r\n        this._useRGBAIfASTCBC7NotAvailableWhenUASTC = value;\r\n        this._isDirty = true;\r\n    }\r\n\r\n    private _useRGBAIfOnlyBC1BC3AvailableWhenUASTC?: boolean = true;\r\n    /**\r\n     * force a (uncompressed) RGBA transcoded format if transcoding a UASTC source format and only BC1 or BC3 are available as a compressed transcoded format.\r\n     * This property is true by default to favor speed over memory, because currently transcoding from UASTC to BC1/3 is slow because the transcoder transcodes\r\n     * to uncompressed and then recompresses the texture\r\n     */\r\n    public get useRGBAIfOnlyBC1BC3AvailableWhenUASTC() {\r\n        return this._useRGBAIfOnlyBC1BC3AvailableWhenUASTC;\r\n    }\r\n\r\n    public set useRGBAIfOnlyBC1BC3AvailableWhenUASTC(value: boolean | undefined) {\r\n        if (this._useRGBAIfOnlyBC1BC3AvailableWhenUASTC === value) {\r\n            return;\r\n        }\r\n        this._useRGBAIfOnlyBC1BC3AvailableWhenUASTC = value;\r\n        this._isDirty = true;\r\n    }\r\n\r\n    private _forceRGBA?: boolean;\r\n    /**\r\n     * force to always use (uncompressed) RGBA for transcoded format\r\n     */\r\n    public get forceRGBA() {\r\n        return this._forceRGBA;\r\n    }\r\n\r\n    public set forceRGBA(value: boolean | undefined) {\r\n        if (this._forceRGBA === value) {\r\n            return;\r\n        }\r\n        this._forceRGBA = value;\r\n        this._isDirty = true;\r\n    }\r\n\r\n    private _forceR8?: boolean;\r\n    /**\r\n     * force to always use (uncompressed) R8 for transcoded format\r\n     */\r\n    public get forceR8() {\r\n        return this._forceR8;\r\n    }\r\n\r\n    public set forceR8(value: boolean | undefined) {\r\n        if (this._forceR8 === value) {\r\n            return;\r\n        }\r\n        this._forceR8 = value;\r\n        this._isDirty = true;\r\n    }\r\n\r\n    private _forceRG8?: boolean;\r\n    /**\r\n     * force to always use (uncompressed) RG8 for transcoded format\r\n     */\r\n    public get forceRG8() {\r\n        return this._forceRG8;\r\n    }\r\n\r\n    public set forceRG8(value: boolean | undefined) {\r\n        if (this._forceRG8 === value) {\r\n            return;\r\n        }\r\n        this._forceRG8 = value;\r\n        this._isDirty = true;\r\n    }\r\n\r\n    private _bypassTranscoders?: string[];\r\n    /**\r\n     * list of transcoders to bypass when looking for a suitable transcoder. The available transcoders are:\r\n     *      UniversalTranscoder_UASTC_ASTC\r\n     *      UniversalTranscoder_UASTC_BC7\r\n     *      UniversalTranscoder_UASTC_RGBA_UNORM\r\n     *      UniversalTranscoder_UASTC_RGBA_SRGB\r\n     *      UniversalTranscoder_UASTC_R8_UNORM\r\n     *      UniversalTranscoder_UASTC_RG8_UNORM\r\n     *      MSCTranscoder\r\n     */\r\n    public get bypassTranscoders() {\r\n        return this._bypassTranscoders;\r\n    }\r\n\r\n    public set bypassTranscoders(value: string[] | undefined) {\r\n        if (this._bypassTranscoders === value) {\r\n            return;\r\n        }\r\n        this._bypassTranscoders = value;\r\n        this._isDirty = true;\r\n    }\r\n\r\n    private _ktx2DecoderOptions: IKTX2DecoderOptions = {};\r\n\r\n    /** @internal */\r\n    public _getKTX2DecoderOptions(): IKTX2DecoderOptions {\r\n        if (!this._isDirty) {\r\n            return this._ktx2DecoderOptions;\r\n        }\r\n\r\n        this._isDirty = false;\r\n\r\n        const options: IKTX2DecoderOptions = {\r\n            useRGBAIfASTCBC7NotAvailableWhenUASTC: this._useRGBAIfASTCBC7NotAvailableWhenUASTC,\r\n            forceRGBA: this._forceRGBA,\r\n            forceR8: this._forceR8,\r\n            forceRG8: this._forceRG8,\r\n            bypassTranscoders: this._bypassTranscoders,\r\n        };\r\n\r\n        if (this.useRGBAIfOnlyBC1BC3AvailableWhenUASTC) {\r\n            options.transcodeFormatDecisionTree = {\r\n                UASTC: {\r\n                    transcodeFormat: [TranscodeTarget.BC1_RGB, TranscodeTarget.BC3_RGBA],\r\n                    yes: {\r\n                        transcodeFormat: TranscodeTarget.RGBA32,\r\n                        engineFormat: EngineFormat.RGBA8Format,\r\n                        roundToMultiple4: false,\r\n                    },\r\n                },\r\n            };\r\n        }\r\n\r\n        this._ktx2DecoderOptions = options;\r\n\r\n        return options;\r\n    }\r\n}\r\n\r\n/**\r\n * Options for the KTX2 decoder\r\n */\r\nexport interface IKhronosTextureContainer2Options {\r\n    /**\r\n     * Number of workers to use for async operations. Specify `0` to disable web workers and run synchronously in the current context.\r\n     */\r\n    numWorkers?: number;\r\n    /**\r\n     * Worker pool to use for async operations. If set, `numWorkers` will be ignored.\r\n     */\r\n    workerPool?: AutoReleaseWorkerPool;\r\n    /**\r\n     * Optional container for the KTX2 decoder module and its dependencies. If set, the module will be used from this container and the URLs will be ignored.\r\n     */\r\n    binariesAndModulesContainer?: { [key in AllowedKeys]?: ArrayBuffer | any };\r\n}\r\n\r\n/**\r\n * Class for loading KTX2 files\r\n */\r\nexport class KhronosTextureContainer2 {\r\n    private static _WorkerPoolPromise?: Promise<AutoReleaseWorkerPool>;\r\n    private static _DecoderModulePromise?: Promise<any>;\r\n    private static _KTX2DecoderModule?: any;\r\n\r\n    /**\r\n     * URLs to use when loading the KTX2 decoder module as well as its dependencies\r\n     * If a url is null, the default url is used (pointing to https://preview.babylonjs.com)\r\n     * Note that jsDecoderModule can't be null and that the other dependencies will only be loaded if necessary\r\n     * Urls you can change:\r\n     *     URLConfig.jsDecoderModule\r\n     *     URLConfig.wasmUASTCToASTC\r\n     *     URLConfig.wasmUASTCToBC7\r\n     *     URLConfig.wasmUASTCToRGBA_UNORM\r\n     *     URLConfig.wasmUASTCToRGBA_SRGB\r\n     *     URLConfig.wasmUASTCToR8_UNORM\r\n     *     URLConfig.wasmUASTCToRG8_UNORM\r\n     *     URLConfig.jsMSCTranscoder\r\n     *     URLConfig.wasmMSCTranscoder\r\n     *     URLConfig.wasmZSTDDecoder\r\n     * You can see their default values in this PG: https://playground.babylonjs.com/#EIJH8L#29\r\n     */\r\n    public static URLConfig: {\r\n        jsDecoderModule: string;\r\n        wasmUASTCToASTC: Nullable<string>;\r\n        wasmUASTCToBC7: Nullable<string>;\r\n        wasmUASTCToRGBA_UNORM: Nullable<string>;\r\n        wasmUASTCToRGBA_SRGB: Nullable<string>;\r\n        wasmUASTCToR8_UNORM: Nullable<string>;\r\n        wasmUASTCToRG8_UNORM: Nullable<string>;\r\n        jsMSCTranscoder: Nullable<string>;\r\n        wasmMSCTranscoder: Nullable<string>;\r\n        wasmZSTDDecoder: Nullable<string>;\r\n    } = {\r\n        jsDecoderModule: \"https://cdn.babylonjs.com/babylon.ktx2Decoder.js\",\r\n        wasmUASTCToASTC: null,\r\n        wasmUASTCToBC7: null,\r\n        wasmUASTCToRGBA_UNORM: null,\r\n        wasmUASTCToRGBA_SRGB: null,\r\n        wasmUASTCToR8_UNORM: null,\r\n        wasmUASTCToRG8_UNORM: null,\r\n        jsMSCTranscoder: null,\r\n        wasmMSCTranscoder: null,\r\n        wasmZSTDDecoder: null,\r\n    };\r\n\r\n    /**\r\n     * If provided, this worker pool will be used instead of creating a new one.\r\n     * This is useful when loading the WASM and the js modules on your own and\r\n     * you want to use the ktxTextureLoader and not construct this class directly.\r\n     */\r\n    public static WorkerPool?: AutoReleaseWorkerPool;\r\n\r\n    /**\r\n     * Default number of workers used to handle data decoding\r\n     */\r\n    public static DefaultNumWorkers = KhronosTextureContainer2.GetDefaultNumWorkers();\r\n\r\n    /**\r\n     * Default configuration for the KTX2 decoder.\r\n     * The options defined in this way have priority over those passed when creating a KTX2 texture with new Texture(...).\r\n     */\r\n    public static DefaultDecoderOptions = new DefaultKTX2DecoderOptions();\r\n\r\n    private static GetDefaultNumWorkers(): number {\r\n        if (typeof navigator !== \"object\" || !navigator.hardwareConcurrency) {\r\n            return 1;\r\n        }\r\n\r\n        // Use 50% of the available logical processors but capped at 4.\r\n        return Math.min(Math.floor(navigator.hardwareConcurrency * 0.5), 4);\r\n    }\r\n\r\n    private _engine: AbstractEngine;\r\n\r\n    private static _Initialize(numWorkers: number): void {\r\n        if (KhronosTextureContainer2._WorkerPoolPromise || KhronosTextureContainer2._DecoderModulePromise) {\r\n            return;\r\n        }\r\n\r\n        const urls = {\r\n            jsDecoderModule: Tools.GetBabylonScriptURL(this.URLConfig.jsDecoderModule, true),\r\n            wasmUASTCToASTC: Tools.GetBabylonScriptURL(this.URLConfig.wasmUASTCToASTC, true),\r\n            wasmUASTCToBC7: Tools.GetBabylonScriptURL(this.URLConfig.wasmUASTCToBC7, true),\r\n            wasmUASTCToRGBA_UNORM: Tools.GetBabylonScriptURL(this.URLConfig.wasmUASTCToRGBA_UNORM, true),\r\n            wasmUASTCToRGBA_SRGB: Tools.GetBabylonScriptURL(this.URLConfig.wasmUASTCToRGBA_SRGB, true),\r\n            wasmUASTCToR8_UNORM: Tools.GetBabylonScriptURL(this.URLConfig.wasmUASTCToR8_UNORM, true),\r\n            wasmUASTCToRG8_UNORM: Tools.GetBabylonScriptURL(this.URLConfig.wasmUASTCToRG8_UNORM, true),\r\n            jsMSCTranscoder: Tools.GetBabylonScriptURL(this.URLConfig.jsMSCTranscoder, true),\r\n            wasmMSCTranscoder: Tools.GetBabylonScriptURL(this.URLConfig.wasmMSCTranscoder, true),\r\n            wasmZSTDDecoder: Tools.GetBabylonScriptURL(this.URLConfig.wasmZSTDDecoder, true),\r\n        };\r\n\r\n        if (numWorkers && typeof Worker === \"function\" && typeof URL !== \"undefined\") {\r\n            KhronosTextureContainer2._WorkerPoolPromise = new Promise((resolve) => {\r\n                const workerContent = `${applyConfig}(${workerFunction})()`;\r\n                const workerBlobUrl = URL.createObjectURL(new Blob([workerContent], { type: \"application/javascript\" }));\r\n                resolve(new AutoReleaseWorkerPool(numWorkers, () => initializeWebWorker(new Worker(workerBlobUrl), undefined, urls)));\r\n            });\r\n        } else {\r\n            if (typeof KhronosTextureContainer2._KTX2DecoderModule === \"undefined\") {\r\n                KhronosTextureContainer2._DecoderModulePromise = Tools.LoadBabylonScriptAsync(urls.jsDecoderModule).then(() => {\r\n                    KhronosTextureContainer2._KTX2DecoderModule = KTX2DECODER;\r\n                    KhronosTextureContainer2._KTX2DecoderModule.MSCTranscoder.UseFromWorkerThread = false;\r\n                    KhronosTextureContainer2._KTX2DecoderModule.WASMMemoryManager.LoadBinariesFromCurrentThread = true;\r\n                    applyConfig(urls, KhronosTextureContainer2._KTX2DecoderModule);\r\n                    return new KhronosTextureContainer2._KTX2DecoderModule.KTX2Decoder();\r\n                });\r\n            } else {\r\n                KhronosTextureContainer2._KTX2DecoderModule.MSCTranscoder.UseFromWorkerThread = false;\r\n                KhronosTextureContainer2._KTX2DecoderModule.WASMMemoryManager.LoadBinariesFromCurrentThread = true;\r\n                KhronosTextureContainer2._DecoderModulePromise = Promise.resolve(new KhronosTextureContainer2._KTX2DecoderModule.KTX2Decoder());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Constructor\r\n     * @param engine The engine to use\r\n     * @param numWorkersOrOptions The number of workers for async operations. Specify `0` to disable web workers and run synchronously in the current context.\r\n     */\r\n    public constructor(engine: AbstractEngine, numWorkersOrOptions: number | IKhronosTextureContainer2Options = KhronosTextureContainer2.DefaultNumWorkers) {\r\n        this._engine = engine;\r\n        const workerPoolOption = (typeof numWorkersOrOptions === \"object\" && numWorkersOrOptions.workerPool) || KhronosTextureContainer2.WorkerPool;\r\n        if (workerPoolOption) {\r\n            KhronosTextureContainer2._WorkerPoolPromise = Promise.resolve(workerPoolOption);\r\n        } else {\r\n            // set the KTX2 decoder module\r\n            if (typeof numWorkersOrOptions === \"object\") {\r\n                KhronosTextureContainer2._KTX2DecoderModule = numWorkersOrOptions?.binariesAndModulesContainer?.jsDecoderModule;\r\n            } else if (typeof KTX2DECODER !== \"undefined\") {\r\n                KhronosTextureContainer2._KTX2DecoderModule = KTX2DECODER;\r\n            }\r\n            const numberOfWorkers = typeof numWorkersOrOptions === \"number\" ? numWorkersOrOptions : (numWorkersOrOptions.numWorkers ?? KhronosTextureContainer2.DefaultNumWorkers);\r\n            KhronosTextureContainer2._Initialize(numberOfWorkers);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _uploadAsync(data: ArrayBufferView, internalTexture: InternalTexture, options?: IKTX2DecoderOptions & IDecodedData): Promise<void> {\r\n        const caps = this._engine.getCaps();\r\n\r\n        const compressedTexturesCaps: ICompressedFormatCapabilities = {\r\n            astc: !!caps.astc,\r\n            bptc: !!caps.bptc,\r\n            s3tc: !!caps.s3tc,\r\n            pvrtc: !!caps.pvrtc,\r\n            etc2: !!caps.etc2,\r\n            etc1: !!caps.etc1,\r\n        };\r\n\r\n        if (KhronosTextureContainer2._WorkerPoolPromise) {\r\n            return KhronosTextureContainer2._WorkerPoolPromise.then((workerPool) => {\r\n                return new Promise((resolve, reject) => {\r\n                    workerPool.push((worker, onComplete) => {\r\n                        const onError = (error: ErrorEvent) => {\r\n                            worker.removeEventListener(\"error\", onError);\r\n                            worker.removeEventListener(\"message\", onMessage);\r\n                            reject(error);\r\n                            onComplete();\r\n                        };\r\n\r\n                        const onMessage = (message: MessageEvent) => {\r\n                            if (message.data.action === \"decoded\") {\r\n                                worker.removeEventListener(\"error\", onError);\r\n                                worker.removeEventListener(\"message\", onMessage);\r\n                                if (!message.data.success) {\r\n                                    reject({ message: message.data.msg });\r\n                                } else {\r\n                                    try {\r\n                                        this._createTexture(message.data.decodedData, internalTexture, options);\r\n                                        resolve();\r\n                                    } catch (err) {\r\n                                        reject({ message: err });\r\n                                    }\r\n                                }\r\n                                onComplete();\r\n                            }\r\n                        };\r\n\r\n                        worker.addEventListener(\"error\", onError);\r\n                        worker.addEventListener(\"message\", onMessage);\r\n                        worker.postMessage({ action: \"setDefaultDecoderOptions\", options: KhronosTextureContainer2.DefaultDecoderOptions._getKTX2DecoderOptions() });\r\n\r\n                        const dataCopy = new Uint8Array(data.byteLength);\r\n                        dataCopy.set(new Uint8Array(data.buffer, data.byteOffset, data.byteLength));\r\n\r\n                        worker.postMessage({ action: \"decode\", data: dataCopy, caps: compressedTexturesCaps, options }, [dataCopy.buffer]);\r\n                    });\r\n                });\r\n            });\r\n        } else if (KhronosTextureContainer2._DecoderModulePromise) {\r\n            return KhronosTextureContainer2._DecoderModulePromise.then((decoder) => {\r\n                if (KhronosTextureContainer2.DefaultDecoderOptions.isDirty) {\r\n                    KhronosTextureContainer2._KTX2DecoderModule.KTX2Decoder.DefaultDecoderOptions = KhronosTextureContainer2.DefaultDecoderOptions._getKTX2DecoderOptions();\r\n                }\r\n                return new Promise((resolve, reject) => {\r\n                    decoder\r\n                        .decode(data, caps)\r\n                        .then((data: IDecodedData) => {\r\n                            this._createTexture(data, internalTexture);\r\n                            resolve();\r\n                        })\r\n                        .catch((reason: any) => {\r\n                            reject({ message: reason });\r\n                        });\r\n                });\r\n            });\r\n        }\r\n\r\n        throw new Error(\"KTX2 decoder module is not available\");\r\n    }\r\n\r\n    protected _createTexture(data: IDecodedData, internalTexture: InternalTexture, options?: IKTX2DecoderOptions & IDecodedData): void {\r\n        const oglTexture2D = 3553; // gl.TEXTURE_2D\r\n\r\n        this._engine._bindTextureDirectly(oglTexture2D, internalTexture);\r\n\r\n        if (options) {\r\n            // return back some information about the decoded data\r\n            options.transcodedFormat = data.transcodedFormat;\r\n            options.isInGammaSpace = data.isInGammaSpace;\r\n            options.hasAlpha = data.hasAlpha;\r\n            options.transcoderName = data.transcoderName;\r\n        }\r\n\r\n        let isUncompressedFormat = true;\r\n\r\n        switch (data.transcodedFormat) {\r\n            case 0x8058 /* RGBA8 */:\r\n                internalTexture.type = Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n                internalTexture.format = Constants.TEXTUREFORMAT_RGBA;\r\n                break;\r\n            case 0x8229 /* R8 */:\r\n                internalTexture.type = Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n                internalTexture.format = Constants.TEXTUREFORMAT_R;\r\n                break;\r\n            case 0x822b /* RG8 */:\r\n                internalTexture.type = Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n                internalTexture.format = Constants.TEXTUREFORMAT_RG;\r\n                break;\r\n            default:\r\n                internalTexture.format = data.transcodedFormat;\r\n                isUncompressedFormat = false;\r\n                break;\r\n        }\r\n\r\n        internalTexture._gammaSpace = data.isInGammaSpace;\r\n        internalTexture.generateMipMaps = data.mipmaps.length > 1;\r\n\r\n        if (data.errors) {\r\n            throw new Error(\"KTX2 container - could not transcode the data. \" + data.errors);\r\n        }\r\n\r\n        for (let t = 0; t < data.mipmaps.length; ++t) {\r\n            const mipmap = data.mipmaps[t];\r\n\r\n            if (!mipmap || !mipmap.data) {\r\n                throw new Error(\"KTX2 container - could not transcode one of the image\");\r\n            }\r\n\r\n            if (isUncompressedFormat) {\r\n                // uncompressed RGBA / R8 / RG8\r\n                internalTexture.width = mipmap.width; // need to set width/height so that the call to _uploadDataToTextureDirectly uses the right dimensions\r\n                internalTexture.height = mipmap.height;\r\n\r\n                this._engine._uploadDataToTextureDirectly(internalTexture, mipmap.data, 0, t, undefined, true);\r\n            } else {\r\n                this._engine._uploadCompressedDataToTextureDirectly(internalTexture, data.transcodedFormat, mipmap.width, mipmap.height, mipmap.data, 0, t);\r\n            }\r\n        }\r\n\r\n        internalTexture._extension = \".ktx2\";\r\n        internalTexture.width = data.mipmaps[0].width;\r\n        internalTexture.height = data.mipmaps[0].height;\r\n        internalTexture.isReady = true;\r\n\r\n        this._engine._bindTextureDirectly(oglTexture2D, null);\r\n    }\r\n\r\n    /**\r\n     * Checks if the given data starts with a KTX2 file identifier.\r\n     * @param data the data to check\r\n     * @returns true if the data is a KTX2 file or false otherwise\r\n     */\r\n    public static IsValid(data: ArrayBufferView): boolean {\r\n        if (data.byteLength >= 12) {\r\n            // '«', 'K', 'T', 'X', ' ', '2', '0', '»', '\\r', '\\n', '\\x1A', '\\n'\r\n            const identifier = new Uint8Array(data.buffer, data.byteOffset, 12);\r\n            if (\r\n                identifier[0] === 0xab &&\r\n                identifier[1] === 0x4b &&\r\n                identifier[2] === 0x54 &&\r\n                identifier[3] === 0x58 &&\r\n                identifier[4] === 0x20 &&\r\n                identifier[5] === 0x32 &&\r\n                identifier[6] === 0x30 &&\r\n                identifier[7] === 0xbb &&\r\n                identifier[8] === 0x0d &&\r\n                identifier[9] === 0x0a &&\r\n                identifier[10] === 0x1a &&\r\n                identifier[11] === 0x0a\r\n            ) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n}\r\n", "import { KhronosTextureContainer } from \"../../../Misc/khronosTextureContainer\";\r\nimport { KhronosTextureContainer2 } from \"../../../Misc/khronosTextureContainer2\";\r\nimport type { Nullable } from \"../../../types\";\r\nimport type { InternalTexture } from \"../../../Materials/Textures/internalTexture\";\r\nimport type { IInternalTextureLoader } from \"./internalTextureLoader\";\r\nimport { Logger } from \"../../../Misc/logger\";\r\nimport { Constants } from \"../../../Engines/constants\";\r\n\r\nfunction mapSRGBToLinear(format: number): Nullable<number> {\r\n    switch (format) {\r\n        case Constants.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:\r\n            return Constants.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1;\r\n        case Constants.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:\r\n            return Constants.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3;\r\n        case Constants.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:\r\n            return Constants.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5;\r\n        case Constants.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:\r\n            return Constants.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2;\r\n        case Constants.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:\r\n            return Constants.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC;\r\n        case Constants.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:\r\n            return Constants.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2;\r\n        case Constants.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:\r\n            return Constants.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4;\r\n        case Constants.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:\r\n            return Constants.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM;\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\n/**\r\n * Implementation of the KTX Texture Loader.\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class _KTXTextureLoader implements IInternalTextureLoader {\r\n    /**\r\n     * Defines whether the loader supports cascade loading the different faces.\r\n     */\r\n    public readonly supportCascades = false;\r\n\r\n    /**\r\n     * Uploads the cube texture data to the WebGL texture. It has already been bound.\r\n     * @param data contains the texture data\r\n     * @param texture defines the BabylonJS internal texture\r\n     * @param createPolynomials will be true if polynomials have been requested\r\n     * @param onLoad defines the callback to trigger once the texture is ready\r\n     */\r\n    public loadCubeData(data: ArrayBufferView | ArrayBufferView[], texture: InternalTexture, createPolynomials: boolean, onLoad: Nullable<(data?: any) => void>): void {\r\n        if (Array.isArray(data)) {\r\n            return;\r\n        }\r\n\r\n        // Need to invert vScale as invertY via UNPACK_FLIP_Y_WEBGL is not supported by compressed texture\r\n        texture._invertVScale = !texture.invertY;\r\n        const engine = texture.getEngine();\r\n        const ktx = new KhronosTextureContainer(data, 6);\r\n\r\n        const loadMipmap = ktx.numberOfMipmapLevels > 1 && texture.generateMipMaps;\r\n\r\n        engine._unpackFlipY(true);\r\n\r\n        ktx.uploadLevels(texture, texture.generateMipMaps);\r\n\r\n        texture.width = ktx.pixelWidth;\r\n        texture.height = ktx.pixelHeight;\r\n\r\n        engine._setCubeMapTextureParams(texture, loadMipmap, ktx.numberOfMipmapLevels - 1);\r\n        texture.isReady = true;\r\n        texture.onLoadedObservable.notifyObservers(texture);\r\n        texture.onLoadedObservable.clear();\r\n\r\n        if (onLoad) {\r\n            onLoad();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Uploads the 2D texture data to the WebGL texture. It has already been bound once in the callback.\r\n     * @param data contains the texture data\r\n     * @param texture defines the BabylonJS internal texture\r\n     * @param callback defines the method to call once ready to upload\r\n     * @param options\r\n     */\r\n    public loadData(\r\n        data: ArrayBufferView,\r\n        texture: InternalTexture,\r\n        callback: (width: number, height: number, loadMipmap: boolean, isCompressed: boolean, done: () => void, loadFailed: boolean) => void,\r\n        options?: any\r\n    ): void {\r\n        if (KhronosTextureContainer.IsValid(data)) {\r\n            // Need to invert vScale as invertY via UNPACK_FLIP_Y_WEBGL is not supported by compressed texture\r\n            texture._invertVScale = !texture.invertY;\r\n            const ktx = new KhronosTextureContainer(data, 1);\r\n\r\n            const mappedFormat = mapSRGBToLinear(ktx.glInternalFormat);\r\n            if (mappedFormat) {\r\n                texture.format = mappedFormat;\r\n                texture._useSRGBBuffer = texture.getEngine()._getUseSRGBBuffer(true, texture.generateMipMaps);\r\n                texture._gammaSpace = true;\r\n            } else {\r\n                texture.format = ktx.glInternalFormat;\r\n            }\r\n\r\n            callback(\r\n                ktx.pixelWidth,\r\n                ktx.pixelHeight,\r\n                texture.generateMipMaps,\r\n                true,\r\n                () => {\r\n                    ktx.uploadLevels(texture, texture.generateMipMaps);\r\n                },\r\n                ktx.isInvalid\r\n            );\r\n        } else if (KhronosTextureContainer2.IsValid(data)) {\r\n            const ktx2 = new KhronosTextureContainer2(texture.getEngine());\r\n            ktx2._uploadAsync(data, texture, options).then(\r\n                () => {\r\n                    callback(texture.width, texture.height, texture.generateMipMaps, true, () => {}, false);\r\n                },\r\n                (error) => {\r\n                    Logger.Warn(`Failed to load KTX2 texture data: ${error.message}`);\r\n                    callback(0, 0, false, false, () => {}, true);\r\n                }\r\n            );\r\n        } else {\r\n            Logger.Error(\"texture missing KTX identifier\");\r\n            callback(0, 0, false, false, () => {}, true);\r\n        }\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": ["worker", "SourceTextureFormat", "TranscodeTarget", "EngineFormat", "data"]
}
