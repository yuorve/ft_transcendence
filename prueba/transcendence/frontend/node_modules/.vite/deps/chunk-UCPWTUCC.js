import {
  UniformBuffer,
  UniqueIdGenerator
} from "./chunk-W4DJKU2D.js";
import {
  PerfCounter
} from "./chunk-3FRLE6QB.js";
import {
  SerializationHelper,
  Texture
} from "./chunk-2TFE2SGV.js";
import {
  __decorate,
  serialize
} from "./chunk-F2Q6VL66.js";
import {
  Vector3
} from "./chunk-KGK6CYQL.js";
import {
  VertexBuffer
} from "./chunk-4NAEY6NG.js";
import {
  RegisterClass
} from "./chunk-LMH7SWDS.js";
import {
  TextureSampler,
  _retryWithInterval
} from "./chunk-3EDTXWHH.js";
import {
  Logger
} from "./chunk-OJJXGLTO.js";
import {
  ShaderStore
} from "./chunk-FX6MN5HL.js";

// node_modules/@babylonjs/core/Engines/WebGPU/webgpuPerfCounter.js
var WebGPUPerfCounter = class {
  constructor() {
    this._gpuTimeInFrameId = -1;
    this.counter = new PerfCounter();
  }
  /**
   * @internal
   */
  _addDuration(currentFrameId, duration) {
    if (currentFrameId < this._gpuTimeInFrameId) {
      return;
    }
    if (this._gpuTimeInFrameId !== currentFrameId) {
      this.counter._fetchResult();
      this.counter.fetchNewFrame();
      this.counter.addCount(duration, false);
      this._gpuTimeInFrameId = currentFrameId;
    } else {
      this.counter.addCount(duration, false);
    }
  }
};

// node_modules/@babylonjs/core/Compute/computeShader.js
var ComputeShader = class _ComputeShader {
  /**
   * The options used to create the shader
   */
  get options() {
    return this._options;
  }
  /**
   * The shaderPath used to create the shader
   */
  get shaderPath() {
    return this._shaderPath;
  }
  /**
   * Instantiates a new compute shader.
   * @param name Defines the name of the compute shader in the scene
   * @param engine Defines the engine the compute shader belongs to
   * @param shaderPath Defines the route to the shader code in one of three ways:
   *  * object: \{ compute: "custom" \}, used with ShaderStore.ShadersStoreWGSL["customComputeShader"]
   *  * object: \{ computeElement: "HTMLElementId" \}, used with shader code in script tags
   *  * object: \{ computeSource: "compute shader code string" \}, where the string contains the shader code
   *  * string: try first to find the code in ShaderStore.ShadersStoreWGSL[shaderPath + "ComputeShader"]. If not, assumes it is a file with name shaderPath.compute.fx in index.html folder.
   * @param options Define the options used to create the shader
   */
  constructor(name2, engine, shaderPath, options = {}) {
    this._bindings = {};
    this._samplers = {};
    this._contextIsDirty = false;
    this.fastMode = false;
    this.onCompiled = null;
    this.onError = null;
    this.name = name2;
    this._engine = engine;
    this.uniqueId = UniqueIdGenerator.UniqueId;
    if (engine.enableGPUTimingMeasurements) {
      this.gpuTimeInFrame = new WebGPUPerfCounter();
    }
    if (!this._engine.getCaps().supportComputeShaders) {
      Logger.Error("This engine does not support compute shaders!");
      return;
    }
    if (!options.bindingsMapping) {
      Logger.Error("You must provide the binding mappings as browsers don't support reflection for wgsl shaders yet!");
      return;
    }
    this._context = engine.createComputeContext();
    this._shaderPath = shaderPath;
    this._options = {
      bindingsMapping: {},
      defines: [],
      ...options
    };
  }
  /**
   * Gets the current class name of the material e.g. "ComputeShader"
   * Mainly use in serialization.
   * @returns the class name
   */
  getClassName() {
    return "ComputeShader";
  }
  /**
   * Binds a texture to the shader
   * @param name Binding name of the texture
   * @param texture Texture to bind
   * @param bindSampler Bind the sampler corresponding to the texture (default: true). The sampler will be bound just before the binding index of the texture
   */
  setTexture(name2, texture, bindSampler = true) {
    const current = this._bindings[name2];
    this._bindings[name2] = {
      type: bindSampler ? 0 : 4,
      object: texture,
      indexInGroupEntries: current == null ? void 0 : current.indexInGroupEntries
    };
    this._contextIsDirty || (this._contextIsDirty = !current || current.object !== texture || current.type !== this._bindings[name2].type);
  }
  /**
   * Binds a storage texture to the shader
   * @param name Binding name of the texture
   * @param texture Texture to bind
   */
  setStorageTexture(name2, texture) {
    const current = this._bindings[name2];
    this._contextIsDirty || (this._contextIsDirty = !current || current.object !== texture);
    this._bindings[name2] = {
      type: 1,
      object: texture,
      indexInGroupEntries: current == null ? void 0 : current.indexInGroupEntries
    };
  }
  /**
   * Binds an external texture to the shader
   * @param name Binding name of the texture
   * @param texture Texture to bind
   */
  setExternalTexture(name2, texture) {
    const current = this._bindings[name2];
    this._contextIsDirty || (this._contextIsDirty = !current || current.object !== texture);
    this._bindings[name2] = {
      type: 6,
      object: texture,
      indexInGroupEntries: current == null ? void 0 : current.indexInGroupEntries
    };
  }
  /**
   * Binds a video texture to the shader (by binding the external texture attached to this video)
   * @param name Binding name of the texture
   * @param texture Texture to bind
   * @returns true if the video texture was successfully bound, else false. false will be returned if the current engine does not support external textures
   */
  setVideoTexture(name2, texture) {
    if (texture.externalTexture) {
      this.setExternalTexture(name2, texture.externalTexture);
      return true;
    }
    return false;
  }
  /**
   * Binds a uniform buffer to the shader
   * @param name Binding name of the buffer
   * @param buffer Buffer to bind
   */
  setUniformBuffer(name2, buffer) {
    const current = this._bindings[name2];
    this._contextIsDirty || (this._contextIsDirty = !current || current.object !== buffer);
    this._bindings[name2] = {
      type: _ComputeShader._BufferIsDataBuffer(buffer) ? 7 : 2,
      object: buffer,
      indexInGroupEntries: current == null ? void 0 : current.indexInGroupEntries
    };
  }
  /**
   * Binds a storage buffer to the shader
   * @param name Binding name of the buffer
   * @param buffer Buffer to bind
   */
  setStorageBuffer(name2, buffer) {
    const current = this._bindings[name2];
    this._contextIsDirty || (this._contextIsDirty = !current || current.object !== buffer);
    this._bindings[name2] = {
      type: _ComputeShader._BufferIsDataBuffer(buffer) ? 7 : 3,
      object: buffer,
      indexInGroupEntries: current == null ? void 0 : current.indexInGroupEntries
    };
  }
  /**
   * Binds a texture sampler to the shader
   * @param name Binding name of the sampler
   * @param sampler Sampler to bind
   */
  setTextureSampler(name2, sampler) {
    const current = this._bindings[name2];
    this._contextIsDirty || (this._contextIsDirty = !current || !sampler.compareSampler(current.object));
    this._bindings[name2] = {
      type: 5,
      object: sampler,
      indexInGroupEntries: current == null ? void 0 : current.indexInGroupEntries
    };
  }
  /**
   * Specifies that the compute shader is ready to be executed (the compute effect and all the resources are ready)
   * @returns true if the compute shader is ready to be executed
   */
  isReady() {
    let effect = this._effect;
    for (const key in this._bindings) {
      const binding = this._bindings[key], type = binding.type, object = binding.object;
      switch (type) {
        case 0:
        case 4:
        case 1: {
          const texture = object;
          if (!texture.isReady()) {
            return false;
          }
          break;
        }
        case 6: {
          const texture = object;
          if (!texture.isReady()) {
            return false;
          }
          break;
        }
      }
    }
    const defines = [];
    const shaderName = this._shaderPath;
    if (this._options.defines) {
      for (let index = 0; index < this._options.defines.length; index++) {
        defines.push(this._options.defines[index]);
      }
    }
    const join = defines.join("\n");
    if (this._cachedDefines !== join) {
      this._cachedDefines = join;
      effect = this._engine.createComputeEffect(shaderName, {
        defines: join,
        entryPoint: this._options.entryPoint,
        onCompiled: this.onCompiled,
        onError: this.onError
      });
      this._effect = effect;
    }
    if (!effect.isReady()) {
      return false;
    }
    return true;
  }
  /**
   * Dispatches (executes) the compute shader
   * @param x Number of workgroups to execute on the X dimension
   * @param y Number of workgroups to execute on the Y dimension (default: 1)
   * @param z Number of workgroups to execute on the Z dimension (default: 1)
   * @returns True if the dispatch could be done, else false (meaning either the compute effect or at least one of the bound resources was not ready)
   */
  dispatch(x, y, z) {
    if (!this.fastMode && !this._checkContext()) {
      return false;
    }
    this._engine.computeDispatch(this._effect, this._context, this._bindings, x, y, z, this._options.bindingsMapping, this.gpuTimeInFrame);
    return true;
  }
  /**
   * Dispatches (executes) the compute shader.
   * @param buffer Buffer containing the number of workgroups to execute on the X, Y and Z dimensions
   * @param offset Offset in the buffer where the workgroup counts are stored (default: 0)
   * @returns True if the dispatch could be done, else false (meaning either the compute effect or at least one of the bound resources was not ready)
   */
  dispatchIndirect(buffer, offset = 0) {
    if (!this.fastMode && !this._checkContext()) {
      return false;
    }
    const dataBuffer = _ComputeShader._BufferIsDataBuffer(buffer) ? buffer : buffer.getBuffer();
    this._engine.computeDispatchIndirect(this._effect, this._context, this._bindings, dataBuffer, offset, this._options.bindingsMapping, this.gpuTimeInFrame);
    return true;
  }
  _checkContext() {
    var _a;
    if (!this.isReady()) {
      return false;
    }
    for (const key in this._bindings) {
      const binding = this._bindings[key];
      if (!this._options.bindingsMapping[key]) {
        throw new Error("ComputeShader ('" + this.name + "'): No binding mapping has been provided for the property '" + key + "'");
      }
      switch (binding.type) {
        case 0: {
          const sampler = this._samplers[key];
          const texture = binding.object;
          if (!sampler || !texture._texture || !sampler.compareSampler(texture._texture)) {
            this._samplers[key] = new TextureSampler().setParameters(texture.wrapU, texture.wrapV, texture.wrapR, texture.anisotropicFilteringLevel, texture._texture.samplingMode, (_a = texture._texture) == null ? void 0 : _a._comparisonFunction);
            this._contextIsDirty = true;
          }
          break;
        }
        case 6: {
          this._contextIsDirty = true;
          break;
        }
        case 2: {
          const ubo = binding.object;
          if (ubo.getBuffer() !== binding.buffer) {
            binding.buffer = ubo.getBuffer();
            this._contextIsDirty = true;
          }
          break;
        }
      }
    }
    if (this._contextIsDirty) {
      this._contextIsDirty = false;
      this._context.clear();
    }
    return true;
  }
  /**
   * Waits for the compute shader to be ready and executes it
   * @param x Number of workgroups to execute on the X dimension
   * @param y Number of workgroups to execute on the Y dimension (default: 1)
   * @param z Number of workgroups to execute on the Z dimension (default: 1)
   * @param delay Delay between the retries while the shader is not ready (in milliseconds - 10 by default)
   * @returns A promise that is resolved once the shader has been sent to the GPU. Note that it does not mean that the shader execution itself is finished!
   */
  dispatchWhenReady(x, y, z, delay = 10) {
    return new Promise((resolve) => {
      _retryWithInterval(() => this.dispatch(x, y, z), resolve, void 0, delay);
    });
  }
  /**
   * Serializes this compute shader in a JSON representation
   * @returns the serialized compute shader object
   */
  serialize() {
    const serializationObject = SerializationHelper.Serialize(this);
    serializationObject.options = this._options;
    serializationObject.shaderPath = this._shaderPath;
    serializationObject.bindings = {};
    serializationObject.textures = {};
    for (const key in this._bindings) {
      const binding = this._bindings[key];
      const object = binding.object;
      switch (binding.type) {
        case 0:
        case 4:
        case 1: {
          const serializedData = object.serialize();
          if (serializedData) {
            serializationObject.textures[key] = serializedData;
            serializationObject.bindings[key] = {
              type: binding.type
            };
          }
          break;
        }
        case 2: {
          break;
        }
      }
    }
    return serializationObject;
  }
  /**
   * Creates a compute shader from parsed compute shader data
   * @param source defines the JSON representation of the compute shader
   * @param scene defines the hosting scene
   * @param rootUrl defines the root URL to use to load textures and relative dependencies
   * @returns a new compute shader
   */
  static Parse(source, scene, rootUrl) {
    const compute = SerializationHelper.Parse(() => new _ComputeShader(source.name, scene.getEngine(), source.shaderPath, source.options), source, scene, rootUrl);
    for (const key in source.textures) {
      const binding = source.bindings[key];
      const texture = Texture.Parse(source.textures[key], scene, rootUrl);
      if (binding.type === 0) {
        compute.setTexture(key, texture);
      } else if (binding.type === 4) {
        compute.setTexture(key, texture, false);
      } else {
        compute.setStorageTexture(key, texture);
      }
    }
    return compute;
  }
  static _BufferIsDataBuffer(buffer) {
    return buffer.underlyingResource !== void 0;
  }
};
__decorate([
  serialize()
], ComputeShader.prototype, "name", void 0);
__decorate([
  serialize()
], ComputeShader.prototype, "fastMode", void 0);
RegisterClass("BABYLON.ComputeShader", ComputeShader);

// node_modules/@babylonjs/core/Buffers/storageBuffer.js
var StorageBuffer = class {
  /**
   * Creates a new storage buffer instance
   * @param engine The engine the buffer will be created inside
   * @param size The size of the buffer in bytes
   * @param creationFlags flags to use when creating the buffer (see undefined). The BUFFER_CREATIONFLAG_STORAGE flag will be automatically added.
   * @param label defines the label of the buffer (for debug purpose)
   */
  constructor(engine, size, creationFlags = 3, label) {
    this._engine = engine;
    this._label = label;
    this._engine._storageBuffers.push(this);
    this._create(size, creationFlags);
  }
  _create(size, creationFlags) {
    this._bufferSize = size;
    this._creationFlags = creationFlags;
    this._buffer = this._engine.createStorageBuffer(size, creationFlags, this._label);
  }
  /** @internal */
  _rebuild() {
    this._create(this._bufferSize, this._creationFlags);
  }
  /**
   * Gets underlying native buffer
   * @returns underlying native buffer
   */
  getBuffer() {
    return this._buffer;
  }
  /**
   * Updates the storage buffer
   * @param data the data used to update the storage buffer
   * @param byteOffset the byte offset of the data (optional)
   * @param byteLength the byte length of the data (optional)
   */
  update(data, byteOffset, byteLength) {
    if (!this._buffer) {
      return;
    }
    this._engine.updateStorageBuffer(this._buffer, data, byteOffset, byteLength);
  }
  /**
   * Reads data from the storage buffer
   * @param offset The offset in the storage buffer to start reading from (default: 0)
   * @param size  The number of bytes to read from the storage buffer (default: capacity of the buffer)
   * @param buffer The buffer to write the data we have read from the storage buffer to (optional)
   * @param noDelay If true, a call to flushFramebuffer will be issued so that the data can be read back immediately. This can speed up data retrieval, at the cost of a small perf penalty (default: false).
   * @returns If not undefined, returns the (promise) buffer (as provided by the 4th parameter) filled with the data, else it returns a (promise) Uint8Array with the data read from the storage buffer
   */
  read(offset, size, buffer, noDelay) {
    return this._engine.readFromStorageBuffer(this._buffer, offset, size, buffer, noDelay);
  }
  /**
   * Disposes the storage buffer
   */
  dispose() {
    const storageBuffers = this._engine._storageBuffers;
    const index = storageBuffers.indexOf(this);
    if (index !== -1) {
      storageBuffers[index] = storageBuffers[storageBuffers.length - 1];
      storageBuffers.pop();
    }
    this._engine._releaseBuffer(this._buffer);
    this._buffer = null;
  }
};

// node_modules/@babylonjs/core/ShadersWGSL/boundingInfo.compute.js
var name = "boundingInfoComputeShader";
var shader = `struct Results {minX : atomic<i32>,
minY : atomic<i32>,
minZ : atomic<i32>,
maxX : atomic<i32>,
maxY : atomic<i32>,
maxZ : atomic<i32>,
dummy1 : i32,
dummy2 : i32,};fn floatToBits(value: f32)->i32 {return bitcast<i32>(value);}
fn bitsToFloat(value: i32)->f32 {return bitcast<f32>(value);}
fn atomicMinFloat(atomicVar: ptr<storage,atomic<i32>,read_write>,value: f32) {let intValue=floatToBits(value);loop {let oldIntValue=atomicLoad(atomicVar);let oldValue=bitsToFloat(oldIntValue);if (value>=oldValue) {break;}
if (atomicCompareExchangeWeak(atomicVar,oldIntValue,intValue).old_value==oldIntValue) {break;}}}
fn atomicMaxFloat(atomicVar: ptr<storage,atomic<i32>,read_write>,value: f32) {let intValue=floatToBits(value);loop {let oldIntValue=atomicLoad(atomicVar);let oldValue=bitsToFloat(oldIntValue);if (value<=oldValue) {break;}
if (atomicCompareExchangeWeak(atomicVar,oldIntValue,intValue).old_value==oldIntValue) {break;}}}
fn readMatrixFromRawSampler(smp : texture_2d<f32>,index : f32)->mat4x4<f32>
{let offset=i32(index) *4; 
let m0=textureLoad(smp,vec2<i32>(offset+0,0),0);let m1=textureLoad(smp,vec2<i32>(offset+1,0),0);let m2=textureLoad(smp,vec2<i32>(offset+2,0),0);let m3=textureLoad(smp,vec2<i32>(offset+3,0),0);return mat4x4<f32>(m0,m1,m2,m3);}
const identity=mat4x4f(
vec4f(1.0,0.0,0.0,0.0),
vec4f(0.0,1.0,0.0,0.0),
vec4f(0.0,0.0,1.0,0.0),
vec4f(0.0,0.0,0.0,1.0)
);struct Settings {morphTargetTextureInfo: vec3f,
morphTargetCount: i32,
indexResult : u32,};@group(0) @binding(0) var<storage,read> positionBuffer : array<f32>;@group(0) @binding(1) var<storage,read_write> resultBuffer : array<Results>;@group(0) @binding(7) var<uniform> settings : Settings;
#if NUM_BONE_INFLUENCERS>0
@group(0) @binding(2) var boneSampler : texture_2d<f32>;@group(0) @binding(3) var<storage,read> indexBuffer : array<vec4f>;@group(0) @binding(4) var<storage,read> weightBuffer : array<vec4f>;
#if NUM_BONE_INFLUENCERS>4
@group(0) @binding(5) var<storage,read> indexExtraBuffer : array<vec4f>;@group(0) @binding(6) var<storage,read> weightExtraBuffer : array<vec4f>;
#endif
#endif
#ifdef MORPHTARGETS
@group(0) @binding(8) var morphTargets : texture_2d_array<f32>;@group(0) @binding(9) var<storage,read> morphTargetInfluences : array<f32>;@group(0) @binding(10) var<storage,read> morphTargetTextureIndices : array<f32>;
#endif
#ifdef MORPHTARGETS
fn readVector3FromRawSampler(targetIndex : i32,vertexIndex : u32)->vec3f
{ 
let vertexID=f32(vertexIndex)*settings.morphTargetTextureInfo.x;let y=floor(vertexID/settings.morphTargetTextureInfo.y);let x=vertexID-y*settings.morphTargetTextureInfo.y;let textureUV=vec2<i32>(i32(x),i32(y));return textureLoad(morphTargets,textureUV,i32(morphTargetTextureIndices[targetIndex]),0).xyz;}
fn readVector4FromRawSampler(targetIndex : i32,vertexIndex : u32)->vec4f
{ 
let vertexID=f32(vertexIndex)*settings.morphTargetTextureInfo.x;let y=floor(vertexID/settings.morphTargetTextureInfo.y);let x=vertexID-y*settings.morphTargetTextureInfo.y;let textureUV=vec2<i32>(i32(x),i32(y));return textureLoad(morphTargets,textureUV,i32(morphTargetTextureIndices[targetIndex]),0);}
#endif
@compute @workgroup_size(256,1,1)
fn main(@builtin(global_invocation_id) global_id : vec3<u32>) {let index=global_id.x;if (index>=arrayLength(&positionBuffer)/3) {return;}
let position=vec3f(positionBuffer[index*3],positionBuffer[index*3+1],positionBuffer[index*3+2]);var finalWorld=identity;var positionUpdated=position;
#if NUM_BONE_INFLUENCERS>0
var influence : mat4x4<f32>;let matricesIndices=indexBuffer[index];let matricesWeights=weightBuffer[index];influence=readMatrixFromRawSampler(boneSampler,matricesIndices[0])*matricesWeights[0];
#if NUM_BONE_INFLUENCERS>1
influence=influence+readMatrixFromRawSampler(boneSampler,matricesIndices[1])*matricesWeights[1];
#endif 
#if NUM_BONE_INFLUENCERS>2
influence=influence+readMatrixFromRawSampler(boneSampler,matricesIndices[2])*matricesWeights[2];
#endif 
#if NUM_BONE_INFLUENCERS>3
influence=influence+readMatrixFromRawSampler(boneSampler,matricesIndices[3])*matricesWeights[3];
#endif 
#if NUM_BONE_INFLUENCERS>4
let matricesIndicesExtra=indexExtraBuffer[index];let matricesWeightsExtra=weightExtraBuffer[index];influence=influence+readMatrixFromRawSampler(boneSampler,matricesIndicesExtra.x)*matricesWeightsExtra.x;
#if NUM_BONE_INFLUENCERS>5
influence=influence+readMatrixFromRawSampler(boneSampler,matricesIndicesExtra.y)*matricesWeightsExtra.y;
#endif 
#if NUM_BONE_INFLUENCERS>6
influence=influence+readMatrixFromRawSampler(boneSampler,matricesIndicesExtra.z)*matricesWeightsExtra.z;
#endif 
#if NUM_BONE_INFLUENCERS>7
influence=influence+readMatrixFromRawSampler(boneSampler,matricesIndicesExtra.w)*matricesWeightsExtra.w;
#endif 
#endif 
finalWorld=finalWorld*influence;
#endif
#ifdef MORPHTARGETS
for (var i=0; i<NUM_MORPH_INFLUENCERS; i=i+1) {if (i>=settings.morphTargetCount) {break;}
positionUpdated=positionUpdated+(readVector3FromRawSampler(i,index)-position)*morphTargetInfluences[i];}
#endif
var worldPos=finalWorld*vec4f(positionUpdated.x,positionUpdated.y,positionUpdated.z,1.0);atomicMinFloat(&resultBuffer[settings.indexResult].minX,worldPos.x);atomicMinFloat(&resultBuffer[settings.indexResult].minY,worldPos.y);atomicMinFloat(&resultBuffer[settings.indexResult].minZ,worldPos.z);atomicMaxFloat(&resultBuffer[settings.indexResult].maxX,worldPos.x);atomicMaxFloat(&resultBuffer[settings.indexResult].maxY,worldPos.y);atomicMaxFloat(&resultBuffer[settings.indexResult].maxZ,worldPos.z);}
`;
ShaderStore.ShadersStoreWGSL[name] = shader;

// node_modules/@babylonjs/core/Culling/Helper/computeShaderBoundingHelper.js
var ComputeShaderBoundingHelper = class {
  /**
   * Creates a new ComputeShaderBoundingHelper
   * @param engine defines the engine to use
   */
  constructor(engine) {
    this._computeShadersCache = {};
    this._positionBuffers = {};
    this._indexBuffers = {};
    this._weightBuffers = {};
    this._indexExtraBuffers = {};
    this._weightExtraBuffers = {};
    this._morphTargetInfluenceBuffers = {};
    this._morphTargetTextureIndexBuffers = {};
    this._ubos = [];
    this._uboIndex = 0;
    this._processedMeshes = [];
    this._computeShaders = [];
    this._uniqueComputeShaders = /* @__PURE__ */ new Set();
    this._resultBuffers = [];
    this._engine = engine;
  }
  _getComputeShader(defines, hasBones, hasMorphs) {
    let computeShader;
    const join = defines.join("\n");
    if (!this._computeShadersCache[join]) {
      const bindingsMapping = {
        positionBuffer: { group: 0, binding: 0 },
        resultBuffer: { group: 0, binding: 1 },
        settings: { group: 0, binding: 7 }
      };
      if (hasBones) {
        bindingsMapping.boneSampler = { group: 0, binding: 2 };
        bindingsMapping.indexBuffer = { group: 0, binding: 3 };
        bindingsMapping.weightBuffer = { group: 0, binding: 4 };
        bindingsMapping.indexExtraBuffer = { group: 0, binding: 5 };
        bindingsMapping.weightExtraBuffer = { group: 0, binding: 6 };
      }
      if (hasMorphs) {
        bindingsMapping.morphTargets = { group: 0, binding: 8 };
        bindingsMapping.morphTargetInfluences = { group: 0, binding: 9 };
        bindingsMapping.morphTargetTextureIndices = { group: 0, binding: 10 };
      }
      computeShader = new ComputeShader(`boundingInfoCompute${hasBones ? "_bones" : ""}${hasMorphs ? "_morphs" : ""}`, this._engine, "boundingInfo", {
        bindingsMapping,
        defines
      });
      this._computeShadersCache[join] = computeShader;
    } else {
      computeShader = this._computeShadersCache[join];
    }
    return computeShader;
  }
  _getUBO() {
    if (this._uboIndex >= this._ubos.length) {
      const ubo = new UniformBuffer(this._engine);
      ubo.addFloat3("morphTargetTextureInfo", 0, 0, 0);
      ubo.addUniform("morphTargetCount", 1);
      ubo.addUniform("indexResult", 1);
      this._ubos.push(ubo);
    }
    return this._ubos[this._uboIndex++];
  }
  _extractDataAndLink(computeShader, mesh, kind, stride, name2, storageUnit) {
    var _a;
    let buffer;
    const vertexCount = mesh.getTotalVertices();
    if (!storageUnit[mesh.uniqueId]) {
      const dataArray = (_a = mesh.getVertexBuffer(kind)) == null ? void 0 : _a.getFloatData(vertexCount);
      buffer = new StorageBuffer(this._engine, Float32Array.BYTES_PER_ELEMENT * vertexCount * stride);
      buffer.update(dataArray);
      storageUnit[mesh.uniqueId] = buffer;
    } else {
      buffer = storageUnit[mesh.uniqueId];
    }
    computeShader.setStorageBuffer(name2, buffer);
  }
  _prepareStorage(computeShader, name2, id, storageUnit, numInfluencers, data) {
    let buffer;
    if (!storageUnit[id]) {
      buffer = new StorageBuffer(this._engine, Float32Array.BYTES_PER_ELEMENT * numInfluencers);
      storageUnit[id] = buffer;
    } else {
      buffer = storageUnit[id];
    }
    buffer.update(data);
    computeShader.setStorageBuffer(name2, buffer);
  }
  /** @internal */
  async processAsync(meshes) {
    await this.registerMeshListAsync(meshes);
    this.processMeshList();
    await this.fetchResultsForMeshListAsync();
  }
  /** @internal */
  registerMeshListAsync(meshes) {
    this._disposeForMeshList();
    if (!Array.isArray(meshes)) {
      meshes = [meshes];
    }
    let maxNumInfluencers = 0;
    for (let i = 0; i < meshes.length; i++) {
      const mesh = meshes[i];
      const vertexCount = mesh.getTotalVertices();
      if (vertexCount === 0 || !mesh.getVertexBuffer || !mesh.getVertexBuffer(VertexBuffer.PositionKind)) {
        continue;
      }
      this._processedMeshes.push(mesh);
      const manager = mesh.morphTargetManager;
      if (manager && manager.supportsPositions) {
        maxNumInfluencers = Math.max(maxNumInfluencers, manager.numTargets);
      }
    }
    for (let i = 0; i < this._processedMeshes.length; i++) {
      const mesh = this._processedMeshes[i];
      let defines = [""];
      let hasBones = false;
      if (mesh && mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {
        defines.push("#define NUM_BONE_INFLUENCERS " + mesh.numBoneInfluencers);
        hasBones = true;
      }
      const computeShaderWithoutMorph = this._getComputeShader(defines, hasBones, false);
      this._uniqueComputeShaders.add(computeShaderWithoutMorph);
      const manager = mesh.morphTargetManager;
      if (manager && manager.supportsPositions) {
        defines = defines.slice();
        defines.push("#define MORPHTARGETS");
        defines.push("#define NUM_MORPH_INFLUENCERS " + maxNumInfluencers);
        const computeShaderWithMorph = this._getComputeShader(defines, hasBones, true);
        this._uniqueComputeShaders.add(computeShaderWithMorph);
        this._computeShaders.push([computeShaderWithoutMorph, computeShaderWithMorph]);
      } else {
        this._computeShaders.push([computeShaderWithoutMorph, computeShaderWithoutMorph]);
      }
      const ubo = this._getUBO();
      ubo.updateUInt("indexResult", i);
      ubo.update();
    }
    return new Promise((resolve) => {
      _retryWithInterval(() => {
        const iterator = this._uniqueComputeShaders.keys();
        for (let key = iterator.next(); key.done !== true; key = iterator.next()) {
          const computeShader = key.value;
          if (!computeShader.isReady()) {
            return false;
          }
        }
        return true;
      }, resolve);
    });
  }
  /** @internal */
  processMeshList() {
    if (this._processedMeshes.length === 0) {
      return;
    }
    this._uboIndex = 0;
    const resultDataSize = 8 * this._processedMeshes.length;
    const resultData = new Float32Array(resultDataSize);
    const resultBuffer = new StorageBuffer(this._engine, Float32Array.BYTES_PER_ELEMENT * resultDataSize);
    this._resultBuffers.push(resultBuffer);
    for (let i = 0; i < this._processedMeshes.length; i++) {
      resultData[i * 8 + 0] = Number.POSITIVE_INFINITY;
      resultData[i * 8 + 1] = Number.POSITIVE_INFINITY;
      resultData[i * 8 + 2] = Number.POSITIVE_INFINITY;
      resultData[i * 8 + 3] = Number.NEGATIVE_INFINITY;
      resultData[i * 8 + 4] = Number.NEGATIVE_INFINITY;
      resultData[i * 8 + 5] = Number.NEGATIVE_INFINITY;
    }
    resultBuffer.update(resultData);
    for (let i = 0; i < this._processedMeshes.length; i++) {
      const mesh = this._processedMeshes[i];
      const vertexCount = mesh.getTotalVertices();
      const [computeShaderWithoutMorph, computeShaderWithMorph] = this._computeShaders[i];
      const manager = mesh.morphTargetManager;
      const hasMorphs = manager && manager.numInfluencers > 0 && manager.supportsPositions;
      const computeShader = hasMorphs ? computeShaderWithMorph : computeShaderWithoutMorph;
      this._extractDataAndLink(computeShader, mesh, VertexBuffer.PositionKind, 3, "positionBuffer", this._positionBuffers);
      if (mesh && mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton && mesh.skeleton.useTextureToStoreBoneMatrices) {
        this._extractDataAndLink(computeShader, mesh, VertexBuffer.MatricesIndicesKind, 4, "indexBuffer", this._indexBuffers);
        this._extractDataAndLink(computeShader, mesh, VertexBuffer.MatricesWeightsKind, 4, "weightBuffer", this._weightBuffers);
        const boneSampler = mesh.skeleton.getTransformMatrixTexture(mesh);
        computeShader.setTexture("boneSampler", boneSampler, false);
        if (mesh.numBoneInfluencers > 4) {
          this._extractDataAndLink(computeShader, mesh, VertexBuffer.MatricesIndicesExtraKind, 4, "indexExtraBuffer", this._indexExtraBuffers);
          this._extractDataAndLink(computeShader, mesh, VertexBuffer.MatricesWeightsExtraKind, 4, "weightExtraBuffer", this._weightExtraBuffers);
        }
      }
      const ubo = this._getUBO();
      if (hasMorphs) {
        const morphTargets = manager._targetStoreTexture;
        computeShader.setTexture("morphTargets", morphTargets, false);
        this._prepareStorage(computeShader, "morphTargetInfluences", mesh.uniqueId, this._morphTargetInfluenceBuffers, manager.numInfluencers, manager.influences);
        this._prepareStorage(computeShader, "morphTargetTextureIndices", mesh.uniqueId, this._morphTargetTextureIndexBuffers, manager.numInfluencers, manager._morphTargetTextureIndices);
        ubo.updateFloat3("morphTargetTextureInfo", manager._textureVertexStride, manager._textureWidth, manager._textureHeight);
        ubo.updateInt("morphTargetCount", manager.numInfluencers);
        ubo.update();
      }
      computeShader.setStorageBuffer("resultBuffer", resultBuffer);
      computeShader.setUniformBuffer("settings", ubo);
      computeShader.dispatch(Math.ceil(vertexCount / 256));
      this._engine.flushFramebuffer();
    }
  }
  /** @internal */
  fetchResultsForMeshListAsync() {
    return new Promise((resolve) => {
      const buffers = [];
      let size = 0;
      for (let i = 0; i < this._resultBuffers.length; i++) {
        const buffer = this._resultBuffers[i].getBuffer();
        buffers.push(buffer);
        size += buffer.capacity;
      }
      const resultData = new Float32Array(size / Float32Array.BYTES_PER_ELEMENT);
      const minimum = Vector3.Zero();
      const maximum = Vector3.Zero();
      const minmax = { minimum, maximum };
      this._engine.readFromMultipleStorageBuffers(buffers, 0, void 0, resultData, true).then(() => {
        let resultDataOffset = 0;
        for (let j = 0; j < this._resultBuffers.length; j++) {
          for (let i = 0; i < this._processedMeshes.length; i++) {
            const mesh = this._processedMeshes[i];
            Vector3.FromArrayToRef(resultData, resultDataOffset + i * 8, minimum);
            Vector3.FromArrayToRef(resultData, resultDataOffset + i * 8 + 3, maximum);
            if (j > 0) {
              minimum.minimizeInPlace(mesh.getBoundingInfo().minimum);
              maximum.maximizeInPlace(mesh.getBoundingInfo().maximum);
            }
            mesh._refreshBoundingInfoDirect(minmax);
          }
          resultDataOffset += 8 * this._processedMeshes.length;
        }
        for (const resultBuffer of this._resultBuffers) {
          resultBuffer.dispose();
        }
        this._resultBuffers = [];
        this._uboIndex = 0;
        resolve();
      });
    });
  }
  _disposeCache(storageUnit) {
    for (const key in storageUnit) {
      storageUnit[key].dispose();
    }
  }
  _disposeForMeshList() {
    for (const resultBuffer of this._resultBuffers) {
      resultBuffer.dispose();
    }
    this._resultBuffers = [];
    this._processedMeshes = [];
    this._computeShaders = [];
    this._uniqueComputeShaders = /* @__PURE__ */ new Set();
  }
  /** @internal */
  dispose() {
    this._disposeCache(this._positionBuffers);
    this._positionBuffers = {};
    this._disposeCache(this._indexBuffers);
    this._indexBuffers = {};
    this._disposeCache(this._weightBuffers);
    this._weightBuffers = {};
    this._disposeCache(this._morphTargetInfluenceBuffers);
    this._morphTargetInfluenceBuffers = {};
    this._disposeCache(this._morphTargetTextureIndexBuffers);
    this._morphTargetTextureIndexBuffers = {};
    for (const ubo of this._ubos) {
      ubo.dispose();
    }
    this._ubos = [];
    this._computeShadersCache = {};
    this._engine = void 0;
    this._disposeForMeshList();
  }
};

export {
  StorageBuffer,
  WebGPUPerfCounter,
  ComputeShader,
  ComputeShaderBoundingHelper
};
//# sourceMappingURL=chunk-UCPWTUCC.js.map
