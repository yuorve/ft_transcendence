{
  "version": 3,
  "sources": ["../../../dev/core/src/Maths/math.axis.ts", "../../../dev/core/src/Maths/math.frustum.ts", "../../../dev/core/src/Maths/math.path.ts", "../../../dev/core/src/Maths/math.vertexFormat.ts", "../../../dev/core/src/Maths/sphericalPolynomial.ts", "../../../dev/core/src/Misc/HighDynamicRange/cubemapToSphericalPolynomial.ts", "../../../dev/core/src/PostProcesses/postProcessManager.ts", "../../../dev/core/src/Misc/smartArray.ts", "../../../dev/core/src/Rendering/renderingGroup.ts", "../../../dev/core/src/Rendering/renderingManager.ts", "../../../dev/core/src/Rendering/objectRenderer.ts", "../../../dev/core/src/Materials/Textures/renderTargetTexture.ts", "../../../dev/core/src/PostProcesses/postProcess.ts", "../../../dev/core/src/Misc/performanceMonitor.ts", "../../../dev/core/src/Engines/Extensions/engine.readTexture.ts", "../../../dev/core/src/Engines/renderTargetWrapper.ts", "../../../dev/core/src/Engines/engine.common.ts", "../../../dev/core/src/Audio/audioEngine.ts", "../../../dev/core/src/Engines/Extensions/engine.alpha.ts", "../../../dev/core/src/Engines/Extensions/engine.rawTexture.ts", "../../../dev/core/src/Engines/Extensions/engine.dynamicBuffer.ts", "../../../dev/core/src/Engines/Extensions/engine.cubeTexture.ts", "../../../dev/core/src/Engines/WebGL/webGLRenderTargetWrapper.ts", "../../../dev/core/src/Engines/AbstractEngine/abstractEngine.texture.ts", "../../../dev/core/src/Engines/Extensions/engine.renderTarget.ts", "../../../dev/core/src/Engines/Extensions/engine.renderTargetTexture.ts", "../../../dev/core/src/Engines/Extensions/engine.renderTargetCube.ts", "../../../dev/core/src/Engines/Extensions/engine.prefilteredCubeTexture.ts", "../../../dev/core/src/Engines/Extensions/engine.uniformBuffer.ts", "../../../dev/core/src/Engines/AbstractEngine/abstractEngine.loadingScreen.ts", "../../../dev/core/src/Engines/AbstractEngine/abstractEngine.dom.ts", "../../../dev/core/src/Engines/AbstractEngine/abstractEngine.alpha.ts", "../../../dev/core/src/Engines/AbstractEngine/abstractEngine.states.ts", "../../../dev/core/src/Engines/AbstractEngine/abstractEngine.renderPass.ts", "../../../dev/core/src/Engines/engine.ts", "../../../dev/core/src/PostProcesses/thinPassPostProcess.ts", "../../../dev/core/src/PostProcesses/passPostProcess.ts", "../../../dev/core/src/Misc/textureTools.ts"],
  "sourcesContent": ["import { Vector3 } from \"./math.vector\";\r\n\r\n/** Defines supported spaces */\r\nexport const enum Space {\r\n    /** Local (object) space */\r\n    LOCAL = 0,\r\n    /** World space */\r\n    WORLD = 1,\r\n    /** Bone space */\r\n    BONE = 2,\r\n}\r\n\r\n/** Defines the 3 main axes */\r\nexport class Axis {\r\n    /** X axis */\r\n    public static X: Vector3 = new Vector3(1.0, 0.0, 0.0);\r\n    /** Y axis */\r\n    public static Y: Vector3 = new Vector3(0.0, 1.0, 0.0);\r\n    /** Z axis */\r\n    public static Z: Vector3 = new Vector3(0.0, 0.0, 1.0);\r\n}\r\n\r\n/**\r\n * Defines cartesian components.\r\n */\r\nexport const enum Coordinate {\r\n    /** X axis */\r\n    X,\r\n    /** Y axis */\r\n    Y,\r\n    /** Z axis */\r\n    Z,\r\n}\r\n", "import type { Matrix, Vector3 } from \"./math.vector\";\r\nimport type { DeepImmutable } from \"../types\";\r\nimport { Plane } from \"./math.plane\";\r\n\r\n/**\r\n * Represents a camera frustum\r\n */\r\nexport class Frustum {\r\n    /**\r\n     * Gets the planes representing the frustum\r\n     * @param transform matrix to be applied to the returned planes\r\n     * @returns a new array of 6 Frustum planes computed by the given transformation matrix.\r\n     */\r\n    public static GetPlanes(transform: DeepImmutable<Matrix>): Plane[] {\r\n        const frustumPlanes = [];\r\n        for (let index = 0; index < 6; index++) {\r\n            frustumPlanes.push(new Plane(0.0, 0.0, 0.0, 0.0));\r\n        }\r\n        Frustum.GetPlanesToRef(transform, frustumPlanes);\r\n        return frustumPlanes;\r\n    }\r\n\r\n    /**\r\n     * Gets the near frustum plane transformed by the transform matrix\r\n     * @param transform transformation matrix to be applied to the resulting frustum plane\r\n     * @param frustumPlane the resulting frustum plane\r\n     */\r\n    public static GetNearPlaneToRef(transform: DeepImmutable<Matrix>, frustumPlane: Plane): void {\r\n        const m = transform.m;\r\n        frustumPlane.normal.x = m[3] + m[2];\r\n        frustumPlane.normal.y = m[7] + m[6];\r\n        frustumPlane.normal.z = m[11] + m[10];\r\n        frustumPlane.d = m[15] + m[14];\r\n        frustumPlane.normalize();\r\n    }\r\n\r\n    /**\r\n     * Gets the far frustum plane transformed by the transform matrix\r\n     * @param transform transformation matrix to be applied to the resulting frustum plane\r\n     * @param frustumPlane the resulting frustum plane\r\n     */\r\n    public static GetFarPlaneToRef(transform: DeepImmutable<Matrix>, frustumPlane: Plane): void {\r\n        const m = transform.m;\r\n        frustumPlane.normal.x = m[3] - m[2];\r\n        frustumPlane.normal.y = m[7] - m[6];\r\n        frustumPlane.normal.z = m[11] - m[10];\r\n        frustumPlane.d = m[15] - m[14];\r\n        frustumPlane.normalize();\r\n    }\r\n\r\n    /**\r\n     * Gets the left frustum plane transformed by the transform matrix\r\n     * @param transform transformation matrix to be applied to the resulting frustum plane\r\n     * @param frustumPlane the resulting frustum plane\r\n     */\r\n    public static GetLeftPlaneToRef(transform: DeepImmutable<Matrix>, frustumPlane: Plane): void {\r\n        const m = transform.m;\r\n        frustumPlane.normal.x = m[3] + m[0];\r\n        frustumPlane.normal.y = m[7] + m[4];\r\n        frustumPlane.normal.z = m[11] + m[8];\r\n        frustumPlane.d = m[15] + m[12];\r\n        frustumPlane.normalize();\r\n    }\r\n\r\n    /**\r\n     * Gets the right frustum plane transformed by the transform matrix\r\n     * @param transform transformation matrix to be applied to the resulting frustum plane\r\n     * @param frustumPlane the resulting frustum plane\r\n     */\r\n    public static GetRightPlaneToRef(transform: DeepImmutable<Matrix>, frustumPlane: Plane): void {\r\n        const m = transform.m;\r\n        frustumPlane.normal.x = m[3] - m[0];\r\n        frustumPlane.normal.y = m[7] - m[4];\r\n        frustumPlane.normal.z = m[11] - m[8];\r\n        frustumPlane.d = m[15] - m[12];\r\n        frustumPlane.normalize();\r\n    }\r\n\r\n    /**\r\n     * Gets the top frustum plane transformed by the transform matrix\r\n     * @param transform transformation matrix to be applied to the resulting frustum plane\r\n     * @param frustumPlane the resulting frustum plane\r\n     */\r\n    public static GetTopPlaneToRef(transform: DeepImmutable<Matrix>, frustumPlane: Plane): void {\r\n        const m = transform.m;\r\n        frustumPlane.normal.x = m[3] - m[1];\r\n        frustumPlane.normal.y = m[7] - m[5];\r\n        frustumPlane.normal.z = m[11] - m[9];\r\n        frustumPlane.d = m[15] - m[13];\r\n        frustumPlane.normalize();\r\n    }\r\n\r\n    /**\r\n     * Gets the bottom frustum plane transformed by the transform matrix\r\n     * @param transform transformation matrix to be applied to the resulting frustum plane\r\n     * @param frustumPlane the resulting frustum plane\r\n     */\r\n    public static GetBottomPlaneToRef(transform: DeepImmutable<Matrix>, frustumPlane: Plane): void {\r\n        const m = transform.m;\r\n        frustumPlane.normal.x = m[3] + m[1];\r\n        frustumPlane.normal.y = m[7] + m[5];\r\n        frustumPlane.normal.z = m[11] + m[9];\r\n        frustumPlane.d = m[15] + m[13];\r\n        frustumPlane.normalize();\r\n    }\r\n\r\n    /**\r\n     * Sets the given array \"frustumPlanes\" with the 6 Frustum planes computed by the given transformation matrix.\r\n     * @param transform transformation matrix to be applied to the resulting frustum planes\r\n     * @param frustumPlanes the resulting frustum planes\r\n     */\r\n    public static GetPlanesToRef(transform: DeepImmutable<Matrix>, frustumPlanes: Plane[]): void {\r\n        // Near\r\n        Frustum.GetNearPlaneToRef(transform, frustumPlanes[0]);\r\n\r\n        // Far\r\n        Frustum.GetFarPlaneToRef(transform, frustumPlanes[1]);\r\n\r\n        // Left\r\n        Frustum.GetLeftPlaneToRef(transform, frustumPlanes[2]);\r\n\r\n        // Right\r\n        Frustum.GetRightPlaneToRef(transform, frustumPlanes[3]);\r\n\r\n        // Top\r\n        Frustum.GetTopPlaneToRef(transform, frustumPlanes[4]);\r\n\r\n        // Bottom\r\n        Frustum.GetBottomPlaneToRef(transform, frustumPlanes[5]);\r\n    }\r\n\r\n    /**\r\n     * Tests if a point is located between the frustum planes.\r\n     * @param point defines the point to test\r\n     * @param frustumPlanes defines the frustum planes to test\r\n     * @returns true if the point is located between the frustum planes\r\n     */\r\n    public static IsPointInFrustum(point: Vector3, frustumPlanes: Array<DeepImmutable<Plane>>): boolean {\r\n        for (let i = 0; i < 6; i++) {\r\n            if (frustumPlanes[i].dotCoordinate(point) < 0) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\r\n", "import type { DeepImmutable, Nullable } from \"../types\";\r\nimport { Clamp, WithinEpsilon } from \"./math.scalar.functions\";\r\nimport { Vector2, Vector3, Quaternion, Matrix } from \"./math.vector\";\r\nimport type { Vector4 } from \"./math.vector\";\r\nimport { Epsilon } from \"./math.constants\";\r\n\r\n/**\r\n * Defines potential orientation for back face culling\r\n */\r\nexport const enum Orientation {\r\n    /**\r\n     * Clockwise\r\n     */\r\n    CW = 0,\r\n    /** Counter clockwise */\r\n    CCW = 1,\r\n}\r\n\r\n/** Class used to represent a Bezier curve */\r\nexport class BezierCurve {\r\n    /**\r\n     * Returns the cubic Bezier interpolated value (float) at \"t\" (float) from the given x1, y1, x2, y2 floats\r\n     * @param t defines the time\r\n     * @param x1 defines the left coordinate on X axis\r\n     * @param y1 defines the left coordinate on Y axis\r\n     * @param x2 defines the right coordinate on X axis\r\n     * @param y2 defines the right coordinate on Y axis\r\n     * @returns the interpolated value\r\n     */\r\n    public static Interpolate(t: number, x1: number, y1: number, x2: number, y2: number): number {\r\n        // Extract X (which is equal to time here)\r\n        const f0 = 1 - 3 * x2 + 3 * x1;\r\n        const f1 = 3 * x2 - 6 * x1;\r\n        const f2 = 3 * x1;\r\n\r\n        let refinedT = t;\r\n        for (let i = 0; i < 5; i++) {\r\n            const refinedT2 = refinedT * refinedT;\r\n            const refinedT3 = refinedT2 * refinedT;\r\n\r\n            const x = f0 * refinedT3 + f1 * refinedT2 + f2 * refinedT;\r\n            const slope = 1.0 / (3.0 * f0 * refinedT2 + 2.0 * f1 * refinedT + f2);\r\n            refinedT -= (x - t) * slope;\r\n            refinedT = Math.min(1, Math.max(0, refinedT));\r\n        }\r\n\r\n        // Resolve cubic bezier for the given x\r\n        return 3 * Math.pow(1 - refinedT, 2) * refinedT * y1 + 3 * (1 - refinedT) * Math.pow(refinedT, 2) * y2 + Math.pow(refinedT, 3);\r\n    }\r\n}\r\n\r\n/**\r\n * Defines angle representation\r\n */\r\nexport class Angle {\r\n    private _radians: number;\r\n\r\n    /**\r\n     * Creates an Angle object of \"radians\" radians (float).\r\n     * @param radians the angle in radians\r\n     */\r\n    constructor(radians: number) {\r\n        this._radians = radians;\r\n        if (this._radians < 0.0) {\r\n            this._radians += 2.0 * Math.PI;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get value in degrees\r\n     * @returns the Angle value in degrees (float)\r\n     */\r\n    public degrees() {\r\n        return (this._radians * 180.0) / Math.PI;\r\n    }\r\n\r\n    /**\r\n     * Get value in radians\r\n     * @returns the Angle value in radians (float)\r\n     */\r\n    public radians() {\r\n        return this._radians;\r\n    }\r\n\r\n    /**\r\n     * Gets a new Angle object with a value of the angle (in radians) between the line connecting the two points and the x-axis\r\n     * @param a defines first point as the origin\r\n     * @param b defines point\r\n     * @returns a new Angle\r\n     */\r\n    public static BetweenTwoPoints(a: DeepImmutable<Vector2>, b: DeepImmutable<Vector2>): Angle {\r\n        const delta = b.subtract(a);\r\n        const theta = Math.atan2(delta.y, delta.x);\r\n        return new Angle(theta);\r\n    }\r\n\r\n    /**\r\n     * Gets the angle between the two vectors\r\n     * @param a defines first vector\r\n     * @param b defines vector\r\n     * @returns Returns an new Angle between 0 and PI\r\n     */\r\n    public static BetweenTwoVectors<Vec extends Vector2 | Vector3 | Vector4>(a: DeepImmutable<Vec>, b: DeepImmutable<Vec>): Angle {\r\n        let product = a.lengthSquared() * b.lengthSquared();\r\n        if (product === 0) return new Angle(Math.PI / 2);\r\n        product = Math.sqrt(product);\r\n        let cosVal = a.dot(b as any) / product;\r\n        cosVal = Clamp(cosVal, -1, 1);\r\n        const angle = Math.acos(cosVal);\r\n        return new Angle(angle);\r\n    }\r\n\r\n    /**\r\n     * Gets a new Angle object from the given float in radians\r\n     * @param radians defines the angle value in radians\r\n     * @returns a new Angle\r\n     */\r\n    public static FromRadians(radians: number): Angle {\r\n        return new Angle(radians);\r\n    }\r\n    /**\r\n     * Gets a new Angle object from the given float in degrees\r\n     * @param degrees defines the angle value in degrees\r\n     * @returns a new Angle\r\n     */\r\n    public static FromDegrees(degrees: number): Angle {\r\n        return new Angle((degrees * Math.PI) / 180.0);\r\n    }\r\n}\r\n\r\n/**\r\n * This represents an arc in a 2d space.\r\n */\r\nexport class Arc2 {\r\n    /**\r\n     * Defines the center point of the arc.\r\n     */\r\n    public centerPoint: Vector2;\r\n    /**\r\n     * Defines the radius of the arc.\r\n     */\r\n    public radius: number;\r\n    /**\r\n     * Defines the angle of the arc (from mid point to end point).\r\n     */\r\n    public angle: Angle;\r\n    /**\r\n     * Defines the start angle of the arc (from start point to middle point).\r\n     */\r\n    public startAngle: Angle;\r\n    /**\r\n     * Defines the orientation of the arc (clock wise/counter clock wise).\r\n     */\r\n    public orientation: Orientation;\r\n\r\n    /**\r\n     * Creates an Arc object from the three given points : start, middle and end.\r\n     * @param startPoint Defines the start point of the arc\r\n     * @param midPoint Defines the middle point of the arc\r\n     * @param endPoint Defines the end point of the arc\r\n     */\r\n    constructor(\r\n        /** Defines the start point of the arc */\r\n        public startPoint: Vector2,\r\n        /** Defines the mid point of the arc */\r\n        public midPoint: Vector2,\r\n        /** Defines the end point of the arc */\r\n        public endPoint: Vector2\r\n    ) {\r\n        const temp = Math.pow(midPoint.x, 2) + Math.pow(midPoint.y, 2);\r\n        const startToMid = (Math.pow(startPoint.x, 2) + Math.pow(startPoint.y, 2) - temp) / 2;\r\n        const midToEnd = (temp - Math.pow(endPoint.x, 2) - Math.pow(endPoint.y, 2)) / 2;\r\n        const det = (startPoint.x - midPoint.x) * (midPoint.y - endPoint.y) - (midPoint.x - endPoint.x) * (startPoint.y - midPoint.y);\r\n\r\n        this.centerPoint = new Vector2(\r\n            (startToMid * (midPoint.y - endPoint.y) - midToEnd * (startPoint.y - midPoint.y)) / det,\r\n            ((startPoint.x - midPoint.x) * midToEnd - (midPoint.x - endPoint.x) * startToMid) / det\r\n        );\r\n\r\n        this.radius = this.centerPoint.subtract(this.startPoint).length();\r\n\r\n        this.startAngle = Angle.BetweenTwoPoints(this.centerPoint, this.startPoint);\r\n\r\n        const a1 = this.startAngle.degrees();\r\n        let a2 = Angle.BetweenTwoPoints(this.centerPoint, this.midPoint).degrees();\r\n        let a3 = Angle.BetweenTwoPoints(this.centerPoint, this.endPoint).degrees();\r\n\r\n        // angles correction\r\n        if (a2 - a1 > +180.0) {\r\n            a2 -= 360.0;\r\n        }\r\n        if (a2 - a1 < -180.0) {\r\n            a2 += 360.0;\r\n        }\r\n        if (a3 - a2 > +180.0) {\r\n            a3 -= 360.0;\r\n        }\r\n        if (a3 - a2 < -180.0) {\r\n            a3 += 360.0;\r\n        }\r\n\r\n        this.orientation = a2 - a1 < 0 ? Orientation.CW : Orientation.CCW;\r\n        this.angle = Angle.FromDegrees(this.orientation === Orientation.CW ? a1 - a3 : a3 - a1);\r\n    }\r\n}\r\n\r\n/**\r\n * Represents a 2D path made up of multiple 2D points\r\n */\r\nexport class Path2 {\r\n    private _points = new Array<Vector2>();\r\n    private _length = 0.0;\r\n\r\n    /**\r\n     * If the path start and end point are the same\r\n     */\r\n    public closed = false;\r\n\r\n    /**\r\n     * Creates a Path2 object from the starting 2D coordinates x and y.\r\n     * @param x the starting points x value\r\n     * @param y the starting points y value\r\n     */\r\n    constructor(x: number, y: number) {\r\n        this._points.push(new Vector2(x, y));\r\n    }\r\n\r\n    /**\r\n     * Adds a new segment until the given coordinates (x, y) to the current Path2.\r\n     * @param x the added points x value\r\n     * @param y the added points y value\r\n     * @returns the updated Path2.\r\n     */\r\n    public addLineTo(x: number, y: number): Path2 {\r\n        if (this.closed) {\r\n            return this;\r\n        }\r\n        const newPoint = new Vector2(x, y);\r\n        const previousPoint = this._points[this._points.length - 1];\r\n        this._points.push(newPoint);\r\n        this._length += newPoint.subtract(previousPoint).length();\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds _numberOfSegments_ segments according to the arc definition (middle point coordinates, end point coordinates, the arc start point being the current Path2 last point) to the current Path2.\r\n     * @param midX middle point x value\r\n     * @param midY middle point y value\r\n     * @param endX end point x value\r\n     * @param endY end point y value\r\n     * @param numberOfSegments (default: 36)\r\n     * @returns the updated Path2.\r\n     */\r\n    public addArcTo(midX: number, midY: number, endX: number, endY: number, numberOfSegments = 36): Path2 {\r\n        if (this.closed) {\r\n            return this;\r\n        }\r\n        const startPoint = this._points[this._points.length - 1];\r\n        const midPoint = new Vector2(midX, midY);\r\n        const endPoint = new Vector2(endX, endY);\r\n\r\n        const arc = new Arc2(startPoint, midPoint, endPoint);\r\n\r\n        let increment = arc.angle.radians() / numberOfSegments;\r\n        if (arc.orientation === Orientation.CW) {\r\n            increment *= -1;\r\n        }\r\n        let currentAngle = arc.startAngle.radians() + increment;\r\n\r\n        for (let i = 0; i < numberOfSegments; i++) {\r\n            const x = Math.cos(currentAngle) * arc.radius + arc.centerPoint.x;\r\n            const y = Math.sin(currentAngle) * arc.radius + arc.centerPoint.y;\r\n            this.addLineTo(x, y);\r\n            currentAngle += increment;\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds _numberOfSegments_ segments according to the quadratic curve definition to the current Path2.\r\n     * @param controlX control point x value\r\n     * @param controlY control point y value\r\n     * @param endX end point x value\r\n     * @param endY end point y value\r\n     * @param numberOfSegments (default: 36)\r\n     * @returns the updated Path2.\r\n     */\r\n    public addQuadraticCurveTo(controlX: number, controlY: number, endX: number, endY: number, numberOfSegments = 36): Path2 {\r\n        if (this.closed) {\r\n            return this;\r\n        }\r\n\r\n        const equation = (t: number, val0: number, val1: number, val2: number) => {\r\n            const res = (1.0 - t) * (1.0 - t) * val0 + 2.0 * t * (1.0 - t) * val1 + t * t * val2;\r\n            return res;\r\n        };\r\n        const startPoint = this._points[this._points.length - 1];\r\n        for (let i = 0; i <= numberOfSegments; i++) {\r\n            const step = i / numberOfSegments;\r\n            const x = equation(step, startPoint.x, controlX, endX);\r\n            const y = equation(step, startPoint.y, controlY, endY);\r\n            this.addLineTo(x, y);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds _numberOfSegments_ segments according to the bezier curve definition to the current Path2.\r\n     * @param originTangentX tangent vector at the origin point x value\r\n     * @param originTangentY tangent vector at the origin point y value\r\n     * @param destinationTangentX tangent vector at the destination point x value\r\n     * @param destinationTangentY tangent vector at the destination point y value\r\n     * @param endX end point x value\r\n     * @param endY end point y value\r\n     * @param numberOfSegments (default: 36)\r\n     * @returns the updated Path2.\r\n     */\r\n    public addBezierCurveTo(\r\n        originTangentX: number,\r\n        originTangentY: number,\r\n        destinationTangentX: number,\r\n        destinationTangentY: number,\r\n        endX: number,\r\n        endY: number,\r\n        numberOfSegments = 36\r\n    ): Path2 {\r\n        if (this.closed) {\r\n            return this;\r\n        }\r\n\r\n        const equation = (t: number, val0: number, val1: number, val2: number, val3: number) => {\r\n            const res = (1.0 - t) * (1.0 - t) * (1.0 - t) * val0 + 3.0 * t * (1.0 - t) * (1.0 - t) * val1 + 3.0 * t * t * (1.0 - t) * val2 + t * t * t * val3;\r\n            return res;\r\n        };\r\n        const startPoint = this._points[this._points.length - 1];\r\n        for (let i = 0; i <= numberOfSegments; i++) {\r\n            const step = i / numberOfSegments;\r\n            const x = equation(step, startPoint.x, originTangentX, destinationTangentX, endX);\r\n            const y = equation(step, startPoint.y, originTangentY, destinationTangentY, endY);\r\n            this.addLineTo(x, y);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Defines if a given point is inside the polygon defines by the path\r\n     * @param point defines the point to test\r\n     * @returns true if the point is inside\r\n     */\r\n    public isPointInside(point: Vector2) {\r\n        let isInside = false;\r\n        const count = this._points.length;\r\n        for (let p = count - 1, q = 0; q < count; p = q++) {\r\n            let edgeLow = this._points[p];\r\n            let edgeHigh = this._points[q];\r\n\r\n            let edgeDx = edgeHigh.x - edgeLow.x;\r\n            let edgeDy = edgeHigh.y - edgeLow.y;\r\n\r\n            if (Math.abs(edgeDy) > Number.EPSILON) {\r\n                // Not parallel\r\n                if (edgeDy < 0) {\r\n                    edgeLow = this._points[q];\r\n                    edgeDx = -edgeDx;\r\n                    edgeHigh = this._points[p];\r\n                    edgeDy = -edgeDy;\r\n                }\r\n\r\n                if (point.y < edgeLow.y || point.y > edgeHigh.y) {\r\n                    continue;\r\n                }\r\n\r\n                if (point.y === edgeLow.y && point.x === edgeLow.x) {\r\n                    return true;\r\n                } else {\r\n                    const perpEdge = edgeDy * (point.x - edgeLow.x) - edgeDx * (point.y - edgeLow.y);\r\n                    if (perpEdge === 0) {\r\n                        return true;\r\n                    }\r\n                    if (perpEdge < 0) {\r\n                        continue;\r\n                    }\r\n                    isInside = !isInside;\r\n                }\r\n            } else {\r\n                // parallel or collinear\r\n                if (point.y !== edgeLow.y) {\r\n                    continue;\r\n                }\r\n\r\n                if ((edgeHigh.x <= point.x && point.x <= edgeLow.x) || (edgeLow.x <= point.x && point.x <= edgeHigh.x)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return isInside;\r\n    }\r\n\r\n    /**\r\n     * Closes the Path2.\r\n     * @returns the Path2.\r\n     */\r\n    public close(): Path2 {\r\n        this.closed = true;\r\n        return this;\r\n    }\r\n    /**\r\n     * Gets the sum of the distance between each sequential point in the path\r\n     * @returns the Path2 total length (float).\r\n     */\r\n    public length(): number {\r\n        let result = this._length;\r\n\r\n        if (this.closed) {\r\n            const lastPoint = this._points[this._points.length - 1];\r\n            const firstPoint = this._points[0];\r\n            result += firstPoint.subtract(lastPoint).length();\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Gets the area of the polygon defined by the path\r\n     * @returns area value\r\n     */\r\n    public area(): number {\r\n        const n = this._points.length;\r\n        let value = 0.0;\r\n\r\n        for (let p = n - 1, q = 0; q < n; p = q++) {\r\n            value += this._points[p].x * this._points[q].y - this._points[q].x * this._points[p].y;\r\n        }\r\n\r\n        return value * 0.5;\r\n    }\r\n\r\n    /**\r\n     * Gets the points which construct the path\r\n     * @returns the Path2 internal array of points.\r\n     */\r\n    public getPoints(): Vector2[] {\r\n        return this._points;\r\n    }\r\n\r\n    /**\r\n     * Retrieves the point at the distance aways from the starting point\r\n     * @param normalizedLengthPosition the length along the path to retrieve the point from\r\n     * @returns a new Vector2 located at a percentage of the Path2 total length on this path.\r\n     */\r\n    public getPointAtLengthPosition(normalizedLengthPosition: number): Vector2 {\r\n        if (normalizedLengthPosition < 0 || normalizedLengthPosition > 1) {\r\n            return Vector2.Zero();\r\n        }\r\n\r\n        const lengthPosition = normalizedLengthPosition * this.length();\r\n\r\n        let previousOffset = 0;\r\n        for (let i = 0; i < this._points.length; i++) {\r\n            const j = (i + 1) % this._points.length;\r\n\r\n            const a = this._points[i];\r\n            const b = this._points[j];\r\n            const bToA = b.subtract(a);\r\n\r\n            const nextOffset = bToA.length() + previousOffset;\r\n            if (lengthPosition >= previousOffset && lengthPosition <= nextOffset) {\r\n                const dir = bToA.normalize();\r\n                const localOffset = lengthPosition - previousOffset;\r\n\r\n                return new Vector2(a.x + dir.x * localOffset, a.y + dir.y * localOffset);\r\n            }\r\n            previousOffset = nextOffset;\r\n        }\r\n\r\n        return Vector2.Zero();\r\n    }\r\n\r\n    /**\r\n     * Creates a new path starting from an x and y position\r\n     * @param x starting x value\r\n     * @param y starting y value\r\n     * @returns a new Path2 starting at the coordinates (x, y).\r\n     */\r\n    public static StartingAt(x: number, y: number): Path2 {\r\n        return new Path2(x, y);\r\n    }\r\n}\r\n\r\n/**\r\n * Represents a 3D path made up of multiple 3D points\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/path3D\r\n */\r\nexport class Path3D {\r\n    private _curve = new Array<Vector3>();\r\n    private _distances = new Array<number>();\r\n    private _tangents = new Array<Vector3>();\r\n    private _normals = new Array<Vector3>();\r\n    private _binormals = new Array<Vector3>();\r\n    private _raw: boolean;\r\n    private _alignTangentsWithPath: boolean;\r\n\r\n    // holds interpolated point data\r\n    private readonly _pointAtData = {\r\n        id: 0,\r\n        point: Vector3.Zero(),\r\n        previousPointArrayIndex: 0,\r\n\r\n        position: 0,\r\n        subPosition: 0,\r\n\r\n        interpolateReady: false,\r\n        interpolationMatrix: Matrix.Identity(),\r\n    };\r\n\r\n    /**\r\n     * new Path3D(path, normal, raw)\r\n     * Creates a Path3D. A Path3D is a logical math object, so not a mesh.\r\n     * please read the description in the tutorial : https://doc.babylonjs.com/features/featuresDeepDive/mesh/path3D\r\n     * @param path an array of Vector3, the curve axis of the Path3D\r\n     * @param firstNormal (options) Vector3, the first wanted normal to the curve. Ex (0, 1, 0) for a vertical normal.\r\n     * @param raw (optional, default false) : boolean, if true the returned Path3D isn't normalized. Useful to depict path acceleration or speed.\r\n     * @param alignTangentsWithPath (optional, default false) : boolean, if true the tangents will be aligned with the path.\r\n     */\r\n    constructor(\r\n        /**\r\n         * an array of Vector3, the curve axis of the Path3D\r\n         */\r\n        public path: Vector3[],\r\n        firstNormal: Nullable<Vector3> = null,\r\n        raw?: boolean,\r\n        alignTangentsWithPath = false\r\n    ) {\r\n        for (let p = 0; p < path.length; p++) {\r\n            this._curve[p] = path[p].clone(); // hard copy\r\n        }\r\n        this._raw = raw || false;\r\n        this._alignTangentsWithPath = alignTangentsWithPath;\r\n        this._compute(firstNormal, alignTangentsWithPath);\r\n    }\r\n\r\n    /**\r\n     * Returns the Path3D array of successive Vector3 designing its curve.\r\n     * @returns the Path3D array of successive Vector3 designing its curve.\r\n     */\r\n    public getCurve(): Vector3[] {\r\n        return this._curve;\r\n    }\r\n\r\n    /**\r\n     * Returns the Path3D array of successive Vector3 designing its curve.\r\n     * @returns the Path3D array of successive Vector3 designing its curve.\r\n     */\r\n    public getPoints(): Vector3[] {\r\n        return this._curve;\r\n    }\r\n\r\n    /**\r\n     * @returns the computed length (float) of the path.\r\n     */\r\n    public length() {\r\n        return this._distances[this._distances.length - 1];\r\n    }\r\n\r\n    /**\r\n     * Returns an array populated with tangent vectors on each Path3D curve point.\r\n     * @returns an array populated with tangent vectors on each Path3D curve point.\r\n     */\r\n    public getTangents(): Vector3[] {\r\n        return this._tangents;\r\n    }\r\n\r\n    /**\r\n     * Returns an array populated with normal vectors on each Path3D curve point.\r\n     * @returns an array populated with normal vectors on each Path3D curve point.\r\n     */\r\n    public getNormals(): Vector3[] {\r\n        return this._normals;\r\n    }\r\n\r\n    /**\r\n     * Returns an array populated with binormal vectors on each Path3D curve point.\r\n     * @returns an array populated with binormal vectors on each Path3D curve point.\r\n     */\r\n    public getBinormals(): Vector3[] {\r\n        return this._binormals;\r\n    }\r\n\r\n    /**\r\n     * Returns an array populated with distances (float) of the i-th point from the first curve point.\r\n     * @returns an array populated with distances (float) of the i-th point from the first curve point.\r\n     */\r\n    public getDistances(): number[] {\r\n        return this._distances;\r\n    }\r\n\r\n    /**\r\n     * Returns an interpolated point along this path\r\n     * @param position the position of the point along this path, from 0.0 to 1.0\r\n     * @returns a new Vector3 as the point\r\n     */\r\n    public getPointAt(position: number): Vector3 {\r\n        return this._updatePointAtData(position).point;\r\n    }\r\n\r\n    /**\r\n     * Returns the tangent vector of an interpolated Path3D curve point at the specified position along this path.\r\n     * @param position the position of the point along this path, from 0.0 to 1.0\r\n     * @param interpolated (optional, default false) : boolean, if true returns an interpolated tangent instead of the tangent of the previous path point.\r\n     * @returns a tangent vector corresponding to the interpolated Path3D curve point, if not interpolated, the tangent is taken from the precomputed tangents array.\r\n     */\r\n    public getTangentAt(position: number, interpolated = false): Vector3 {\r\n        this._updatePointAtData(position, interpolated);\r\n        return interpolated ? Vector3.TransformCoordinates(Vector3.Forward(), this._pointAtData.interpolationMatrix) : this._tangents[this._pointAtData.previousPointArrayIndex];\r\n    }\r\n\r\n    /**\r\n     * Returns the tangent vector of an interpolated Path3D curve point at the specified position along this path.\r\n     * @param position the position of the point along this path, from 0.0 to 1.0\r\n     * @param interpolated (optional, default false) : boolean, if true returns an interpolated normal instead of the normal of the previous path point.\r\n     * @returns a normal vector corresponding to the interpolated Path3D curve point, if not interpolated, the normal is taken from the precomputed normals array.\r\n     */\r\n    public getNormalAt(position: number, interpolated = false): Vector3 {\r\n        this._updatePointAtData(position, interpolated);\r\n        return interpolated ? Vector3.TransformCoordinates(Vector3.Right(), this._pointAtData.interpolationMatrix) : this._normals[this._pointAtData.previousPointArrayIndex];\r\n    }\r\n\r\n    /**\r\n     * Returns the binormal vector of an interpolated Path3D curve point at the specified position along this path.\r\n     * @param position the position of the point along this path, from 0.0 to 1.0\r\n     * @param interpolated (optional, default false) : boolean, if true returns an interpolated binormal instead of the binormal of the previous path point.\r\n     * @returns a binormal vector corresponding to the interpolated Path3D curve point, if not interpolated, the binormal is taken from the precomputed binormals array.\r\n     */\r\n    public getBinormalAt(position: number, interpolated = false): Vector3 {\r\n        this._updatePointAtData(position, interpolated);\r\n        return interpolated ? Vector3.TransformCoordinates(Vector3.UpReadOnly, this._pointAtData.interpolationMatrix) : this._binormals[this._pointAtData.previousPointArrayIndex];\r\n    }\r\n\r\n    /**\r\n     * Returns the distance (float) of an interpolated Path3D curve point at the specified position along this path.\r\n     * @param position the position of the point along this path, from 0.0 to 1.0\r\n     * @returns the distance of the interpolated Path3D curve point at the specified position along this path.\r\n     */\r\n    public getDistanceAt(position: number): number {\r\n        return this.length() * position;\r\n    }\r\n\r\n    /**\r\n     * Returns the array index of the previous point of an interpolated point along this path\r\n     * @param position the position of the point to interpolate along this path, from 0.0 to 1.0\r\n     * @returns the array index\r\n     */\r\n    public getPreviousPointIndexAt(position: number) {\r\n        this._updatePointAtData(position);\r\n        return this._pointAtData.previousPointArrayIndex;\r\n    }\r\n\r\n    /**\r\n     * Returns the position of an interpolated point relative to the two path points it lies between, from 0.0 (point A) to 1.0 (point B)\r\n     * @param position the position of the point to interpolate along this path, from 0.0 to 1.0\r\n     * @returns the sub position\r\n     */\r\n    public getSubPositionAt(position: number) {\r\n        this._updatePointAtData(position);\r\n        return this._pointAtData.subPosition;\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the closest virtual point on this path to an arbitrary Vector3, from 0.0 to 1.0\r\n     * @param target the vector of which to get the closest position to\r\n     * @returns the position of the closest virtual point on this path to the target vector\r\n     */\r\n    public getClosestPositionTo(target: Vector3) {\r\n        let smallestDistance = Number.MAX_VALUE;\r\n        let closestPosition = 0.0;\r\n        for (let i = 0; i < this._curve.length - 1; i++) {\r\n            const point = this._curve[i + 0];\r\n            const tangent = this._curve[i + 1].subtract(point).normalize();\r\n            const subLength = this._distances[i + 1] - this._distances[i + 0];\r\n            const subPosition = Math.min((Math.max(Vector3.Dot(tangent, target.subtract(point).normalize()), 0.0) * Vector3.Distance(point, target)) / subLength, 1.0);\r\n            const distance = Vector3.Distance(point.add(tangent.scale(subPosition * subLength)), target);\r\n\r\n            if (distance < smallestDistance) {\r\n                smallestDistance = distance;\r\n                closestPosition = (this._distances[i + 0] + subLength * subPosition) / this.length();\r\n            }\r\n        }\r\n        return closestPosition;\r\n    }\r\n\r\n    /**\r\n     * Returns a sub path (slice) of this path\r\n     * @param start the position of the fist path point, from 0.0 to 1.0, or a negative value, which will get wrapped around from the end of the path to 0.0 to 1.0 values\r\n     * @param end the position of the last path point, from 0.0 to 1.0, or a negative value, which will get wrapped around from the end of the path to 0.0 to 1.0 values\r\n     * @returns a sub path (slice) of this path\r\n     */\r\n    public slice(start: number = 0.0, end: number = 1.0) {\r\n        if (start < 0.0) {\r\n            start = 1 - ((start * -1.0) % 1.0);\r\n        }\r\n        if (end < 0.0) {\r\n            end = 1 - ((end * -1.0) % 1.0);\r\n        }\r\n        if (start > end) {\r\n            const _start = start;\r\n            start = end;\r\n            end = _start;\r\n        }\r\n        const curvePoints = this.getCurve();\r\n\r\n        const startPoint = this.getPointAt(start);\r\n        let startIndex = this.getPreviousPointIndexAt(start);\r\n\r\n        const endPoint = this.getPointAt(end);\r\n        const endIndex = this.getPreviousPointIndexAt(end) + 1;\r\n\r\n        const slicePoints: Vector3[] = [];\r\n        if (start !== 0.0) {\r\n            startIndex++;\r\n            slicePoints.push(startPoint);\r\n        }\r\n\r\n        slicePoints.push(...curvePoints.slice(startIndex, endIndex));\r\n        if (end !== 1.0 || start === 1.0) {\r\n            slicePoints.push(endPoint);\r\n        }\r\n        return new Path3D(slicePoints, this.getNormalAt(start), this._raw, this._alignTangentsWithPath);\r\n    }\r\n\r\n    /**\r\n     * Forces the Path3D tangent, normal, binormal and distance recomputation.\r\n     * @param path path which all values are copied into the curves points\r\n     * @param firstNormal which should be projected onto the curve\r\n     * @param alignTangentsWithPath (optional, default false) : boolean, if true the tangents will be aligned with the path\r\n     * @returns the same object updated.\r\n     */\r\n    public update(path: Vector3[], firstNormal: Nullable<Vector3> = null, alignTangentsWithPath = false): Path3D {\r\n        for (let p = 0; p < path.length; p++) {\r\n            this._curve[p].x = path[p].x;\r\n            this._curve[p].y = path[p].y;\r\n            this._curve[p].z = path[p].z;\r\n        }\r\n        this._compute(firstNormal, alignTangentsWithPath);\r\n        return this;\r\n    }\r\n\r\n    // private function compute() : computes tangents, normals and binormals\r\n    private _compute(firstNormal: Nullable<Vector3>, alignTangentsWithPath = false): void {\r\n        const l = this._curve.length;\r\n\r\n        if (l < 2) {\r\n            return;\r\n        }\r\n\r\n        // first and last tangents\r\n        this._tangents[0] = this._getFirstNonNullVector(0);\r\n        if (!this._raw) {\r\n            this._tangents[0].normalize();\r\n        }\r\n        this._tangents[l - 1] = this._curve[l - 1].subtract(this._curve[l - 2]);\r\n        if (!this._raw) {\r\n            this._tangents[l - 1].normalize();\r\n        }\r\n\r\n        // normals and binormals at first point : arbitrary vector with _normalVector()\r\n        const tg0 = this._tangents[0];\r\n        const pp0 = this._normalVector(tg0, firstNormal);\r\n        this._normals[0] = pp0;\r\n        if (!this._raw) {\r\n            this._normals[0].normalize();\r\n        }\r\n        this._binormals[0] = Vector3.Cross(tg0, this._normals[0]);\r\n        if (!this._raw) {\r\n            this._binormals[0].normalize();\r\n        }\r\n        this._distances[0] = 0.0;\r\n\r\n        // normals and binormals : next points\r\n        let prev: Vector3; // previous vector (segment)\r\n        let cur: Vector3; // current vector (segment)\r\n        let curTang: Vector3; // current tangent\r\n        // previous normal\r\n        let prevNor: Vector3; // previous normal\r\n        let prevBinor: Vector3; // previous binormal\r\n\r\n        for (let i = 1; i < l; i++) {\r\n            // tangents\r\n            prev = this._getLastNonNullVector(i);\r\n            if (i < l - 1) {\r\n                cur = this._getFirstNonNullVector(i);\r\n                this._tangents[i] = alignTangentsWithPath ? cur : prev.add(cur);\r\n                this._tangents[i].normalize();\r\n            }\r\n            this._distances[i] = this._distances[i - 1] + this._curve[i].subtract(this._curve[i - 1]).length();\r\n\r\n            // normals and binormals\r\n            // http://www.cs.cmu.edu/afs/andrew/scs/cs/15-462/web/old/asst2camera.html\r\n            curTang = this._tangents[i];\r\n            prevBinor = this._binormals[i - 1];\r\n            this._normals[i] = Vector3.Cross(prevBinor, curTang);\r\n            if (!this._raw) {\r\n                if (this._normals[i].length() === 0) {\r\n                    prevNor = this._normals[i - 1];\r\n                    this._normals[i] = prevNor.clone();\r\n                } else {\r\n                    this._normals[i].normalize();\r\n                }\r\n            }\r\n            this._binormals[i] = Vector3.Cross(curTang, this._normals[i]);\r\n            if (!this._raw) {\r\n                this._binormals[i].normalize();\r\n            }\r\n        }\r\n        this._pointAtData.id = NaN;\r\n    }\r\n\r\n    // private function getFirstNonNullVector(index)\r\n    // returns the first non null vector from index : curve[index + N].subtract(curve[index])\r\n    private _getFirstNonNullVector(index: number): Vector3 {\r\n        let i = 1;\r\n        let nNVector: Vector3 = this._curve[index + i].subtract(this._curve[index]);\r\n        while (nNVector.length() === 0 && index + i + 1 < this._curve.length) {\r\n            i++;\r\n            nNVector = this._curve[index + i].subtract(this._curve[index]);\r\n        }\r\n        return nNVector;\r\n    }\r\n\r\n    // private function getLastNonNullVector(index)\r\n    // returns the last non null vector from index : curve[index].subtract(curve[index - N])\r\n    private _getLastNonNullVector(index: number): Vector3 {\r\n        let i = 1;\r\n        let nLVector: Vector3 = this._curve[index].subtract(this._curve[index - i]);\r\n        while (nLVector.length() === 0 && index > i + 1) {\r\n            i++;\r\n            nLVector = this._curve[index].subtract(this._curve[index - i]);\r\n        }\r\n        return nLVector;\r\n    }\r\n\r\n    // private function normalVector(v0, vt, va) :\r\n    // returns an arbitrary point in the plane defined by the point v0 and the vector vt orthogonal to this plane\r\n    // if va is passed, it returns the va projection on the plane orthogonal to vt at the point v0\r\n    private _normalVector(vt: Vector3, va: Nullable<Vector3>): Vector3 {\r\n        let normal0: Vector3;\r\n        let tgl = vt.length();\r\n        if (tgl === 0.0) {\r\n            tgl = 1.0;\r\n        }\r\n\r\n        if (va === undefined || va === null) {\r\n            let point: Vector3;\r\n            if (!WithinEpsilon(Math.abs(vt.y) / tgl, 1.0, Epsilon)) {\r\n                // search for a point in the plane\r\n                point = new Vector3(0.0, -1.0, 0.0);\r\n            } else if (!WithinEpsilon(Math.abs(vt.x) / tgl, 1.0, Epsilon)) {\r\n                point = new Vector3(1.0, 0.0, 0.0);\r\n            } else if (!WithinEpsilon(Math.abs(vt.z) / tgl, 1.0, Epsilon)) {\r\n                point = new Vector3(0.0, 0.0, 1.0);\r\n            } else {\r\n                point = Vector3.Zero();\r\n            }\r\n            normal0 = Vector3.Cross(vt, point);\r\n        } else {\r\n            normal0 = Vector3.Cross(vt, va);\r\n            Vector3.CrossToRef(normal0, vt, normal0);\r\n        }\r\n        normal0.normalize();\r\n        return normal0;\r\n    }\r\n\r\n    /**\r\n     * Updates the point at data for an interpolated point along this curve\r\n     * @param position the position of the point along this curve, from 0.0 to 1.0\r\n     * @param interpolateTNB\r\n     * @interpolateTNB whether to compute the interpolated tangent, normal and binormal\r\n     * @returns the (updated) point at data\r\n     */\r\n    private _updatePointAtData(position: number, interpolateTNB: boolean = false) {\r\n        // set an id for caching the result\r\n        if (this._pointAtData.id === position) {\r\n            if (!this._pointAtData.interpolateReady) {\r\n                this._updateInterpolationMatrix();\r\n            }\r\n            return this._pointAtData;\r\n        } else {\r\n            this._pointAtData.id = position;\r\n        }\r\n        const curvePoints = this.getPoints();\r\n\r\n        // clamp position between 0.0 and 1.0\r\n        if (position <= 0.0) {\r\n            return this._setPointAtData(0.0, 0.0, curvePoints[0], 0, interpolateTNB);\r\n        } else if (position >= 1.0) {\r\n            return this._setPointAtData(1.0, 1.0, curvePoints[curvePoints.length - 1], curvePoints.length - 1, interpolateTNB);\r\n        }\r\n\r\n        let previousPoint: Vector3 = curvePoints[0];\r\n        let currentPoint: Vector3;\r\n        let currentLength = 0.0;\r\n        const targetLength = position * this.length();\r\n\r\n        for (let i = 1; i < curvePoints.length; i++) {\r\n            currentPoint = curvePoints[i];\r\n            const distance = Vector3.Distance(previousPoint, currentPoint);\r\n            currentLength += distance;\r\n            if (currentLength === targetLength) {\r\n                return this._setPointAtData(position, 1.0, currentPoint, i, interpolateTNB);\r\n            } else if (currentLength > targetLength) {\r\n                const toLength = currentLength - targetLength;\r\n                const diff = toLength / distance;\r\n                const dir = previousPoint.subtract(currentPoint);\r\n                const point = currentPoint.add(dir.scaleInPlace(diff));\r\n                return this._setPointAtData(position, 1 - diff, point, i - 1, interpolateTNB);\r\n            }\r\n            previousPoint = currentPoint;\r\n        }\r\n        return this._pointAtData;\r\n    }\r\n\r\n    /**\r\n     * Updates the point at data from the specified parameters\r\n     * @param position where along the path the interpolated point is, from 0.0 to 1.0\r\n     * @param subPosition\r\n     * @param point the interpolated point\r\n     * @param parentIndex the index of an existing curve point that is on, or else positionally the first behind, the interpolated point\r\n     * @param interpolateTNB whether to compute the interpolated tangent, normal and binormal\r\n     * @returns the (updated) point at data\r\n     */\r\n    private _setPointAtData(position: number, subPosition: number, point: Vector3, parentIndex: number, interpolateTNB: boolean) {\r\n        this._pointAtData.point = point;\r\n        this._pointAtData.position = position;\r\n        this._pointAtData.subPosition = subPosition;\r\n        this._pointAtData.previousPointArrayIndex = parentIndex;\r\n        this._pointAtData.interpolateReady = interpolateTNB;\r\n\r\n        if (interpolateTNB) {\r\n            this._updateInterpolationMatrix();\r\n        }\r\n        return this._pointAtData;\r\n    }\r\n\r\n    /**\r\n     * Updates the point at interpolation matrix for the tangents, normals and binormals\r\n     */\r\n    private _updateInterpolationMatrix() {\r\n        this._pointAtData.interpolationMatrix = Matrix.Identity();\r\n        const parentIndex = this._pointAtData.previousPointArrayIndex;\r\n\r\n        if (parentIndex !== this._tangents.length - 1) {\r\n            const index = parentIndex + 1;\r\n\r\n            const tangentFrom = this._tangents[parentIndex].clone();\r\n            const normalFrom = this._normals[parentIndex].clone();\r\n            const binormalFrom = this._binormals[parentIndex].clone();\r\n\r\n            const tangentTo = this._tangents[index].clone();\r\n            const normalTo = this._normals[index].clone();\r\n            const binormalTo = this._binormals[index].clone();\r\n\r\n            const quatFrom = Quaternion.RotationQuaternionFromAxis(normalFrom, binormalFrom, tangentFrom);\r\n            const quatTo = Quaternion.RotationQuaternionFromAxis(normalTo, binormalTo, tangentTo);\r\n            const quatAt = Quaternion.Slerp(quatFrom, quatTo, this._pointAtData.subPosition);\r\n\r\n            quatAt.toRotationMatrix(this._pointAtData.interpolationMatrix);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * A Curve3 object is a logical object, so not a mesh, to handle curves in the 3D geometric space.\r\n * A Curve3 is designed from a series of successive Vector3.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/drawCurves\r\n */\r\nexport class Curve3 {\r\n    private _points: Vector3[];\r\n    private _length: number = 0.0;\r\n\r\n    /**\r\n     * Returns a Curve3 object along a Quadratic Bezier curve : https://doc.babylonjs.com/features/featuresDeepDive/mesh/drawCurves#quadratic-bezier-curve\r\n     * @param v0 (Vector3) the origin point of the Quadratic Bezier\r\n     * @param v1 (Vector3) the control point\r\n     * @param v2 (Vector3) the end point of the Quadratic Bezier\r\n     * @param nbPoints (integer) the wanted number of points in the curve\r\n     * @returns the created Curve3\r\n     */\r\n    public static CreateQuadraticBezier(v0: DeepImmutable<Vector3>, v1: DeepImmutable<Vector3>, v2: DeepImmutable<Vector3>, nbPoints: number): Curve3 {\r\n        nbPoints = nbPoints > 2 ? nbPoints : 3;\r\n        const bez: Vector3[] = [];\r\n        const equation = (t: number, val0: number, val1: number, val2: number) => {\r\n            const res = (1.0 - t) * (1.0 - t) * val0 + 2.0 * t * (1.0 - t) * val1 + t * t * val2;\r\n            return res;\r\n        };\r\n        for (let i = 0; i <= nbPoints; i++) {\r\n            bez.push(new Vector3(equation(i / nbPoints, v0.x, v1.x, v2.x), equation(i / nbPoints, v0.y, v1.y, v2.y), equation(i / nbPoints, v0.z, v1.z, v2.z)));\r\n        }\r\n        return new Curve3(bez);\r\n    }\r\n\r\n    /**\r\n     * Returns a Curve3 object along a Cubic Bezier curve : https://doc.babylonjs.com/features/featuresDeepDive/mesh/drawCurves#cubic-bezier-curve\r\n     * @param v0 (Vector3) the origin point of the Cubic Bezier\r\n     * @param v1 (Vector3) the first control point\r\n     * @param v2 (Vector3) the second control point\r\n     * @param v3 (Vector3) the end point of the Cubic Bezier\r\n     * @param nbPoints (integer) the wanted number of points in the curve\r\n     * @returns the created Curve3\r\n     */\r\n    public static CreateCubicBezier(v0: DeepImmutable<Vector3>, v1: DeepImmutable<Vector3>, v2: DeepImmutable<Vector3>, v3: DeepImmutable<Vector3>, nbPoints: number): Curve3 {\r\n        nbPoints = nbPoints > 3 ? nbPoints : 4;\r\n        const bez: Vector3[] = [];\r\n        const equation = (t: number, val0: number, val1: number, val2: number, val3: number) => {\r\n            const res = (1.0 - t) * (1.0 - t) * (1.0 - t) * val0 + 3.0 * t * (1.0 - t) * (1.0 - t) * val1 + 3.0 * t * t * (1.0 - t) * val2 + t * t * t * val3;\r\n            return res;\r\n        };\r\n        for (let i = 0; i <= nbPoints; i++) {\r\n            bez.push(new Vector3(equation(i / nbPoints, v0.x, v1.x, v2.x, v3.x), equation(i / nbPoints, v0.y, v1.y, v2.y, v3.y), equation(i / nbPoints, v0.z, v1.z, v2.z, v3.z)));\r\n        }\r\n        return new Curve3(bez);\r\n    }\r\n\r\n    /**\r\n     * Returns a Curve3 object along a Hermite Spline curve : https://doc.babylonjs.com/features/featuresDeepDive/mesh/drawCurves#hermite-spline\r\n     * @param p1 (Vector3) the origin point of the Hermite Spline\r\n     * @param t1 (Vector3) the tangent vector at the origin point\r\n     * @param p2 (Vector3) the end point of the Hermite Spline\r\n     * @param t2 (Vector3) the tangent vector at the end point\r\n     * @param nSeg (integer) the number of curve segments or nSeg + 1 points in the array\r\n     * @returns the created Curve3\r\n     */\r\n    public static CreateHermiteSpline(p1: DeepImmutable<Vector3>, t1: DeepImmutable<Vector3>, p2: DeepImmutable<Vector3>, t2: DeepImmutable<Vector3>, nSeg: number): Curve3 {\r\n        const hermite: Vector3[] = [];\r\n        const step = 1.0 / nSeg;\r\n        for (let i = 0; i <= nSeg; i++) {\r\n            hermite.push(Vector3.Hermite(p1, t1, p2, t2, i * step));\r\n        }\r\n        return new Curve3(hermite);\r\n    }\r\n\r\n    /**\r\n     * Returns a Curve3 object along a CatmullRom Spline curve :\r\n     * @param points (array of Vector3) the points the spline must pass through. At least, four points required\r\n     * @param nbPoints (integer) the wanted number of points between each curve control points\r\n     * @param closed (boolean) optional with default false, when true forms a closed loop from the points\r\n     * @returns the created Curve3\r\n     */\r\n    public static CreateCatmullRomSpline(points: DeepImmutable<Vector3[]>, nbPoints: number, closed?: boolean): Curve3 {\r\n        const catmullRom: Vector3[] = [];\r\n        const step = 1.0 / nbPoints;\r\n        let amount = 0.0;\r\n        if (closed) {\r\n            const pointsCount = points.length;\r\n            for (let i = 0; i < pointsCount; i++) {\r\n                amount = 0;\r\n                for (let c = 0; c < nbPoints; c++) {\r\n                    catmullRom.push(\r\n                        Vector3.CatmullRom(points[i % pointsCount], points[(i + 1) % pointsCount], points[(i + 2) % pointsCount], points[(i + 3) % pointsCount], amount)\r\n                    );\r\n                    amount += step;\r\n                }\r\n            }\r\n            catmullRom.push(catmullRom[0]);\r\n        } else {\r\n            const totalPoints: Vector3[] = [];\r\n            totalPoints.push(points[0].clone());\r\n            Array.prototype.push.apply(totalPoints, points);\r\n            totalPoints.push(points[points.length - 1].clone());\r\n            let i = 0;\r\n            for (; i < totalPoints.length - 3; i++) {\r\n                amount = 0;\r\n                for (let c = 0; c < nbPoints; c++) {\r\n                    catmullRom.push(Vector3.CatmullRom(totalPoints[i], totalPoints[i + 1], totalPoints[i + 2], totalPoints[i + 3], amount));\r\n                    amount += step;\r\n                }\r\n            }\r\n            i--;\r\n            catmullRom.push(Vector3.CatmullRom(totalPoints[i], totalPoints[i + 1], totalPoints[i + 2], totalPoints[i + 3], amount));\r\n        }\r\n        return new Curve3(catmullRom);\r\n    }\r\n\r\n    /**\r\n     * Returns a Curve3 object along an arc through three vector3 points:\r\n     * The three points should not be colinear. When they are the Curve3 is empty.\r\n     * @param first (Vector3) the first point the arc must pass through.\r\n     * @param second (Vector3) the second point the arc must pass through.\r\n     * @param third (Vector3) the third point the arc must pass through.\r\n     * @param steps (number) the larger the number of steps the more detailed the arc.\r\n     * @param closed (boolean) optional with default false, when true forms the chord from the first and third point\r\n     * @param fullCircle Circle (boolean) optional with default false, when true forms the complete circle through the three points\r\n     * @returns the created Curve3\r\n     */\r\n    public static ArcThru3Points(first: Vector3, second: Vector3, third: Vector3, steps: number = 32, closed: boolean = false, fullCircle: boolean = false): Curve3 {\r\n        const arc: Vector3[] = [];\r\n        const vec1 = second.subtract(first);\r\n        const vec2 = third.subtract(second);\r\n        const vec3 = first.subtract(third);\r\n        const zAxis = Vector3.Cross(vec1, vec2);\r\n        const len4 = zAxis.length();\r\n        if (len4 < Math.pow(10, -8)) {\r\n            return new Curve3(arc); // colinear points arc is empty\r\n        }\r\n        const len1_sq = vec1.lengthSquared();\r\n        const len2_sq = vec2.lengthSquared();\r\n        const len3_sq = vec3.lengthSquared();\r\n        const len4_sq = zAxis.lengthSquared();\r\n        const len1 = vec1.length();\r\n        const len2 = vec2.length();\r\n        const len3 = vec3.length();\r\n        const radius = (0.5 * len1 * len2 * len3) / len4;\r\n        const dot1 = Vector3.Dot(vec1, vec3);\r\n        const dot2 = Vector3.Dot(vec1, vec2);\r\n        const dot3 = Vector3.Dot(vec2, vec3);\r\n        const a = (-0.5 * len2_sq * dot1) / len4_sq;\r\n        const b = (-0.5 * len3_sq * dot2) / len4_sq;\r\n        const c = (-0.5 * len1_sq * dot3) / len4_sq;\r\n        const center = first.scale(a).add(second.scale(b)).add(third.scale(c));\r\n        const radiusVec = first.subtract(center);\r\n        const xAxis = radiusVec.normalize();\r\n        const yAxis = Vector3.Cross(zAxis, xAxis).normalize();\r\n        if (fullCircle) {\r\n            const dStep = (2 * Math.PI) / steps;\r\n            for (let theta = 0; theta <= 2 * Math.PI; theta += dStep) {\r\n                arc.push(center.add(xAxis.scale(radius * Math.cos(theta)).add(yAxis.scale(radius * Math.sin(theta)))));\r\n            }\r\n            arc.push(first);\r\n        } else {\r\n            const dStep = 1 / steps;\r\n            let theta = 0;\r\n            let point = Vector3.Zero();\r\n            do {\r\n                point = center.add(xAxis.scale(radius * Math.cos(theta)).add(yAxis.scale(radius * Math.sin(theta))));\r\n                arc.push(point);\r\n                theta += dStep;\r\n            } while (!point.equalsWithEpsilon(third, radius * dStep * 1.1));\r\n            arc.push(third);\r\n            if (closed) {\r\n                arc.push(first);\r\n            }\r\n        }\r\n        return new Curve3(arc);\r\n    }\r\n\r\n    /**\r\n     * A Curve3 object is a logical object, so not a mesh, to handle curves in the 3D geometric space.\r\n     * A Curve3 is designed from a series of successive Vector3.\r\n     * Tuto : https://doc.babylonjs.com/features/featuresDeepDive/mesh/drawCurves#curve3-object\r\n     * @param points points which make up the curve\r\n     */\r\n    constructor(points: Vector3[]) {\r\n        this._points = points;\r\n        this._length = this._computeLength(points);\r\n    }\r\n\r\n    /**\r\n     * @returns the Curve3 stored array of successive Vector3\r\n     */\r\n    public getPoints() {\r\n        return this._points;\r\n    }\r\n\r\n    /**\r\n     * @returns the computed length (float) of the curve.\r\n     */\r\n    public length() {\r\n        return this._length;\r\n    }\r\n\r\n    /**\r\n     * Returns a new instance of Curve3 object : var curve = curveA.continue(curveB);\r\n     * This new Curve3 is built by translating and sticking the curveB at the end of the curveA.\r\n     * curveA and curveB keep unchanged.\r\n     * @param curve the curve to continue from this curve\r\n     * @returns the newly constructed curve\r\n     */\r\n    public continue(curve: DeepImmutable<Curve3>): Curve3 {\r\n        const lastPoint = this._points[this._points.length - 1];\r\n        const continuedPoints = this._points.slice();\r\n        const curvePoints = curve.getPoints();\r\n        for (let i = 1; i < curvePoints.length; i++) {\r\n            continuedPoints.push(curvePoints[i].subtract(curvePoints[0]).add(lastPoint));\r\n        }\r\n        const continuedCurve = new Curve3(continuedPoints);\r\n        return continuedCurve;\r\n    }\r\n\r\n    private _computeLength(path: DeepImmutable<Vector3[]>): number {\r\n        let l = 0;\r\n        for (let i = 1; i < path.length; i++) {\r\n            l += path[i].subtract(path[i - 1]).length();\r\n        }\r\n        return l;\r\n    }\r\n}\r\n", "import { Vector3, Vector2 } from \"./math.vector\";\r\n\r\n/**\r\n * Contains position and normal vectors for a vertex\r\n */\r\nexport class PositionNormalVertex {\r\n    /**\r\n     * Creates a PositionNormalVertex\r\n     * @param position the position of the vertex (defaut: 0,0,0)\r\n     * @param normal the normal of the vertex (defaut: 0,1,0)\r\n     */\r\n    constructor(\r\n        /** [Vector3.Zero()] the position of the vertex (defaut: 0,0,0) */\r\n        public position: Vector3 = Vector3.Zero(),\r\n        /** [Vector3.Up()] the normal of the vertex (defaut: 0,1,0) */\r\n        public normal: Vector3 = Vector3.Up()\r\n    ) {}\r\n\r\n    /**\r\n     * Clones the PositionNormalVertex\r\n     * @returns the cloned PositionNormalVertex\r\n     */\r\n    public clone(): PositionNormalVertex {\r\n        return new PositionNormalVertex(this.position.clone(), this.normal.clone());\r\n    }\r\n}\r\n\r\n/**\r\n * Contains position, normal and uv vectors for a vertex\r\n */\r\nexport class PositionNormalTextureVertex {\r\n    /**\r\n     * Creates a PositionNormalTextureVertex\r\n     * @param position the position of the vertex (defaut: 0,0,0)\r\n     * @param normal the normal of the vertex (defaut: 0,1,0)\r\n     * @param uv the uv of the vertex (default: 0,0)\r\n     */\r\n    constructor(\r\n        /** [Vector3.Zero()] the position of the vertex (defaut: 0,0,0) */\r\n        public position: Vector3 = Vector3.Zero(),\r\n        /** [Vector3.Up()] the normal of the vertex (defaut: 0,1,0) */\r\n        public normal: Vector3 = Vector3.Up(),\r\n        /** [Vector3.Zero()] the uv of the vertex (default: 0,0) */\r\n        public uv: Vector2 = Vector2.Zero()\r\n    ) {}\r\n    /**\r\n     * Clones the PositionNormalTextureVertex\r\n     * @returns the cloned PositionNormalTextureVertex\r\n     */\r\n    public clone(): PositionNormalTextureVertex {\r\n        return new PositionNormalTextureVertex(this.position.clone(), this.normal.clone(), this.uv.clone());\r\n    }\r\n}\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Color3 } from \"../Maths/math.color\";\r\nimport { TmpVectors } from \"./math\";\r\n\r\n// https://dickyjim.wordpress.com/2013/09/04/spherical-harmonics-for-beginners/\r\n// http://silviojemma.com/public/papers/lighting/spherical-harmonic-lighting.pdf\r\n// https://www.ppsloan.org/publications/StupidSH36.pdf\r\n// http://cseweb.ucsd.edu/~ravir/papers/envmap/envmap.pdf\r\n// https://www.ppsloan.org/publications/SHJCGT.pdf\r\n// https://www.ppsloan.org/publications/shdering.pdf\r\n// https://google.github.io/filament/Filament.md.html#annex/sphericalharmonics\r\n// https://patapom.com/blog/SHPortal/\r\n// https://imdoingitwrong.wordpress.com/2011/04/14/spherical-harmonics-wtf/\r\n\r\n// Using real SH basis:\r\n//  m>0             m   m\r\n// y   = sqrt(2) * K * P * cos(m*phi) * cos(theta)\r\n//  l               l   l\r\n//\r\n//  m<0             m   |m|\r\n// y   = sqrt(2) * K * P * sin(m*phi) * cos(theta)\r\n//  l               l   l\r\n//\r\n//  m=0   0   0\r\n// y   = K * P * trigono terms\r\n//  l     l   l\r\n//\r\n//  m       (2l + 1)(l - |m|)!\r\n// K = sqrt(------------------)\r\n//  l           4pi(l + |m|)!\r\n//\r\n// and P by recursion:\r\n//\r\n// P00(x) = 1\r\n// P01(x) = x\r\n// Pll(x) = (-1^l)(2l - 1)!!(1-x*x)^(1/2)\r\n//          ((2l - 1)x[Pl-1/m]-(l + m - 1)[Pl-2/m])\r\n// Plm(x) = ---------------------------------------\r\n//                         l - m\r\n// Leaving the trigonometric terms aside we can precompute the constants to :\r\nconst SH3ylmBasisConstants = [\r\n    Math.sqrt(1 / (4 * Math.PI)), // l00\r\n\r\n    -Math.sqrt(3 / (4 * Math.PI)), // l1_1\r\n    Math.sqrt(3 / (4 * Math.PI)), // l10\r\n    -Math.sqrt(3 / (4 * Math.PI)), // l11\r\n\r\n    Math.sqrt(15 / (4 * Math.PI)), // l2_2\r\n    -Math.sqrt(15 / (4 * Math.PI)), // l2_1\r\n    Math.sqrt(5 / (16 * Math.PI)), // l20\r\n    -Math.sqrt(15 / (4 * Math.PI)), // l21\r\n    Math.sqrt(15 / (16 * Math.PI)), // l22\r\n];\r\n\r\n// cm = cos(m * phi)\r\n// sm = sin(m * phi)\r\n// {x,y,z} = {cos(phi)sin(theta), sin(phi)sin(theta), cos(theta)}\r\n// By recursion on using trigo identities:\r\nconst SH3ylmBasisTrigonometricTerms = [\r\n    () => 1, // l00\r\n\r\n    (direction: Vector3) => direction.y, // l1_1\r\n    (direction: Vector3) => direction.z, // l10\r\n    (direction: Vector3) => direction.x, // l11\r\n\r\n    (direction: Vector3) => direction.x * direction.y, // l2_2\r\n    (direction: Vector3) => direction.y * direction.z, // l2_1\r\n    (direction: Vector3) => 3 * direction.z * direction.z - 1, // l20\r\n    (direction: Vector3) => direction.x * direction.z, // l21\r\n    (direction: Vector3) => direction.x * direction.x - direction.y * direction.y, // l22\r\n];\r\n\r\n// Wrap the full compute\r\nconst applySH3 = (lm: number, direction: Vector3) => {\r\n    return SH3ylmBasisConstants[lm] * SH3ylmBasisTrigonometricTerms[lm](direction);\r\n};\r\n\r\n// Derived from the integration of the a kernel convolution to SH.\r\n// Great explanation here: https://patapom.com/blog/SHPortal/#about-distant-radiance-and-irradiance-environments\r\nconst SHCosKernelConvolution = [Math.PI, (2 * Math.PI) / 3, (2 * Math.PI) / 3, (2 * Math.PI) / 3, Math.PI / 4, Math.PI / 4, Math.PI / 4, Math.PI / 4, Math.PI / 4];\r\n\r\n/**\r\n * Class representing spherical harmonics coefficients to the 3rd degree\r\n */\r\nexport class SphericalHarmonics {\r\n    /**\r\n     * Defines whether or not the harmonics have been prescaled for rendering.\r\n     */\r\n    public preScaled = false;\r\n\r\n    /**\r\n     * The l0,0 coefficients of the spherical harmonics\r\n     */\r\n    public l00: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * The l1,-1 coefficients of the spherical harmonics\r\n     */\r\n    public l1_1: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * The l1,0 coefficients of the spherical harmonics\r\n     */\r\n    public l10: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * The l1,1 coefficients of the spherical harmonics\r\n     */\r\n    public l11: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * The l2,-2 coefficients of the spherical harmonics\r\n     */\r\n    public l2_2: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * The l2,-1 coefficients of the spherical harmonics\r\n     */\r\n    public l2_1: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * The l2,0 coefficients of the spherical harmonics\r\n     */\r\n    public l20: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * The l2,1 coefficients of the spherical harmonics\r\n     */\r\n    public l21: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * The l2,2 coefficients of the spherical harmonics\r\n     */\r\n    public l22: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * Adds a light to the spherical harmonics\r\n     * @param direction the direction of the light\r\n     * @param color the color of the light\r\n     * @param deltaSolidAngle the delta solid angle of the light\r\n     */\r\n    public addLight(direction: Vector3, color: Color3, deltaSolidAngle: number): void {\r\n        TmpVectors.Vector3[0].set(color.r, color.g, color.b);\r\n        const colorVector = TmpVectors.Vector3[0];\r\n        const c = TmpVectors.Vector3[1];\r\n        colorVector.scaleToRef(deltaSolidAngle, c);\r\n\r\n        c.scaleToRef(applySH3(0, direction), TmpVectors.Vector3[2]);\r\n        this.l00.addInPlace(TmpVectors.Vector3[2]);\r\n\r\n        c.scaleToRef(applySH3(1, direction), TmpVectors.Vector3[2]);\r\n        this.l1_1.addInPlace(TmpVectors.Vector3[2]);\r\n        c.scaleToRef(applySH3(2, direction), TmpVectors.Vector3[2]);\r\n        this.l10.addInPlace(TmpVectors.Vector3[2]);\r\n        c.scaleToRef(applySH3(3, direction), TmpVectors.Vector3[2]);\r\n        this.l11.addInPlace(TmpVectors.Vector3[2]);\r\n\r\n        c.scaleToRef(applySH3(4, direction), TmpVectors.Vector3[2]);\r\n        this.l2_2.addInPlace(TmpVectors.Vector3[2]);\r\n        c.scaleToRef(applySH3(5, direction), TmpVectors.Vector3[2]);\r\n        this.l2_1.addInPlace(TmpVectors.Vector3[2]);\r\n        c.scaleToRef(applySH3(6, direction), TmpVectors.Vector3[2]);\r\n        this.l20.addInPlace(TmpVectors.Vector3[2]);\r\n        c.scaleToRef(applySH3(7, direction), TmpVectors.Vector3[2]);\r\n        this.l21.addInPlace(TmpVectors.Vector3[2]);\r\n        c.scaleToRef(applySH3(8, direction), TmpVectors.Vector3[2]);\r\n        this.l22.addInPlace(TmpVectors.Vector3[2]);\r\n    }\r\n\r\n    /**\r\n     * Scales the spherical harmonics by the given amount\r\n     * @param scale the amount to scale\r\n     */\r\n    public scaleInPlace(scale: number): void {\r\n        this.l00.scaleInPlace(scale);\r\n        this.l1_1.scaleInPlace(scale);\r\n        this.l10.scaleInPlace(scale);\r\n        this.l11.scaleInPlace(scale);\r\n        this.l2_2.scaleInPlace(scale);\r\n        this.l2_1.scaleInPlace(scale);\r\n        this.l20.scaleInPlace(scale);\r\n        this.l21.scaleInPlace(scale);\r\n        this.l22.scaleInPlace(scale);\r\n    }\r\n\r\n    /**\r\n     * Convert from incident radiance (Li) to irradiance (E) by applying convolution with the cosine-weighted hemisphere.\r\n     *\r\n     * ```\r\n     * E_lm = A_l * L_lm\r\n     * ```\r\n     *\r\n     * In spherical harmonics this convolution amounts to scaling factors for each frequency band.\r\n     * This corresponds to equation 5 in \"An Efficient Representation for Irradiance Environment Maps\", where\r\n     * the scaling factors are given in equation 9.\r\n     */\r\n    public convertIncidentRadianceToIrradiance(): void {\r\n        // Constant (Band 0)\r\n        this.l00.scaleInPlace(SHCosKernelConvolution[0]);\r\n\r\n        // Linear (Band 1)\r\n        this.l1_1.scaleInPlace(SHCosKernelConvolution[1]);\r\n        this.l10.scaleInPlace(SHCosKernelConvolution[2]);\r\n        this.l11.scaleInPlace(SHCosKernelConvolution[3]);\r\n\r\n        // Quadratic (Band 2)\r\n        this.l2_2.scaleInPlace(SHCosKernelConvolution[4]);\r\n        this.l2_1.scaleInPlace(SHCosKernelConvolution[5]);\r\n        this.l20.scaleInPlace(SHCosKernelConvolution[6]);\r\n        this.l21.scaleInPlace(SHCosKernelConvolution[7]);\r\n        this.l22.scaleInPlace(SHCosKernelConvolution[8]);\r\n    }\r\n\r\n    /**\r\n     * Convert from irradiance to outgoing radiance for Lambertian BDRF, suitable for efficient shader evaluation.\r\n     *\r\n     * ```\r\n     * L = (1/pi) * E * rho\r\n     * ```\r\n     *\r\n     * This is done by an additional scale by 1/pi, so is a fairly trivial operation but important conceptually.\r\n     */\r\n    public convertIrradianceToLambertianRadiance(): void {\r\n        this.scaleInPlace(1.0 / Math.PI);\r\n\r\n        // The resultant SH now represents outgoing radiance, so includes the Lambert 1/pi normalisation factor but without albedo (rho) applied\r\n        // (The pixel shader must apply albedo after texture fetches, etc).\r\n    }\r\n\r\n    /**\r\n     * Integrates the reconstruction coefficients directly in to the SH preventing further\r\n     * required operations at run time.\r\n     *\r\n     * This is simply done by scaling back the SH with Ylm constants parameter.\r\n     * The trigonometric part being applied by the shader at run time.\r\n     */\r\n    public preScaleForRendering(): void {\r\n        this.preScaled = true;\r\n\r\n        this.l00.scaleInPlace(SH3ylmBasisConstants[0]);\r\n\r\n        this.l1_1.scaleInPlace(SH3ylmBasisConstants[1]);\r\n        this.l10.scaleInPlace(SH3ylmBasisConstants[2]);\r\n        this.l11.scaleInPlace(SH3ylmBasisConstants[3]);\r\n\r\n        this.l2_2.scaleInPlace(SH3ylmBasisConstants[4]);\r\n        this.l2_1.scaleInPlace(SH3ylmBasisConstants[5]);\r\n        this.l20.scaleInPlace(SH3ylmBasisConstants[6]);\r\n        this.l21.scaleInPlace(SH3ylmBasisConstants[7]);\r\n        this.l22.scaleInPlace(SH3ylmBasisConstants[8]);\r\n    }\r\n\r\n    /**\r\n     * update the spherical harmonics coefficients from the given array\r\n     * @param data defines the 9x3 coefficients (l00, l1-1, l10, l11, l2-2, l2-1, l20, l21, l22)\r\n     * @returns the spherical harmonics (this)\r\n     */\r\n    public updateFromArray(data: ArrayLike<ArrayLike<number>>): SphericalHarmonics {\r\n        Vector3.FromArrayToRef(data[0], 0, this.l00);\r\n        Vector3.FromArrayToRef(data[1], 0, this.l1_1);\r\n        Vector3.FromArrayToRef(data[2], 0, this.l10);\r\n        Vector3.FromArrayToRef(data[3], 0, this.l11);\r\n        Vector3.FromArrayToRef(data[4], 0, this.l2_2);\r\n        Vector3.FromArrayToRef(data[5], 0, this.l2_1);\r\n        Vector3.FromArrayToRef(data[6], 0, this.l20);\r\n        Vector3.FromArrayToRef(data[7], 0, this.l21);\r\n        Vector3.FromArrayToRef(data[8], 0, this.l22);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * update the spherical harmonics coefficients from the given floats array\r\n     * @param data defines the 9x3 coefficients (l00, l1-1, l10, l11, l2-2, l2-1, l20, l21, l22)\r\n     * @returns the spherical harmonics (this)\r\n     */\r\n    public updateFromFloatsArray(data: ArrayLike<number>): SphericalHarmonics {\r\n        Vector3.FromFloatsToRef(data[0], data[1], data[2], this.l00);\r\n        Vector3.FromFloatsToRef(data[3], data[4], data[5], this.l1_1);\r\n        Vector3.FromFloatsToRef(data[6], data[7], data[8], this.l10);\r\n        Vector3.FromFloatsToRef(data[9], data[10], data[11], this.l11);\r\n        Vector3.FromFloatsToRef(data[12], data[13], data[14], this.l2_2);\r\n        Vector3.FromFloatsToRef(data[15], data[16], data[17], this.l2_1);\r\n        Vector3.FromFloatsToRef(data[18], data[19], data[20], this.l20);\r\n        Vector3.FromFloatsToRef(data[21], data[22], data[23], this.l21);\r\n        Vector3.FromFloatsToRef(data[24], data[25], data[26], this.l22);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Constructs a spherical harmonics from an array.\r\n     * @param data defines the 9x3 coefficients (l00, l1-1, l10, l11, l2-2, l2-1, l20, l21, l22)\r\n     * @returns the spherical harmonics\r\n     */\r\n    public static FromArray(data: ArrayLike<ArrayLike<number>>): SphericalHarmonics {\r\n        const sh = new SphericalHarmonics();\r\n        return sh.updateFromArray(data);\r\n    }\r\n\r\n    // Keep for references.\r\n    /**\r\n     * Gets the spherical harmonics from polynomial\r\n     * @param polynomial the spherical polynomial\r\n     * @returns the spherical harmonics\r\n     */\r\n    public static FromPolynomial(polynomial: SphericalPolynomial): SphericalHarmonics {\r\n        const result = new SphericalHarmonics();\r\n\r\n        result.l00 = polynomial.xx.scale(0.376127).add(polynomial.yy.scale(0.376127)).add(polynomial.zz.scale(0.376126));\r\n        result.l1_1 = polynomial.y.scale(0.977204);\r\n        result.l10 = polynomial.z.scale(0.977204);\r\n        result.l11 = polynomial.x.scale(0.977204);\r\n        result.l2_2 = polynomial.xy.scale(1.16538);\r\n        result.l2_1 = polynomial.yz.scale(1.16538);\r\n        result.l20 = polynomial.zz.scale(1.34567).subtract(polynomial.xx.scale(0.672834)).subtract(polynomial.yy.scale(0.672834));\r\n        result.l21 = polynomial.zx.scale(1.16538);\r\n        result.l22 = polynomial.xx.scale(1.16538).subtract(polynomial.yy.scale(1.16538));\r\n\r\n        result.l1_1.scaleInPlace(-1);\r\n        result.l11.scaleInPlace(-1);\r\n        result.l2_1.scaleInPlace(-1);\r\n        result.l21.scaleInPlace(-1);\r\n\r\n        result.scaleInPlace(Math.PI);\r\n\r\n        return result;\r\n    }\r\n}\r\n\r\n/**\r\n * Class representing spherical polynomial coefficients to the 3rd degree\r\n */\r\nexport class SphericalPolynomial {\r\n    private _harmonics: Nullable<SphericalHarmonics>;\r\n\r\n    /**\r\n     * The spherical harmonics used to create the polynomials.\r\n     */\r\n    public get preScaledHarmonics(): SphericalHarmonics {\r\n        if (!this._harmonics) {\r\n            this._harmonics = SphericalHarmonics.FromPolynomial(this);\r\n        }\r\n        if (!this._harmonics.preScaled) {\r\n            this._harmonics.preScaleForRendering();\r\n        }\r\n        return this._harmonics;\r\n    }\r\n\r\n    /**\r\n     * The x coefficients of the spherical polynomial\r\n     */\r\n    public x: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * The y coefficients of the spherical polynomial\r\n     */\r\n    public y: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * The z coefficients of the spherical polynomial\r\n     */\r\n    public z: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * The xx coefficients of the spherical polynomial\r\n     */\r\n    public xx: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * The yy coefficients of the spherical polynomial\r\n     */\r\n    public yy: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * The zz coefficients of the spherical polynomial\r\n     */\r\n    public zz: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * The xy coefficients of the spherical polynomial\r\n     */\r\n    public xy: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * The yz coefficients of the spherical polynomial\r\n     */\r\n    public yz: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * The zx coefficients of the spherical polynomial\r\n     */\r\n    public zx: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * Adds an ambient color to the spherical polynomial\r\n     * @param color the color to add\r\n     */\r\n    public addAmbient(color: Color3): void {\r\n        TmpVectors.Vector3[0].copyFromFloats(color.r, color.g, color.b);\r\n        const colorVector = TmpVectors.Vector3[0];\r\n        this.xx.addInPlace(colorVector);\r\n        this.yy.addInPlace(colorVector);\r\n        this.zz.addInPlace(colorVector);\r\n    }\r\n\r\n    /**\r\n     * Scales the spherical polynomial by the given amount\r\n     * @param scale the amount to scale\r\n     */\r\n    public scaleInPlace(scale: number) {\r\n        this.x.scaleInPlace(scale);\r\n        this.y.scaleInPlace(scale);\r\n        this.z.scaleInPlace(scale);\r\n        this.xx.scaleInPlace(scale);\r\n        this.yy.scaleInPlace(scale);\r\n        this.zz.scaleInPlace(scale);\r\n        this.yz.scaleInPlace(scale);\r\n        this.zx.scaleInPlace(scale);\r\n        this.xy.scaleInPlace(scale);\r\n    }\r\n\r\n    /**\r\n     * Updates the spherical polynomial from harmonics\r\n     * @param harmonics the spherical harmonics\r\n     * @returns the spherical polynomial\r\n     */\r\n    public updateFromHarmonics(harmonics: SphericalHarmonics): SphericalPolynomial {\r\n        this._harmonics = harmonics;\r\n\r\n        this.x.copyFrom(harmonics.l11);\r\n        this.x.scaleInPlace(1.02333).scaleInPlace(-1);\r\n        this.y.copyFrom(harmonics.l1_1);\r\n        this.y.scaleInPlace(1.02333).scaleInPlace(-1);\r\n        this.z.copyFrom(harmonics.l10);\r\n        this.z.scaleInPlace(1.02333);\r\n\r\n        this.xx.copyFrom(harmonics.l00);\r\n        TmpVectors.Vector3[0].copyFrom(harmonics.l20).scaleInPlace(0.247708);\r\n        TmpVectors.Vector3[1].copyFrom(harmonics.l22).scaleInPlace(0.429043);\r\n        this.xx.scaleInPlace(0.886277).subtractInPlace(TmpVectors.Vector3[0]).addInPlace(TmpVectors.Vector3[1]);\r\n        this.yy.copyFrom(harmonics.l00);\r\n        this.yy.scaleInPlace(0.886277).subtractInPlace(TmpVectors.Vector3[0]).subtractInPlace(TmpVectors.Vector3[1]);\r\n        this.zz.copyFrom(harmonics.l00);\r\n        TmpVectors.Vector3[0].copyFrom(harmonics.l20).scaleInPlace(0.495417);\r\n        this.zz.scaleInPlace(0.886277).addInPlace(TmpVectors.Vector3[0]);\r\n\r\n        this.yz.copyFrom(harmonics.l2_1);\r\n        this.yz.scaleInPlace(0.858086).scaleInPlace(-1);\r\n        this.zx.copyFrom(harmonics.l21);\r\n        this.zx.scaleInPlace(0.858086).scaleInPlace(-1);\r\n        this.xy.copyFrom(harmonics.l2_2);\r\n        this.xy.scaleInPlace(0.858086);\r\n\r\n        this.scaleInPlace(1.0 / Math.PI);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets the spherical polynomial from harmonics\r\n     * @param harmonics the spherical harmonics\r\n     * @returns the spherical polynomial\r\n     */\r\n    public static FromHarmonics(harmonics: SphericalHarmonics): SphericalPolynomial {\r\n        const result = new SphericalPolynomial();\r\n        return result.updateFromHarmonics(harmonics);\r\n    }\r\n\r\n    /**\r\n     * Constructs a spherical polynomial from an array.\r\n     * @param data defines the 9x3 coefficients (x, y, z, xx, yy, zz, yz, zx, xy)\r\n     * @returns the spherical polynomial\r\n     */\r\n    public static FromArray(data: ArrayLike<ArrayLike<number>>): SphericalPolynomial {\r\n        const sp = new SphericalPolynomial();\r\n        Vector3.FromArrayToRef(data[0], 0, sp.x);\r\n        Vector3.FromArrayToRef(data[1], 0, sp.y);\r\n        Vector3.FromArrayToRef(data[2], 0, sp.z);\r\n        Vector3.FromArrayToRef(data[3], 0, sp.xx);\r\n        Vector3.FromArrayToRef(data[4], 0, sp.yy);\r\n        Vector3.FromArrayToRef(data[5], 0, sp.zz);\r\n        Vector3.FromArrayToRef(data[6], 0, sp.yz);\r\n        Vector3.FromArrayToRef(data[7], 0, sp.zx);\r\n        Vector3.FromArrayToRef(data[8], 0, sp.xy);\r\n        return sp;\r\n    }\r\n}\r\n", "import { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Clamp } from \"../../Maths/math.scalar.functions\";\r\nimport { SphericalPolynomial, SphericalHarmonics } from \"../../Maths/sphericalPolynomial\";\r\nimport type { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport type { CubeMapInfo } from \"./panoramaToCubemap\";\r\nimport { ToLinearSpace } from \"../../Maths/math.constants\";\r\nimport { Color3 } from \"../../Maths/math.color\";\r\n\r\nclass FileFaceOrientation {\r\n    public name: string;\r\n    public worldAxisForNormal: Vector3; // the world axis corresponding to the normal to the face\r\n    public worldAxisForFileX: Vector3; // the world axis corresponding to texture right x-axis in file\r\n    public worldAxisForFileY: Vector3; // the world axis corresponding to texture down y-axis in file\r\n\r\n    public constructor(name: string, worldAxisForNormal: Vector3, worldAxisForFileX: Vector3, worldAxisForFileY: Vector3) {\r\n        this.name = name;\r\n        this.worldAxisForNormal = worldAxisForNormal;\r\n        this.worldAxisForFileX = worldAxisForFileX;\r\n        this.worldAxisForFileY = worldAxisForFileY;\r\n    }\r\n}\r\n\r\n/**\r\n * Helper class dealing with the extraction of spherical polynomial dataArray\r\n * from a cube map.\r\n */\r\nexport class CubeMapToSphericalPolynomialTools {\r\n    private static _FileFaces: FileFaceOrientation[] = [\r\n        new FileFaceOrientation(\"right\", new Vector3(1, 0, 0), new Vector3(0, 0, -1), new Vector3(0, -1, 0)), // +X east\r\n        new FileFaceOrientation(\"left\", new Vector3(-1, 0, 0), new Vector3(0, 0, 1), new Vector3(0, -1, 0)), // -X west\r\n        new FileFaceOrientation(\"up\", new Vector3(0, 1, 0), new Vector3(1, 0, 0), new Vector3(0, 0, 1)), // +Y north\r\n        new FileFaceOrientation(\"down\", new Vector3(0, -1, 0), new Vector3(1, 0, 0), new Vector3(0, 0, -1)), // -Y south\r\n        new FileFaceOrientation(\"front\", new Vector3(0, 0, 1), new Vector3(1, 0, 0), new Vector3(0, -1, 0)), // +Z top\r\n        new FileFaceOrientation(\"back\", new Vector3(0, 0, -1), new Vector3(-1, 0, 0), new Vector3(0, -1, 0)), // -Z bottom\r\n    ];\r\n\r\n    /** @internal */\r\n    public static MAX_HDRI_VALUE = 4096;\r\n    /** @internal */\r\n    public static PRESERVE_CLAMPED_COLORS = false;\r\n\r\n    /**\r\n     * Converts a texture to the according Spherical Polynomial data.\r\n     * This extracts the first 3 orders only as they are the only one used in the lighting.\r\n     *\r\n     * @param texture The texture to extract the information from.\r\n     * @returns The Spherical Polynomial data.\r\n     */\r\n    public static ConvertCubeMapTextureToSphericalPolynomial(texture: BaseTexture): Nullable<Promise<SphericalPolynomial>> {\r\n        if (!texture.isCube) {\r\n            // Only supports cube Textures currently.\r\n            return null;\r\n        }\r\n\r\n        texture.getScene()?.getEngine().flushFramebuffer();\r\n\r\n        const size = texture.getSize().width;\r\n        const rightPromise = texture.readPixels(0, undefined, undefined, false);\r\n        const leftPromise = texture.readPixels(1, undefined, undefined, false);\r\n\r\n        let upPromise: Nullable<Promise<ArrayBufferView>>;\r\n        let downPromise: Nullable<Promise<ArrayBufferView>>;\r\n        if (texture.isRenderTarget) {\r\n            upPromise = texture.readPixels(3, undefined, undefined, false);\r\n            downPromise = texture.readPixels(2, undefined, undefined, false);\r\n        } else {\r\n            upPromise = texture.readPixels(2, undefined, undefined, false);\r\n            downPromise = texture.readPixels(3, undefined, undefined, false);\r\n        }\r\n\r\n        const frontPromise = texture.readPixels(4, undefined, undefined, false);\r\n        const backPromise = texture.readPixels(5, undefined, undefined, false);\r\n\r\n        const gammaSpace = texture.gammaSpace;\r\n        // Always read as RGBA.\r\n        const format = Constants.TEXTUREFORMAT_RGBA;\r\n        let type = Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n        if (texture.textureType == Constants.TEXTURETYPE_FLOAT || texture.textureType == Constants.TEXTURETYPE_HALF_FLOAT) {\r\n            type = Constants.TEXTURETYPE_FLOAT;\r\n        }\r\n\r\n        return new Promise((resolve) => {\r\n            Promise.all([leftPromise, rightPromise, upPromise, downPromise, frontPromise, backPromise]).then(([left, right, up, down, front, back]) => {\r\n                const cubeInfo: CubeMapInfo = {\r\n                    size,\r\n                    right,\r\n                    left,\r\n                    up,\r\n                    down,\r\n                    front,\r\n                    back,\r\n                    format,\r\n                    type,\r\n                    gammaSpace,\r\n                };\r\n\r\n                resolve(this.ConvertCubeMapToSphericalPolynomial(cubeInfo));\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Compute the area on the unit sphere of the rectangle defined by (x,y) and the origin\r\n     * See https://www.rorydriscoll.com/2012/01/15/cubemap-texel-solid-angle/\r\n     * @param x\r\n     * @param y\r\n     * @returns the area\r\n     */\r\n    private static _AreaElement(x: number, y: number): number {\r\n        return Math.atan2(x * y, Math.sqrt(x * x + y * y + 1));\r\n    }\r\n\r\n    /**\r\n     * Converts a cubemap to the according Spherical Polynomial data.\r\n     * This extracts the first 3 orders only as they are the only one used in the lighting.\r\n     *\r\n     * @param cubeInfo The Cube map to extract the information from.\r\n     * @returns The Spherical Polynomial data.\r\n     */\r\n    public static ConvertCubeMapToSphericalPolynomial(cubeInfo: CubeMapInfo): SphericalPolynomial {\r\n        const sphericalHarmonics = new SphericalHarmonics();\r\n        let totalSolidAngle = 0.0;\r\n\r\n        // The (u,v) range is [-1,+1], so the distance between each texel is 2/Size.\r\n        const du = 2.0 / cubeInfo.size;\r\n        const dv = du;\r\n\r\n        const halfTexel = 0.5 * du;\r\n\r\n        // The (u,v) of the first texel is half a texel from the corner (-1,-1).\r\n        const minUV = halfTexel - 1.0;\r\n\r\n        for (let faceIndex = 0; faceIndex < 6; faceIndex++) {\r\n            const fileFace = this._FileFaces[faceIndex];\r\n            const dataArray = (<any>cubeInfo)[fileFace.name];\r\n            let v = minUV;\r\n\r\n            // TODO: we could perform the summation directly into a SphericalPolynomial (SP), which is more efficient than SphericalHarmonic (SH).\r\n            // This is possible because during the summation we do not need the SH-specific properties, e.g. orthogonality.\r\n            // Because SP is still linear, so summation is fine in that basis.\r\n            const stride = cubeInfo.format === Constants.TEXTUREFORMAT_RGBA ? 4 : 3;\r\n            for (let y = 0; y < cubeInfo.size; y++) {\r\n                let u = minUV;\r\n\r\n                for (let x = 0; x < cubeInfo.size; x++) {\r\n                    // World direction (not normalised)\r\n                    const worldDirection = fileFace.worldAxisForFileX.scale(u).add(fileFace.worldAxisForFileY.scale(v)).add(fileFace.worldAxisForNormal);\r\n                    worldDirection.normalize();\r\n\r\n                    const deltaSolidAngle =\r\n                        this._AreaElement(u - halfTexel, v - halfTexel) -\r\n                        this._AreaElement(u - halfTexel, v + halfTexel) -\r\n                        this._AreaElement(u + halfTexel, v - halfTexel) +\r\n                        this._AreaElement(u + halfTexel, v + halfTexel);\r\n\r\n                    let r = dataArray[y * cubeInfo.size * stride + x * stride + 0];\r\n                    let g = dataArray[y * cubeInfo.size * stride + x * stride + 1];\r\n                    let b = dataArray[y * cubeInfo.size * stride + x * stride + 2];\r\n\r\n                    // Prevent NaN harmonics with extreme HDRI data.\r\n                    if (isNaN(r)) {\r\n                        r = 0;\r\n                    }\r\n                    if (isNaN(g)) {\r\n                        g = 0;\r\n                    }\r\n                    if (isNaN(b)) {\r\n                        b = 0;\r\n                    }\r\n\r\n                    // Handle Integer types.\r\n                    if (cubeInfo.type === Constants.TEXTURETYPE_UNSIGNED_BYTE) {\r\n                        r /= 255;\r\n                        g /= 255;\r\n                        b /= 255;\r\n                    }\r\n\r\n                    // Handle Gamma space textures.\r\n                    if (cubeInfo.gammaSpace) {\r\n                        r = Math.pow(Clamp(r), ToLinearSpace);\r\n                        g = Math.pow(Clamp(g), ToLinearSpace);\r\n                        b = Math.pow(Clamp(b), ToLinearSpace);\r\n                    }\r\n\r\n                    // Prevent to explode in case of really high dynamic ranges.\r\n                    // sh 3 would not be enough to accurately represent it.\r\n                    const max = this.MAX_HDRI_VALUE;\r\n                    if (this.PRESERVE_CLAMPED_COLORS) {\r\n                        const currentMax = Math.max(r, g, b);\r\n                        if (currentMax > max) {\r\n                            const factor = max / currentMax;\r\n                            r *= factor;\r\n                            g *= factor;\r\n                            b *= factor;\r\n                        }\r\n                    } else {\r\n                        r = Clamp(r, 0, max);\r\n                        g = Clamp(g, 0, max);\r\n                        b = Clamp(b, 0, max);\r\n                    }\r\n\r\n                    const color = new Color3(r, g, b);\r\n\r\n                    sphericalHarmonics.addLight(worldDirection, color, deltaSolidAngle);\r\n\r\n                    totalSolidAngle += deltaSolidAngle;\r\n\r\n                    u += du;\r\n                }\r\n\r\n                v += dv;\r\n            }\r\n        }\r\n\r\n        // Solid angle for entire sphere is 4*pi\r\n        const sphereSolidAngle = 4.0 * Math.PI;\r\n\r\n        // Adjust the solid angle to allow for how many faces we processed.\r\n        const facesProcessed = 6.0;\r\n        const expectedSolidAngle = (sphereSolidAngle * facesProcessed) / 6.0;\r\n\r\n        // Adjust the harmonics so that the accumulated solid angle matches the expected solid angle.\r\n        // This is needed because the numerical integration over the cube uses a\r\n        // small angle approximation of solid angle for each texel (see deltaSolidAngle),\r\n        // and also to compensate for accumulative error due to float precision in the summation.\r\n        const correctionFactor = expectedSolidAngle / totalSolidAngle;\r\n        sphericalHarmonics.scaleInPlace(correctionFactor);\r\n\r\n        sphericalHarmonics.convertIncidentRadianceToIrradiance();\r\n        sphericalHarmonics.convertIrradianceToLambertianRadiance();\r\n\r\n        return SphericalPolynomial.FromHarmonics(sphericalHarmonics);\r\n    }\r\n}\r\n", "import type { Nullable } from \"../types\";\r\nimport type { InternalTexture } from \"../Materials/Textures/internalTexture\";\r\nimport type { PostProcess } from \"./postProcess\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport type { DataBuffer } from \"../Buffers/dataBuffer\";\r\nimport type { RenderTargetWrapper } from \"../Engines/renderTargetWrapper\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { Scene } from \"../scene\";\r\n\r\n/**\r\n * PostProcessManager is used to manage one or more post processes or post process pipelines\r\n * See https://doc.babylonjs.com/features/featuresDeepDive/postProcesses/usePostProcesses\r\n */\r\nexport class PostProcessManager {\r\n    private _scene: Scene;\r\n    private _indexBuffer: Nullable<DataBuffer>;\r\n    private _vertexBuffers: { [key: string]: Nullable<VertexBuffer> } = {};\r\n\r\n    /**\r\n     * Creates a new instance PostProcess\r\n     * @param scene The scene that the post process is associated with.\r\n     */\r\n    constructor(scene: Scene) {\r\n        this._scene = scene;\r\n    }\r\n\r\n    private _prepareBuffers(): void {\r\n        if (this._vertexBuffers[VertexBuffer.PositionKind]) {\r\n            return;\r\n        }\r\n\r\n        // VBO\r\n        const vertices = [];\r\n        vertices.push(1, 1);\r\n        vertices.push(-1, 1);\r\n        vertices.push(-1, -1);\r\n        vertices.push(1, -1);\r\n\r\n        this._vertexBuffers[VertexBuffer.PositionKind] = new VertexBuffer(this._scene.getEngine(), vertices, VertexBuffer.PositionKind, false, false, 2);\r\n\r\n        this._buildIndexBuffer();\r\n    }\r\n\r\n    private _buildIndexBuffer(): void {\r\n        // Indices\r\n        const indices = [];\r\n        indices.push(0);\r\n        indices.push(1);\r\n        indices.push(2);\r\n\r\n        indices.push(0);\r\n        indices.push(2);\r\n        indices.push(3);\r\n\r\n        this._indexBuffer = this._scene.getEngine().createIndexBuffer(indices);\r\n    }\r\n\r\n    public onBeforeRenderObservable = new Observable<PostProcessManager>();\r\n\r\n    /**\r\n     * Rebuilds the vertex buffers of the manager.\r\n     * @internal\r\n     */\r\n    public _rebuild(): void {\r\n        const vb = this._vertexBuffers[VertexBuffer.PositionKind];\r\n\r\n        if (!vb) {\r\n            return;\r\n        }\r\n        vb._rebuild();\r\n        this._buildIndexBuffer();\r\n    }\r\n\r\n    // Methods\r\n    /**\r\n     * Prepares a frame to be run through a post process.\r\n     * @param sourceTexture The input texture to the post processes. (default: null)\r\n     * @param postProcesses An array of post processes to be run. (default: null)\r\n     * @returns True if the post processes were able to be run.\r\n     * @internal\r\n     */\r\n    public _prepareFrame(sourceTexture: Nullable<InternalTexture> = null, postProcesses: Nullable<PostProcess[]> = null): boolean {\r\n        const camera = this._scene.activeCamera;\r\n        if (!camera) {\r\n            return false;\r\n        }\r\n\r\n        postProcesses = postProcesses || <Nullable<PostProcess[]>>camera._postProcesses.filter((pp) => {\r\n                return pp != null;\r\n            });\r\n\r\n        if (!postProcesses || postProcesses.length === 0 || !this._scene.postProcessesEnabled) {\r\n            return false;\r\n        }\r\n\r\n        postProcesses[0].activate(camera, sourceTexture, postProcesses !== null && postProcesses !== undefined);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Manually render a set of post processes to a texture.\r\n     * Please note, the frame buffer won't be unbound after the call in case you have more render to do.\r\n     * @param postProcesses An array of post processes to be run.\r\n     * @param targetTexture The render target wrapper to render to.\r\n     * @param forceFullscreenViewport force gl.viewport to be full screen eg. 0,0,textureWidth,textureHeight\r\n     * @param faceIndex defines the face to render to if a cubemap is defined as the target\r\n     * @param lodLevel defines which lod of the texture to render to\r\n     * @param doNotBindFrambuffer If set to true, assumes that the framebuffer has been bound previously\r\n     */\r\n    public directRender(\r\n        postProcesses: PostProcess[],\r\n        targetTexture: Nullable<RenderTargetWrapper> = null,\r\n        forceFullscreenViewport = false,\r\n        faceIndex = 0,\r\n        lodLevel = 0,\r\n        doNotBindFrambuffer = false\r\n    ): void {\r\n        const engine = this._scene.getEngine();\r\n\r\n        for (let index = 0; index < postProcesses.length; index++) {\r\n            if (index < postProcesses.length - 1) {\r\n                postProcesses[index + 1].activate(this._scene.activeCamera || this._scene, targetTexture?.texture);\r\n            } else {\r\n                if (targetTexture) {\r\n                    engine.bindFramebuffer(targetTexture, faceIndex, undefined, undefined, forceFullscreenViewport, lodLevel);\r\n                } else if (!doNotBindFrambuffer) {\r\n                    engine.restoreDefaultFramebuffer();\r\n                }\r\n                engine._debugInsertMarker?.(`post process ${postProcesses[index].name} output`);\r\n            }\r\n\r\n            const pp = postProcesses[index];\r\n            const effect = pp.apply();\r\n\r\n            if (effect) {\r\n                pp.onBeforeRenderObservable.notifyObservers(effect);\r\n\r\n                // VBOs\r\n                this._prepareBuffers();\r\n                engine.bindBuffers(this._vertexBuffers, this._indexBuffer, effect);\r\n\r\n                // Draw order\r\n                engine.drawElementsType(Constants.MATERIAL_TriangleFillMode, 0, 6);\r\n\r\n                pp.onAfterRenderObservable.notifyObservers(effect);\r\n            }\r\n        }\r\n\r\n        // Restore depth buffer\r\n        engine.setDepthBuffer(true);\r\n        engine.setDepthWrite(true);\r\n    }\r\n\r\n    /**\r\n     * Finalize the result of the output of the postprocesses.\r\n     * @param doNotPresent If true the result will not be displayed to the screen.\r\n     * @param targetTexture The render target wrapper to render to.\r\n     * @param faceIndex The index of the face to bind the target texture to.\r\n     * @param postProcesses The array of post processes to render.\r\n     * @param forceFullscreenViewport force gl.viewport to be full screen eg. 0,0,textureWidth,textureHeight (default: false)\r\n     * @internal\r\n     */\r\n    public _finalizeFrame(\r\n        doNotPresent?: boolean,\r\n        targetTexture?: RenderTargetWrapper,\r\n        faceIndex?: number,\r\n        postProcesses?: Array<PostProcess>,\r\n        forceFullscreenViewport = false\r\n    ): void {\r\n        const camera = this._scene.activeCamera;\r\n\r\n        if (!camera) {\r\n            return;\r\n        }\r\n\r\n        this.onBeforeRenderObservable.notifyObservers(this);\r\n\r\n        postProcesses = postProcesses || <Array<PostProcess>>camera._postProcesses.filter((pp) => {\r\n                return pp != null;\r\n            });\r\n        if (postProcesses.length === 0 || !this._scene.postProcessesEnabled) {\r\n            return;\r\n        }\r\n        const engine = this._scene.getEngine();\r\n\r\n        for (let index = 0, len = postProcesses.length; index < len; index++) {\r\n            const pp = postProcesses[index];\r\n\r\n            if (index < len - 1) {\r\n                pp._outputTexture = postProcesses[index + 1].activate(camera, targetTexture?.texture);\r\n            } else {\r\n                if (targetTexture) {\r\n                    engine.bindFramebuffer(targetTexture, faceIndex, undefined, undefined, forceFullscreenViewport);\r\n                    pp._outputTexture = targetTexture;\r\n                } else {\r\n                    engine.restoreDefaultFramebuffer();\r\n                    pp._outputTexture = null;\r\n                }\r\n                engine._debugInsertMarker?.(`post process ${postProcesses[index].name} output`);\r\n            }\r\n\r\n            if (doNotPresent) {\r\n                break;\r\n            }\r\n\r\n            const effect = pp.apply();\r\n\r\n            if (effect) {\r\n                pp.onBeforeRenderObservable.notifyObservers(effect);\r\n\r\n                // VBOs\r\n                this._prepareBuffers();\r\n                engine.bindBuffers(this._vertexBuffers, this._indexBuffer, effect);\r\n\r\n                // Draw order\r\n                engine.drawElementsType(Constants.MATERIAL_TriangleFillMode, 0, 6);\r\n\r\n                pp.onAfterRenderObservable.notifyObservers(effect);\r\n            }\r\n        }\r\n\r\n        // Restore states\r\n        engine.setDepthBuffer(true);\r\n        engine.setDepthWrite(true);\r\n        engine.setAlphaMode(Constants.ALPHA_DISABLE);\r\n    }\r\n\r\n    /**\r\n     * Disposes of the post process manager.\r\n     */\r\n    public dispose(): void {\r\n        const buffer = this._vertexBuffers[VertexBuffer.PositionKind];\r\n        if (buffer) {\r\n            buffer.dispose();\r\n            this._vertexBuffers[VertexBuffer.PositionKind] = null;\r\n        }\r\n\r\n        if (this._indexBuffer) {\r\n            this._scene.getEngine()._releaseBuffer(this._indexBuffer);\r\n            this._indexBuffer = null;\r\n        }\r\n    }\r\n}\r\n", "/**\r\n * Defines an array and its length.\r\n * It can be helpful to group result from both Arrays and smart arrays in one structure.\r\n */\r\nexport interface ISmartArrayLike<T> {\r\n    /**\r\n     * The data of the array.\r\n     */\r\n    data: Array<T>;\r\n    /**\r\n     * The active length of the array.\r\n     */\r\n    length: number;\r\n}\r\n\r\n/**\r\n * Defines an GC Friendly array where the backfield array do not shrink to prevent over allocations.\r\n */\r\nexport class SmartArray<T> implements ISmartArrayLike<T> {\r\n    /**\r\n     * The full set of data from the array.\r\n     */\r\n    public data: Array<T>;\r\n\r\n    /**\r\n     * The active length of the array.\r\n     */\r\n    public length: number = 0;\r\n\r\n    protected _id: number;\r\n\r\n    /**\r\n     * Instantiates a Smart Array.\r\n     * @param capacity defines the default capacity of the array.\r\n     */\r\n    constructor(capacity: number) {\r\n        this.data = new Array(capacity);\r\n        this._id = SmartArray._GlobalId++;\r\n    }\r\n\r\n    /**\r\n     * Pushes a value at the end of the active data.\r\n     * @param value defines the object to push in the array.\r\n     */\r\n    public push(value: T): void {\r\n        this.data[this.length++] = value;\r\n\r\n        if (this.length > this.data.length) {\r\n            this.data.length *= 2;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Iterates over the active data and apply the lambda to them.\r\n     * @param func defines the action to apply on each value.\r\n     */\r\n    public forEach(func: (content: T) => void): void {\r\n        for (let index = 0; index < this.length; index++) {\r\n            func(this.data[index]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sorts the full sets of data.\r\n     * @param compareFn defines the comparison function to apply.\r\n     */\r\n    public sort(compareFn: (a: T, b: T) => number): void {\r\n        this.data.sort(compareFn);\r\n    }\r\n\r\n    /**\r\n     * Resets the active data to an empty array.\r\n     */\r\n    public reset(): void {\r\n        this.length = 0;\r\n    }\r\n\r\n    /**\r\n     * Releases all the data from the array as well as the array.\r\n     */\r\n    public dispose(): void {\r\n        this.reset();\r\n\r\n        if (this.data) {\r\n            this.data.length = 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Concats the active data with a given array.\r\n     * @param array defines the data to concatenate with.\r\n     */\r\n    public concat(array: any): void {\r\n        if (array.length === 0) {\r\n            return;\r\n        }\r\n        if (this.length + array.length > this.data.length) {\r\n            this.data.length = (this.length + array.length) * 2;\r\n        }\r\n\r\n        for (let index = 0; index < array.length; index++) {\r\n            this.data[this.length++] = (array.data || array)[index];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the position of a value in the active data.\r\n     * @param value defines the value to find the index for\r\n     * @returns the index if found in the active data otherwise -1\r\n     */\r\n    public indexOf(value: T): number {\r\n        const position = this.data.indexOf(value);\r\n\r\n        if (position >= this.length) {\r\n            return -1;\r\n        }\r\n\r\n        return position;\r\n    }\r\n\r\n    /**\r\n     * Returns whether an element is part of the active data.\r\n     * @param value defines the value to look for\r\n     * @returns true if found in the active data otherwise false\r\n     */\r\n    public contains(value: T): boolean {\r\n        return this.indexOf(value) !== -1;\r\n    }\r\n\r\n    // Statics\r\n    private static _GlobalId = 0;\r\n}\r\n\r\n/**\r\n * Defines an GC Friendly array where the backfield array do not shrink to prevent over allocations.\r\n * The data in this array can only be present once\r\n */\r\nexport class SmartArrayNoDuplicate<T> extends SmartArray<T> {\r\n    private _duplicateId = 0;\r\n\r\n    /**\r\n     * Pushes a value at the end of the active data.\r\n     * THIS DOES NOT PREVENT DUPPLICATE DATA\r\n     * @param value defines the object to push in the array.\r\n     */\r\n    public override push(value: T): void {\r\n        super.push(value);\r\n\r\n        if (!(<any>value).__smartArrayFlags) {\r\n            (<any>value).__smartArrayFlags = {};\r\n        }\r\n\r\n        (<any>value).__smartArrayFlags[this._id] = this._duplicateId;\r\n    }\r\n\r\n    /**\r\n     * Pushes a value at the end of the active data.\r\n     * If the data is already present, it won t be added again\r\n     * @param value defines the object to push in the array.\r\n     * @returns true if added false if it was already present\r\n     */\r\n    public pushNoDuplicate(value: T): boolean {\r\n        if ((<any>value).__smartArrayFlags && (<any>value).__smartArrayFlags[this._id] === this._duplicateId) {\r\n            return false;\r\n        }\r\n        this.push(value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Resets the active data to an empty array.\r\n     */\r\n    public override reset(): void {\r\n        super.reset();\r\n        this._duplicateId++;\r\n    }\r\n\r\n    /**\r\n     * Concats the active data with a given array.\r\n     * This ensures no duplicate will be present in the result.\r\n     * @param array defines the data to concatenate with.\r\n     */\r\n    public concatWithNoDuplicate(array: any): void {\r\n        if (array.length === 0) {\r\n            return;\r\n        }\r\n        if (this.length + array.length > this.data.length) {\r\n            this.data.length = (this.length + array.length) * 2;\r\n        }\r\n\r\n        for (let index = 0; index < array.length; index++) {\r\n            const item = (array.data || array)[index];\r\n            this.pushNoDuplicate(item);\r\n        }\r\n    }\r\n}\r\n", "import { SmartArray, SmartArrayNoDuplicate } from \"../Misc/smartArray\";\r\nimport type { SubMesh } from \"../Meshes/subMesh\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Nullable, DeepImmutable } from \"../types\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport type { IParticleSystem } from \"../Particles/IParticleSystem\";\r\nimport type { IEdgesRenderer } from \"./edgesRenderer\";\r\nimport type { ISpriteManager } from \"../Sprites/spriteManager\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport type { Material } from \"../Materials/material\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\n\r\n/**\r\n * This represents the object necessary to create a rendering group.\r\n * This is exclusively used and created by the rendering manager.\r\n * To modify the behavior, you use the available helpers in your scene or meshes.\r\n * @internal\r\n */\r\nexport class RenderingGroup {\r\n    private static _ZeroVector: DeepImmutable<Vector3> = Vector3.Zero();\r\n    private _scene: Scene;\r\n    private _opaqueSubMeshes = new SmartArray<SubMesh>(256);\r\n    private _transparentSubMeshes = new SmartArray<SubMesh>(256);\r\n    private _alphaTestSubMeshes = new SmartArray<SubMesh>(256);\r\n    private _depthOnlySubMeshes = new SmartArray<SubMesh>(256);\r\n    private _particleSystems = new SmartArray<IParticleSystem>(256);\r\n    private _spriteManagers = new SmartArray<ISpriteManager>(256);\r\n\r\n    private _opaqueSortCompareFn: Nullable<(a: SubMesh, b: SubMesh) => number>;\r\n    private _alphaTestSortCompareFn: Nullable<(a: SubMesh, b: SubMesh) => number>;\r\n    private _transparentSortCompareFn: (a: SubMesh, b: SubMesh) => number;\r\n\r\n    private _renderOpaque: (subMeshes: SmartArray<SubMesh>) => void;\r\n    private _renderAlphaTest: (subMeshes: SmartArray<SubMesh>) => void;\r\n    private _renderTransparent: (subMeshes: SmartArray<SubMesh>) => void;\r\n\r\n    /** @internal */\r\n    public _empty = true;\r\n\r\n    /** @internal */\r\n    public _edgesRenderers = new SmartArrayNoDuplicate<IEdgesRenderer>(16);\r\n\r\n    public onBeforeTransparentRendering: () => void;\r\n\r\n    /**\r\n     * Set the opaque sort comparison function.\r\n     * If null the sub meshes will be render in the order they were created\r\n     */\r\n    public set opaqueSortCompareFn(value: Nullable<(a: SubMesh, b: SubMesh) => number>) {\r\n        if (value) {\r\n            this._opaqueSortCompareFn = value;\r\n        } else {\r\n            this._opaqueSortCompareFn = RenderingGroup.PainterSortCompare;\r\n        }\r\n        this._renderOpaque = this._renderOpaqueSorted;\r\n    }\r\n\r\n    /**\r\n     * Set the alpha test sort comparison function.\r\n     * If null the sub meshes will be render in the order they were created\r\n     */\r\n    public set alphaTestSortCompareFn(value: Nullable<(a: SubMesh, b: SubMesh) => number>) {\r\n        if (value) {\r\n            this._alphaTestSortCompareFn = value;\r\n        } else {\r\n            this._alphaTestSortCompareFn = RenderingGroup.PainterSortCompare;\r\n        }\r\n        this._renderAlphaTest = this._renderAlphaTestSorted;\r\n    }\r\n\r\n    /**\r\n     * Set the transparent sort comparison function.\r\n     * If null the sub meshes will be render in the order they were created\r\n     */\r\n    public set transparentSortCompareFn(value: Nullable<(a: SubMesh, b: SubMesh) => number>) {\r\n        if (value) {\r\n            this._transparentSortCompareFn = value;\r\n        } else {\r\n            this._transparentSortCompareFn = RenderingGroup.defaultTransparentSortCompare;\r\n        }\r\n        this._renderTransparent = this._renderTransparentSorted;\r\n    }\r\n\r\n    /**\r\n     * Creates a new rendering group.\r\n     * @param index The rendering group index\r\n     * @param scene\r\n     * @param opaqueSortCompareFn The opaque sort comparison function. If null no order is applied\r\n     * @param alphaTestSortCompareFn The alpha test sort comparison function. If null no order is applied\r\n     * @param transparentSortCompareFn The transparent sort comparison function. If null back to front + alpha index sort is applied\r\n     */\r\n    constructor(\r\n        public index: number,\r\n        scene: Scene,\r\n        opaqueSortCompareFn: Nullable<(a: SubMesh, b: SubMesh) => number> = null,\r\n        alphaTestSortCompareFn: Nullable<(a: SubMesh, b: SubMesh) => number> = null,\r\n        transparentSortCompareFn: Nullable<(a: SubMesh, b: SubMesh) => number> = null\r\n    ) {\r\n        this._scene = scene;\r\n\r\n        this.opaqueSortCompareFn = opaqueSortCompareFn;\r\n        this.alphaTestSortCompareFn = alphaTestSortCompareFn;\r\n        this.transparentSortCompareFn = transparentSortCompareFn;\r\n    }\r\n\r\n    /**\r\n     * Render all the sub meshes contained in the group.\r\n     * @param customRenderFunction Used to override the default render behaviour of the group.\r\n     * @param renderSprites\r\n     * @param renderParticles\r\n     * @param activeMeshes\r\n     */\r\n    public render(\r\n        customRenderFunction: Nullable<\r\n            (\r\n                opaqueSubMeshes: SmartArray<SubMesh>,\r\n                transparentSubMeshes: SmartArray<SubMesh>,\r\n                alphaTestSubMeshes: SmartArray<SubMesh>,\r\n                depthOnlySubMeshes: SmartArray<SubMesh>\r\n            ) => void\r\n        >,\r\n        renderSprites: boolean,\r\n        renderParticles: boolean,\r\n        activeMeshes: Nullable<AbstractMesh[]>\r\n    ): void {\r\n        if (customRenderFunction) {\r\n            customRenderFunction(this._opaqueSubMeshes, this._alphaTestSubMeshes, this._transparentSubMeshes, this._depthOnlySubMeshes);\r\n            return;\r\n        }\r\n\r\n        const engine = this._scene.getEngine();\r\n\r\n        // Depth only\r\n        if (this._depthOnlySubMeshes.length !== 0) {\r\n            engine.setColorWrite(false);\r\n            this._renderAlphaTest(this._depthOnlySubMeshes);\r\n            engine.setColorWrite(true);\r\n        }\r\n\r\n        // Opaque\r\n        if (this._opaqueSubMeshes.length !== 0) {\r\n            this._renderOpaque(this._opaqueSubMeshes);\r\n        }\r\n\r\n        // Alpha test\r\n        if (this._alphaTestSubMeshes.length !== 0) {\r\n            this._renderAlphaTest(this._alphaTestSubMeshes);\r\n        }\r\n\r\n        const stencilState = engine.getStencilBuffer();\r\n        engine.setStencilBuffer(false);\r\n\r\n        // Sprites\r\n        if (renderSprites) {\r\n            this._renderSprites();\r\n        }\r\n\r\n        // Particles\r\n        if (renderParticles) {\r\n            this._renderParticles(activeMeshes);\r\n        }\r\n\r\n        if (this.onBeforeTransparentRendering) {\r\n            this.onBeforeTransparentRendering();\r\n        }\r\n\r\n        // Transparent\r\n        if (this._transparentSubMeshes.length !== 0 || this._scene.useOrderIndependentTransparency) {\r\n            engine.setStencilBuffer(stencilState);\r\n            if (this._scene.useOrderIndependentTransparency) {\r\n                const excludedMeshes = this._scene.depthPeelingRenderer!.render(this._transparentSubMeshes);\r\n                if (excludedMeshes.length) {\r\n                    // Render leftover meshes that could not be processed by depth peeling\r\n                    this._renderTransparent(excludedMeshes);\r\n                }\r\n            } else {\r\n                this._renderTransparent(this._transparentSubMeshes);\r\n            }\r\n            engine.setAlphaMode(Constants.ALPHA_DISABLE);\r\n        }\r\n\r\n        // Set back stencil to false in case it changes before the edge renderer.\r\n        engine.setStencilBuffer(false);\r\n\r\n        // Edges\r\n        if (this._edgesRenderers.length) {\r\n            for (let edgesRendererIndex = 0; edgesRendererIndex < this._edgesRenderers.length; edgesRendererIndex++) {\r\n                this._edgesRenderers.data[edgesRendererIndex].render();\r\n            }\r\n\r\n            engine.setAlphaMode(Constants.ALPHA_DISABLE);\r\n        }\r\n\r\n        // Restore Stencil state.\r\n        engine.setStencilBuffer(stencilState);\r\n    }\r\n\r\n    /**\r\n     * Renders the opaque submeshes in the order from the opaqueSortCompareFn.\r\n     * @param subMeshes The submeshes to render\r\n     */\r\n    private _renderOpaqueSorted(subMeshes: SmartArray<SubMesh>): void {\r\n        RenderingGroup._RenderSorted(subMeshes, this._opaqueSortCompareFn, this._scene.activeCamera, false);\r\n    }\r\n\r\n    /**\r\n     * Renders the opaque submeshes in the order from the alphatestSortCompareFn.\r\n     * @param subMeshes The submeshes to render\r\n     */\r\n    private _renderAlphaTestSorted(subMeshes: SmartArray<SubMesh>): void {\r\n        RenderingGroup._RenderSorted(subMeshes, this._alphaTestSortCompareFn, this._scene.activeCamera, false);\r\n    }\r\n\r\n    /**\r\n     * Renders the opaque submeshes in the order from the transparentSortCompareFn.\r\n     * @param subMeshes The submeshes to render\r\n     */\r\n    private _renderTransparentSorted(subMeshes: SmartArray<SubMesh>): void {\r\n        RenderingGroup._RenderSorted(subMeshes, this._transparentSortCompareFn, this._scene.activeCamera, true);\r\n    }\r\n\r\n    /**\r\n     * Renders the submeshes in a specified order.\r\n     * @param subMeshes The submeshes to sort before render\r\n     * @param sortCompareFn The comparison function use to sort\r\n     * @param camera The camera position use to preprocess the submeshes to help sorting\r\n     * @param transparent Specifies to activate blending if true\r\n     */\r\n    private static _RenderSorted(\r\n        subMeshes: SmartArray<SubMesh>,\r\n        sortCompareFn: Nullable<(a: SubMesh, b: SubMesh) => number>,\r\n        camera: Nullable<Camera>,\r\n        transparent: boolean\r\n    ): void {\r\n        let subIndex = 0;\r\n        let subMesh: SubMesh;\r\n        const cameraPosition = camera ? camera.globalPosition : RenderingGroup._ZeroVector;\r\n\r\n        if (transparent) {\r\n            for (; subIndex < subMeshes.length; subIndex++) {\r\n                subMesh = subMeshes.data[subIndex];\r\n                subMesh._alphaIndex = subMesh.getMesh().alphaIndex;\r\n                subMesh._distanceToCamera = Vector3.Distance(subMesh.getBoundingInfo().boundingSphere.centerWorld, cameraPosition);\r\n            }\r\n        }\r\n\r\n        const sortedArray = subMeshes.length === subMeshes.data.length ? subMeshes.data : subMeshes.data.slice(0, subMeshes.length);\r\n\r\n        if (sortCompareFn) {\r\n            sortedArray.sort(sortCompareFn);\r\n        }\r\n\r\n        const scene = sortedArray[0].getMesh().getScene();\r\n        for (subIndex = 0; subIndex < sortedArray.length; subIndex++) {\r\n            subMesh = sortedArray[subIndex];\r\n\r\n            if (scene._activeMeshesFrozenButKeepClipping && !subMesh.isInFrustum(scene._frustumPlanes)) {\r\n                continue;\r\n            }\r\n\r\n            if (transparent) {\r\n                const material = subMesh.getMaterial();\r\n\r\n                if (material && material.needDepthPrePass) {\r\n                    const engine = material.getScene().getEngine();\r\n                    engine.setColorWrite(false);\r\n                    engine.setAlphaMode(Constants.ALPHA_DISABLE);\r\n                    subMesh.render(false);\r\n                    engine.setColorWrite(true);\r\n                }\r\n            }\r\n\r\n            subMesh.render(transparent);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Build in function which can be applied to ensure meshes of a special queue (opaque, alpha test, transparent)\r\n     * are rendered back to front if in the same alpha index.\r\n     *\r\n     * @param a The first submesh\r\n     * @param b The second submesh\r\n     * @returns The result of the comparison\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public static defaultTransparentSortCompare(a: SubMesh, b: SubMesh): number {\r\n        // Alpha index first\r\n        if (a._alphaIndex > b._alphaIndex) {\r\n            return 1;\r\n        }\r\n        if (a._alphaIndex < b._alphaIndex) {\r\n            return -1;\r\n        }\r\n\r\n        // Then distance to camera\r\n        return RenderingGroup.backToFrontSortCompare(a, b);\r\n    }\r\n\r\n    /**\r\n     * Build in function which can be applied to ensure meshes of a special queue (opaque, alpha test, transparent)\r\n     * are rendered back to front.\r\n     *\r\n     * @param a The first submesh\r\n     * @param b The second submesh\r\n     * @returns The result of the comparison\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public static backToFrontSortCompare(a: SubMesh, b: SubMesh): number {\r\n        // Then distance to camera\r\n        if (a._distanceToCamera < b._distanceToCamera) {\r\n            return 1;\r\n        }\r\n        if (a._distanceToCamera > b._distanceToCamera) {\r\n            return -1;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Build in function which can be applied to ensure meshes of a special queue (opaque, alpha test, transparent)\r\n     * are rendered front to back (prevent overdraw).\r\n     *\r\n     * @param a The first submesh\r\n     * @param b The second submesh\r\n     * @returns The result of the comparison\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public static frontToBackSortCompare(a: SubMesh, b: SubMesh): number {\r\n        // Then distance to camera\r\n        if (a._distanceToCamera < b._distanceToCamera) {\r\n            return -1;\r\n        }\r\n        if (a._distanceToCamera > b._distanceToCamera) {\r\n            return 1;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Build in function which can be applied to ensure meshes of a special queue (opaque, alpha test, transparent)\r\n     * are grouped by material then geometry.\r\n     *\r\n     * @param a The first submesh\r\n     * @param b The second submesh\r\n     * @returns The result of the comparison\r\n     */\r\n    public static PainterSortCompare(a: SubMesh, b: SubMesh): number {\r\n        const meshA = a.getMesh();\r\n        const meshB = b.getMesh();\r\n\r\n        if (meshA.material && meshB.material) {\r\n            return meshA.material.uniqueId - meshB.material.uniqueId;\r\n        }\r\n\r\n        return meshA.uniqueId - meshB.uniqueId;\r\n    }\r\n\r\n    /**\r\n     * Resets the different lists of submeshes to prepare a new frame.\r\n     */\r\n    public prepare(): void {\r\n        this._opaqueSubMeshes.reset();\r\n        this._transparentSubMeshes.reset();\r\n        this._alphaTestSubMeshes.reset();\r\n        this._depthOnlySubMeshes.reset();\r\n        this._particleSystems.reset();\r\n        this.prepareSprites();\r\n        this._edgesRenderers.reset();\r\n        this._empty = true;\r\n    }\r\n\r\n    /**\r\n     * Resets the different lists of sprites to prepare a new frame.\r\n     */\r\n    public prepareSprites(): void {\r\n        this._spriteManagers.reset();\r\n    }\r\n\r\n    public dispose(): void {\r\n        this._opaqueSubMeshes.dispose();\r\n        this._transparentSubMeshes.dispose();\r\n        this._alphaTestSubMeshes.dispose();\r\n        this._depthOnlySubMeshes.dispose();\r\n        this._particleSystems.dispose();\r\n        this._spriteManagers.dispose();\r\n        this._edgesRenderers.dispose();\r\n    }\r\n\r\n    /**\r\n     * Inserts the submesh in its correct queue depending on its material.\r\n     * @param subMesh The submesh to dispatch\r\n     * @param [mesh] Optional reference to the submeshes's mesh. Provide if you have an exiting reference to improve performance.\r\n     * @param [material] Optional reference to the submeshes's material. Provide if you have an exiting reference to improve performance.\r\n     */\r\n    public dispatch(subMesh: SubMesh, mesh?: AbstractMesh, material?: Nullable<Material>): void {\r\n        // Get mesh and materials if not provided\r\n        if (mesh === undefined) {\r\n            mesh = subMesh.getMesh();\r\n        }\r\n        if (material === undefined) {\r\n            material = subMesh.getMaterial();\r\n        }\r\n\r\n        if (material === null || material === undefined) {\r\n            return;\r\n        }\r\n\r\n        if (material.needAlphaBlendingForMesh(mesh)) {\r\n            // Transparent\r\n            this._transparentSubMeshes.push(subMesh);\r\n        } else if (material.needAlphaTestingForMesh(mesh)) {\r\n            // Alpha test\r\n            if (material.needDepthPrePass) {\r\n                this._depthOnlySubMeshes.push(subMesh);\r\n            }\r\n\r\n            this._alphaTestSubMeshes.push(subMesh);\r\n        } else {\r\n            if (material.needDepthPrePass) {\r\n                this._depthOnlySubMeshes.push(subMesh);\r\n            }\r\n\r\n            this._opaqueSubMeshes.push(subMesh); // Opaque\r\n        }\r\n\r\n        mesh._renderingGroup = this;\r\n\r\n        if (mesh._edgesRenderer && mesh.isEnabled() && mesh.isVisible && mesh._edgesRenderer.isEnabled) {\r\n            this._edgesRenderers.pushNoDuplicate(mesh._edgesRenderer);\r\n        }\r\n\r\n        this._empty = false;\r\n    }\r\n\r\n    public dispatchSprites(spriteManager: ISpriteManager) {\r\n        this._spriteManagers.push(spriteManager);\r\n        this._empty = false;\r\n    }\r\n\r\n    public dispatchParticles(particleSystem: IParticleSystem) {\r\n        this._particleSystems.push(particleSystem);\r\n        this._empty = false;\r\n    }\r\n\r\n    private _renderParticles(activeMeshes: Nullable<AbstractMesh[]>): void {\r\n        if (this._particleSystems.length === 0) {\r\n            return;\r\n        }\r\n\r\n        // Particles\r\n        const activeCamera = this._scene.activeCamera;\r\n        this._scene.onBeforeParticlesRenderingObservable.notifyObservers(this._scene);\r\n        for (let particleIndex = 0; particleIndex < this._particleSystems.length; particleIndex++) {\r\n            const particleSystem = this._particleSystems.data[particleIndex];\r\n\r\n            if ((activeCamera && activeCamera.layerMask & particleSystem.layerMask) === 0) {\r\n                continue;\r\n            }\r\n\r\n            const emitter: any = particleSystem.emitter;\r\n            if (!emitter.position || !activeMeshes || activeMeshes.indexOf(emitter) !== -1) {\r\n                this._scene._activeParticles.addCount(particleSystem.render(), false);\r\n            }\r\n        }\r\n        this._scene.onAfterParticlesRenderingObservable.notifyObservers(this._scene);\r\n    }\r\n\r\n    private _renderSprites(): void {\r\n        if (!this._scene.spritesEnabled || this._spriteManagers.length === 0) {\r\n            return;\r\n        }\r\n\r\n        // Sprites\r\n        const activeCamera = this._scene.activeCamera;\r\n        this._scene.onBeforeSpritesRenderingObservable.notifyObservers(this._scene);\r\n        for (let id = 0; id < this._spriteManagers.length; id++) {\r\n            const spriteManager = this._spriteManagers.data[id];\r\n\r\n            if ((activeCamera && activeCamera.layerMask & spriteManager.layerMask) !== 0) {\r\n                spriteManager.render();\r\n            }\r\n        }\r\n        this._scene.onAfterSpritesRenderingObservable.notifyObservers(this._scene);\r\n    }\r\n}\r\n", "import type { Nullable } from \"../types\";\r\nimport type { SmartArray } from \"../Misc/smartArray\";\r\nimport type { ISpriteManager } from \"../Sprites/spriteManager\";\r\nimport type { IParticleSystem } from \"../Particles/IParticleSystem\";\r\nimport { RenderingGroup } from \"./renderingGroup\";\r\n\r\nimport type { Scene } from \"../scene\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Material } from \"../Materials/material\";\r\nimport type { SubMesh } from \"../Meshes/subMesh\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\n\r\n/**\r\n * Interface describing the different options available in the rendering manager\r\n * regarding Auto Clear between groups.\r\n */\r\nexport interface IRenderingManagerAutoClearSetup {\r\n    /**\r\n     * Defines whether or not autoclear is enable.\r\n     */\r\n    autoClear: boolean;\r\n    /**\r\n     * Defines whether or not to autoclear the depth buffer.\r\n     */\r\n    depth: boolean;\r\n    /**\r\n     * Defines whether or not to autoclear the stencil buffer.\r\n     */\r\n    stencil: boolean;\r\n}\r\n\r\n/**\r\n * This class is used by the onRenderingGroupObservable\r\n */\r\nexport class RenderingGroupInfo {\r\n    /**\r\n     * The Scene that being rendered\r\n     */\r\n    scene: Scene;\r\n\r\n    /**\r\n     * The camera currently used for the rendering pass\r\n     */\r\n    camera: Nullable<Camera>;\r\n\r\n    /**\r\n     * The ID of the renderingGroup being processed\r\n     */\r\n    renderingGroupId: number;\r\n\r\n    /**\r\n     * The rendering manager\r\n     */\r\n    renderingManager: RenderingManager;\r\n}\r\n\r\n/**\r\n * This is the manager responsible of all the rendering for meshes sprites and particles.\r\n * It is enable to manage the different groups as well as the different necessary sort functions.\r\n * This should not be used directly aside of the few static configurations\r\n */\r\nexport class RenderingManager {\r\n    /**\r\n     * The max id used for rendering groups (not included)\r\n     */\r\n    public static MAX_RENDERINGGROUPS = 4;\r\n\r\n    /**\r\n     * The min id used for rendering groups (included)\r\n     */\r\n    public static MIN_RENDERINGGROUPS = 0;\r\n\r\n    /**\r\n     * Used to globally prevent autoclearing scenes.\r\n     */\r\n    public static AUTOCLEAR = true;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _useSceneAutoClearSetup = false;\r\n\r\n    private _scene: Scene;\r\n    private _renderingGroups = new Array<RenderingGroup>();\r\n    private _depthStencilBufferAlreadyCleaned: boolean;\r\n\r\n    private _autoClearDepthStencil: { [id: number]: IRenderingManagerAutoClearSetup } = {};\r\n    private _customOpaqueSortCompareFn: { [id: number]: Nullable<(a: SubMesh, b: SubMesh) => number> } = {};\r\n    private _customAlphaTestSortCompareFn: { [id: number]: Nullable<(a: SubMesh, b: SubMesh) => number> } = {};\r\n    private _customTransparentSortCompareFn: { [id: number]: Nullable<(a: SubMesh, b: SubMesh) => number> } = {};\r\n    private _renderingGroupInfo: Nullable<RenderingGroupInfo> = new RenderingGroupInfo();\r\n\r\n    private _maintainStateBetweenFrames = false;\r\n    /**\r\n     * Gets or sets a boolean indicating that the manager will not reset between frames.\r\n     * This means that if a mesh becomes invisible or transparent it will not be visible until this boolean is set to false again.\r\n     * By default, the rendering manager will dispatch all active meshes per frame (moving them to the transparent, opaque or alpha testing lists).\r\n     * By turning this property on, you will accelerate the rendering by keeping all these lists unchanged between frames.\r\n     */\r\n    public get maintainStateBetweenFrames() {\r\n        return this._maintainStateBetweenFrames;\r\n    }\r\n\r\n    public set maintainStateBetweenFrames(value: boolean) {\r\n        if (value === this._maintainStateBetweenFrames) {\r\n            return;\r\n        }\r\n\r\n        this._maintainStateBetweenFrames = value;\r\n        if (!this._maintainStateBetweenFrames) {\r\n            this.restoreDispachedFlags();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Restore wasDispatched flags on the lists of elements to render.\r\n     */\r\n    public restoreDispachedFlags() {\r\n        for (const mesh of this._scene.meshes) {\r\n            if (mesh.subMeshes) {\r\n                for (const subMesh of mesh.subMeshes) {\r\n                    subMesh._wasDispatched = false;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (this._scene.spriteManagers) {\r\n            for (const spriteManager of this._scene.spriteManagers) {\r\n                spriteManager._wasDispatched = false;\r\n            }\r\n        }\r\n\r\n        for (const particleSystem of this._scene.particleSystems) {\r\n            particleSystem._wasDispatched = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Instantiates a new rendering group for a particular scene\r\n     * @param scene Defines the scene the groups belongs to\r\n     */\r\n    constructor(scene: Scene) {\r\n        this._scene = scene;\r\n\r\n        for (let i = RenderingManager.MIN_RENDERINGGROUPS; i < RenderingManager.MAX_RENDERINGGROUPS; i++) {\r\n            this._autoClearDepthStencil[i] = { autoClear: true, depth: true, stencil: true };\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @returns the rendering group with the specified id.\r\n     * @param id the id of the rendering group (0 by default)\r\n     */\r\n    public getRenderingGroup(id: number): RenderingGroup {\r\n        const renderingGroupId = id || 0;\r\n\r\n        this._prepareRenderingGroup(renderingGroupId);\r\n\r\n        return this._renderingGroups[renderingGroupId];\r\n    }\r\n\r\n    private _clearDepthStencilBuffer(depth = true, stencil = true): void {\r\n        if (this._depthStencilBufferAlreadyCleaned) {\r\n            return;\r\n        }\r\n\r\n        this._scene.getEngine().clear(null, false, depth, stencil);\r\n        this._depthStencilBufferAlreadyCleaned = true;\r\n    }\r\n\r\n    /**\r\n     * Renders the entire managed groups. This is used by the scene or the different render targets.\r\n     * @internal\r\n     */\r\n    public render(\r\n        customRenderFunction: Nullable<\r\n            (\r\n                opaqueSubMeshes: SmartArray<SubMesh>,\r\n                transparentSubMeshes: SmartArray<SubMesh>,\r\n                alphaTestSubMeshes: SmartArray<SubMesh>,\r\n                depthOnlySubMeshes: SmartArray<SubMesh>\r\n            ) => void\r\n        >,\r\n        activeMeshes: Nullable<AbstractMesh[]>,\r\n        renderParticles: boolean,\r\n        renderSprites: boolean\r\n    ): void {\r\n        // Update the observable context (not null as it only goes away on dispose)\r\n        const info = this._renderingGroupInfo!;\r\n        info.scene = this._scene;\r\n        info.camera = this._scene.activeCamera;\r\n        info.renderingManager = this;\r\n\r\n        // Dispatch sprites\r\n        if (this._scene.spriteManagers && renderSprites) {\r\n            for (let index = 0; index < this._scene.spriteManagers.length; index++) {\r\n                const manager = this._scene.spriteManagers[index];\r\n                this.dispatchSprites(manager);\r\n            }\r\n        }\r\n\r\n        // Render\r\n        for (let index = RenderingManager.MIN_RENDERINGGROUPS; index < RenderingManager.MAX_RENDERINGGROUPS; index++) {\r\n            this._depthStencilBufferAlreadyCleaned = index === RenderingManager.MIN_RENDERINGGROUPS;\r\n            const renderingGroup = this._renderingGroups[index];\r\n            if (!renderingGroup || renderingGroup._empty) {\r\n                continue;\r\n            }\r\n\r\n            const renderingGroupMask = 1 << index;\r\n            info.renderingGroupId = index;\r\n\r\n            // Before Observable\r\n            this._scene.onBeforeRenderingGroupObservable.notifyObservers(info, renderingGroupMask);\r\n\r\n            // Clear depth/stencil if needed\r\n            if (RenderingManager.AUTOCLEAR) {\r\n                const autoClear = this._useSceneAutoClearSetup ? this._scene.getAutoClearDepthStencilSetup(index) : this._autoClearDepthStencil[index];\r\n\r\n                if (autoClear && autoClear.autoClear) {\r\n                    this._clearDepthStencilBuffer(autoClear.depth, autoClear.stencil);\r\n                }\r\n            }\r\n\r\n            // Render\r\n            for (const step of this._scene._beforeRenderingGroupDrawStage) {\r\n                step.action(index);\r\n            }\r\n            renderingGroup.render(customRenderFunction, renderSprites, renderParticles, activeMeshes);\r\n            for (const step of this._scene._afterRenderingGroupDrawStage) {\r\n                step.action(index);\r\n            }\r\n\r\n            // After Observable\r\n            this._scene.onAfterRenderingGroupObservable.notifyObservers(info, renderingGroupMask);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Resets the different information of the group to prepare a new frame\r\n     * @internal\r\n     */\r\n    public reset(): void {\r\n        if (this.maintainStateBetweenFrames) {\r\n            return;\r\n        }\r\n\r\n        for (let index = RenderingManager.MIN_RENDERINGGROUPS; index < RenderingManager.MAX_RENDERINGGROUPS; index++) {\r\n            const renderingGroup = this._renderingGroups[index];\r\n            if (renderingGroup) {\r\n                renderingGroup.prepare();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Resets the sprites information of the group to prepare a new frame\r\n     * @internal\r\n     */\r\n    public resetSprites(): void {\r\n        if (this.maintainStateBetweenFrames) {\r\n            return;\r\n        }\r\n\r\n        for (let index = RenderingManager.MIN_RENDERINGGROUPS; index < RenderingManager.MAX_RENDERINGGROUPS; index++) {\r\n            const renderingGroup = this._renderingGroups[index];\r\n            if (renderingGroup) {\r\n                renderingGroup.prepareSprites();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Dispose and release the group and its associated resources.\r\n     * @internal\r\n     */\r\n    public dispose(): void {\r\n        this.freeRenderingGroups();\r\n        this._renderingGroups.length = 0;\r\n        this._renderingGroupInfo = null;\r\n    }\r\n\r\n    /**\r\n     * Clear the info related to rendering groups preventing retention points during dispose.\r\n     */\r\n    public freeRenderingGroups(): void {\r\n        for (let index = RenderingManager.MIN_RENDERINGGROUPS; index < RenderingManager.MAX_RENDERINGGROUPS; index++) {\r\n            const renderingGroup = this._renderingGroups[index];\r\n            if (renderingGroup) {\r\n                renderingGroup.dispose();\r\n            }\r\n        }\r\n    }\r\n\r\n    private _prepareRenderingGroup(renderingGroupId: number): void {\r\n        if (this._renderingGroups[renderingGroupId] === undefined) {\r\n            this._renderingGroups[renderingGroupId] = new RenderingGroup(\r\n                renderingGroupId,\r\n                this._scene,\r\n                this._customOpaqueSortCompareFn[renderingGroupId],\r\n                this._customAlphaTestSortCompareFn[renderingGroupId],\r\n                this._customTransparentSortCompareFn[renderingGroupId]\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add a sprite manager to the rendering manager in order to render it this frame.\r\n     * @param spriteManager Define the sprite manager to render\r\n     */\r\n    public dispatchSprites(spriteManager: ISpriteManager) {\r\n        if (this.maintainStateBetweenFrames && spriteManager._wasDispatched) {\r\n            return;\r\n        }\r\n        spriteManager._wasDispatched = true;\r\n        this.getRenderingGroup(spriteManager.renderingGroupId).dispatchSprites(spriteManager);\r\n    }\r\n\r\n    /**\r\n     * Add a particle system to the rendering manager in order to render it this frame.\r\n     * @param particleSystem Define the particle system to render\r\n     */\r\n    public dispatchParticles(particleSystem: IParticleSystem) {\r\n        if (this.maintainStateBetweenFrames && particleSystem._wasDispatched) {\r\n            return;\r\n        }\r\n        particleSystem._wasDispatched = true;\r\n        this.getRenderingGroup(particleSystem.renderingGroupId).dispatchParticles(particleSystem);\r\n    }\r\n\r\n    /**\r\n     * Add a submesh to the manager in order to render it this frame\r\n     * @param subMesh The submesh to dispatch\r\n     * @param mesh Optional reference to the submeshes's mesh. Provide if you have an exiting reference to improve performance.\r\n     * @param material Optional reference to the submeshes's material. Provide if you have an exiting reference to improve performance.\r\n     */\r\n    public dispatch(subMesh: SubMesh, mesh?: AbstractMesh, material?: Nullable<Material>): void {\r\n        if (mesh === undefined) {\r\n            mesh = subMesh.getMesh();\r\n        }\r\n        if (this.maintainStateBetweenFrames && subMesh._wasDispatched) {\r\n            return;\r\n        }\r\n        subMesh._wasDispatched = true;\r\n        this.getRenderingGroup(mesh.renderingGroupId).dispatch(subMesh, mesh, material);\r\n    }\r\n\r\n    /**\r\n     * Overrides the default sort function applied in the rendering group to prepare the meshes.\r\n     * This allowed control for front to back rendering or reversely depending of the special needs.\r\n     *\r\n     * @param renderingGroupId The rendering group id corresponding to its index\r\n     * @param opaqueSortCompareFn The opaque queue comparison function use to sort.\r\n     * @param alphaTestSortCompareFn The alpha test queue comparison function use to sort.\r\n     * @param transparentSortCompareFn The transparent queue comparison function use to sort.\r\n     */\r\n    public setRenderingOrder(\r\n        renderingGroupId: number,\r\n        opaqueSortCompareFn: Nullable<(a: SubMesh, b: SubMesh) => number> = null,\r\n        alphaTestSortCompareFn: Nullable<(a: SubMesh, b: SubMesh) => number> = null,\r\n        transparentSortCompareFn: Nullable<(a: SubMesh, b: SubMesh) => number> = null\r\n    ) {\r\n        this._customOpaqueSortCompareFn[renderingGroupId] = opaqueSortCompareFn;\r\n        this._customAlphaTestSortCompareFn[renderingGroupId] = alphaTestSortCompareFn;\r\n        this._customTransparentSortCompareFn[renderingGroupId] = transparentSortCompareFn;\r\n\r\n        if (this._renderingGroups[renderingGroupId]) {\r\n            const group = this._renderingGroups[renderingGroupId];\r\n            group.opaqueSortCompareFn = this._customOpaqueSortCompareFn[renderingGroupId];\r\n            group.alphaTestSortCompareFn = this._customAlphaTestSortCompareFn[renderingGroupId];\r\n            group.transparentSortCompareFn = this._customTransparentSortCompareFn[renderingGroupId];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Specifies whether or not the stencil and depth buffer are cleared between two rendering groups.\r\n     *\r\n     * @param renderingGroupId The rendering group id corresponding to its index\r\n     * @param autoClearDepthStencil Automatically clears depth and stencil between groups if true.\r\n     * @param depth Automatically clears depth between groups if true and autoClear is true.\r\n     * @param stencil Automatically clears stencil between groups if true and autoClear is true.\r\n     */\r\n    public setRenderingAutoClearDepthStencil(renderingGroupId: number, autoClearDepthStencil: boolean, depth = true, stencil = true): void {\r\n        this._autoClearDepthStencil[renderingGroupId] = {\r\n            autoClear: autoClearDepthStencil,\r\n            depth: depth,\r\n            stencil: stencil,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets the current auto clear configuration for one rendering group of the rendering\r\n     * manager.\r\n     * @param index the rendering group index to get the information for\r\n     * @returns The auto clear setup for the requested rendering group\r\n     */\r\n    public getAutoClearDepthStencilSetup(index: number): IRenderingManagerAutoClearSetup {\r\n        return this._autoClearDepthStencil[index];\r\n    }\r\n}\r\n", "// eslint-disable-next-line import/no-internal-modules\r\nimport type { SmartArray, Nullable, Immutable, Camera, Scene, AbstractMesh, SubMesh, Material, IParticleSystem } from \"core/index\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { RenderingManager } from \"../Rendering/renderingManager\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { _ObserveArray } from \"../Misc/arrayTools\";\r\n\r\n/**\r\n * Defines the options of the object renderer\r\n */\r\nexport interface ObjectRendererOptions {\r\n    /** The number of passes the renderer will support (1 by default) */\r\n    numPasses?: number;\r\n\r\n    /** True (default) to not change the aspect ratio of the scene in the RTT */\r\n    doNotChangeAspectRatio?: boolean;\r\n}\r\n\r\n/**\r\n * A class that renders objects to the currently bound render target.\r\n * This class only renders objects, and is not concerned with the output texture or post-processing.\r\n */\r\nexport class ObjectRenderer {\r\n    /**\r\n     * Objects will only be rendered once which can be useful to improve performance if everything in your render is static for instance.\r\n     */\r\n    public static readonly REFRESHRATE_RENDER_ONCE: number = 0;\r\n    /**\r\n     * Objects will be rendered every frame and is recommended for dynamic contents.\r\n     */\r\n    public static readonly REFRESHRATE_RENDER_ONEVERYFRAME: number = 1;\r\n    /**\r\n     * Objects will be rendered every 2 frames which could be enough if your dynamic objects are not\r\n     * the central point of your effect and can save a lot of performances.\r\n     */\r\n    public static readonly REFRESHRATE_RENDER_ONEVERYTWOFRAMES: number = 2;\r\n\r\n    /**\r\n     * Use this predicate to dynamically define the list of mesh you want to render.\r\n     * If set, the renderList property will be overwritten.\r\n     */\r\n    public renderListPredicate: (AbstractMesh: AbstractMesh) => boolean;\r\n\r\n    private _renderList: Nullable<Array<AbstractMesh>>;\r\n    private _unObserveRenderList: Nullable<() => void> = null;\r\n\r\n    /**\r\n     * Use this list to define the list of mesh you want to render.\r\n     */\r\n    public get renderList(): Nullable<Array<AbstractMesh>> {\r\n        return this._renderList;\r\n    }\r\n\r\n    public set renderList(value: Nullable<Array<AbstractMesh>>) {\r\n        if (this._renderList === value) {\r\n            return;\r\n        }\r\n        if (this._unObserveRenderList) {\r\n            this._unObserveRenderList();\r\n            this._unObserveRenderList = null;\r\n        }\r\n\r\n        if (value) {\r\n            this._unObserveRenderList = _ObserveArray(value, this._renderListHasChanged);\r\n        }\r\n\r\n        this._renderList = value;\r\n    }\r\n\r\n    private _renderListHasChanged = (_functionName: String, previousLength: number) => {\r\n        const newLength = this._renderList ? this._renderList.length : 0;\r\n        if ((previousLength === 0 && newLength > 0) || newLength === 0) {\r\n            this._scene.meshes.forEach((mesh) => {\r\n                mesh._markSubMeshesAsLightDirty();\r\n            });\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Define the list of particle systems to render. If not provided, will render all the particle systems of the scene.\r\n     * Note that the particle systems are rendered only if renderParticles is set to true.\r\n     */\r\n    public particleSystemList: Nullable<Array<IParticleSystem>> = null;\r\n\r\n    /**\r\n     * Use this function to overload the renderList array at rendering time.\r\n     * Return null to render with the current renderList, else return the list of meshes to use for rendering.\r\n     * For 2DArray, layerOrFace is the index of the layer that is going to be rendered, else it is the faceIndex of\r\n     * the cube (if the RTT is a cube, else layerOrFace=0).\r\n     * The renderList passed to the function is the current render list (the one that will be used if the function returns null).\r\n     * The length of this list is passed through renderListLength: don't use renderList.length directly because the array can\r\n     * hold dummy elements!\r\n     */\r\n    public getCustomRenderList: Nullable<(layerOrFace: number, renderList: Nullable<Immutable<Array<AbstractMesh>>>, renderListLength: number) => Nullable<Array<AbstractMesh>>> =\r\n        null;\r\n\r\n    /**\r\n     * Define if particles should be rendered.\r\n     */\r\n    public renderParticles = true;\r\n\r\n    /**\r\n     * Define if sprites should be rendered.\r\n     */\r\n    public renderSprites = false;\r\n\r\n    /**\r\n     * Force checking the layerMask property even if a custom list of meshes is provided (ie. if renderList is not undefined)\r\n     */\r\n    public forceLayerMaskCheck = false;\r\n\r\n    /**\r\n     * Define the camera used to render the objects.\r\n     */\r\n    public activeCamera: Nullable<Camera>;\r\n\r\n    /**\r\n     * Define the camera used to calculate the LOD of the objects.\r\n     * If not defined, activeCamera will be used. If not defined nor activeCamera, scene's active camera will be used.\r\n     */\r\n    public cameraForLOD: Nullable<Camera>;\r\n\r\n    /**\r\n     * Override the mesh isReady function with your own one.\r\n     */\r\n    public customIsReadyFunction: (mesh: AbstractMesh, refreshRate: number, preWarm?: boolean) => boolean;\r\n\r\n    /**\r\n     * Override the render function with your own one.\r\n     */\r\n    public customRenderFunction: (\r\n        opaqueSubMeshes: SmartArray<SubMesh>,\r\n        alphaTestSubMeshes: SmartArray<SubMesh>,\r\n        transparentSubMeshes: SmartArray<SubMesh>,\r\n        depthOnlySubMeshes: SmartArray<SubMesh>,\r\n        beforeTransparents?: () => void\r\n    ) => void;\r\n\r\n    /**\r\n     * An event triggered before rendering the objects\r\n     */\r\n    public readonly onBeforeRenderObservable = new Observable<number>();\r\n\r\n    /**\r\n     * An event triggered after rendering the objects\r\n     */\r\n    public readonly onAfterRenderObservable = new Observable<number>();\r\n\r\n    /**\r\n     * An event triggered before the rendering group is processed\r\n     */\r\n    public readonly onBeforeRenderingManagerRenderObservable = new Observable<number>();\r\n\r\n    /**\r\n     * An event triggered after the rendering group is processed\r\n     */\r\n    public readonly onAfterRenderingManagerRenderObservable = new Observable<number>();\r\n\r\n    /**\r\n     * An event triggered when fast path rendering is used\r\n     */\r\n    public readonly onFastPathRenderObservable = new Observable<number>();\r\n\r\n    protected _scene: Scene;\r\n    /** @internal */\r\n    public _renderingManager: RenderingManager;\r\n    /** @internal */\r\n    public _waitingRenderList?: string[];\r\n    protected _currentRefreshId = -1;\r\n    protected _refreshRate = 1;\r\n\r\n    /**\r\n     * The options used by the object renderer\r\n     */\r\n    public options: Required<ObjectRendererOptions>;\r\n\r\n    private _name: string;\r\n    /**\r\n     * Friendly name of the object renderer\r\n     */\r\n    public get name() {\r\n        return this._name;\r\n    }\r\n\r\n    public set name(value: string) {\r\n        if (this._name === value) {\r\n            return;\r\n        }\r\n\r\n        this._name = value;\r\n\r\n        if (!this._scene) {\r\n            return;\r\n        }\r\n\r\n        const engine = this._scene.getEngine();\r\n\r\n        for (let i = 0; i < this._renderPassIds.length; ++i) {\r\n            const renderPassId = this._renderPassIds[i];\r\n            engine._renderPassNames[renderPassId] = `${this._name}#${i}`;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Current render pass id. Note it can change over the rendering as there's a separate id for each face of a cube / each layer of an array layer!\r\n     */\r\n    public renderPassId: number;\r\n    private readonly _renderPassIds: number[];\r\n    /**\r\n     * Gets the render pass ids used by the object renderer.\r\n     */\r\n    public get renderPassIds(): readonly number[] {\r\n        return this._renderPassIds;\r\n    }\r\n\r\n    /**\r\n     * Gets the current value of the refreshId counter\r\n     */\r\n    public get currentRefreshId() {\r\n        return this._currentRefreshId;\r\n    }\r\n\r\n    /**\r\n     * Sets a specific material to be used to render a mesh/a list of meshes with this object renderer\r\n     * @param mesh mesh or array of meshes\r\n     * @param material material or array of materials to use for this render pass. If undefined is passed, no specific material will be used but the regular material instead (mesh.material). It's possible to provide an array of materials to use a different material for each rendering pass.\r\n     */\r\n    public setMaterialForRendering(mesh: AbstractMesh | AbstractMesh[], material?: Material | Material[]): void {\r\n        let meshes;\r\n        if (!Array.isArray(mesh)) {\r\n            meshes = [mesh];\r\n        } else {\r\n            meshes = mesh;\r\n        }\r\n        for (let j = 0; j < meshes.length; ++j) {\r\n            for (let i = 0; i < this.options.numPasses; ++i) {\r\n                meshes[j].setMaterialForRenderPass(this._renderPassIds[i], material !== undefined ? (Array.isArray(material) ? material[i] : material) : undefined);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Instantiates an object renderer.\r\n     * @param name The friendly name of the object renderer\r\n     * @param scene The scene the renderer belongs to\r\n     * @param options The options used to create the renderer (optional)\r\n     */\r\n    constructor(name: string, scene: Scene, options?: ObjectRendererOptions) {\r\n        this.name = name;\r\n        this._scene = scene;\r\n\r\n        this.renderList = [] as AbstractMesh[];\r\n        this._renderPassIds = [];\r\n\r\n        this.options = {\r\n            numPasses: 1,\r\n            doNotChangeAspectRatio: true,\r\n            ...options,\r\n        };\r\n\r\n        this._createRenderPassId();\r\n\r\n        this.renderPassId = this._renderPassIds[0];\r\n\r\n        // Rendering groups\r\n        this._renderingManager = new RenderingManager(scene);\r\n        this._renderingManager._useSceneAutoClearSetup = true;\r\n    }\r\n\r\n    private _releaseRenderPassId(): void {\r\n        const engine = this._scene.getEngine();\r\n        for (let i = 0; i < this.options.numPasses; ++i) {\r\n            engine.releaseRenderPassId(this._renderPassIds[i]);\r\n        }\r\n        this._renderPassIds.length = 0;\r\n    }\r\n\r\n    private _createRenderPassId(): void {\r\n        this._releaseRenderPassId();\r\n\r\n        const engine = this._scene.getEngine();\r\n\r\n        for (let i = 0; i < this.options.numPasses; ++i) {\r\n            this._renderPassIds[i] = engine.createRenderPassId(`${this.name}#${i}`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Resets the refresh counter of the renderer and start back from scratch.\r\n     * Could be useful to re-render if it is setup to render only once.\r\n     */\r\n    public resetRefreshCounter(): void {\r\n        this._currentRefreshId = -1;\r\n    }\r\n\r\n    /**\r\n     * Defines the refresh rate of the rendering or the rendering frequency.\r\n     * Use 0 to render just once, 1 to render on every frame, 2 to render every two frames and so on...\r\n     */\r\n    public get refreshRate(): number {\r\n        return this._refreshRate;\r\n    }\r\n    public set refreshRate(value: number) {\r\n        this._refreshRate = value;\r\n        this.resetRefreshCounter();\r\n    }\r\n\r\n    /**\r\n     * Indicates if the renderer should render the current frame.\r\n     * The output is based on the specified refresh rate.\r\n     * @returns true if the renderer should render the current frame\r\n     */\r\n    public shouldRender(): boolean {\r\n        if (this._currentRefreshId === -1) {\r\n            // At least render once\r\n            this._currentRefreshId = 1;\r\n            return true;\r\n        }\r\n\r\n        if (this.refreshRate === this._currentRefreshId) {\r\n            this._currentRefreshId = 1;\r\n            return true;\r\n        }\r\n\r\n        this._currentRefreshId++;\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * This function will check if the renderer is ready to render (textures are loaded, shaders are compiled)\r\n     * @param viewportWidth defines the width of the viewport\r\n     * @param viewportHeight defines the height of the viewport\r\n     * @returns true if all required resources are ready\r\n     */\r\n    public isReadyForRendering(viewportWidth: number, viewportHeight: number): boolean {\r\n        this.prepareRenderList();\r\n        this.initRender(viewportWidth, viewportHeight);\r\n\r\n        const isReady = this._checkReadiness();\r\n\r\n        this.finishRender();\r\n\r\n        return isReady;\r\n    }\r\n\r\n    /**\r\n     * Makes sure the list of meshes is ready to be rendered\r\n     * You should call this function before \"initRender\", but if you know the render list is ok, you may call \"initRender\" directly\r\n     */\r\n    public prepareRenderList(): void {\r\n        const scene = this._scene;\r\n\r\n        if (this._waitingRenderList) {\r\n            if (!this.renderListPredicate) {\r\n                this.renderList = [];\r\n                for (let index = 0; index < this._waitingRenderList.length; index++) {\r\n                    const id = this._waitingRenderList[index];\r\n                    const mesh = scene.getMeshById(id);\r\n                    if (mesh) {\r\n                        this.renderList.push(mesh);\r\n                    }\r\n                }\r\n            }\r\n            this._waitingRenderList = undefined;\r\n        }\r\n\r\n        // Is predicate defined?\r\n        if (this.renderListPredicate) {\r\n            if (this.renderList) {\r\n                this.renderList.length = 0; // Clear previous renderList\r\n            } else {\r\n                this.renderList = [];\r\n            }\r\n\r\n            const sceneMeshes = this._scene.meshes;\r\n\r\n            for (let index = 0; index < sceneMeshes.length; index++) {\r\n                const mesh = sceneMeshes[index];\r\n                if (this.renderListPredicate(mesh)) {\r\n                    this.renderList.push(mesh);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private _defaultRenderListPrepared: boolean;\r\n    private _currentSceneCamera: Nullable<Camera> = null;\r\n\r\n    /**\r\n     * This method makes sure everything is setup before \"render\" can be called\r\n     * @param viewportWidth Width of the viewport to render to\r\n     * @param viewportHeight Height of the viewport to render to\r\n     */\r\n    public initRender(viewportWidth: number, viewportHeight: number): void {\r\n        const engine = this._scene.getEngine();\r\n        const camera: Nullable<Camera> = this.activeCamera ?? this._scene.activeCamera;\r\n\r\n        this._currentSceneCamera = this._scene.activeCamera;\r\n\r\n        if (camera) {\r\n            if (camera !== this._scene.activeCamera) {\r\n                this._scene.setTransformMatrix(camera.getViewMatrix(), camera.getProjectionMatrix(true));\r\n                this._scene.activeCamera = camera;\r\n            }\r\n            engine.setViewport(camera.rigParent ? camera.rigParent.viewport : camera.viewport, viewportWidth, viewportHeight);\r\n        }\r\n\r\n        this._defaultRenderListPrepared = false;\r\n    }\r\n\r\n    /**\r\n     * This method must be called after the \"render\" call(s), to complete the rendering process.\r\n     */\r\n    public finishRender() {\r\n        const scene = this._scene;\r\n\r\n        scene.activeCamera = this._currentSceneCamera;\r\n        if (this._currentSceneCamera) {\r\n            if (this.activeCamera && this.activeCamera !== scene.activeCamera) {\r\n                scene.setTransformMatrix(this._currentSceneCamera.getViewMatrix(), this._currentSceneCamera.getProjectionMatrix(true));\r\n            }\r\n            scene.getEngine().setViewport(this._currentSceneCamera.viewport);\r\n        }\r\n\r\n        scene.resetCachedMaterial();\r\n    }\r\n\r\n    /**\r\n     * Renders all the objects (meshes, particles systems, sprites) to the currently bound render target texture.\r\n     * @param passIndex defines the pass index to use (default: 0)\r\n     * @param skipOnAfterRenderObservable defines a flag to skip raising the onAfterRenderObservable\r\n     */\r\n    public render(passIndex = 0, skipOnAfterRenderObservable = false): void {\r\n        const scene = this._scene;\r\n        const engine = scene.getEngine();\r\n\r\n        const currentRenderPassId = engine.currentRenderPassId;\r\n\r\n        engine.currentRenderPassId = this._renderPassIds[passIndex];\r\n\r\n        this.onBeforeRenderObservable.notifyObservers(passIndex);\r\n\r\n        const fastPath = engine.snapshotRendering && engine.snapshotRenderingMode === Constants.SNAPSHOTRENDERING_FAST;\r\n\r\n        if (!fastPath) {\r\n            // Get the list of meshes to render\r\n            let currentRenderList: Nullable<Array<AbstractMesh>> = null;\r\n            const defaultRenderList = this.renderList ? this.renderList : scene.getActiveMeshes().data;\r\n            const defaultRenderListLength = this.renderList ? this.renderList.length : scene.getActiveMeshes().length;\r\n\r\n            if (this.getCustomRenderList) {\r\n                currentRenderList = this.getCustomRenderList(passIndex, defaultRenderList, defaultRenderListLength);\r\n            }\r\n\r\n            if (!currentRenderList) {\r\n                // No custom render list provided, we prepare the rendering for the default list, but check\r\n                // first if we did not already performed the preparation before so as to avoid re-doing it several times\r\n                if (!this._defaultRenderListPrepared) {\r\n                    this._prepareRenderingManager(defaultRenderList, defaultRenderListLength, !this.renderList || this.forceLayerMaskCheck);\r\n                    this._defaultRenderListPrepared = true;\r\n                }\r\n                currentRenderList = defaultRenderList;\r\n            } else {\r\n                // Prepare the rendering for the custom render list provided\r\n                this._prepareRenderingManager(currentRenderList, currentRenderList.length, this.forceLayerMaskCheck);\r\n            }\r\n\r\n            this.onBeforeRenderingManagerRenderObservable.notifyObservers(passIndex);\r\n\r\n            this._renderingManager.render(this.customRenderFunction, currentRenderList, this.renderParticles, this.renderSprites);\r\n\r\n            this.onAfterRenderingManagerRenderObservable.notifyObservers(passIndex);\r\n        } else {\r\n            this.onFastPathRenderObservable.notifyObservers(passIndex);\r\n        }\r\n\r\n        if (!skipOnAfterRenderObservable) {\r\n            this.onAfterRenderObservable.notifyObservers(passIndex);\r\n        }\r\n\r\n        engine.currentRenderPassId = currentRenderPassId;\r\n    }\r\n\r\n    /** @internal */\r\n    public _checkReadiness(): boolean {\r\n        const scene = this._scene;\r\n        const engine = scene.getEngine();\r\n        const currentRenderPassId = engine.currentRenderPassId;\r\n\r\n        let returnValue = true;\r\n\r\n        if (!scene.getViewMatrix()) {\r\n            // We probably didn't execute scene.render() yet, so make sure we have a view/projection matrix setup for the scene\r\n            scene.updateTransformMatrix();\r\n        }\r\n\r\n        const numPasses = this.options.numPasses;\r\n        for (let passIndex = 0; passIndex < numPasses && returnValue; passIndex++) {\r\n            let currentRenderList: Nullable<Array<AbstractMesh>> = null;\r\n            const defaultRenderList = this.renderList ? this.renderList : scene.getActiveMeshes().data;\r\n            const defaultRenderListLength = this.renderList ? this.renderList.length : scene.getActiveMeshes().length;\r\n\r\n            engine.currentRenderPassId = this._renderPassIds[passIndex];\r\n\r\n            this.onBeforeRenderObservable.notifyObservers(passIndex);\r\n\r\n            if (this.getCustomRenderList) {\r\n                currentRenderList = this.getCustomRenderList(passIndex, defaultRenderList, defaultRenderListLength);\r\n            }\r\n\r\n            if (!currentRenderList) {\r\n                currentRenderList = defaultRenderList;\r\n            }\r\n\r\n            if (!this.options.doNotChangeAspectRatio) {\r\n                scene.updateTransformMatrix(true);\r\n            }\r\n\r\n            for (let i = 0; i < currentRenderList.length && returnValue; ++i) {\r\n                const mesh = currentRenderList[i];\r\n\r\n                if (!mesh.isEnabled() || mesh.isBlocked || !mesh.isVisible || !mesh.subMeshes) {\r\n                    continue;\r\n                }\r\n\r\n                if (this.customIsReadyFunction) {\r\n                    if (!this.customIsReadyFunction(mesh, this.refreshRate, true)) {\r\n                        returnValue = false;\r\n                        continue;\r\n                    }\r\n                } else if (!mesh.isReady(true)) {\r\n                    returnValue = false;\r\n                    continue;\r\n                }\r\n            }\r\n\r\n            this.onAfterRenderObservable.notifyObservers(passIndex);\r\n\r\n            if (numPasses > 1) {\r\n                scene.incrementRenderId();\r\n                scene.resetCachedMaterial();\r\n            }\r\n        }\r\n\r\n        const particleSystems = this.particleSystemList || scene.particleSystems;\r\n        for (const particleSystem of particleSystems) {\r\n            if (!particleSystem.isReady()) {\r\n                returnValue = false;\r\n            }\r\n        }\r\n\r\n        engine.currentRenderPassId = currentRenderPassId;\r\n\r\n        return returnValue;\r\n    }\r\n\r\n    private _prepareRenderingManager(currentRenderList: Array<AbstractMesh>, currentRenderListLength: number, checkLayerMask: boolean): void {\r\n        const scene = this._scene;\r\n        const camera = scene.activeCamera; // note that at this point, scene.activeCamera == this.activeCamera if defined, because initRender() has been called before\r\n        const cameraForLOD = this.cameraForLOD ?? camera;\r\n\r\n        this._renderingManager.reset();\r\n\r\n        const sceneRenderId = scene.getRenderId();\r\n        const currentFrameId = scene.getFrameId();\r\n        for (let meshIndex = 0; meshIndex < currentRenderListLength; meshIndex++) {\r\n            const mesh = currentRenderList[meshIndex];\r\n\r\n            if (mesh && !mesh.isBlocked) {\r\n                if (this.customIsReadyFunction) {\r\n                    if (!this.customIsReadyFunction(mesh, this.refreshRate, false)) {\r\n                        this.resetRefreshCounter();\r\n                        continue;\r\n                    }\r\n                } else if (!mesh.isReady(this.refreshRate === 0)) {\r\n                    this.resetRefreshCounter();\r\n                    continue;\r\n                }\r\n\r\n                let meshToRender: Nullable<AbstractMesh> = null;\r\n\r\n                if (cameraForLOD) {\r\n                    const meshToRenderAndFrameId = mesh._internalAbstractMeshDataInfo._currentLOD.get(cameraForLOD);\r\n                    if (!meshToRenderAndFrameId || meshToRenderAndFrameId[1] !== currentFrameId) {\r\n                        meshToRender = scene.customLODSelector ? scene.customLODSelector(mesh, cameraForLOD) : mesh.getLOD(cameraForLOD);\r\n                        if (!meshToRenderAndFrameId) {\r\n                            mesh._internalAbstractMeshDataInfo._currentLOD.set(cameraForLOD, [meshToRender, currentFrameId]);\r\n                        } else {\r\n                            meshToRenderAndFrameId[0] = meshToRender;\r\n                            meshToRenderAndFrameId[1] = currentFrameId;\r\n                        }\r\n                    } else {\r\n                        meshToRender = meshToRenderAndFrameId[0];\r\n                    }\r\n                } else {\r\n                    meshToRender = mesh;\r\n                }\r\n\r\n                if (!meshToRender) {\r\n                    continue;\r\n                }\r\n\r\n                if (meshToRender !== mesh && meshToRender.billboardMode !== 0) {\r\n                    meshToRender.computeWorldMatrix(); // Compute world matrix if LOD is billboard\r\n                }\r\n\r\n                meshToRender._preActivateForIntermediateRendering(sceneRenderId);\r\n\r\n                let isMasked;\r\n                if (checkLayerMask && camera) {\r\n                    isMasked = (mesh.layerMask & camera.layerMask) === 0;\r\n                } else {\r\n                    isMasked = false;\r\n                }\r\n\r\n                if (mesh.isEnabled() && mesh.isVisible && mesh.subMeshes && !isMasked) {\r\n                    if (meshToRender !== mesh) {\r\n                        meshToRender._activate(sceneRenderId, true);\r\n                    }\r\n                    if (mesh._activate(sceneRenderId, true) && mesh.subMeshes.length) {\r\n                        if (!mesh.isAnInstance) {\r\n                            meshToRender._internalAbstractMeshDataInfo._onlyForInstancesIntermediate = false;\r\n                        } else {\r\n                            if (mesh._internalAbstractMeshDataInfo._actAsRegularMesh) {\r\n                                meshToRender = mesh;\r\n                            }\r\n                        }\r\n                        meshToRender._internalAbstractMeshDataInfo._isActiveIntermediate = true;\r\n\r\n                        scene._prepareSkeleton(meshToRender);\r\n\r\n                        for (let subIndex = 0; subIndex < meshToRender.subMeshes.length; subIndex++) {\r\n                            const subMesh = meshToRender.subMeshes[subIndex];\r\n                            this._renderingManager.dispatch(subMesh, meshToRender);\r\n                        }\r\n                    }\r\n\r\n                    mesh._postActivate();\r\n                }\r\n            }\r\n        }\r\n\r\n        const particleSystems = this.particleSystemList || scene.particleSystems;\r\n        for (let particleIndex = 0; particleIndex < particleSystems.length; particleIndex++) {\r\n            const particleSystem = particleSystems[particleIndex];\r\n\r\n            const emitter: any = particleSystem.emitter;\r\n\r\n            if (!particleSystem.isStarted() || !emitter || (emitter.position && !emitter.isEnabled())) {\r\n                continue;\r\n            }\r\n\r\n            this._renderingManager.dispatchParticles(particleSystem);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Overrides the default sort function applied in the rendering group to prepare the meshes.\r\n     * This allowed control for front to back rendering or reversely depending of the special needs.\r\n     *\r\n     * @param renderingGroupId The rendering group id corresponding to its index\r\n     * @param opaqueSortCompareFn The opaque queue comparison function use to sort.\r\n     * @param alphaTestSortCompareFn The alpha test queue comparison function use to sort.\r\n     * @param transparentSortCompareFn The transparent queue comparison function use to sort.\r\n     */\r\n    public setRenderingOrder(\r\n        renderingGroupId: number,\r\n        opaqueSortCompareFn: Nullable<(a: SubMesh, b: SubMesh) => number> = null,\r\n        alphaTestSortCompareFn: Nullable<(a: SubMesh, b: SubMesh) => number> = null,\r\n        transparentSortCompareFn: Nullable<(a: SubMesh, b: SubMesh) => number> = null\r\n    ): void {\r\n        this._renderingManager.setRenderingOrder(renderingGroupId, opaqueSortCompareFn, alphaTestSortCompareFn, transparentSortCompareFn);\r\n    }\r\n\r\n    /**\r\n     * Specifies whether or not the stencil and depth buffer are cleared between two rendering groups.\r\n     *\r\n     * @param renderingGroupId The rendering group id corresponding to its index\r\n     * @param autoClearDepthStencil Automatically clears depth and stencil between groups if true.\r\n     * @param depth Automatically clears depth between groups if true and autoClear is true.\r\n     * @param stencil Automatically clears stencil between groups if true and autoClear is true.\r\n     */\r\n    public setRenderingAutoClearDepthStencil(renderingGroupId: number, autoClearDepthStencil: boolean, depth = true, stencil = true): void {\r\n        this._renderingManager.setRenderingAutoClearDepthStencil(renderingGroupId, autoClearDepthStencil, depth, stencil);\r\n        this._renderingManager._useSceneAutoClearSetup = false;\r\n    }\r\n\r\n    /**\r\n     * Clones the renderer.\r\n     * @returns the cloned renderer\r\n     */\r\n    public clone(): ObjectRenderer {\r\n        const newRenderer = new ObjectRenderer(this.name, this._scene, this.options);\r\n\r\n        if (this.renderList) {\r\n            newRenderer.renderList = this.renderList.slice(0);\r\n        }\r\n\r\n        return newRenderer;\r\n    }\r\n\r\n    /**\r\n     * Dispose the renderer and release its associated resources.\r\n     */\r\n    public dispose(): void {\r\n        const renderList = this.renderList ? this.renderList : this._scene.getActiveMeshes().data;\r\n        const renderListLength = this.renderList ? this.renderList.length : this._scene.getActiveMeshes().length;\r\n        for (let i = 0; i < renderListLength; i++) {\r\n            const mesh = renderList[i];\r\n            if (mesh.getMaterialForRenderPass(this.renderPassId) !== undefined) {\r\n                mesh.setMaterialForRenderPass(this.renderPassId, undefined);\r\n            }\r\n        }\r\n\r\n        this.onBeforeRenderObservable.clear();\r\n        this.onAfterRenderObservable.clear();\r\n        this.onBeforeRenderingManagerRenderObservable.clear();\r\n        this.onAfterRenderingManagerRenderObservable.clear();\r\n        this.onFastPathRenderObservable.clear();\r\n\r\n        this._releaseRenderPassId();\r\n\r\n        this.renderList = null;\r\n    }\r\n\r\n    /** @internal */\r\n    public _rebuild(): void {\r\n        if (this.refreshRate === ObjectRenderer.REFRESHRATE_RENDER_ONCE) {\r\n            this.refreshRate = ObjectRenderer.REFRESHRATE_RENDER_ONCE;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clear the info related to rendering groups preventing retention point in material dispose.\r\n     */\r\n    public freeRenderingGroups(): void {\r\n        if (this._renderingManager) {\r\n            this._renderingManager.freeRenderingGroups();\r\n        }\r\n    }\r\n}\r\n", "import type { Observer } from \"../../Misc/observable\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport type { SmartArray } from \"../../Misc/smartArray\";\r\nimport type { Nullable, Immutable } from \"../../types\";\r\nimport type { Camera } from \"../../Cameras/camera\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Matrix, Vector3 } from \"../../Maths/math.vector\";\r\nimport type { Color4 } from \"../../Maths/math.color\";\r\nimport type { RenderTargetCreationOptions, TextureSize } from \"../../Materials/Textures/textureCreationOptions\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { SubMesh } from \"../../Meshes/subMesh\";\r\nimport type { InternalTexture } from \"../../Materials/Textures/internalTexture\";\r\nimport { Texture } from \"../../Materials/Textures/texture\";\r\nimport { PostProcessManager } from \"../../PostProcesses/postProcessManager\";\r\nimport type { PostProcess } from \"../../PostProcesses/postProcess\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport type { IRenderTargetTexture, RenderTargetWrapper } from \"../../Engines/renderTargetWrapper\";\r\n\r\nimport type { Material } from \"../material\";\r\nimport { FloorPOT, NearestPOT } from \"../../Misc/tools.functions\";\r\nimport { Effect } from \"../effect\";\r\nimport type { AbstractEngine } from \"../../Engines/abstractEngine\";\r\nimport type { IParticleSystem } from \"core/Particles/IParticleSystem\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport { ObjectRenderer } from \"core/Rendering/objectRenderer\";\r\n\r\ndeclare module \"../effect\" {\r\n    export interface Effect {\r\n        /**\r\n         * Sets a depth stencil texture from a render target on the engine to be used in the shader.\r\n         * @param channel Name of the sampler variable.\r\n         * @param texture Texture to set.\r\n         */\r\n        setDepthStencilTexture(channel: string, texture: Nullable<RenderTargetTexture>): void;\r\n    }\r\n}\r\n\r\n/**\r\n * Sets a depth stencil texture from a render target on the engine to be used in the shader.\r\n * @param channel Name of the sampler variable.\r\n * @param texture Texture to set.\r\n */\r\nEffect.prototype.setDepthStencilTexture = function (channel: string, texture: Nullable<RenderTargetTexture>): void {\r\n    this._engine.setDepthStencilTexture(this._samplers[channel], this._uniforms[channel], texture, channel);\r\n};\r\n\r\n/**\r\n * Options for the RenderTargetTexture constructor\r\n */\r\nexport interface RenderTargetTextureOptions {\r\n    /** True (default: false) if mipmaps need to be generated after render */\r\n    generateMipMaps?: boolean;\r\n\r\n    /** True (default) to not change the aspect ratio of the scene in the RTT */\r\n    doNotChangeAspectRatio?: boolean;\r\n\r\n    /** The type of the buffer in the RTT (byte (default), half float, float...) */\r\n    type?: number;\r\n\r\n    /** True (default: false) if a cube texture needs to be created */\r\n    isCube?: boolean;\r\n\r\n    /** The sampling mode to be used with the render target (Trilinear (default), Linear, Nearest...) */\r\n    samplingMode?: number;\r\n\r\n    /** True (default) to generate a depth buffer */\r\n    generateDepthBuffer?: boolean;\r\n\r\n    /** True (default: false) to generate a stencil buffer */\r\n    generateStencilBuffer?: boolean;\r\n\r\n    /** True (default: false) if multiple textures need to be created (Draw Buffers) */\r\n    isMulti?: boolean;\r\n\r\n    /** The internal format of the buffer in the RTT (RED, RG, RGB, RGBA (default), ALPHA...) */\r\n    format?: number;\r\n\r\n    /** True (default: false) if the texture allocation should be delayed */\r\n    delayAllocation?: boolean;\r\n\r\n    /** Sample count to use when creating the RTT */\r\n    samples?: number;\r\n\r\n    /** specific flags to use when creating the texture (e.g., Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures) */\r\n    creationFlags?: number;\r\n\r\n    /** True (default: false) to indicate that no color target should be created. (e.g., if you only want to write to the depth buffer) */\r\n    noColorAttachment?: boolean;\r\n\r\n    /** Specifies the internal texture to use directly instead of creating one (ignores `noColorAttachment` flag when set) **/\r\n    colorAttachment?: InternalTexture;\r\n\r\n    /** True (default: false) to create a SRGB texture */\r\n    useSRGBBuffer?: boolean;\r\n\r\n    /** Defines the underlying texture texture space */\r\n    gammaSpace?: boolean;\r\n\r\n    /** If not provided (default), a new object renderer instance will be created */\r\n    existingObjectRenderer?: ObjectRenderer;\r\n}\r\n\r\n/**\r\n * This Helps creating a texture that will be created from a camera in your scene.\r\n * It is basically a dynamic texture that could be used to create special effects for instance.\r\n * Actually, It is the base of lot of effects in the framework like post process, shadows, effect layers and rendering pipelines...\r\n */\r\nexport class RenderTargetTexture extends Texture implements IRenderTargetTexture {\r\n    /**\r\n     * The texture will only be rendered once which can be useful to improve performance if everything in your render is static for instance.\r\n     */\r\n    public static readonly REFRESHRATE_RENDER_ONCE: number = ObjectRenderer.REFRESHRATE_RENDER_ONCE;\r\n    /**\r\n     * The texture will be rendered every frame and is recommended for dynamic contents.\r\n     */\r\n    public static readonly REFRESHRATE_RENDER_ONEVERYFRAME: number = ObjectRenderer.REFRESHRATE_RENDER_ONEVERYFRAME;\r\n    /**\r\n     * The texture will be rendered every 2 frames which could be enough if your dynamic objects are not\r\n     * the central point of your effect and can save a lot of performances.\r\n     */\r\n    public static readonly REFRESHRATE_RENDER_ONEVERYTWOFRAMES: number = ObjectRenderer.REFRESHRATE_RENDER_ONEVERYTWOFRAMES;\r\n\r\n    /**\r\n     * Use this predicate to dynamically define the list of mesh you want to render.\r\n     * If set, the renderList property will be overwritten.\r\n     */\r\n    public get renderListPredicate(): (AbstractMesh: AbstractMesh) => boolean {\r\n        return this._objectRenderer.renderListPredicate;\r\n    }\r\n\r\n    public set renderListPredicate(value: (AbstractMesh: AbstractMesh) => boolean) {\r\n        this._objectRenderer.renderListPredicate = value;\r\n    }\r\n\r\n    /**\r\n     * Use this list to define the list of mesh you want to render.\r\n     */\r\n    public get renderList(): Nullable<Array<AbstractMesh>> {\r\n        return this._objectRenderer.renderList;\r\n    }\r\n\r\n    public set renderList(value: Nullable<Array<AbstractMesh>>) {\r\n        this._objectRenderer.renderList = value;\r\n    }\r\n\r\n    /**\r\n     * Define the list of particle systems to render in the texture. If not provided, will render all the particle systems of the scene.\r\n     * Note that the particle systems are rendered only if renderParticles is set to true.\r\n     */\r\n    public get particleSystemList(): Nullable<Array<IParticleSystem>> {\r\n        return this._objectRenderer.particleSystemList;\r\n    }\r\n\r\n    public set particleSystemList(value: Nullable<Array<IParticleSystem>>) {\r\n        this._objectRenderer.particleSystemList = value;\r\n    }\r\n\r\n    /**\r\n     * Use this function to overload the renderList array at rendering time.\r\n     * Return null to render with the current renderList, else return the list of meshes to use for rendering.\r\n     * For 2DArray RTT, layerOrFace is the index of the layer that is going to be rendered, else it is the faceIndex of\r\n     * the cube (if the RTT is a cube, else layerOrFace=0).\r\n     * The renderList passed to the function is the current render list (the one that will be used if the function returns null).\r\n     * The length of this list is passed through renderListLength: don't use renderList.length directly because the array can\r\n     * hold dummy elements!\r\n     */\r\n    public get getCustomRenderList(): Nullable<\r\n        (layerOrFace: number, renderList: Nullable<Immutable<Array<AbstractMesh>>>, renderListLength: number) => Nullable<Array<AbstractMesh>>\r\n    > {\r\n        return this._objectRenderer.getCustomRenderList;\r\n    }\r\n\r\n    public set getCustomRenderList(\r\n        value: Nullable<(layerOrFace: number, renderList: Nullable<Immutable<Array<AbstractMesh>>>, renderListLength: number) => Nullable<Array<AbstractMesh>>>\r\n    ) {\r\n        this._objectRenderer.getCustomRenderList = value;\r\n    }\r\n\r\n    /**\r\n     * Define if particles should be rendered in your texture (default: true).\r\n     */\r\n    public get renderParticles() {\r\n        return this._objectRenderer.renderParticles;\r\n    }\r\n\r\n    public set renderParticles(value: boolean) {\r\n        this._objectRenderer.renderParticles = value;\r\n    }\r\n\r\n    /**\r\n     * Define if sprites should be rendered in your texture (default: false).\r\n     */\r\n    public get renderSprites() {\r\n        return this._objectRenderer.renderSprites;\r\n    }\r\n\r\n    public set renderSprites(value: boolean) {\r\n        this._objectRenderer.renderSprites = value;\r\n    }\r\n\r\n    /**\r\n     * Force checking the layerMask property even if a custom list of meshes is provided (ie. if renderList is not undefined) (default: false).\r\n     */\r\n    public get forceLayerMaskCheck() {\r\n        return this._objectRenderer.forceLayerMaskCheck;\r\n    }\r\n\r\n    public set forceLayerMaskCheck(value: boolean) {\r\n        this._objectRenderer.forceLayerMaskCheck = value;\r\n    }\r\n\r\n    /**\r\n     * Define the camera used to render the texture.\r\n     */\r\n    public get activeCamera(): Nullable<Camera> {\r\n        return this._objectRenderer.activeCamera;\r\n    }\r\n\r\n    public set activeCamera(value: Nullable<Camera>) {\r\n        this._objectRenderer.activeCamera = value;\r\n    }\r\n\r\n    /**\r\n     * Define the camera used to calculate the LOD of the objects.\r\n     * If not defined, activeCamera will be used. If not defined nor activeCamera, scene's active camera will be used.\r\n     */\r\n    public get cameraForLOD(): Nullable<Camera> {\r\n        return this._objectRenderer.cameraForLOD;\r\n    }\r\n\r\n    public set cameraForLOD(value: Nullable<Camera>) {\r\n        this._objectRenderer.cameraForLOD = value;\r\n    }\r\n\r\n    /**\r\n     * Override the mesh isReady function with your own one.\r\n     */\r\n    public get customIsReadyFunction(): (mesh: AbstractMesh, refreshRate: number, preWarm?: boolean) => boolean {\r\n        return this._objectRenderer.customIsReadyFunction;\r\n    }\r\n\r\n    public set customIsReadyFunction(value: (mesh: AbstractMesh, refreshRate: number, preWarm?: boolean) => boolean) {\r\n        this._objectRenderer.customIsReadyFunction = value;\r\n    }\r\n\r\n    /**\r\n     * Override the render function of the texture with your own one.\r\n     */\r\n    public get customRenderFunction(): (\r\n        opaqueSubMeshes: SmartArray<SubMesh>,\r\n        alphaTestSubMeshes: SmartArray<SubMesh>,\r\n        transparentSubMeshes: SmartArray<SubMesh>,\r\n        depthOnlySubMeshes: SmartArray<SubMesh>,\r\n        beforeTransparents?: () => void\r\n    ) => void {\r\n        return this._objectRenderer.customRenderFunction;\r\n    }\r\n\r\n    public set customRenderFunction(\r\n        value: (\r\n            opaqueSubMeshes: SmartArray<SubMesh>,\r\n            alphaTestSubMeshes: SmartArray<SubMesh>,\r\n            transparentSubMeshes: SmartArray<SubMesh>,\r\n            depthOnlySubMeshes: SmartArray<SubMesh>,\r\n            beforeTransparents?: () => void\r\n        ) => void\r\n    ) {\r\n        this._objectRenderer.customRenderFunction = value;\r\n    }\r\n\r\n    /**\r\n     * Define if camera post processes should be use while rendering the texture.\r\n     */\r\n    public useCameraPostProcesses: boolean;\r\n    /**\r\n     * Define if the camera viewport should be respected while rendering the texture or if the render should be done to the entire texture.\r\n     */\r\n    public ignoreCameraViewport: boolean = false;\r\n\r\n    private _postProcessManager: Nullable<PostProcessManager>;\r\n\r\n    /**\r\n     * Post-processes for this render target\r\n     */\r\n    public get postProcesses() {\r\n        return this._postProcesses;\r\n    }\r\n    private _postProcesses: PostProcess[];\r\n    private _resizeObserver: Nullable<Observer<AbstractEngine>>;\r\n\r\n    private get _prePassEnabled() {\r\n        return !!this._prePassRenderTarget && this._prePassRenderTarget.enabled;\r\n    }\r\n\r\n    /**\r\n     * An event triggered when the texture is unbind.\r\n     */\r\n    public onBeforeBindObservable = new Observable<RenderTargetTexture>();\r\n\r\n    /**\r\n     * An event triggered when the texture is unbind.\r\n     */\r\n    public onAfterUnbindObservable = new Observable<RenderTargetTexture>();\r\n\r\n    private _onAfterUnbindObserver: Nullable<Observer<RenderTargetTexture>>;\r\n    /**\r\n     * Set a after unbind callback in the texture.\r\n     * This has been kept for backward compatibility and use of onAfterUnbindObservable is recommended.\r\n     */\r\n    public set onAfterUnbind(callback: () => void) {\r\n        if (this._onAfterUnbindObserver) {\r\n            this.onAfterUnbindObservable.remove(this._onAfterUnbindObserver);\r\n        }\r\n        this._onAfterUnbindObserver = this.onAfterUnbindObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * An event triggered before rendering the texture\r\n     */\r\n    public get onBeforeRenderObservable() {\r\n        return this._objectRenderer.onBeforeRenderObservable;\r\n    }\r\n\r\n    private _onBeforeRenderObserver: Nullable<Observer<number>>;\r\n    /**\r\n     * Set a before render callback in the texture.\r\n     * This has been kept for backward compatibility and use of onBeforeRenderObservable is recommended.\r\n     */\r\n    public set onBeforeRender(callback: (faceIndex: number) => void) {\r\n        if (this._onBeforeRenderObserver) {\r\n            this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver);\r\n        }\r\n        this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * An event triggered after rendering the texture\r\n     */\r\n    public get onAfterRenderObservable() {\r\n        return this._objectRenderer.onAfterRenderObservable;\r\n    }\r\n\r\n    private _onAfterRenderObserver: Nullable<Observer<number>>;\r\n    /**\r\n     * Set a after render callback in the texture.\r\n     * This has been kept for backward compatibility and use of onAfterRenderObservable is recommended.\r\n     */\r\n    public set onAfterRender(callback: (faceIndex: number) => void) {\r\n        if (this._onAfterRenderObserver) {\r\n            this.onAfterRenderObservable.remove(this._onAfterRenderObserver);\r\n        }\r\n        this._onAfterRenderObserver = this.onAfterRenderObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * An event triggered after the texture clear\r\n     */\r\n    public onClearObservable = new Observable<AbstractEngine>();\r\n\r\n    private _onClearObserver: Nullable<Observer<AbstractEngine>>;\r\n    /**\r\n     * Set a clear callback in the texture.\r\n     * This has been kept for backward compatibility and use of onClearObservable is recommended.\r\n     */\r\n    public set onClear(callback: (Engine: AbstractEngine) => void) {\r\n        if (this._onClearObserver) {\r\n            this.onClearObservable.remove(this._onClearObserver);\r\n        }\r\n        this._onClearObserver = this.onClearObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * An event triggered when the texture is resized.\r\n     */\r\n    public onResizeObservable = new Observable<RenderTargetTexture>();\r\n\r\n    /**\r\n     * Define the clear color of the Render Target if it should be different from the scene.\r\n     */\r\n    public clearColor: Color4;\r\n    /** @internal */\r\n    public _size: TextureSize;\r\n    protected _initialSizeParameter: TextureSize | { ratio: number };\r\n    protected _sizeRatio: Nullable<number>;\r\n    /** @internal */\r\n    public _generateMipMaps: boolean;\r\n    /** @internal */\r\n    public _cleared = false;\r\n    /**\r\n     * Skip the initial clear of the rtt at the beginning of the frame render loop\r\n     */\r\n    public skipInitialClear = false;\r\n    /** @internal */\r\n    public get _waitingRenderList() {\r\n        return this._objectRenderer._waitingRenderList;\r\n    }\r\n\r\n    /** @internal */\r\n    public set _waitingRenderList(value: string[] | undefined) {\r\n        this._objectRenderer._waitingRenderList = value;\r\n    }\r\n\r\n    protected _objectRenderer: ObjectRenderer;\r\n    protected _doNotChangeAspectRatio: boolean;\r\n    protected _textureMatrix: Matrix;\r\n    protected _samples = 1;\r\n    protected _renderTargetOptions: RenderTargetCreationOptions;\r\n    private _canRescale = true;\r\n    protected _renderTarget: Nullable<RenderTargetWrapper> = null;\r\n    private _currentFaceIndex: number;\r\n    private _currentLayer: number;\r\n    private _currentUseCameraPostProcess: boolean;\r\n    private _currentDumpForDebug: boolean;\r\n    private _dontDisposeObjectRenderer = false;\r\n\r\n    /**\r\n     * Current render pass id of the render target texture. Note it can change over the rendering as there's a separate id for each face of a cube / each layer of an array layer!\r\n     */\r\n    public get renderPassId(): number {\r\n        return this._objectRenderer.renderPassId;\r\n    }\r\n\r\n    /**\r\n     * Gets the render pass ids used by the render target texture. For a single render target the array length will be 1, for a cube texture it will be 6 and for\r\n     * a 2D texture array it will return an array of ids the size of the 2D texture array\r\n     */\r\n    public get renderPassIds(): readonly number[] {\r\n        return this._objectRenderer.renderPassIds;\r\n    }\r\n\r\n    /**\r\n     * Gets the current value of the refreshId counter\r\n     */\r\n    public get currentRefreshId() {\r\n        return this._objectRenderer.currentRefreshId;\r\n    }\r\n\r\n    /**\r\n     * Sets a specific material to be used to render a mesh/a list of meshes in this render target texture\r\n     * @param mesh mesh or array of meshes\r\n     * @param material material or array of materials to use for this render pass. If undefined is passed, no specific material will be used but the regular material instead (mesh.material). It's possible to provide an array of materials to use a different material for each rendering in the case of a cube texture (6 rendering) and a 2D texture array (as many rendering as the length of the array)\r\n     */\r\n    public setMaterialForRendering(mesh: AbstractMesh | AbstractMesh[], material?: Material | Material[]): void {\r\n        this._objectRenderer.setMaterialForRendering(mesh, material);\r\n    }\r\n\r\n    /**\r\n     * Define if the texture has multiple draw buffers or if false a single draw buffer.\r\n     */\r\n    public get isMulti(): boolean {\r\n        return this._renderTarget?.isMulti ?? false;\r\n    }\r\n\r\n    /**\r\n     * Gets render target creation options that were used.\r\n     */\r\n    public get renderTargetOptions(): RenderTargetCreationOptions {\r\n        return this._renderTargetOptions;\r\n    }\r\n\r\n    /**\r\n     * Gets the render target wrapper associated with this render target\r\n     */\r\n    public get renderTarget(): Nullable<RenderTargetWrapper> {\r\n        return this._renderTarget;\r\n    }\r\n\r\n    protected _onRatioRescale(): void {\r\n        if (this._sizeRatio) {\r\n            this.resize(this._initialSizeParameter);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the center of the bounding box associated with the texture (when in cube mode)\r\n     * It must define where the camera used to render the texture is set\r\n     */\r\n    public boundingBoxPosition = Vector3.Zero();\r\n\r\n    private _boundingBoxSize: Vector3;\r\n\r\n    /**\r\n     * Gets or sets the size of the bounding box associated with the texture (when in cube mode)\r\n     * When defined, the cubemap will switch to local mode\r\n     * @see https://community.arm.com/graphics/b/blog/posts/reflections-based-on-local-cubemaps-in-unity\r\n     * @example https://www.babylonjs-playground.com/#RNASML\r\n     */\r\n    public set boundingBoxSize(value: Vector3) {\r\n        if (this._boundingBoxSize && this._boundingBoxSize.equals(value)) {\r\n            return;\r\n        }\r\n        this._boundingBoxSize = value;\r\n        const scene = this.getScene();\r\n        if (scene) {\r\n            scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n        }\r\n    }\r\n    public get boundingBoxSize(): Vector3 {\r\n        return this._boundingBoxSize;\r\n    }\r\n\r\n    /**\r\n     * In case the RTT has been created with a depth texture, get the associated\r\n     * depth texture.\r\n     * Otherwise, return null.\r\n     */\r\n    public get depthStencilTexture(): Nullable<InternalTexture> {\r\n        return this._renderTarget?._depthStencilTexture ?? null;\r\n    }\r\n\r\n    /** @internal */\r\n    public _disableEngineStages = false; // TODO: remove this when the shadow generator task (frame graph) is reworked (see https://github.com/BabylonJS/Babylon.js/pull/15962#discussion_r1874417607)\r\n\r\n    private readonly _onBeforeRenderingManagerRenderObserver: Nullable<Observer<number>>;\r\n    private readonly _onAfterRenderingManagerRenderObserver: Nullable<Observer<number>>;\r\n    private readonly _onFastPathRenderObserver: Nullable<Observer<number>>;\r\n\r\n    /**\r\n     * Instantiate a render target texture. This is mainly used to render of screen the scene to for instance apply post process\r\n     * or used a shadow, depth texture...\r\n     * @param name The friendly name of the texture\r\n     * @param size The size of the RTT (number if square, or {width: number, height:number} or {ratio:} to define a ratio from the main scene)\r\n     * @param scene The scene the RTT belongs to. Default is the last created scene.\r\n     * @param options The options for creating the render target texture.\r\n     */\r\n    constructor(name: string, size: TextureSize | { ratio: number }, scene?: Nullable<Scene>, options?: RenderTargetTextureOptions);\r\n\r\n    /**\r\n     * Instantiate a render target texture. This is mainly used to render of screen the scene to for instance apply post process\r\n     * or used a shadow, depth texture...\r\n     * @param name The friendly name of the texture\r\n     * @param size The size of the RTT (number if square, or {width: number, height:number} or {ratio:} to define a ratio from the main scene)\r\n     * @param scene The scene the RTT belongs to. Default is the last created scene\r\n     * @param generateMipMaps True (default: false) if mipmaps need to be generated after render\r\n     * @param doNotChangeAspectRatio True (default) to not change the aspect ratio of the scene in the RTT\r\n     * @param type The type of the buffer in the RTT (byte (default), half float, float...)\r\n     * @param isCube True (default: false) if a cube texture needs to be created\r\n     * @param samplingMode The sampling mode to be used with the render target (Trilinear (default), Linear, Nearest...)\r\n     * @param generateDepthBuffer True (default) to generate a depth buffer\r\n     * @param generateStencilBuffer True (default: false) to generate a stencil buffer\r\n     * @param isMulti True (default: false) if multiple textures need to be created (Draw Buffers)\r\n     * @param format The internal format of the buffer in the RTT (RED, RG, RGB, RGBA (default), ALPHA...)\r\n     * @param delayAllocation True (default: false) if the texture allocation should be delayed\r\n     * @param samples Sample count to use when creating the RTT\r\n     * @param creationFlags specific flags to use when creating the texture (e.g., Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures)\r\n     * @param noColorAttachment True (default: false) to indicate that no color target should be created. (e.g., if you only want to write to the depth buffer)\r\n     * @param useSRGBBuffer True (default: false) to create a SRGB texture\r\n     */\r\n    constructor(\r\n        name: string,\r\n        size: TextureSize | { ratio: number },\r\n        scene?: Nullable<Scene>,\r\n        generateMipMaps?: boolean,\r\n        doNotChangeAspectRatio?: boolean,\r\n        type?: number,\r\n        isCube?: boolean,\r\n        samplingMode?: number,\r\n        generateDepthBuffer?: boolean,\r\n        generateStencilBuffer?: boolean,\r\n        isMulti?: boolean,\r\n        format?: number,\r\n        delayAllocation?: boolean,\r\n        samples?: number,\r\n        creationFlags?: number,\r\n        noColorAttachment?: boolean,\r\n        useSRGBBuffer?: boolean\r\n    );\r\n\r\n    /** @internal */\r\n    constructor(\r\n        name: string,\r\n        size: TextureSize | { ratio: number },\r\n        scene?: Nullable<Scene>,\r\n        generateMipMaps: boolean | RenderTargetTextureOptions = false,\r\n        doNotChangeAspectRatio: boolean = true,\r\n        type: number = Constants.TEXTURETYPE_UNSIGNED_BYTE,\r\n        isCube = false,\r\n        samplingMode = Texture.TRILINEAR_SAMPLINGMODE,\r\n        generateDepthBuffer = true,\r\n        generateStencilBuffer = false,\r\n        isMulti = false,\r\n        format = Constants.TEXTUREFORMAT_RGBA,\r\n        delayAllocation = false,\r\n        samples?: number,\r\n        creationFlags?: number,\r\n        noColorAttachment = false,\r\n        useSRGBBuffer = false\r\n    ) {\r\n        let colorAttachment: InternalTexture | undefined = undefined;\r\n        let gammaSpace = true;\r\n        let existingObjectRenderer: ObjectRenderer | undefined = undefined;\r\n        if (typeof generateMipMaps === \"object\") {\r\n            const options = generateMipMaps;\r\n            generateMipMaps = !!options.generateMipMaps;\r\n            doNotChangeAspectRatio = options.doNotChangeAspectRatio ?? true;\r\n            type = options.type ?? Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n            isCube = !!options.isCube;\r\n            samplingMode = options.samplingMode ?? Texture.TRILINEAR_SAMPLINGMODE;\r\n            generateDepthBuffer = options.generateDepthBuffer ?? true;\r\n            generateStencilBuffer = !!options.generateStencilBuffer;\r\n            isMulti = !!options.isMulti;\r\n            format = options.format ?? Constants.TEXTUREFORMAT_RGBA;\r\n            delayAllocation = !!options.delayAllocation;\r\n            samples = options.samples;\r\n            creationFlags = options.creationFlags;\r\n            noColorAttachment = !!options.noColorAttachment;\r\n            useSRGBBuffer = !!options.useSRGBBuffer;\r\n            colorAttachment = options.colorAttachment;\r\n            gammaSpace = options.gammaSpace ?? gammaSpace;\r\n            existingObjectRenderer = options.existingObjectRenderer;\r\n        }\r\n\r\n        super(null, scene, !generateMipMaps, undefined, samplingMode, undefined, undefined, undefined, undefined, format);\r\n\r\n        scene = this.getScene();\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        const engine = this.getScene()!.getEngine();\r\n\r\n        this._gammaSpace = gammaSpace;\r\n        this._coordinatesMode = Texture.PROJECTION_MODE;\r\n        this.name = name;\r\n        this.isRenderTarget = true;\r\n        this._initialSizeParameter = size;\r\n        this._dontDisposeObjectRenderer = !!existingObjectRenderer;\r\n\r\n        this._processSizeParameter(size);\r\n\r\n        this._objectRenderer =\r\n            existingObjectRenderer ??\r\n            new ObjectRenderer(name, scene, {\r\n                numPasses: isCube ? 6 : this.getRenderLayers() || 1,\r\n                doNotChangeAspectRatio,\r\n            });\r\n\r\n        this._onBeforeRenderingManagerRenderObserver = this._objectRenderer.onBeforeRenderingManagerRenderObservable.add(() => {\r\n            // Before clear\r\n            if (!this._disableEngineStages) {\r\n                for (const step of this._scene!._beforeRenderTargetClearStage) {\r\n                    step.action(this, this._currentFaceIndex, this._currentLayer);\r\n                }\r\n            }\r\n\r\n            // Clear\r\n            if (this.onClearObservable.hasObservers()) {\r\n                this.onClearObservable.notifyObservers(engine);\r\n            } else if (!this.skipInitialClear) {\r\n                engine.clear(this.clearColor || this._scene!.clearColor, true, true, true);\r\n            }\r\n\r\n            if (!this._doNotChangeAspectRatio) {\r\n                this._scene!.updateTransformMatrix(true);\r\n            }\r\n\r\n            // Before Camera Draw\r\n            if (!this._disableEngineStages) {\r\n                for (const step of this._scene!._beforeRenderTargetDrawStage) {\r\n                    step.action(this, this._currentFaceIndex, this._currentLayer);\r\n                }\r\n            }\r\n        });\r\n\r\n        this._onAfterRenderingManagerRenderObserver = this._objectRenderer.onAfterRenderingManagerRenderObservable.add(() => {\r\n            // After Camera Draw\r\n            if (!this._disableEngineStages) {\r\n                for (const step of this._scene!._afterRenderTargetDrawStage) {\r\n                    step.action(this, this._currentFaceIndex, this._currentLayer);\r\n                }\r\n            }\r\n\r\n            const saveGenerateMipMaps = this._texture?.generateMipMaps ?? false;\r\n\r\n            if (this._texture) {\r\n                this._texture.generateMipMaps = false; // if left true, the mipmaps will be generated (if this._texture.generateMipMaps = true) when the first post process binds its own RTT: by doing so it will unbind the current RTT,\r\n                // which will trigger a mipmap generation. We don't want this because it's a wasted work, we will do an unbind of the current RTT at the end of the process (see unbindFrameBuffer) which will\r\n                // trigger the generation of the final mipmaps\r\n            }\r\n\r\n            if (this._postProcessManager) {\r\n                this._postProcessManager._finalizeFrame(false, this._renderTarget ?? undefined, this._currentFaceIndex, this._postProcesses, this.ignoreCameraViewport);\r\n            } else if (this._currentUseCameraPostProcess) {\r\n                this._scene!.postProcessManager._finalizeFrame(false, this._renderTarget ?? undefined, this._currentFaceIndex);\r\n            }\r\n\r\n            if (!this._disableEngineStages) {\r\n                for (const step of this._scene!._afterRenderTargetPostProcessStage) {\r\n                    step.action(this, this._currentFaceIndex, this._currentLayer);\r\n                }\r\n            }\r\n\r\n            if (this._texture) {\r\n                this._texture.generateMipMaps = saveGenerateMipMaps;\r\n            }\r\n\r\n            if (!this._doNotChangeAspectRatio) {\r\n                this._scene!.updateTransformMatrix(true);\r\n            }\r\n\r\n            // Dump ?\r\n            if (this._currentDumpForDebug) {\r\n                if (!this._dumpTools) {\r\n                    Logger.Error(\"dumpTools module is still being loaded. To speed up the process import dump tools directly in your project\");\r\n                } else {\r\n                    this._dumpTools.DumpFramebuffer(this.getRenderWidth(), this.getRenderHeight(), engine);\r\n                }\r\n            }\r\n        });\r\n\r\n        this._onFastPathRenderObserver = this._objectRenderer.onFastPathRenderObservable.add(() => {\r\n            if (this.onClearObservable.hasObservers()) {\r\n                this.onClearObservable.notifyObservers(engine);\r\n            } else {\r\n                if (!this.skipInitialClear) {\r\n                    engine.clear(this.clearColor || this._scene!.clearColor, true, true, true);\r\n                }\r\n            }\r\n        });\r\n\r\n        this._resizeObserver = engine.onResizeObservable.add(() => {});\r\n\r\n        this._generateMipMaps = generateMipMaps ? true : false;\r\n        this._doNotChangeAspectRatio = doNotChangeAspectRatio;\r\n\r\n        if (isMulti) {\r\n            return;\r\n        }\r\n\r\n        this._renderTargetOptions = {\r\n            generateMipMaps: generateMipMaps,\r\n            type: type,\r\n            format: this._format ?? undefined,\r\n            samplingMode: this.samplingMode,\r\n            generateDepthBuffer: generateDepthBuffer,\r\n            generateStencilBuffer: generateStencilBuffer,\r\n            samples,\r\n            creationFlags,\r\n            noColorAttachment: noColorAttachment,\r\n            useSRGBBuffer,\r\n            colorAttachment: colorAttachment,\r\n            label: this.name,\r\n        };\r\n\r\n        if (this.samplingMode === Texture.NEAREST_SAMPLINGMODE) {\r\n            this.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n            this.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n        }\r\n\r\n        if (!delayAllocation) {\r\n            if (isCube) {\r\n                this._renderTarget = scene.getEngine().createRenderTargetCubeTexture(this.getRenderSize(), this._renderTargetOptions);\r\n                this.coordinatesMode = Texture.INVCUBIC_MODE;\r\n                this._textureMatrix = Matrix.Identity();\r\n            } else {\r\n                this._renderTarget = scene.getEngine().createRenderTargetTexture(this._size, this._renderTargetOptions);\r\n            }\r\n            this._texture = this._renderTarget.texture;\r\n            if (samples !== undefined) {\r\n                this.samples = samples;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a depth stencil texture.\r\n     * This is only available in WebGL 2 or with the depth texture extension available.\r\n     * @param comparisonFunction Specifies the comparison function to set on the texture. If 0 or undefined, the texture is not in comparison mode (default: 0)\r\n     * @param bilinearFiltering Specifies whether or not bilinear filtering is enable on the texture (default: true)\r\n     * @param generateStencil Specifies whether or not a stencil should be allocated in the texture (default: false)\r\n     * @param samples sample count of the depth/stencil texture (default: 1)\r\n     * @param format format of the depth texture (default: Constants.TEXTUREFORMAT_DEPTH32_FLOAT)\r\n     * @param label defines the label of the texture (for debugging purpose)\r\n     */\r\n    public createDepthStencilTexture(\r\n        comparisonFunction: number = 0,\r\n        bilinearFiltering: boolean = true,\r\n        generateStencil: boolean = false,\r\n        samples: number = 1,\r\n        format: number = Constants.TEXTUREFORMAT_DEPTH32_FLOAT,\r\n        label?: string\r\n    ): void {\r\n        this._renderTarget?.createDepthStencilTexture(comparisonFunction, bilinearFiltering, generateStencil, samples, format, label);\r\n    }\r\n\r\n    protected _processSizeParameter(size: TextureSize | { ratio: number }): void {\r\n        if ((<{ ratio: number }>size).ratio) {\r\n            this._sizeRatio = (<{ ratio: number }>size).ratio;\r\n            const engine = this._getEngine()!;\r\n            this._size = {\r\n                width: this._bestReflectionRenderTargetDimension(engine.getRenderWidth(), this._sizeRatio),\r\n                height: this._bestReflectionRenderTargetDimension(engine.getRenderHeight(), this._sizeRatio),\r\n            };\r\n        } else {\r\n            this._size = <TextureSize>size;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Define the number of samples to use in case of MSAA.\r\n     * It defaults to one meaning no MSAA has been enabled.\r\n     */\r\n    public get samples(): number {\r\n        return this._renderTarget?.samples ?? this._samples;\r\n    }\r\n\r\n    public set samples(value: number) {\r\n        if (this._renderTarget) {\r\n            this._samples = this._renderTarget.setSamples(value);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds a post process to the render target rendering passes.\r\n     * @param postProcess define the post process to add\r\n     */\r\n    public addPostProcess(postProcess: PostProcess): void {\r\n        if (!this._postProcessManager) {\r\n            const scene = this.getScene();\r\n\r\n            if (!scene) {\r\n                return;\r\n            }\r\n            this._postProcessManager = new PostProcessManager(scene);\r\n            this._postProcesses = new Array<PostProcess>();\r\n        }\r\n\r\n        this._postProcesses.push(postProcess);\r\n        this._postProcesses[0].autoClear = false;\r\n    }\r\n\r\n    /**\r\n     * Clear all the post processes attached to the render target\r\n     * @param dispose define if the cleared post processes should also be disposed (false by default)\r\n     */\r\n    public clearPostProcesses(dispose: boolean = false): void {\r\n        if (!this._postProcesses) {\r\n            return;\r\n        }\r\n\r\n        if (dispose) {\r\n            for (const postProcess of this._postProcesses) {\r\n                postProcess.dispose();\r\n            }\r\n        }\r\n\r\n        this._postProcesses = [];\r\n    }\r\n\r\n    /**\r\n     * Remove one of the post process from the list of attached post processes to the texture\r\n     * @param postProcess define the post process to remove from the list\r\n     */\r\n    public removePostProcess(postProcess: PostProcess): void {\r\n        if (!this._postProcesses) {\r\n            return;\r\n        }\r\n\r\n        const index = this._postProcesses.indexOf(postProcess);\r\n\r\n        if (index === -1) {\r\n            return;\r\n        }\r\n\r\n        this._postProcesses.splice(index, 1);\r\n\r\n        if (this._postProcesses.length > 0) {\r\n            this._postProcesses[0].autoClear = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Resets the refresh counter of the texture and start bak from scratch.\r\n     * Could be useful to regenerate the texture if it is setup to render only once.\r\n     */\r\n    public resetRefreshCounter(): void {\r\n        this._objectRenderer.resetRefreshCounter();\r\n    }\r\n\r\n    /**\r\n     * Define the refresh rate of the texture or the rendering frequency.\r\n     * Use 0 to render just once, 1 to render on every frame, 2 to render every two frames and so on...\r\n     */\r\n    public get refreshRate(): number {\r\n        return this._objectRenderer.refreshRate;\r\n    }\r\n    public set refreshRate(value: number) {\r\n        this._objectRenderer.refreshRate = value;\r\n    }\r\n\r\n    /** @internal */\r\n    public _shouldRender(): boolean {\r\n        return this._objectRenderer.shouldRender();\r\n    }\r\n\r\n    /**\r\n     * Gets the actual render size of the texture.\r\n     * @returns the width of the render size\r\n     */\r\n    public getRenderSize(): number {\r\n        return this.getRenderWidth();\r\n    }\r\n\r\n    /**\r\n     * Gets the actual render width of the texture.\r\n     * @returns the width of the render size\r\n     */\r\n    public getRenderWidth(): number {\r\n        if ((<{ width: number; height: number }>this._size).width) {\r\n            return (<{ width: number; height: number }>this._size).width;\r\n        }\r\n\r\n        return <number>this._size;\r\n    }\r\n\r\n    /**\r\n     * Gets the actual render height of the texture.\r\n     * @returns the height of the render size\r\n     */\r\n    public getRenderHeight(): number {\r\n        if ((<{ width: number; height: number }>this._size).width) {\r\n            return (<{ width: number; height: number }>this._size).height;\r\n        }\r\n\r\n        return <number>this._size;\r\n    }\r\n\r\n    /**\r\n     * Gets the actual number of layers of the texture or, in the case of a 3D texture, return the depth.\r\n     * @returns the number of layers\r\n     */\r\n    public getRenderLayers(): number {\r\n        const layers = (<{ width: number; height: number; depth?: number; layers?: number }>this._size).layers;\r\n        if (layers) {\r\n            return layers;\r\n        }\r\n        const depth = (<{ width: number; height: number; depth?: number; layers?: number }>this._size).depth;\r\n        if (depth) {\r\n            return depth;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Don't allow this render target texture to rescale. Mainly used to prevent rescaling by the scene optimizer.\r\n     */\r\n    public disableRescaling() {\r\n        this._canRescale = false;\r\n    }\r\n\r\n    /**\r\n     * Get if the texture can be rescaled or not.\r\n     */\r\n    public override get canRescale(): boolean {\r\n        return this._canRescale;\r\n    }\r\n\r\n    /**\r\n     * Resize the texture using a ratio.\r\n     * @param ratio the ratio to apply to the texture size in order to compute the new target size\r\n     */\r\n    public override scale(ratio: number): void {\r\n        const newSize = Math.max(1, this.getRenderSize() * ratio);\r\n\r\n        this.resize(newSize);\r\n    }\r\n\r\n    /**\r\n     * Get the texture reflection matrix used to rotate/transform the reflection.\r\n     * @returns the reflection matrix\r\n     */\r\n    public override getReflectionTextureMatrix(): Matrix {\r\n        if (this.isCube) {\r\n            return this._textureMatrix;\r\n        }\r\n\r\n        return super.getReflectionTextureMatrix();\r\n    }\r\n\r\n    /**\r\n     * Resize the texture to a new desired size.\r\n     * Be careful as it will recreate all the data in the new texture.\r\n     * @param size Define the new size. It can be:\r\n     *   - a number for squared texture,\r\n     *   - an object containing { width: number, height: number }\r\n     *   - or an object containing a ratio { ratio: number }\r\n     */\r\n    public resize(size: TextureSize | { ratio: number }): void {\r\n        const wasCube = this.isCube;\r\n\r\n        this._renderTarget?.dispose();\r\n        this._renderTarget = null;\r\n\r\n        const scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        this._processSizeParameter(size);\r\n\r\n        if (wasCube) {\r\n            this._renderTarget = scene.getEngine().createRenderTargetCubeTexture(this.getRenderSize(), this._renderTargetOptions);\r\n        } else {\r\n            this._renderTarget = scene.getEngine().createRenderTargetTexture(this._size, this._renderTargetOptions);\r\n        }\r\n        this._texture = this._renderTarget.texture;\r\n\r\n        if (this._renderTargetOptions.samples !== undefined) {\r\n            this.samples = this._renderTargetOptions.samples;\r\n        }\r\n\r\n        if (this.onResizeObservable.hasObservers()) {\r\n            this.onResizeObservable.notifyObservers(this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Renders all the objects from the render list into the texture.\r\n     * @param useCameraPostProcess Define if camera post processes should be used during the rendering\r\n     * @param dumpForDebug Define if the rendering result should be dumped (copied) for debugging purpose\r\n     */\r\n    public render(useCameraPostProcess: boolean = false, dumpForDebug: boolean = false): void {\r\n        this._render(useCameraPostProcess, dumpForDebug);\r\n    }\r\n\r\n    private _dumpToolsLoading = false;\r\n    private _dumpTools: typeof import(\"../../Misc/dumpTools\");\r\n\r\n    /**\r\n     * This function will check if the render target texture can be rendered (textures are loaded, shaders are compiled)\r\n     * @returns true if all required resources are ready\r\n     */\r\n    public isReadyForRendering(): boolean {\r\n        if (!this._dumpToolsLoading) {\r\n            this._dumpToolsLoading = true;\r\n            // avoid a static import to allow ignoring the import in some cases\r\n            import(\"../../Misc/dumpTools\").then((module) => (this._dumpTools = module));\r\n        }\r\n\r\n        this._objectRenderer.prepareRenderList();\r\n\r\n        this.onBeforeBindObservable.notifyObservers(this);\r\n\r\n        this._objectRenderer.initRender(this.getRenderWidth(), this.getRenderHeight());\r\n\r\n        const isReady = this._objectRenderer._checkReadiness();\r\n\r\n        this.onAfterUnbindObservable.notifyObservers(this);\r\n\r\n        this._objectRenderer.finishRender();\r\n\r\n        return isReady;\r\n    }\r\n\r\n    private _render(useCameraPostProcess: boolean = false, dumpForDebug: boolean = false): void {\r\n        const scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        if (this.useCameraPostProcesses !== undefined) {\r\n            useCameraPostProcess = this.useCameraPostProcesses;\r\n        }\r\n\r\n        this._objectRenderer.prepareRenderList();\r\n\r\n        this.onBeforeBindObservable.notifyObservers(this);\r\n\r\n        this._objectRenderer.initRender(this.getRenderWidth(), this.getRenderHeight());\r\n\r\n        if ((this.is2DArray || this.is3D) && !this.isMulti) {\r\n            for (let layer = 0; layer < this.getRenderLayers(); layer++) {\r\n                this._renderToTarget(0, useCameraPostProcess, dumpForDebug, layer);\r\n                scene.incrementRenderId();\r\n                scene.resetCachedMaterial();\r\n            }\r\n        } else if (this.isCube && !this.isMulti) {\r\n            for (let face = 0; face < 6; face++) {\r\n                this._renderToTarget(face, useCameraPostProcess, dumpForDebug);\r\n                scene.incrementRenderId();\r\n                scene.resetCachedMaterial();\r\n            }\r\n        } else {\r\n            this._renderToTarget(0, useCameraPostProcess, dumpForDebug);\r\n        }\r\n\r\n        this.onAfterUnbindObservable.notifyObservers(this);\r\n\r\n        this._objectRenderer.finishRender();\r\n    }\r\n\r\n    private _bestReflectionRenderTargetDimension(renderDimension: number, scale: number): number {\r\n        const minimum = 128;\r\n        const x = renderDimension * scale;\r\n        const curved = NearestPOT(x + (minimum * minimum) / (minimum + x));\r\n\r\n        // Ensure we don't exceed the render dimension (while staying POT)\r\n        return Math.min(FloorPOT(renderDimension), curved);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * @param faceIndex face index to bind to if this is a cubetexture\r\n     * @param layer defines the index of the texture to bind in the array\r\n     */\r\n    public _bindFrameBuffer(faceIndex: number = 0, layer = 0) {\r\n        const scene = this.getScene();\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        const engine = scene.getEngine();\r\n        if (this._renderTarget) {\r\n            engine.bindFramebuffer(this._renderTarget, this.isCube ? faceIndex : undefined, undefined, undefined, this.ignoreCameraViewport, 0, layer);\r\n        }\r\n    }\r\n\r\n    protected _unbindFrameBuffer(engine: AbstractEngine, faceIndex: number): void {\r\n        if (!this._renderTarget) {\r\n            return;\r\n        }\r\n        engine.unBindFramebuffer(this._renderTarget, this.isCube, () => {\r\n            this.onAfterRenderObservable.notifyObservers(faceIndex);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _prepareFrame(scene: Scene, faceIndex?: number, layer?: number, useCameraPostProcess?: boolean) {\r\n        if (this._postProcessManager) {\r\n            if (!this._prePassEnabled) {\r\n                this._postProcessManager._prepareFrame(this._texture, this._postProcesses);\r\n            }\r\n        } else if (!useCameraPostProcess || !scene.postProcessManager._prepareFrame(this._texture)) {\r\n            this._bindFrameBuffer(faceIndex, layer);\r\n        }\r\n    }\r\n\r\n    private _renderToTarget(faceIndex: number, useCameraPostProcess: boolean, dumpForDebug: boolean, layer = 0): void {\r\n        const scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        const engine = scene.getEngine();\r\n\r\n        this._currentFaceIndex = faceIndex;\r\n        this._currentLayer = layer;\r\n        this._currentUseCameraPostProcess = useCameraPostProcess;\r\n        this._currentDumpForDebug = dumpForDebug;\r\n\r\n        this._prepareFrame(scene, faceIndex, layer, useCameraPostProcess);\r\n\r\n        engine._debugPushGroup?.(`render to face #${faceIndex} layer #${layer}`, 2);\r\n\r\n        this._objectRenderer.render(faceIndex + layer, true); // only faceIndex or layer (if any) will be different from 0 (we don't support array of cubes), so it's safe to add them to get the pass index\r\n\r\n        engine._debugPopGroup?.(2);\r\n\r\n        this._unbindFrameBuffer(engine, faceIndex);\r\n\r\n        if (this._texture && this.isCube && faceIndex === 5) {\r\n            engine.generateMipMapsForCubemap(this._texture, true);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Overrides the default sort function applied in the rendering group to prepare the meshes.\r\n     * This allowed control for front to back rendering or reversely depending of the special needs.\r\n     *\r\n     * @param renderingGroupId The rendering group id corresponding to its index\r\n     * @param opaqueSortCompareFn The opaque queue comparison function use to sort.\r\n     * @param alphaTestSortCompareFn The alpha test queue comparison function use to sort.\r\n     * @param transparentSortCompareFn The transparent queue comparison function use to sort.\r\n     */\r\n    public setRenderingOrder(\r\n        renderingGroupId: number,\r\n        opaqueSortCompareFn: Nullable<(a: SubMesh, b: SubMesh) => number> = null,\r\n        alphaTestSortCompareFn: Nullable<(a: SubMesh, b: SubMesh) => number> = null,\r\n        transparentSortCompareFn: Nullable<(a: SubMesh, b: SubMesh) => number> = null\r\n    ): void {\r\n        this._objectRenderer.setRenderingOrder(renderingGroupId, opaqueSortCompareFn, alphaTestSortCompareFn, transparentSortCompareFn);\r\n    }\r\n\r\n    /**\r\n     * Specifies whether or not the stencil and depth buffer are cleared between two rendering groups.\r\n     *\r\n     * @param renderingGroupId The rendering group id corresponding to its index\r\n     * @param autoClearDepthStencil Automatically clears depth and stencil between groups if true.\r\n     */\r\n    public setRenderingAutoClearDepthStencil(renderingGroupId: number, autoClearDepthStencil: boolean): void {\r\n        this._objectRenderer.setRenderingAutoClearDepthStencil(renderingGroupId, autoClearDepthStencil);\r\n    }\r\n\r\n    /**\r\n     * Clones the texture.\r\n     * @returns the cloned texture\r\n     */\r\n    public override clone(): RenderTargetTexture {\r\n        const textureSize = this.getSize();\r\n        const newTexture = new RenderTargetTexture(\r\n            this.name,\r\n            textureSize,\r\n            this.getScene(),\r\n            this._renderTargetOptions.generateMipMaps,\r\n            this._doNotChangeAspectRatio,\r\n            this._renderTargetOptions.type,\r\n            this.isCube,\r\n            this._renderTargetOptions.samplingMode,\r\n            this._renderTargetOptions.generateDepthBuffer,\r\n            this._renderTargetOptions.generateStencilBuffer,\r\n            undefined,\r\n            this._renderTargetOptions.format,\r\n            undefined,\r\n            this._renderTargetOptions.samples\r\n        );\r\n\r\n        // Base texture\r\n        newTexture.hasAlpha = this.hasAlpha;\r\n        newTexture.level = this.level;\r\n\r\n        // RenderTarget Texture\r\n        newTexture.coordinatesMode = this.coordinatesMode;\r\n        if (this.renderList) {\r\n            newTexture.renderList = this.renderList.slice(0);\r\n        }\r\n\r\n        return newTexture;\r\n    }\r\n\r\n    /**\r\n     * Serialize the texture to a JSON representation we can easily use in the respective Parse function.\r\n     * @returns The JSON representation of the texture\r\n     */\r\n    public override serialize(): any {\r\n        if (!this.name) {\r\n            return null;\r\n        }\r\n\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.renderTargetSize = this.getRenderSize();\r\n        serializationObject.renderList = [];\r\n\r\n        if (this.renderList) {\r\n            for (let index = 0; index < this.renderList.length; index++) {\r\n                serializationObject.renderList.push(this.renderList[index].id);\r\n            }\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     *  This will remove the attached framebuffer objects. The texture will not be able to be used as render target anymore\r\n     */\r\n    public disposeFramebufferObjects(): void {\r\n        this._renderTarget?.dispose(true);\r\n    }\r\n\r\n    /**\r\n     * Release and destroy the underlying lower level texture aka internalTexture.\r\n     */\r\n    public override releaseInternalTexture(): void {\r\n        this._renderTarget?.releaseTextures();\r\n        this._texture = null;\r\n    }\r\n\r\n    /**\r\n     * Dispose the texture and release its associated resources.\r\n     */\r\n    public override dispose(): void {\r\n        this.onResizeObservable.clear();\r\n        this.onClearObservable.clear();\r\n        this.onAfterUnbindObservable.clear();\r\n        this.onBeforeBindObservable.clear();\r\n\r\n        if (this._postProcessManager) {\r\n            this._postProcessManager.dispose();\r\n            this._postProcessManager = null;\r\n        }\r\n\r\n        if (this._prePassRenderTarget) {\r\n            this._prePassRenderTarget.dispose();\r\n        }\r\n\r\n        this._objectRenderer.onBeforeRenderingManagerRenderObservable.remove(this._onBeforeRenderingManagerRenderObserver);\r\n        this._objectRenderer.onAfterRenderingManagerRenderObservable.remove(this._onAfterRenderingManagerRenderObserver);\r\n        this._objectRenderer.onFastPathRenderObservable.remove(this._onFastPathRenderObserver);\r\n\r\n        if (!this._dontDisposeObjectRenderer) {\r\n            this._objectRenderer.dispose();\r\n        }\r\n\r\n        this.clearPostProcesses(true);\r\n\r\n        if (this._resizeObserver) {\r\n            this.getScene()!.getEngine().onResizeObservable.remove(this._resizeObserver);\r\n            this._resizeObserver = null;\r\n        }\r\n\r\n        // Remove from custom render targets\r\n        const scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        let index = scene.customRenderTargets.indexOf(this);\r\n\r\n        if (index >= 0) {\r\n            scene.customRenderTargets.splice(index, 1);\r\n        }\r\n\r\n        for (const camera of scene.cameras) {\r\n            index = camera.customRenderTargets.indexOf(this);\r\n\r\n            if (index >= 0) {\r\n                camera.customRenderTargets.splice(index, 1);\r\n            }\r\n        }\r\n\r\n        this._renderTarget?.dispose();\r\n        this._renderTarget = null;\r\n        this._texture = null;\r\n\r\n        super.dispose();\r\n    }\r\n\r\n    /** @internal */\r\n    public override _rebuild(): void {\r\n        this._objectRenderer._rebuild();\r\n\r\n        if (this._postProcessManager) {\r\n            this._postProcessManager._rebuild();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clear the info related to rendering groups preventing retention point in material dispose.\r\n     */\r\n    public freeRenderingGroups(): void {\r\n        this._objectRenderer.freeRenderingGroups();\r\n    }\r\n\r\n    /**\r\n     * Gets the number of views the corresponding to the texture (eg. a MultiviewRenderTarget will have > 1)\r\n     * @returns the view count\r\n     */\r\n    public getViewCount() {\r\n        return 1;\r\n    }\r\n}\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\r\nTexture._CreateRenderTargetTexture = (name: string, renderTargetSize: number, scene: Scene, generateMipMaps: boolean, creationFlags?: number) => {\r\n    return new RenderTargetTexture(name, renderTargetSize, scene, generateMipMaps);\r\n};\r\n", "import type { Nullable } from \"../types\";\r\nimport { SmartArray } from \"../Misc/smartArray\";\r\nimport type { Observer } from \"../Misc/observable\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { Vector2 } from \"../Maths/math.vector\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport { Effect } from \"../Materials/effect\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport type { RenderTargetCreationOptions } from \"../Materials/Textures/textureCreationOptions\";\r\nimport type { IInspectable } from \"../Misc/iInspectable\";\r\nimport type { Color4 } from \"../Maths/math.color\";\r\n\r\nimport type { NodeMaterial } from \"../Materials/Node/nodeMaterial\";\r\nimport { serialize, serializeAsColor4 } from \"../Misc/decorators\";\r\nimport { SerializationHelper } from \"../Misc/decorators.serialization\";\r\nimport { GetClass, RegisterClass } from \"../Misc/typeStore\";\r\nimport type { RenderTargetWrapper } from \"../Engines/renderTargetWrapper\";\r\nimport { ShaderLanguage } from \"../Materials/shaderLanguage\";\r\n\r\nimport type { Scene } from \"../scene\";\r\nimport type { InternalTexture } from \"../Materials/Textures/internalTexture\";\r\nimport type { Animation } from \"../Animations/animation\";\r\nimport type { PrePassRenderer } from \"../Rendering/prePassRenderer\";\r\nimport type { PrePassEffectConfiguration } from \"../Rendering/prePassEffectConfiguration\";\r\nimport { AbstractEngine } from \"../Engines/abstractEngine\";\r\nimport { GetExponentOfTwo } from \"../Misc/tools.functions\";\r\nimport type { IAssetContainer } from \"core/IAssetContainer\";\r\nimport type { EffectWrapperCustomShaderCodeProcessing, EffectWrapperCreationOptions } from \"../Materials/effectRenderer\";\r\nimport { EffectWrapper } from \"../Materials/effectRenderer\";\r\n\r\ndeclare module \"../Engines/abstractEngine\" {\r\n    export interface AbstractEngine {\r\n        /**\r\n         * Sets a texture to the context from a postprocess\r\n         * @param channel defines the channel to use\r\n         * @param postProcess defines the source postprocess\r\n         * @param name name of the channel\r\n         */\r\n        setTextureFromPostProcess(channel: number, postProcess: Nullable<PostProcess>, name: string): void;\r\n\r\n        /**\r\n         * Binds the output of the passed in post process to the texture channel specified\r\n         * @param channel The channel the texture should be bound to\r\n         * @param postProcess The post process which's output should be bound\r\n         * @param name name of the channel\r\n         */\r\n        setTextureFromPostProcessOutput(channel: number, postProcess: Nullable<PostProcess>, name: string): void;\r\n    }\r\n}\r\n\r\nAbstractEngine.prototype.setTextureFromPostProcess = function (channel: number, postProcess: Nullable<PostProcess>, name: string): void {\r\n    let postProcessInput = null;\r\n    if (postProcess) {\r\n        if (postProcess._forcedOutputTexture) {\r\n            postProcessInput = postProcess._forcedOutputTexture;\r\n        } else if (postProcess._textures.data[postProcess._currentRenderTextureInd]) {\r\n            postProcessInput = postProcess._textures.data[postProcess._currentRenderTextureInd];\r\n        }\r\n    }\r\n\r\n    this._bindTexture(channel, postProcessInput?.texture ?? null, name);\r\n};\r\n\r\nAbstractEngine.prototype.setTextureFromPostProcessOutput = function (channel: number, postProcess: Nullable<PostProcess>, name: string): void {\r\n    this._bindTexture(channel, postProcess?._outputTexture?.texture ?? null, name);\r\n};\r\n\r\ndeclare module \"../Materials/effect\" {\r\n    export interface Effect {\r\n        /**\r\n         * Sets a texture to be the input of the specified post process. (To use the output, pass in the next post process in the pipeline)\r\n         * @param channel Name of the sampler variable.\r\n         * @param postProcess Post process to get the input texture from.\r\n         */\r\n        setTextureFromPostProcess(channel: string, postProcess: Nullable<PostProcess>): void;\r\n\r\n        /**\r\n         * (Warning! setTextureFromPostProcessOutput may be desired instead)\r\n         * Sets the input texture of the passed in post process to be input of this effect. (To use the output of the passed in post process use setTextureFromPostProcessOutput)\r\n         * @param channel Name of the sampler variable.\r\n         * @param postProcess Post process to get the output texture from.\r\n         */\r\n        setTextureFromPostProcessOutput(channel: string, postProcess: Nullable<PostProcess>): void;\r\n    }\r\n}\r\n\r\n/**\r\n * Sets a texture to be the input of the specified post process. (To use the output, pass in the next post process in the pipeline)\r\n * @param channel Name of the sampler variable.\r\n * @param postProcess Post process to get the input texture from.\r\n */\r\nEffect.prototype.setTextureFromPostProcess = function (channel: string, postProcess: Nullable<PostProcess>): void {\r\n    this._engine.setTextureFromPostProcess(this._samplers[channel], postProcess, channel);\r\n};\r\n\r\n/**\r\n * (Warning! setTextureFromPostProcessOutput may be desired instead)\r\n * Sets the input texture of the passed in post process to be input of this effect. (To use the output of the passed in post process use setTextureFromPostProcessOutput)\r\n * @param channel Name of the sampler variable.\r\n * @param postProcess Post process to get the output texture from.\r\n */\r\nEffect.prototype.setTextureFromPostProcessOutput = function (channel: string, postProcess: Nullable<PostProcess>): void {\r\n    this._engine.setTextureFromPostProcessOutput(this._samplers[channel], postProcess, channel);\r\n};\r\n\r\n/**\r\n * Options for the PostProcess constructor\r\n */\r\nexport type PostProcessOptions = EffectWrapperCreationOptions & {\r\n    /**\r\n     * The width of the texture created for this post process.\r\n     * This parameter (and height) is only used when passing a value for the 5th parameter (options) to the PostProcess constructor function.\r\n     * If you use a PostProcessOptions for the 3rd parameter of the constructor, size is used instead of width and height.\r\n     */\r\n    width?: number;\r\n    /**\r\n     * The height of the texture created for this post process.\r\n     * This parameter (and width) is only used when passing a value for the 5th parameter (options) to the PostProcess constructor function.\r\n     * If you use a PostProcessOptions for the 3rd parameter of the constructor, size is used instead of width and height.\r\n     */\r\n    height?: number;\r\n\r\n    /**\r\n     * The size of the post process texture.\r\n     * It is either a ratio to downscale or upscale the texture create for this post process, or an object containing width and height values.\r\n     * Default: 1\r\n     */\r\n    size?: number | { width: number; height: number };\r\n    /**\r\n     * The camera that the post process will be attached to (default: null)\r\n     */\r\n    camera?: Nullable<Camera>;\r\n    /**\r\n     * The sampling mode to be used by the shader (default: Constants.TEXTURE_NEAREST_SAMPLINGMODE)\r\n     */\r\n    samplingMode?: number;\r\n    /**\r\n     * The engine to be used to render the post process (default: engine from scene)\r\n     */\r\n    engine?: AbstractEngine;\r\n    /**\r\n     * If the post process can be reused on the same frame. (default: false)\r\n     */\r\n    reusable?: boolean;\r\n    /**\r\n     * Type of the texture created for this post process (default: Constants.TEXTURETYPE_UNSIGNED_BYTE)\r\n     */\r\n    textureType?: number;\r\n    /**\r\n     * Format of the texture created for this post process (default: TEXTUREFORMAT_RGBA)\r\n     */\r\n    textureFormat?: number;\r\n    /**\r\n     * The effect wrapper instance used by the post process. If not provided, a new one will be created.\r\n     */\r\n    effectWrapper?: EffectWrapper;\r\n};\r\n\r\ntype TextureCache = { texture: RenderTargetWrapper; postProcessChannel: number; lastUsedRenderId: number };\r\n\r\n/**\r\n * PostProcess can be used to apply a shader to a texture after it has been rendered\r\n * See https://doc.babylonjs.com/features/featuresDeepDive/postProcesses/usePostProcesses\r\n */\r\nexport class PostProcess {\r\n    /**\r\n     * Force all the postprocesses to compile to glsl even on WebGPU engines.\r\n     * False by default. This is mostly meant for backward compatibility.\r\n     */\r\n    public static get ForceGLSL(): boolean {\r\n        return EffectWrapper.ForceGLSL;\r\n    }\r\n\r\n    public static set ForceGLSL(force: boolean) {\r\n        EffectWrapper.ForceGLSL = force;\r\n    }\r\n\r\n    /** @internal */\r\n    public _parentContainer: Nullable<IAssetContainer> = null;\r\n\r\n    /**\r\n     * Registers a shader code processing with a post process name.\r\n     * @param postProcessName name of the post process. Use null for the fallback shader code processing. This is the shader code processing that will be used in case no specific shader code processing has been associated to a post process name\r\n     * @param customShaderCodeProcessing shader code processing to associate to the post process name\r\n     */\r\n    public static RegisterShaderCodeProcessing(postProcessName: Nullable<string>, customShaderCodeProcessing?: EffectWrapperCustomShaderCodeProcessing) {\r\n        EffectWrapper.RegisterShaderCodeProcessing(postProcessName, customShaderCodeProcessing);\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the unique id of the post process\r\n     */\r\n    @serialize()\r\n    public uniqueId: number;\r\n\r\n    /** Name of the PostProcess. */\r\n    @serialize()\r\n    public get name() {\r\n        return this._effectWrapper.name;\r\n    }\r\n\r\n    public set name(value: string) {\r\n        this._effectWrapper.name = value;\r\n    }\r\n\r\n    /**\r\n     * Width of the texture to apply the post process on\r\n     */\r\n    @serialize()\r\n    public width = -1;\r\n\r\n    /**\r\n     * Height of the texture to apply the post process on\r\n     */\r\n    @serialize()\r\n    public height = -1;\r\n\r\n    /**\r\n     * Gets the node material used to create this postprocess (null if the postprocess was manually created)\r\n     */\r\n    public nodeMaterialSource: Nullable<NodeMaterial> = null;\r\n\r\n    /**\r\n     * Internal, reference to the location where this postprocess was output to. (Typically the texture on the next postprocess in the chain)\r\n     * @internal\r\n     */\r\n    public _outputTexture: Nullable<RenderTargetWrapper> = null;\r\n    /**\r\n     * Sampling mode used by the shader\r\n     */\r\n    @serialize()\r\n    public renderTargetSamplingMode: number;\r\n    /**\r\n     * Clear color to use when screen clearing\r\n     */\r\n    @serializeAsColor4()\r\n    public clearColor: Color4;\r\n    /**\r\n     * If the buffer needs to be cleared before applying the post process. (default: true)\r\n     * Should be set to false if shader will overwrite all previous pixels.\r\n     */\r\n    @serialize()\r\n    public autoClear = true;\r\n    /**\r\n     * If clearing the buffer should be forced in autoClear mode, even when alpha mode is enabled (default: false).\r\n     * By default, the buffer will only be cleared if alpha mode is disabled (and autoClear is true).\r\n     */\r\n    @serialize()\r\n    public forceAutoClearInAlphaMode = false;\r\n\r\n    /**\r\n     * Type of alpha mode to use when performing the post process (default: Engine.ALPHA_DISABLE)\r\n     */\r\n    @serialize()\r\n    public get alphaMode() {\r\n        return this._effectWrapper.alphaMode;\r\n    }\r\n\r\n    public set alphaMode(value: number) {\r\n        this._effectWrapper.alphaMode = value;\r\n    }\r\n\r\n    /**\r\n     * Sets the setAlphaBlendConstants of the babylon engine\r\n     */\r\n    @serialize()\r\n    public alphaConstants: Color4;\r\n\r\n    /**\r\n     * Animations to be used for the post processing\r\n     */\r\n    public animations: Animation[] = [];\r\n\r\n    /**\r\n     * Enable Pixel Perfect mode where texture is not scaled to be power of 2.\r\n     * Can only be used on a single postprocess or on the last one of a chain. (default: false)\r\n     */\r\n    @serialize()\r\n    public enablePixelPerfectMode = false;\r\n\r\n    /**\r\n     * Force the postprocess to be applied without taking in account viewport\r\n     */\r\n    @serialize()\r\n    public forceFullscreenViewport = true;\r\n\r\n    /**\r\n     * List of inspectable custom properties (used by the Inspector)\r\n     * @see https://doc.babylonjs.com/toolsAndResources/inspector#extensibility\r\n     */\r\n    public inspectableCustomProperties: IInspectable[];\r\n\r\n    /**\r\n     * Scale mode for the post process (default: Engine.SCALEMODE_FLOOR)\r\n     *\r\n     * | Value | Type                                | Description |\r\n     * | ----- | ----------------------------------- | ----------- |\r\n     * | 1     | SCALEMODE_FLOOR                     | [engine.scalemode_floor](https://doc.babylonjs.com/api/classes/babylon.engine#scalemode_floor) |\r\n     * | 2     | SCALEMODE_NEAREST                   | [engine.scalemode_nearest](https://doc.babylonjs.com/api/classes/babylon.engine#scalemode_nearest) |\r\n     * | 3     | SCALEMODE_CEILING                   | [engine.scalemode_ceiling](https://doc.babylonjs.com/api/classes/babylon.engine#scalemode_ceiling) |\r\n     *\r\n     */\r\n    @serialize()\r\n    public scaleMode = Constants.SCALEMODE_FLOOR;\r\n    /**\r\n     * Force textures to be a power of two (default: false)\r\n     */\r\n    @serialize()\r\n    public alwaysForcePOT = false;\r\n\r\n    @serialize(\"samples\")\r\n    private _samples = 1;\r\n\r\n    /**\r\n     * Number of sample textures (default: 1)\r\n     */\r\n    public get samples() {\r\n        return this._samples;\r\n    }\r\n\r\n    public set samples(n: number) {\r\n        this._samples = Math.min(n, this._engine.getCaps().maxMSAASamples);\r\n\r\n        this._textures.forEach((texture) => {\r\n            texture.setSamples(this._samples);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Modify the scale of the post process to be the same as the viewport (default: false)\r\n     */\r\n    @serialize()\r\n    public adaptScaleToCurrentViewport = false;\r\n\r\n    private _camera: Camera;\r\n    protected _scene: Scene;\r\n    private _engine: AbstractEngine;\r\n\r\n    protected _webGPUReady = false;\r\n\r\n    private _options: number | { width: number; height: number };\r\n    private _reusable = false;\r\n    private _renderId = 0;\r\n    private _textureType: number;\r\n    private _textureFormat: number;\r\n    /** @internal */\r\n    private _shaderLanguage: ShaderLanguage;\r\n\r\n    /**\r\n     * Gets the shader language type used to generate vertex and fragment source code.\r\n     */\r\n    public get shaderLanguage(): ShaderLanguage {\r\n        return this._shaderLanguage;\r\n    }\r\n\r\n    /**\r\n     * if externalTextureSamplerBinding is true, the \"apply\" method won't bind the textureSampler texture, it is expected to be done by the \"outside\" (by the onApplyObservable observer most probably).\r\n     * counter-productive in some cases because if the texture bound by \"apply\" is different from the currently texture bound, (the one set by the onApplyObservable observer, for eg) some\r\n     * internal structures (materialContext) will be dirtified, which may impact performances\r\n     */\r\n    public externalTextureSamplerBinding = false;\r\n\r\n    /**\r\n     * Smart array of input and output textures for the post process.\r\n     * @internal\r\n     */\r\n    public _textures = new SmartArray<RenderTargetWrapper>(2);\r\n    /**\r\n     * Smart array of input and output textures for the post process.\r\n     * @internal\r\n     */\r\n    private _textureCache: TextureCache[] = [];\r\n    /**\r\n     * The index in _textures that corresponds to the output texture.\r\n     * @internal\r\n     */\r\n    public _currentRenderTextureInd = 0;\r\n    private _samplers: string[];\r\n    private _fragmentUrl: string;\r\n    private _vertexUrl: string;\r\n    private _parameters: string[];\r\n    private _uniformBuffers: string[];\r\n    protected _postProcessDefines: Nullable<string>;\r\n    private _scaleRatio = new Vector2(1, 1);\r\n    protected _indexParameters: any;\r\n    private _shareOutputWithPostProcess: Nullable<PostProcess>;\r\n    private _texelSize = Vector2.Zero();\r\n\r\n    /** @internal */\r\n    public _forcedOutputTexture: Nullable<RenderTargetWrapper>;\r\n\r\n    /**\r\n     * Prepass configuration in case this post process needs a texture from prepass\r\n     * @internal\r\n     */\r\n    public _prePassEffectConfiguration: PrePassEffectConfiguration;\r\n\r\n    /**\r\n     * Returns the fragment url or shader name used in the post process.\r\n     * @returns the fragment url or name in the shader store.\r\n     */\r\n    public getEffectName(): string {\r\n        return this._fragmentUrl;\r\n    }\r\n\r\n    /**\r\n     * Executed when the effect was created\r\n     * @returns effect that was created for this post process\r\n     */\r\n    public onEffectCreatedObservable;\r\n\r\n    // Events\r\n\r\n    /**\r\n     * An event triggered when the postprocess is activated.\r\n     */\r\n    public onActivateObservable = new Observable<Camera>();\r\n\r\n    private _onActivateObserver: Nullable<Observer<Camera>>;\r\n    /**\r\n     * A function that is added to the onActivateObservable\r\n     */\r\n    public set onActivate(callback: Nullable<(camera: Camera) => void>) {\r\n        if (this._onActivateObserver) {\r\n            this.onActivateObservable.remove(this._onActivateObserver);\r\n        }\r\n        if (callback) {\r\n            this._onActivateObserver = this.onActivateObservable.add(callback);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * An event triggered when the postprocess changes its size.\r\n     */\r\n    public onSizeChangedObservable = new Observable<PostProcess>();\r\n\r\n    private _onSizeChangedObserver: Nullable<Observer<PostProcess>>;\r\n    /**\r\n     * A function that is added to the onSizeChangedObservable\r\n     */\r\n    public set onSizeChanged(callback: (postProcess: PostProcess) => void) {\r\n        if (this._onSizeChangedObserver) {\r\n            this.onSizeChangedObservable.remove(this._onSizeChangedObserver);\r\n        }\r\n        this._onSizeChangedObserver = this.onSizeChangedObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * An event triggered when the postprocess applies its effect.\r\n     */\r\n    public onApplyObservable = new Observable<Effect>();\r\n\r\n    private _onApplyObserver: Nullable<Observer<Effect>>;\r\n    /**\r\n     * A function that is added to the onApplyObservable\r\n     */\r\n    public set onApply(callback: (effect: Effect) => void) {\r\n        if (this._onApplyObserver) {\r\n            this.onApplyObservable.remove(this._onApplyObserver);\r\n        }\r\n        this._onApplyObserver = this.onApplyObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * An event triggered before rendering the postprocess\r\n     */\r\n    public onBeforeRenderObservable = new Observable<Effect>();\r\n\r\n    private _onBeforeRenderObserver: Nullable<Observer<Effect>>;\r\n    /**\r\n     * A function that is added to the onBeforeRenderObservable\r\n     */\r\n    public set onBeforeRender(callback: (effect: Effect) => void) {\r\n        if (this._onBeforeRenderObserver) {\r\n            this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver);\r\n        }\r\n        this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * An event triggered after rendering the postprocess\r\n     */\r\n    public onAfterRenderObservable = new Observable<Effect>();\r\n\r\n    private _onAfterRenderObserver: Nullable<Observer<Effect>>;\r\n    /**\r\n     * A function that is added to the onAfterRenderObservable\r\n     */\r\n    public set onAfterRender(callback: (efect: Effect) => void) {\r\n        if (this._onAfterRenderObserver) {\r\n            this.onAfterRenderObservable.remove(this._onAfterRenderObserver);\r\n        }\r\n        this._onAfterRenderObserver = this.onAfterRenderObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * The input texture for this post process and the output texture of the previous post process. When added to a pipeline the previous post process will\r\n     * render it's output into this texture and this texture will be used as textureSampler in the fragment shader of this post process.\r\n     */\r\n    public get inputTexture(): RenderTargetWrapper {\r\n        return this._textures.data[this._currentRenderTextureInd];\r\n    }\r\n\r\n    public set inputTexture(value: RenderTargetWrapper) {\r\n        this._forcedOutputTexture = value;\r\n    }\r\n\r\n    /**\r\n     * Since inputTexture should always be defined, if we previously manually set `inputTexture`,\r\n     * the only way to unset it is to use this function to restore its internal state\r\n     */\r\n    public restoreDefaultInputTexture() {\r\n        if (this._forcedOutputTexture) {\r\n            this._forcedOutputTexture = null;\r\n            this.markTextureDirty();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the camera which post process is applied to.\r\n     * @returns The camera the post process is applied to.\r\n     */\r\n    public getCamera(): Camera {\r\n        return this._camera;\r\n    }\r\n\r\n    /**\r\n     * Gets the texel size of the postprocess.\r\n     * See https://en.wikipedia.org/wiki/Texel_(graphics)\r\n     */\r\n    public get texelSize(): Vector2 {\r\n        if (this._shareOutputWithPostProcess) {\r\n            return this._shareOutputWithPostProcess.texelSize;\r\n        }\r\n\r\n        if (this._forcedOutputTexture) {\r\n            this._texelSize.copyFromFloats(1.0 / this._forcedOutputTexture.width, 1.0 / this._forcedOutputTexture.height);\r\n        }\r\n\r\n        return this._texelSize;\r\n    }\r\n\r\n    protected readonly _effectWrapper: EffectWrapper;\r\n\r\n    /**\r\n     * Creates a new instance PostProcess\r\n     * @param name The name of the PostProcess.\r\n     * @param fragmentUrl The url of the fragment shader to be used.\r\n     * @param options The options to be used when constructing the post process.\r\n     */\r\n    constructor(name: string, fragmentUrl: string, options?: PostProcessOptions);\r\n\r\n    /**\r\n     * Creates a new instance PostProcess\r\n     * @param name The name of the PostProcess.\r\n     * @param fragmentUrl The url of the fragment shader to be used.\r\n     * @param parameters Array of the names of uniform non-sampler2D variables that will be passed to the shader.\r\n     * @param samplers Array of the names of uniform sampler2D variables that will be passed to the shader.\r\n     * @param options The required width/height ratio to downsize to before computing the render pass. (Use 1.0 for full size)\r\n     * @param camera The camera to apply the render pass to.\r\n     * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\r\n     * @param engine The engine which the post process will be applied. (default: current engine)\r\n     * @param reusable If the post process can be reused on the same frame. (default: false)\r\n     * @param defines String of defines that will be set when running the fragment shader. (default: null)\r\n     * @param textureType Type of textures used when performing the post process. (default: 0)\r\n     * @param vertexUrl The url of the vertex shader to be used. (default: \"postprocess\")\r\n     * @param indexParameters The index parameters to be used for babylons include syntax \"#include<kernelBlurVaryingDeclaration>[0..varyingCount]\". (default: undefined) See usage in babylon.blurPostProcess.ts and kernelBlur.vertex.fx\r\n     * @param blockCompilation If the shader should not be compiled immediatly. (default: false)\r\n     * @param textureFormat Format of textures used when performing the post process. (default: TEXTUREFORMAT_RGBA)\r\n     * @param shaderLanguage The shader language of the shader. (default: GLSL)\r\n     * @param extraInitializations Defines additional code to call to prepare the shader code\r\n     */\r\n    constructor(\r\n        name: string,\r\n        fragmentUrl: string,\r\n        parameters: Nullable<string[]>,\r\n        samplers: Nullable<string[]>,\r\n        options: number | PostProcessOptions,\r\n        camera: Nullable<Camera>,\r\n        samplingMode?: number,\r\n        engine?: AbstractEngine,\r\n        reusable?: boolean,\r\n        defines?: Nullable<string>,\r\n        textureType?: number,\r\n        vertexUrl?: string,\r\n        indexParameters?: any,\r\n        blockCompilation?: boolean,\r\n        textureFormat?: number,\r\n        shaderLanguage?: ShaderLanguage,\r\n        extraInitializations?: (useWebGPU: boolean, list: Promise<any>[]) => void\r\n    );\r\n\r\n    /** @internal */\r\n    constructor(\r\n        name: string,\r\n        fragmentUrl: string,\r\n        parameters?: Nullable<string[]> | PostProcessOptions,\r\n        samplers?: Nullable<string[]>,\r\n        _size?: number | PostProcessOptions,\r\n        camera?: Nullable<Camera>,\r\n        samplingMode: number = Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n        engine?: AbstractEngine,\r\n        reusable?: boolean,\r\n        defines: Nullable<string> = null,\r\n        textureType: number = Constants.TEXTURETYPE_UNSIGNED_BYTE,\r\n        vertexUrl: string = \"postprocess\",\r\n        indexParameters?: any,\r\n        blockCompilation = false,\r\n        textureFormat = Constants.TEXTUREFORMAT_RGBA,\r\n        shaderLanguage?: ShaderLanguage,\r\n        extraInitializations?: (useWebGPU: boolean, list: Promise<any>[]) => void\r\n    ) {\r\n        let size: number | { width: number; height: number } = 1;\r\n        let uniformBuffers: Nullable<string[]> = null;\r\n        let effectWrapper: EffectWrapper | undefined;\r\n        if (parameters && !Array.isArray(parameters)) {\r\n            const options = parameters;\r\n            parameters = options.uniforms ?? null;\r\n            samplers = options.samplers ?? null;\r\n            size = options.size ?? 1;\r\n            camera = options.camera ?? null;\r\n            samplingMode = options.samplingMode ?? Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n            engine = options.engine;\r\n            reusable = options.reusable;\r\n            defines = Array.isArray(options.defines) ? options.defines.join(\"\\n\") : (options.defines ?? null);\r\n            textureType = options.textureType ?? Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n            vertexUrl = options.vertexUrl ?? \"postprocess\";\r\n            indexParameters = options.indexParameters;\r\n            blockCompilation = options.blockCompilation ?? false;\r\n            textureFormat = options.textureFormat ?? Constants.TEXTUREFORMAT_RGBA;\r\n            shaderLanguage = options.shaderLanguage ?? ShaderLanguage.GLSL;\r\n            uniformBuffers = options.uniformBuffers ?? null;\r\n            extraInitializations = options.extraInitializations;\r\n            effectWrapper = options.effectWrapper;\r\n        } else if (_size) {\r\n            if (typeof _size === \"number\") {\r\n                size = _size;\r\n            } else {\r\n                size = { width: _size.width!, height: _size.height! };\r\n            }\r\n        }\r\n\r\n        const useExistingThinPostProcess = !!effectWrapper;\r\n\r\n        this._effectWrapper =\r\n            effectWrapper ??\r\n            new EffectWrapper({\r\n                name,\r\n                useShaderStore: true,\r\n                useAsPostProcess: true,\r\n                fragmentShader: fragmentUrl,\r\n                engine: engine || camera?.getScene().getEngine(),\r\n                uniforms: parameters,\r\n                samplers,\r\n                uniformBuffers,\r\n                defines,\r\n                vertexUrl,\r\n                indexParameters,\r\n                blockCompilation: true,\r\n                shaderLanguage,\r\n                extraInitializations: undefined,\r\n            });\r\n\r\n        this.name = name;\r\n        this.onEffectCreatedObservable = this._effectWrapper.onEffectCreatedObservable;\r\n\r\n        if (camera != null) {\r\n            this._camera = camera;\r\n            this._scene = camera.getScene();\r\n            camera.attachPostProcess(this);\r\n            this._engine = this._scene.getEngine();\r\n\r\n            this._scene.postProcesses.push(this);\r\n            this.uniqueId = this._scene.getUniqueId();\r\n        } else if (engine) {\r\n            this._engine = engine;\r\n            this._engine.postProcesses.push(this);\r\n        }\r\n\r\n        this._options = size;\r\n        this.renderTargetSamplingMode = samplingMode ? samplingMode : Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        this._reusable = reusable || false;\r\n        this._textureType = textureType;\r\n        this._textureFormat = textureFormat;\r\n        this._shaderLanguage = shaderLanguage || ShaderLanguage.GLSL;\r\n\r\n        this._samplers = samplers || [];\r\n        if (this._samplers.indexOf(\"textureSampler\") === -1) {\r\n            this._samplers.push(\"textureSampler\");\r\n        }\r\n\r\n        this._fragmentUrl = fragmentUrl;\r\n        this._vertexUrl = vertexUrl;\r\n        this._parameters = parameters || [];\r\n\r\n        if (this._parameters.indexOf(\"scale\") === -1) {\r\n            this._parameters.push(\"scale\");\r\n        }\r\n        this._uniformBuffers = uniformBuffers || [];\r\n\r\n        this._indexParameters = indexParameters;\r\n\r\n        if (!useExistingThinPostProcess) {\r\n            this._webGPUReady = this._shaderLanguage === ShaderLanguage.WGSL;\r\n\r\n            const importPromises: Array<Promise<any>> = [];\r\n\r\n            this._gatherImports(this._engine.isWebGPU && !PostProcess.ForceGLSL, importPromises);\r\n\r\n            this._effectWrapper._webGPUReady = this._webGPUReady;\r\n            this._effectWrapper._postConstructor(blockCompilation, defines, extraInitializations, importPromises);\r\n        }\r\n    }\r\n\r\n    protected _gatherImports(useWebGPU = false, list: Promise<any>[]) {\r\n        // this._webGPUReady is used to detect when a postprocess is intended to be used with WebGPU\r\n        if (useWebGPU && this._webGPUReady) {\r\n            list.push(Promise.all([import(\"../ShadersWGSL/postprocess.vertex\")]));\r\n        } else {\r\n            list.push(Promise.all([import(\"../Shaders/postprocess.vertex\")]));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets a string identifying the name of the class\r\n     * @returns \"PostProcess\" string\r\n     */\r\n    public getClassName(): string {\r\n        return \"PostProcess\";\r\n    }\r\n\r\n    /**\r\n     * Gets the engine which this post process belongs to.\r\n     * @returns The engine the post process was enabled with.\r\n     */\r\n    public getEngine(): AbstractEngine {\r\n        return this._engine;\r\n    }\r\n\r\n    /**\r\n     * The effect that is created when initializing the post process.\r\n     * @returns The created effect corresponding to the postprocess.\r\n     */\r\n    public getEffect(): Effect {\r\n        return this._effectWrapper.drawWrapper.effect!;\r\n    }\r\n\r\n    /**\r\n     * To avoid multiple redundant textures for multiple post process, the output the output texture for this post process can be shared with another.\r\n     * @param postProcess The post process to share the output with.\r\n     * @returns This post process.\r\n     */\r\n    public shareOutputWith(postProcess: PostProcess): PostProcess {\r\n        this._disposeTextures();\r\n\r\n        this._shareOutputWithPostProcess = postProcess;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Reverses the effect of calling shareOutputWith and returns the post process back to its original state.\r\n     * This should be called if the post process that shares output with this post process is disabled/disposed.\r\n     */\r\n    public useOwnOutput() {\r\n        if (this._textures.length == 0) {\r\n            this._textures = new SmartArray<RenderTargetWrapper>(2);\r\n        }\r\n\r\n        this._shareOutputWithPostProcess = null;\r\n    }\r\n\r\n    /**\r\n     * Updates the effect with the current post process compile time values and recompiles the shader.\r\n     * @param defines Define statements that should be added at the beginning of the shader. (default: null)\r\n     * @param uniforms Set of uniform variables that will be passed to the shader. (default: null)\r\n     * @param samplers Set of Texture2D variables that will be passed to the shader. (default: null)\r\n     * @param indexParameters The index parameters to be used for babylons include syntax \"#include<kernelBlurVaryingDeclaration>[0..varyingCount]\". (default: undefined) See usage in babylon.blurPostProcess.ts and kernelBlur.vertex.fx\r\n     * @param onCompiled Called when the shader has been compiled.\r\n     * @param onError Called if there is an error when compiling a shader.\r\n     * @param vertexUrl The url of the vertex shader to be used (default: the one given at construction time)\r\n     * @param fragmentUrl The url of the fragment shader to be used (default: the one given at construction time)\r\n     */\r\n    public updateEffect(\r\n        defines: Nullable<string> = null,\r\n        uniforms: Nullable<string[]> = null,\r\n        samplers: Nullable<string[]> = null,\r\n        indexParameters?: any,\r\n        onCompiled?: (effect: Effect) => void,\r\n        onError?: (effect: Effect, errors: string) => void,\r\n        vertexUrl?: string,\r\n        fragmentUrl?: string\r\n    ) {\r\n        this._effectWrapper.updateEffect(defines, uniforms, samplers, indexParameters, onCompiled, onError, vertexUrl, fragmentUrl);\r\n        this._postProcessDefines = Array.isArray(this._effectWrapper.options.defines) ? this._effectWrapper.options.defines.join(\"\\n\") : this._effectWrapper.options.defines;\r\n    }\r\n\r\n    /**\r\n     * The post process is reusable if it can be used multiple times within one frame.\r\n     * @returns If the post process is reusable\r\n     */\r\n    public isReusable(): boolean {\r\n        return this._reusable;\r\n    }\r\n\r\n    /** invalidate frameBuffer to hint the postprocess to create a depth buffer */\r\n    public markTextureDirty(): void {\r\n        this.width = -1;\r\n    }\r\n\r\n    private _createRenderTargetTexture(textureSize: { width: number; height: number }, textureOptions: RenderTargetCreationOptions, channel = 0) {\r\n        for (let i = 0; i < this._textureCache.length; i++) {\r\n            if (\r\n                this._textureCache[i].texture.width === textureSize.width &&\r\n                this._textureCache[i].texture.height === textureSize.height &&\r\n                this._textureCache[i].postProcessChannel === channel &&\r\n                this._textureCache[i].texture._generateDepthBuffer === textureOptions.generateDepthBuffer &&\r\n                this._textureCache[i].texture.samples === textureOptions.samples\r\n            ) {\r\n                return this._textureCache[i].texture;\r\n            }\r\n        }\r\n\r\n        const tex = this._engine.createRenderTargetTexture(textureSize, textureOptions);\r\n        this._textureCache.push({ texture: tex, postProcessChannel: channel, lastUsedRenderId: -1 });\r\n\r\n        return tex;\r\n    }\r\n\r\n    private _flushTextureCache() {\r\n        const currentRenderId = this._renderId;\r\n\r\n        for (let i = this._textureCache.length - 1; i >= 0; i--) {\r\n            if (currentRenderId - this._textureCache[i].lastUsedRenderId > 100) {\r\n                let currentlyUsed = false;\r\n                for (let j = 0; j < this._textures.length; j++) {\r\n                    if (this._textures.data[j] === this._textureCache[i].texture) {\r\n                        currentlyUsed = true;\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                if (!currentlyUsed) {\r\n                    this._textureCache[i].texture.dispose();\r\n                    this._textureCache.splice(i, 1);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Resizes the post-process texture\r\n     * @param width Width of the texture\r\n     * @param height Height of the texture\r\n     * @param camera The camera this post-process is applied to. Pass null if the post-process is used outside the context of a camera post-process chain (default: null)\r\n     * @param needMipMaps True if mip maps need to be generated after render (default: false)\r\n     * @param forceDepthStencil True to force post-process texture creation with stencil depth and buffer (default: false)\r\n     */\r\n    public resize(width: number, height: number, camera: Nullable<Camera> = null, needMipMaps = false, forceDepthStencil = false) {\r\n        if (this._textures.length > 0) {\r\n            this._textures.reset();\r\n        }\r\n\r\n        this.width = width;\r\n        this.height = height;\r\n\r\n        let firstPP = null;\r\n        if (camera) {\r\n            for (let i = 0; i < camera._postProcesses.length; i++) {\r\n                if (camera._postProcesses[i] !== null) {\r\n                    firstPP = camera._postProcesses[i];\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        const textureSize = { width: this.width, height: this.height };\r\n        const textureOptions = {\r\n            generateMipMaps: needMipMaps,\r\n            generateDepthBuffer: forceDepthStencil || firstPP === this,\r\n            generateStencilBuffer: (forceDepthStencil || firstPP === this) && this._engine.isStencilEnable,\r\n            samplingMode: this.renderTargetSamplingMode,\r\n            type: this._textureType,\r\n            format: this._textureFormat,\r\n            samples: this._samples,\r\n            label: \"PostProcessRTT-\" + this.name,\r\n        };\r\n\r\n        this._textures.push(this._createRenderTargetTexture(textureSize, textureOptions, 0));\r\n\r\n        if (this._reusable) {\r\n            this._textures.push(this._createRenderTargetTexture(textureSize, textureOptions, 1));\r\n        }\r\n\r\n        this._texelSize.copyFromFloats(1.0 / this.width, 1.0 / this.height);\r\n\r\n        this.onSizeChangedObservable.notifyObservers(this);\r\n    }\r\n\r\n    private _getTarget() {\r\n        let target: RenderTargetWrapper;\r\n\r\n        if (this._shareOutputWithPostProcess) {\r\n            target = this._shareOutputWithPostProcess.inputTexture;\r\n        } else if (this._forcedOutputTexture) {\r\n            target = this._forcedOutputTexture;\r\n\r\n            this.width = this._forcedOutputTexture.width;\r\n            this.height = this._forcedOutputTexture.height;\r\n        } else {\r\n            target = this.inputTexture;\r\n\r\n            let cache;\r\n            for (let i = 0; i < this._textureCache.length; i++) {\r\n                if (this._textureCache[i].texture === target) {\r\n                    cache = this._textureCache[i];\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (cache) {\r\n                cache.lastUsedRenderId = this._renderId;\r\n            }\r\n        }\r\n\r\n        return target;\r\n    }\r\n\r\n    /**\r\n     * Activates the post process by intializing the textures to be used when executed. Notifies onActivateObservable.\r\n     * When this post process is used in a pipeline, this is call will bind the input texture of this post process to the output of the previous.\r\n     * @param cameraOrScene The camera that will be used in the post process. This camera will be used when calling onActivateObservable. You can also pass the scene if no camera is available.\r\n     * @param sourceTexture The source texture to be inspected to get the width and height if not specified in the post process constructor. (default: null)\r\n     * @param forceDepthStencil If true, a depth and stencil buffer will be generated. (default: false)\r\n     * @returns The render target wrapper that was bound to be written to.\r\n     */\r\n    public activate(cameraOrScene: Nullable<Camera> | Scene, sourceTexture: Nullable<InternalTexture> = null, forceDepthStencil?: boolean): RenderTargetWrapper {\r\n        const camera = cameraOrScene === null || (cameraOrScene as Camera).cameraRigMode !== undefined ? (cameraOrScene as Camera) || this._camera : null;\r\n\r\n        const scene = camera?.getScene() ?? (cameraOrScene as Scene);\r\n        const engine = scene.getEngine();\r\n        const maxSize = engine.getCaps().maxTextureSize;\r\n\r\n        const requiredWidth = ((sourceTexture ? sourceTexture.width : this._engine.getRenderWidth(true)) * <number>this._options) | 0;\r\n        const requiredHeight = ((sourceTexture ? sourceTexture.height : this._engine.getRenderHeight(true)) * <number>this._options) | 0;\r\n\r\n        let desiredWidth = (<PostProcessOptions>this._options).width || requiredWidth;\r\n        let desiredHeight = (<PostProcessOptions>this._options).height || requiredHeight;\r\n\r\n        const needMipMaps =\r\n            this.renderTargetSamplingMode !== Constants.TEXTURE_NEAREST_LINEAR &&\r\n            this.renderTargetSamplingMode !== Constants.TEXTURE_NEAREST_NEAREST &&\r\n            this.renderTargetSamplingMode !== Constants.TEXTURE_LINEAR_LINEAR;\r\n\r\n        let target: Nullable<RenderTargetWrapper> = null;\r\n\r\n        if (!this._shareOutputWithPostProcess && !this._forcedOutputTexture) {\r\n            if (this.adaptScaleToCurrentViewport) {\r\n                const currentViewport = engine.currentViewport;\r\n\r\n                if (currentViewport) {\r\n                    desiredWidth *= currentViewport.width;\r\n                    desiredHeight *= currentViewport.height;\r\n                }\r\n            }\r\n\r\n            if (needMipMaps || this.alwaysForcePOT) {\r\n                if (!(<PostProcessOptions>this._options).width) {\r\n                    desiredWidth = engine.needPOTTextures ? GetExponentOfTwo(desiredWidth, maxSize, this.scaleMode) : desiredWidth;\r\n                }\r\n\r\n                if (!(<PostProcessOptions>this._options).height) {\r\n                    desiredHeight = engine.needPOTTextures ? GetExponentOfTwo(desiredHeight, maxSize, this.scaleMode) : desiredHeight;\r\n                }\r\n            }\r\n\r\n            if (this.width !== desiredWidth || this.height !== desiredHeight || !(target = this._getTarget())) {\r\n                this.resize(desiredWidth, desiredHeight, camera, needMipMaps, forceDepthStencil);\r\n            }\r\n\r\n            this._textures.forEach((texture) => {\r\n                if (texture.samples !== this.samples) {\r\n                    this._engine.updateRenderTargetTextureSampleCount(texture, this.samples);\r\n                }\r\n            });\r\n\r\n            this._flushTextureCache();\r\n            this._renderId++;\r\n        }\r\n\r\n        if (!target) {\r\n            target = this._getTarget();\r\n        }\r\n\r\n        // Bind the input of this post process to be used as the output of the previous post process.\r\n        if (this.enablePixelPerfectMode) {\r\n            this._scaleRatio.copyFromFloats(requiredWidth / desiredWidth, requiredHeight / desiredHeight);\r\n            this._engine.bindFramebuffer(target, 0, requiredWidth, requiredHeight, this.forceFullscreenViewport);\r\n        } else {\r\n            this._scaleRatio.copyFromFloats(1, 1);\r\n            this._engine.bindFramebuffer(target, 0, undefined, undefined, this.forceFullscreenViewport);\r\n        }\r\n\r\n        this._engine._debugInsertMarker?.(`post process ${this.name} input`);\r\n\r\n        this.onActivateObservable.notifyObservers(camera!);\r\n\r\n        // Clear\r\n        if (this.autoClear && (this.alphaMode === Constants.ALPHA_DISABLE || this.forceAutoClearInAlphaMode)) {\r\n            this._engine.clear(this.clearColor ? this.clearColor : scene.clearColor, scene._allowPostProcessClearColor, true, true);\r\n        }\r\n\r\n        if (this._reusable) {\r\n            this._currentRenderTextureInd = (this._currentRenderTextureInd + 1) % 2;\r\n        }\r\n        return target;\r\n    }\r\n\r\n    /**\r\n     * If the post process is supported.\r\n     */\r\n    public get isSupported(): boolean {\r\n        return this._effectWrapper.drawWrapper.effect!.isSupported;\r\n    }\r\n\r\n    /**\r\n     * The aspect ratio of the output texture.\r\n     */\r\n    public get aspectRatio(): number {\r\n        if (this._shareOutputWithPostProcess) {\r\n            return this._shareOutputWithPostProcess.aspectRatio;\r\n        }\r\n\r\n        if (this._forcedOutputTexture) {\r\n            return this._forcedOutputTexture.width / this._forcedOutputTexture.height;\r\n        }\r\n        return this.width / this.height;\r\n    }\r\n\r\n    /**\r\n     * Get a value indicating if the post-process is ready to be used\r\n     * @returns true if the post-process is ready (shader is compiled)\r\n     */\r\n    public isReady(): boolean {\r\n        return this._effectWrapper.isReady();\r\n    }\r\n\r\n    /**\r\n     * Binds all textures and uniforms to the shader, this will be run on every pass.\r\n     * @returns the effect corresponding to this post process. Null if not compiled or not ready.\r\n     */\r\n    public apply(): Nullable<Effect> {\r\n        // Check\r\n        if (!this._effectWrapper.isReady()) {\r\n            return null;\r\n        }\r\n\r\n        // States\r\n        this._engine.enableEffect(this._effectWrapper.drawWrapper);\r\n        this._engine.setState(false);\r\n        this._engine.setDepthBuffer(false);\r\n        this._engine.setDepthWrite(false);\r\n\r\n        // Alpha\r\n        if (this.alphaConstants) {\r\n            this.getEngine().setAlphaConstants(this.alphaConstants.r, this.alphaConstants.g, this.alphaConstants.b, this.alphaConstants.a);\r\n        }\r\n\r\n        // Bind the output texture of the preivous post process as the input to this post process.\r\n        let source: RenderTargetWrapper;\r\n        if (this._shareOutputWithPostProcess) {\r\n            source = this._shareOutputWithPostProcess.inputTexture;\r\n        } else if (this._forcedOutputTexture) {\r\n            source = this._forcedOutputTexture;\r\n        } else {\r\n            source = this.inputTexture;\r\n        }\r\n\r\n        if (!this.externalTextureSamplerBinding) {\r\n            this._effectWrapper.drawWrapper.effect!._bindTexture(\"textureSampler\", source?.texture);\r\n        }\r\n\r\n        // Parameters\r\n        this._effectWrapper.drawWrapper.effect!.setVector2(\"scale\", this._scaleRatio);\r\n        this.onApplyObservable.notifyObservers(this._effectWrapper.drawWrapper.effect!);\r\n\r\n        this._effectWrapper.bind();\r\n\r\n        return this._effectWrapper.drawWrapper.effect;\r\n    }\r\n\r\n    private _disposeTextures() {\r\n        if (this._shareOutputWithPostProcess || this._forcedOutputTexture) {\r\n            this._disposeTextureCache();\r\n            return;\r\n        }\r\n\r\n        this._disposeTextureCache();\r\n        this._textures.dispose();\r\n    }\r\n\r\n    private _disposeTextureCache() {\r\n        for (let i = this._textureCache.length - 1; i >= 0; i--) {\r\n            this._textureCache[i].texture.dispose();\r\n        }\r\n\r\n        this._textureCache.length = 0;\r\n    }\r\n\r\n    /**\r\n     * Sets the required values to the prepass renderer.\r\n     * @param prePassRenderer defines the prepass renderer to setup.\r\n     * @returns true if the pre pass is needed.\r\n     */\r\n    public setPrePassRenderer(prePassRenderer: PrePassRenderer): boolean {\r\n        if (this._prePassEffectConfiguration) {\r\n            this._prePassEffectConfiguration = prePassRenderer.addEffectConfiguration(this._prePassEffectConfiguration);\r\n            this._prePassEffectConfiguration.enabled = true;\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Disposes the post process.\r\n     * @param camera The camera to dispose the post process on.\r\n     */\r\n    public dispose(camera?: Camera): void {\r\n        camera = camera || this._camera;\r\n\r\n        this._disposeTextures();\r\n\r\n        let index;\r\n        if (this._scene) {\r\n            index = this._scene.postProcesses.indexOf(this);\r\n            if (index !== -1) {\r\n                this._scene.postProcesses.splice(index, 1);\r\n            }\r\n        }\r\n\r\n        if (this._parentContainer) {\r\n            const index = this._parentContainer.postProcesses.indexOf(this);\r\n            if (index > -1) {\r\n                this._parentContainer.postProcesses.splice(index, 1);\r\n            }\r\n            this._parentContainer = null;\r\n        }\r\n\r\n        index = this._engine.postProcesses.indexOf(this);\r\n        if (index !== -1) {\r\n            this._engine.postProcesses.splice(index, 1);\r\n        }\r\n\r\n        if (!camera) {\r\n            return;\r\n        }\r\n        camera.detachPostProcess(this);\r\n\r\n        index = camera._postProcesses.indexOf(this);\r\n        if (index === 0 && camera._postProcesses.length > 0) {\r\n            const firstPostProcess = this._camera._getFirstPostProcess();\r\n            if (firstPostProcess) {\r\n                firstPostProcess.markTextureDirty();\r\n            }\r\n        }\r\n\r\n        this.onActivateObservable.clear();\r\n        this.onAfterRenderObservable.clear();\r\n        this.onApplyObservable.clear();\r\n        this.onBeforeRenderObservable.clear();\r\n        this.onSizeChangedObservable.clear();\r\n        this.onEffectCreatedObservable.clear();\r\n    }\r\n\r\n    /**\r\n     * Serializes the post process to a JSON object\r\n     * @returns the JSON object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = SerializationHelper.Serialize(this);\r\n        const camera = this.getCamera() || (this._scene && this._scene.activeCamera);\r\n        serializationObject.customType = \"BABYLON.\" + this.getClassName();\r\n        serializationObject.cameraId = camera ? camera.id : null;\r\n        serializationObject.reusable = this._reusable;\r\n        serializationObject.textureType = this._textureType;\r\n        serializationObject.fragmentUrl = this._fragmentUrl;\r\n        serializationObject.parameters = this._parameters;\r\n        serializationObject.samplers = this._samplers;\r\n        serializationObject.uniformBuffers = this._uniformBuffers;\r\n        serializationObject.options = this._options;\r\n        serializationObject.defines = this._postProcessDefines;\r\n        serializationObject.textureFormat = this._textureFormat;\r\n        serializationObject.vertexUrl = this._vertexUrl;\r\n        serializationObject.indexParameters = this._indexParameters;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Clones this post process\r\n     * @returns a new post process similar to this one\r\n     */\r\n    public clone(): Nullable<PostProcess> {\r\n        const serializationObject = this.serialize();\r\n        serializationObject._engine = this._engine;\r\n        serializationObject.cameraId = null;\r\n\r\n        const result = PostProcess.Parse(serializationObject, this._scene, \"\");\r\n\r\n        if (!result) {\r\n            return null;\r\n        }\r\n\r\n        result.onActivateObservable = this.onActivateObservable.clone();\r\n        result.onSizeChangedObservable = this.onSizeChangedObservable.clone();\r\n        result.onApplyObservable = this.onApplyObservable.clone();\r\n        result.onBeforeRenderObservable = this.onBeforeRenderObservable.clone();\r\n        result.onAfterRenderObservable = this.onAfterRenderObservable.clone();\r\n\r\n        result._prePassEffectConfiguration = this._prePassEffectConfiguration;\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates a material from parsed material data\r\n     * @param parsedPostProcess defines parsed post process data\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures\r\n     * @returns a new post process\r\n     */\r\n    public static Parse(parsedPostProcess: any, scene: Scene, rootUrl: string): Nullable<PostProcess> {\r\n        const postProcessType = GetClass(parsedPostProcess.customType);\r\n\r\n        if (!postProcessType || !postProcessType._Parse) {\r\n            return null;\r\n        }\r\n\r\n        const camera = scene ? scene.getCameraById(parsedPostProcess.cameraId) : null;\r\n        return postProcessType._Parse(parsedPostProcess, camera, scene, rootUrl);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _Parse(parsedPostProcess: any, targetCamera: Nullable<Camera>, scene: Nullable<Scene>, rootUrl: string): Nullable<PostProcess> {\r\n        return SerializationHelper.Parse(\r\n            () => {\r\n                return new PostProcess(\r\n                    parsedPostProcess.name,\r\n                    parsedPostProcess.fragmentUrl,\r\n                    parsedPostProcess.parameters,\r\n                    parsedPostProcess.samplers,\r\n                    parsedPostProcess.options,\r\n                    targetCamera,\r\n                    parsedPostProcess.renderTargetSamplingMode,\r\n                    parsedPostProcess._engine,\r\n                    parsedPostProcess.reusable,\r\n                    parsedPostProcess.defines,\r\n                    parsedPostProcess.textureType,\r\n                    parsedPostProcess.vertexUrl,\r\n                    parsedPostProcess.indexParameters,\r\n                    false,\r\n                    parsedPostProcess.textureFormat\r\n                );\r\n            },\r\n            parsedPostProcess,\r\n            scene,\r\n            rootUrl\r\n        );\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.PostProcess\", PostProcess);\r\n", "import type { Nullable } from \"../types\";\r\nimport { PrecisionDate } from \"./precisionDate\";\r\n\r\n/**\r\n * Performance monitor tracks rolling average frame-time and frame-time variance over a user defined sliding-window\r\n */\r\nexport class PerformanceMonitor {\r\n    private _enabled: boolean = true;\r\n    private _rollingFrameTime: RollingAverage;\r\n    private _lastFrameTimeMs: Nullable<number>;\r\n\r\n    /**\r\n     * constructor\r\n     * @param frameSampleSize The number of samples required to saturate the sliding window\r\n     */\r\n    constructor(frameSampleSize: number = 30) {\r\n        this._rollingFrameTime = new RollingAverage(frameSampleSize);\r\n    }\r\n\r\n    /**\r\n     * Samples current frame\r\n     * @param timeMs A timestamp in milliseconds of the current frame to compare with other frames\r\n     */\r\n    public sampleFrame(timeMs: number = PrecisionDate.Now) {\r\n        if (!this._enabled) {\r\n            return;\r\n        }\r\n\r\n        if (this._lastFrameTimeMs != null) {\r\n            const dt = timeMs - this._lastFrameTimeMs;\r\n            this._rollingFrameTime.add(dt);\r\n        }\r\n\r\n        this._lastFrameTimeMs = timeMs;\r\n    }\r\n\r\n    /**\r\n     * Returns the average frame time in milliseconds over the sliding window (or the subset of frames sampled so far)\r\n     */\r\n    public get averageFrameTime(): number {\r\n        return this._rollingFrameTime.average;\r\n    }\r\n\r\n    /**\r\n     * Returns the variance frame time in milliseconds over the sliding window (or the subset of frames sampled so far)\r\n     */\r\n    public get averageFrameTimeVariance(): number {\r\n        return this._rollingFrameTime.variance;\r\n    }\r\n\r\n    /**\r\n     * Returns the frame time of the most recent frame\r\n     */\r\n    public get instantaneousFrameTime(): number {\r\n        return this._rollingFrameTime.history(0);\r\n    }\r\n\r\n    /**\r\n     * Returns the average framerate in frames per second over the sliding window (or the subset of frames sampled so far)\r\n     */\r\n    public get averageFPS(): number {\r\n        return 1000.0 / this._rollingFrameTime.average;\r\n    }\r\n\r\n    /**\r\n     * Returns the average framerate in frames per second using the most recent frame time\r\n     */\r\n    public get instantaneousFPS(): number {\r\n        const history = this._rollingFrameTime.history(0);\r\n\r\n        if (history === 0) {\r\n            return 0;\r\n        }\r\n\r\n        return 1000.0 / history;\r\n    }\r\n\r\n    /**\r\n     * Returns true if enough samples have been taken to completely fill the sliding window\r\n     */\r\n    public get isSaturated(): boolean {\r\n        return this._rollingFrameTime.isSaturated();\r\n    }\r\n\r\n    /**\r\n     * Enables contributions to the sliding window sample set\r\n     */\r\n    public enable() {\r\n        this._enabled = true;\r\n    }\r\n\r\n    /**\r\n     * Disables contributions to the sliding window sample set\r\n     * Samples will not be interpolated over the disabled period\r\n     */\r\n    public disable() {\r\n        this._enabled = false;\r\n        //clear last sample to avoid interpolating over the disabled period when next enabled\r\n        this._lastFrameTimeMs = null;\r\n    }\r\n\r\n    /**\r\n     * Returns true if sampling is enabled\r\n     */\r\n    public get isEnabled(): boolean {\r\n        return this._enabled;\r\n    }\r\n\r\n    /**\r\n     * Resets performance monitor\r\n     */\r\n    public reset() {\r\n        //clear last sample to avoid interpolating over the disabled period when next enabled\r\n        this._lastFrameTimeMs = null;\r\n        //wipe record\r\n        this._rollingFrameTime.reset();\r\n    }\r\n}\r\n\r\n/**\r\n * RollingAverage\r\n *\r\n * Utility to efficiently compute the rolling average and variance over a sliding window of samples\r\n */\r\nexport class RollingAverage {\r\n    /**\r\n     * Current average\r\n     */\r\n    public average: number;\r\n    /**\r\n     * Current variance\r\n     */\r\n    public variance: number;\r\n\r\n    protected _samples: Array<number>;\r\n    protected _sampleCount: number;\r\n    protected _pos: number;\r\n    protected _m2: number; //sum of squares of differences from the (current) mean\r\n\r\n    /**\r\n     * constructor\r\n     * @param length The number of samples required to saturate the sliding window\r\n     */\r\n    constructor(length: number) {\r\n        this._samples = new Array<number>(length);\r\n        this.reset();\r\n    }\r\n\r\n    /**\r\n     * Adds a sample to the sample set\r\n     * @param v The sample value\r\n     */\r\n    public add(v: number) {\r\n        //http://en.wikipedia.org/wiki/Algorithms_for_calculating_variance\r\n        let delta: number;\r\n\r\n        //we need to check if we've already wrapped round\r\n        if (this.isSaturated()) {\r\n            //remove bottom of stack from mean\r\n            const bottomValue = this._samples[this._pos];\r\n            delta = bottomValue - this.average;\r\n            this.average -= delta / (this._sampleCount - 1);\r\n            this._m2 -= delta * (bottomValue - this.average);\r\n        } else {\r\n            this._sampleCount++;\r\n        }\r\n\r\n        //add new value to mean\r\n        delta = v - this.average;\r\n        this.average += delta / this._sampleCount;\r\n        this._m2 += delta * (v - this.average);\r\n\r\n        //set the new variance\r\n        this.variance = this._m2 / (this._sampleCount - 1);\r\n\r\n        this._samples[this._pos] = v;\r\n        this._pos++;\r\n\r\n        this._pos %= this._samples.length; //positive wrap around\r\n    }\r\n\r\n    /**\r\n     * Returns previously added values or null if outside of history or outside the sliding window domain\r\n     * @param i Index in history. For example, pass 0 for the most recent value and 1 for the value before that\r\n     * @returns Value previously recorded with add() or null if outside of range\r\n     */\r\n    public history(i: number): number {\r\n        if (i >= this._sampleCount || i >= this._samples.length) {\r\n            return 0;\r\n        }\r\n\r\n        const i0 = this._wrapPosition(this._pos - 1.0);\r\n        return this._samples[this._wrapPosition(i0 - i)];\r\n    }\r\n\r\n    /**\r\n     * Returns true if enough samples have been taken to completely fill the sliding window\r\n     * @returns true if sample-set saturated\r\n     */\r\n    public isSaturated(): boolean {\r\n        return this._sampleCount >= this._samples.length;\r\n    }\r\n\r\n    /**\r\n     * Resets the rolling average (equivalent to 0 samples taken so far)\r\n     */\r\n    public reset() {\r\n        this.average = 0;\r\n        this.variance = 0;\r\n        this._sampleCount = 0;\r\n        this._pos = 0;\r\n        this._m2 = 0;\r\n    }\r\n\r\n    /**\r\n     * Wraps a value around the sample range boundaries\r\n     * @param i Position in sample range, for example if the sample length is 5, and i is -3, then 2 will be returned.\r\n     * @returns Wrapped position in sample range\r\n     */\r\n    protected _wrapPosition(i: number): number {\r\n        const max = this._samples.length;\r\n        return ((i % max) + max) % max;\r\n    }\r\n}\r\n", "import { ThinEngine } from \"../../Engines/thinEngine\";\r\nimport type { InternalTexture } from \"../../Materials/Textures/internalTexture\";\r\nimport type { Nullable } from \"../../types\";\r\n\r\ndeclare module \"../../Engines/abstractEngine\" {\r\n    export interface AbstractEngine {\r\n        /** @internal */\r\n        _readTexturePixels(\r\n            texture: InternalTexture,\r\n            width: number,\r\n            height: number,\r\n            faceIndex?: number,\r\n            level?: number,\r\n            buffer?: Nullable<ArrayBufferView>,\r\n            flushRenderer?: boolean,\r\n            noDataConversion?: boolean,\r\n            x?: number,\r\n            y?: number\r\n        ): Promise<ArrayBufferView>;\r\n\r\n        /** @internal */\r\n        _readTexturePixelsSync(\r\n            texture: InternalTexture,\r\n            width: number,\r\n            height: number,\r\n            faceIndex?: number,\r\n            level?: number,\r\n            buffer?: Nullable<ArrayBufferView>,\r\n            flushRenderer?: boolean,\r\n            noDataConversion?: boolean,\r\n            x?: number,\r\n            y?: number\r\n        ): ArrayBufferView;\r\n    }\r\n}\r\n\r\n// back-compat\r\nimport { allocateAndCopyTypedBuffer } from \"../../Engines/abstractEngine.functions\";\r\nexport { allocateAndCopyTypedBuffer };\r\n\r\nThinEngine.prototype._readTexturePixelsSync = function (\r\n    texture: InternalTexture,\r\n    width: number,\r\n    height: number,\r\n    faceIndex = -1,\r\n    level = 0,\r\n    buffer: Nullable<ArrayBufferView> = null,\r\n    flushRenderer = true,\r\n    noDataConversion = false,\r\n    x = 0,\r\n    y = 0\r\n): ArrayBufferView {\r\n    const gl = this._gl;\r\n    if (!gl) {\r\n        throw new Error(\"Engine does not have gl rendering context.\");\r\n    }\r\n    if (!this._dummyFramebuffer) {\r\n        const dummy = gl.createFramebuffer();\r\n\r\n        if (!dummy) {\r\n            throw new Error(\"Unable to create dummy framebuffer\");\r\n        }\r\n\r\n        this._dummyFramebuffer = dummy;\r\n    }\r\n    gl.bindFramebuffer(gl.FRAMEBUFFER, this._dummyFramebuffer);\r\n\r\n    if (faceIndex > -1) {\r\n        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, texture._hardwareTexture?.underlyingResource, level);\r\n    } else {\r\n        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture._hardwareTexture?.underlyingResource, level);\r\n    }\r\n\r\n    let readType = texture.type !== undefined ? this._getWebGLTextureType(texture.type) : gl.UNSIGNED_BYTE;\r\n\r\n    if (!noDataConversion) {\r\n        switch (readType) {\r\n            case gl.UNSIGNED_BYTE:\r\n                if (!buffer) {\r\n                    buffer = new Uint8Array(4 * width * height);\r\n                }\r\n                readType = gl.UNSIGNED_BYTE;\r\n                break;\r\n            default:\r\n                if (!buffer) {\r\n                    buffer = new Float32Array(4 * width * height);\r\n                }\r\n                readType = gl.FLOAT;\r\n                break;\r\n        }\r\n    } else if (!buffer) {\r\n        buffer = allocateAndCopyTypedBuffer(texture.type, 4 * width * height);\r\n    }\r\n\r\n    if (flushRenderer) {\r\n        this.flushFramebuffer();\r\n    }\r\n\r\n    gl.readPixels(x, y, width, height, gl.RGBA, readType, <DataView>buffer);\r\n    gl.bindFramebuffer(gl.FRAMEBUFFER, this._currentFramebuffer);\r\n\r\n    return buffer;\r\n};\r\n\r\nThinEngine.prototype._readTexturePixels = function (\r\n    texture: InternalTexture,\r\n    width: number,\r\n    height: number,\r\n    faceIndex = -1,\r\n    level = 0,\r\n    buffer: Nullable<ArrayBufferView> = null,\r\n    flushRenderer = true,\r\n    noDataConversion = false,\r\n    x = 0,\r\n    y = 0\r\n): Promise<ArrayBufferView> {\r\n    return Promise.resolve(this._readTexturePixelsSync(texture, width, height, faceIndex, level, buffer, flushRenderer, noDataConversion, x, y));\r\n};\r\n", "import type { InternalTexture } from \"../Materials/Textures/internalTexture\";\r\nimport { InternalTextureSource } from \"../Materials/Textures/internalTexture\";\r\nimport type { RenderTargetCreationOptions, TextureSize } from \"../Materials/Textures/textureCreationOptions\";\r\nimport type { Nullable } from \"../types\";\r\nimport { Constants } from \"./constants\";\r\nimport type { AbstractEngine } from \"./abstractEngine\";\r\nimport type { IMultiRenderTargetOptions } from \"../Materials/Textures/multiRenderTarget\";\r\nimport { HasStencilAspect } from \"core/Materials/Textures/textureHelper.functions\";\r\n\r\n/**\r\n * An interface enforcing the renderTarget accessor to used by render target textures.\r\n */\r\nexport interface IRenderTargetTexture {\r\n    /**\r\n     * Entry point to access the wrapper on a texture.\r\n     */\r\n    renderTarget: Nullable<RenderTargetWrapper>;\r\n}\r\n\r\n/**\r\n * Wrapper around a render target (either single or multi textures)\r\n */\r\nexport class RenderTargetWrapper {\r\n    protected _engine: AbstractEngine;\r\n    private _size: TextureSize;\r\n    private _isCube: boolean;\r\n    private _isMulti: boolean;\r\n    private _textures: Nullable<InternalTexture[]> = null;\r\n    private _faceIndices: Nullable<number[]> = null;\r\n    private _layerIndices: Nullable<number[]> = null;\r\n    private _depthStencilTextureLabel?: string;\r\n    /** @internal */\r\n    public _samples = 1;\r\n\r\n    /** @internal */\r\n    public _attachments: Nullable<number[]> = null;\r\n    /** @internal */\r\n    public _generateStencilBuffer: boolean = false;\r\n    /** @internal */\r\n    public _generateDepthBuffer: boolean = false;\r\n\r\n    /** @internal */\r\n    public _depthStencilTexture: Nullable<InternalTexture>;\r\n    /** @internal */\r\n    public _depthStencilTextureWithStencil: boolean = false;\r\n\r\n    /**\r\n     * Gets or sets the label of the render target wrapper (optional, for debugging purpose)\r\n     */\r\n    public label?: string;\r\n\r\n    /**\r\n     * Gets the depth/stencil texture\r\n     */\r\n    public get depthStencilTexture() {\r\n        return this._depthStencilTexture;\r\n    }\r\n\r\n    /**\r\n     * Sets the depth/stencil texture\r\n     * @param texture The depth/stencil texture to set\r\n     * @param disposeExisting True to dispose the existing depth/stencil texture (if any) before replacing it (default: true)\r\n     */\r\n    public setDepthStencilTexture(texture: Nullable<InternalTexture>, disposeExisting = true) {\r\n        if (disposeExisting && this._depthStencilTexture) {\r\n            this._depthStencilTexture.dispose();\r\n        }\r\n\r\n        this._depthStencilTexture = texture;\r\n\r\n        this._generateDepthBuffer = this._generateStencilBuffer = this._depthStencilTextureWithStencil = false;\r\n\r\n        if (texture) {\r\n            this._generateDepthBuffer = true;\r\n            this._generateStencilBuffer = this._depthStencilTextureWithStencil = HasStencilAspect(texture.format);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Indicates if the depth/stencil texture has a stencil aspect\r\n     */\r\n    public get depthStencilTextureWithStencil() {\r\n        return this._depthStencilTextureWithStencil;\r\n    }\r\n\r\n    /**\r\n     * Defines if the render target wrapper is for a cube texture or if false a 2d texture\r\n     */\r\n    public get isCube(): boolean {\r\n        return this._isCube;\r\n    }\r\n\r\n    /**\r\n     * Defines if the render target wrapper is for a single or multi target render wrapper\r\n     */\r\n    public get isMulti(): boolean {\r\n        return this._isMulti;\r\n    }\r\n\r\n    /**\r\n     * Defines if the render target wrapper is for a single or an array of textures\r\n     */\r\n    public get is2DArray(): boolean {\r\n        return this.layers > 0;\r\n    }\r\n\r\n    /**\r\n     * Defines if the render target wrapper is for a 3D texture\r\n     */\r\n    public get is3D(): boolean {\r\n        return this.depth > 0;\r\n    }\r\n\r\n    /**\r\n     * Gets the size of the render target wrapper (used for cubes, as width=height in this case)\r\n     */\r\n    public get size(): number {\r\n        return this.width;\r\n    }\r\n\r\n    /**\r\n     * Gets the width of the render target wrapper\r\n     */\r\n    public get width(): number {\r\n        return (<{ width: number; height: number }>this._size).width ?? <number>this._size;\r\n    }\r\n\r\n    /**\r\n     * Gets the height of the render target wrapper\r\n     */\r\n    public get height(): number {\r\n        return (<{ width: number; height: number }>this._size).height ?? <number>this._size;\r\n    }\r\n\r\n    /**\r\n     * Gets the number of layers of the render target wrapper (only used if is2DArray is true and wrapper is not a multi render target)\r\n     */\r\n    public get layers(): number {\r\n        return (<{ width: number; height: number; depth?: number; layers?: number }>this._size).layers || 0;\r\n    }\r\n\r\n    /**\r\n     * Gets the depth of the render target wrapper (only used if is3D is true and wrapper is not a multi render target)\r\n     */\r\n    public get depth(): number {\r\n        return (<{ width: number; height: number; depth?: number; layers?: number }>this._size).depth || 0;\r\n    }\r\n\r\n    /**\r\n     * Gets the render texture. If this is a multi render target, gets the first texture\r\n     */\r\n    public get texture(): Nullable<InternalTexture> {\r\n        return this._textures?.[0] ?? null;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of render textures. If we are not in a multi render target, the list will be null (use the texture getter instead)\r\n     */\r\n    public get textures(): Nullable<InternalTexture[]> {\r\n        return this._textures;\r\n    }\r\n\r\n    /**\r\n     * Gets the face indices that correspond to the list of render textures. If we are not in a multi render target, the list will be null\r\n     */\r\n    public get faceIndices(): Nullable<number[]> {\r\n        return this._faceIndices;\r\n    }\r\n\r\n    /**\r\n     * Gets the layer indices that correspond to the list of render textures. If we are not in a multi render target, the list will be null\r\n     */\r\n    public get layerIndices(): Nullable<number[]> {\r\n        return this._layerIndices;\r\n    }\r\n\r\n    /**\r\n     * Sets this property to true to disable the automatic MSAA resolve that happens when the render target wrapper is unbound (default is false)\r\n     */\r\n    public disableAutomaticMSAAResolve = false;\r\n\r\n    /**\r\n     * Indicates if MSAA color texture(s) should be resolved when a resolve occur (either automatically by the engine or manually by the user) (default is true)\r\n     * Note that you can trigger a MSAA resolve at any time by calling resolveMSAATextures()\r\n     */\r\n    public resolveMSAAColors = true;\r\n\r\n    /**\r\n     * Indicates if MSAA depth texture should be resolved when a resolve occur (either automatically by the engine or manually by the user) (default is false)\r\n     */\r\n    public resolveMSAADepth = false;\r\n\r\n    /**\r\n     * Indicates if MSAA stencil texture should be resolved when a resolve occur (either automatically by the engine or manually by the user) (default is false)\r\n     */\r\n    public resolveMSAAStencil = false;\r\n\r\n    /**\r\n     * Gets the base array layer of a texture in the textures array\r\n     * This is an number that is calculated based on the layer and face indices set for this texture at that index\r\n     * @param index The index of the texture in the textures array to get the base array layer for\r\n     * @returns the base array layer of the texture at the given index\r\n     */\r\n    public getBaseArrayLayer(index: number): number {\r\n        if (!this._textures) {\r\n            return -1;\r\n        }\r\n\r\n        const texture = this._textures[index];\r\n        const layerIndex = this._layerIndices?.[index] ?? 0;\r\n        const faceIndex = this._faceIndices?.[index] ?? 0;\r\n\r\n        return texture.isCube ? layerIndex * 6 + faceIndex : texture.is3D ? 0 : layerIndex;\r\n    }\r\n\r\n    /**\r\n     * Gets the sample count of the render target\r\n     */\r\n    public get samples(): number {\r\n        return this._samples;\r\n    }\r\n\r\n    /**\r\n     * Sets the sample count of the render target\r\n     * @param value sample count\r\n     * @param initializeBuffers If set to true, the engine will make an initializing call to drawBuffers (only used when isMulti=true).\r\n     * @param force true to force calling the update sample count engine function even if the current sample count is equal to value\r\n     * @returns the sample count that has been set\r\n     */\r\n    public setSamples(value: number, initializeBuffers = true, force = false): number {\r\n        if (this.samples === value && !force) {\r\n            return value;\r\n        }\r\n\r\n        const result = this._isMulti\r\n            ? this._engine.updateMultipleRenderTargetTextureSampleCount(this, value, initializeBuffers)\r\n            : this._engine.updateRenderTargetTextureSampleCount(this, value);\r\n        this._samples = value;\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Resolves the MSAA textures into their non-MSAA version.\r\n     * Note that if samples equals 1 (no MSAA), no resolve is performed.\r\n     */\r\n    public resolveMSAATextures(): void {\r\n        if (this.isMulti) {\r\n            this._engine.resolveMultiFramebuffer(this);\r\n        } else {\r\n            this._engine.resolveFramebuffer(this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Generates mipmaps for each texture of the render target\r\n     */\r\n    public generateMipMaps(): void {\r\n        if (this._engine._currentRenderTarget === this) {\r\n            this._engine.unBindFramebuffer(this, true);\r\n        }\r\n        if (this.isMulti) {\r\n            this._engine.generateMipMapsMultiFramebuffer(this);\r\n        } else {\r\n            this._engine.generateMipMapsFramebuffer(this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Initializes the render target wrapper\r\n     * @param isMulti true if the wrapper is a multi render target\r\n     * @param isCube true if the wrapper should render to a cube texture\r\n     * @param size size of the render target (width/height/layers)\r\n     * @param engine engine used to create the render target\r\n     * @param label defines the label to use for the wrapper (for debugging purpose only)\r\n     */\r\n    constructor(isMulti: boolean, isCube: boolean, size: TextureSize, engine: AbstractEngine, label?: string) {\r\n        this._isMulti = isMulti;\r\n        this._isCube = isCube;\r\n        this._size = size;\r\n        this._engine = engine;\r\n        this._depthStencilTexture = null;\r\n        this.label = label;\r\n    }\r\n\r\n    /**\r\n     * Sets the render target texture(s)\r\n     * @param textures texture(s) to set\r\n     */\r\n    public setTextures(textures: Nullable<InternalTexture> | Nullable<InternalTexture[]>): void {\r\n        if (Array.isArray(textures)) {\r\n            this._textures = textures;\r\n        } else if (textures) {\r\n            this._textures = [textures];\r\n        } else {\r\n            this._textures = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set a texture in the textures array\r\n     * @param texture The texture to set\r\n     * @param index The index in the textures array to set\r\n     * @param disposePrevious If this function should dispose the previous texture\r\n     */\r\n    public setTexture(texture: InternalTexture, index: number = 0, disposePrevious: boolean = true): void {\r\n        if (!this._textures) {\r\n            this._textures = [];\r\n        }\r\n        if (this._textures[index] === texture) {\r\n            return;\r\n        }\r\n\r\n        if (this._textures[index] && disposePrevious) {\r\n            this._textures[index].dispose();\r\n        }\r\n\r\n        this._textures[index] = texture;\r\n    }\r\n\r\n    /**\r\n     * Sets the layer and face indices of every render target texture bound to each color attachment\r\n     * @param layers The layers of each texture to be set\r\n     * @param faces The faces of each texture to be set\r\n     */\r\n    public setLayerAndFaceIndices(layers: number[], faces: number[]) {\r\n        this._layerIndices = layers;\r\n        this._faceIndices = faces;\r\n    }\r\n\r\n    /**\r\n     * Sets the layer and face indices of a texture in the textures array that should be bound to each color attachment\r\n     * @param index The index of the texture in the textures array to modify\r\n     * @param layer The layer of the texture to be set\r\n     * @param face The face of the texture to be set\r\n     */\r\n    public setLayerAndFaceIndex(index: number = 0, layer?: number, face?: number): void {\r\n        if (!this._layerIndices) {\r\n            this._layerIndices = [];\r\n        }\r\n        if (!this._faceIndices) {\r\n            this._faceIndices = [];\r\n        }\r\n\r\n        if (layer !== undefined && layer >= 0) {\r\n            this._layerIndices[index] = layer;\r\n        }\r\n        if (face !== undefined && face >= 0) {\r\n            this._faceIndices[index] = face;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates the depth/stencil texture\r\n     * @param comparisonFunction Comparison function to use for the texture\r\n     * @param bilinearFiltering true if bilinear filtering should be used when sampling the texture\r\n     * @param generateStencil Not used anymore. \"format\" will be used to determine if stencil should be created\r\n     * @param samples sample count to use when creating the texture (default: 1)\r\n     * @param format format of the depth texture (default: Constants.TEXTUREFORMAT_DEPTH32_FLOAT)\r\n     * @param label defines the label to use for the texture (for debugging purpose only)\r\n     * @returns the depth/stencil created texture\r\n     */\r\n    public createDepthStencilTexture(\r\n        comparisonFunction: number = 0,\r\n        bilinearFiltering: boolean = true,\r\n        generateStencil: boolean = false,\r\n        samples: number = 1,\r\n        format: number = Constants.TEXTUREFORMAT_DEPTH32_FLOAT,\r\n        label?: string\r\n    ): InternalTexture {\r\n        this._depthStencilTexture?.dispose();\r\n\r\n        this._depthStencilTextureWithStencil = generateStencil;\r\n        this._depthStencilTextureLabel = label;\r\n        this._depthStencilTexture = this._engine.createDepthStencilTexture(\r\n            this._size,\r\n            {\r\n                bilinearFiltering,\r\n                comparisonFunction,\r\n                generateStencil,\r\n                isCube: this._isCube,\r\n                samples,\r\n                depthTextureFormat: format,\r\n                label,\r\n            },\r\n            this\r\n        );\r\n\r\n        return this._depthStencilTexture;\r\n    }\r\n\r\n    /**\r\n     * @deprecated Use shareDepth instead\r\n     * @param renderTarget Destination renderTarget\r\n     */\r\n    public _shareDepth(renderTarget: RenderTargetWrapper): void {\r\n        this.shareDepth(renderTarget);\r\n    }\r\n\r\n    /**\r\n     * Shares the depth buffer of this render target with another render target.\r\n     * @param renderTarget Destination renderTarget\r\n     */\r\n    public shareDepth(renderTarget: RenderTargetWrapper): void {\r\n        if (this._depthStencilTexture) {\r\n            if (renderTarget._depthStencilTexture) {\r\n                renderTarget._depthStencilTexture.dispose();\r\n            }\r\n\r\n            renderTarget._depthStencilTexture = this._depthStencilTexture;\r\n            renderTarget._depthStencilTextureWithStencil = this._depthStencilTextureWithStencil;\r\n            this._depthStencilTexture.incrementReferences();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _swapAndDie(target: InternalTexture): void {\r\n        if (this.texture) {\r\n            this.texture._swapAndDie(target);\r\n        }\r\n        this._textures = null;\r\n        this.dispose(true);\r\n    }\r\n\r\n    protected _cloneRenderTargetWrapper(): Nullable<RenderTargetWrapper> {\r\n        let rtw: Nullable<RenderTargetWrapper> = null;\r\n\r\n        if (this._isMulti) {\r\n            const textureArray = this.textures;\r\n            if (textureArray && textureArray.length > 0) {\r\n                let generateDepthTexture = false;\r\n                let textureCount = textureArray.length;\r\n                let depthTextureFormat = -1;\r\n\r\n                const lastTextureSource = textureArray[textureArray.length - 1]._source;\r\n                if (lastTextureSource === InternalTextureSource.Depth || lastTextureSource === InternalTextureSource.DepthStencil) {\r\n                    generateDepthTexture = true;\r\n                    depthTextureFormat = textureArray[textureArray.length - 1].format;\r\n                    textureCount--;\r\n                }\r\n\r\n                const samplingModes: number[] = [];\r\n                const types: number[] = [];\r\n                const formats: number[] = [];\r\n                const targetTypes: number[] = [];\r\n                const faceIndex: number[] = [];\r\n                const layerIndex: number[] = [];\r\n                const layerCounts: number[] = [];\r\n                const internalTexture2Index: { [id: number]: number } = {};\r\n\r\n                for (let i = 0; i < textureCount; ++i) {\r\n                    const texture = textureArray[i];\r\n\r\n                    samplingModes.push(texture.samplingMode);\r\n                    types.push(texture.type);\r\n                    formats.push(texture.format);\r\n\r\n                    const index = internalTexture2Index[texture.uniqueId];\r\n                    if (index !== undefined) {\r\n                        targetTypes.push(-1);\r\n                        layerCounts.push(0);\r\n                    } else {\r\n                        internalTexture2Index[texture.uniqueId] = i;\r\n                        if (texture.is2DArray) {\r\n                            targetTypes.push(Constants.TEXTURE_2D_ARRAY);\r\n                            layerCounts.push(texture.depth);\r\n                        } else if (texture.isCube) {\r\n                            targetTypes.push(Constants.TEXTURE_CUBE_MAP);\r\n                            layerCounts.push(0);\r\n                        } /*else if (texture.isCubeArray) {\r\n                            targetTypes.push(Constants.TEXTURE_CUBE_MAP_ARRAY);\r\n                            layerCounts.push(texture.depth);\r\n                        }*/ else if (texture.is3D) {\r\n                            targetTypes.push(Constants.TEXTURE_3D);\r\n                            layerCounts.push(texture.depth);\r\n                        } else {\r\n                            targetTypes.push(Constants.TEXTURE_2D);\r\n                            layerCounts.push(0);\r\n                        }\r\n                    }\r\n\r\n                    if (this._faceIndices) {\r\n                        faceIndex.push(this._faceIndices[i] ?? 0);\r\n                    }\r\n                    if (this._layerIndices) {\r\n                        layerIndex.push(this._layerIndices[i] ?? 0);\r\n                    }\r\n                }\r\n\r\n                const optionsMRT: IMultiRenderTargetOptions = {\r\n                    samplingModes,\r\n                    generateMipMaps: textureArray[0].generateMipMaps,\r\n                    generateDepthBuffer: this._generateDepthBuffer,\r\n                    generateStencilBuffer: this._generateStencilBuffer,\r\n                    generateDepthTexture,\r\n                    depthTextureFormat,\r\n                    types,\r\n                    formats,\r\n                    textureCount,\r\n                    targetTypes,\r\n                    faceIndex,\r\n                    layerIndex,\r\n                    layerCounts,\r\n                    label: this.label,\r\n                };\r\n                const size = {\r\n                    width: this.width,\r\n                    height: this.height,\r\n                    depth: this.depth,\r\n                };\r\n\r\n                rtw = this._engine.createMultipleRenderTarget(size, optionsMRT);\r\n\r\n                for (let i = 0; i < textureCount; ++i) {\r\n                    if (targetTypes[i] !== -1) {\r\n                        continue;\r\n                    }\r\n                    const index = internalTexture2Index[textureArray[i].uniqueId];\r\n                    rtw.setTexture(rtw.textures![index], i);\r\n                }\r\n            }\r\n        } else {\r\n            const options: RenderTargetCreationOptions = {};\r\n\r\n            options.generateDepthBuffer = this._generateDepthBuffer;\r\n            options.generateMipMaps = this.texture?.generateMipMaps ?? false;\r\n            options.generateStencilBuffer = this._generateStencilBuffer;\r\n            options.samplingMode = this.texture?.samplingMode;\r\n            options.type = this.texture?.type;\r\n            options.format = this.texture?.format;\r\n            options.noColorAttachment = !this._textures;\r\n            options.label = this.label;\r\n\r\n            if (this.isCube) {\r\n                rtw = this._engine.createRenderTargetCubeTexture(this.width, options);\r\n            } else {\r\n                const size = {\r\n                    width: this.width,\r\n                    height: this.height,\r\n                    layers: this.is2DArray || this.is3D ? this.texture?.depth : undefined,\r\n                };\r\n\r\n                rtw = this._engine.createRenderTargetTexture(size, options);\r\n            }\r\n            if (rtw.texture) {\r\n                rtw.texture!.isReady = true;\r\n            }\r\n        }\r\n\r\n        return rtw;\r\n    }\r\n\r\n    protected _swapRenderTargetWrapper(target: RenderTargetWrapper): void {\r\n        if (this._textures && target._textures) {\r\n            for (let i = 0; i < this._textures.length; ++i) {\r\n                this._textures[i]._swapAndDie(target._textures[i], false);\r\n                target._textures[i].isReady = true;\r\n            }\r\n        }\r\n        if (this._depthStencilTexture && target._depthStencilTexture) {\r\n            this._depthStencilTexture._swapAndDie(target._depthStencilTexture);\r\n            target._depthStencilTexture.isReady = true;\r\n        }\r\n\r\n        this._textures = null;\r\n        this._depthStencilTexture = null;\r\n    }\r\n\r\n    /** @internal */\r\n    public _rebuild(): void {\r\n        const rtw = this._cloneRenderTargetWrapper();\r\n        if (!rtw) {\r\n            return;\r\n        }\r\n\r\n        if (this._depthStencilTexture) {\r\n            const samplingMode = this._depthStencilTexture.samplingMode;\r\n            const format = this._depthStencilTexture.format;\r\n            const bilinear =\r\n                samplingMode === Constants.TEXTURE_BILINEAR_SAMPLINGMODE ||\r\n                samplingMode === Constants.TEXTURE_TRILINEAR_SAMPLINGMODE ||\r\n                samplingMode === Constants.TEXTURE_LINEAR_LINEAR_MIPNEAREST;\r\n\r\n            rtw.createDepthStencilTexture(\r\n                this._depthStencilTexture._comparisonFunction,\r\n                bilinear,\r\n                this._depthStencilTextureWithStencil,\r\n                this._depthStencilTexture.samples,\r\n                format,\r\n                this._depthStencilTextureLabel\r\n            );\r\n        }\r\n\r\n        if (this.samples > 1) {\r\n            rtw.setSamples(this.samples);\r\n        }\r\n\r\n        rtw._swapRenderTargetWrapper(this);\r\n        rtw.dispose();\r\n    }\r\n\r\n    /**\r\n     * Releases the internal render textures\r\n     */\r\n    public releaseTextures(): void {\r\n        if (this._textures) {\r\n            for (let i = 0; i < this._textures.length; ++i) {\r\n                this._textures[i].dispose();\r\n            }\r\n        }\r\n        this._textures = null;\r\n    }\r\n\r\n    /**\r\n     * Disposes the whole render target wrapper\r\n     * @param disposeOnlyFramebuffers true if only the frame buffers should be released (used for the WebGL engine). If false, all the textures will also be released\r\n     */\r\n    public dispose(disposeOnlyFramebuffers = false): void {\r\n        if (!disposeOnlyFramebuffers) {\r\n            this._depthStencilTexture?.dispose();\r\n            this._depthStencilTexture = null;\r\n            this.releaseTextures();\r\n        }\r\n\r\n        this._engine._releaseRenderTargetWrapper(this);\r\n    }\r\n}\r\n", "import { IsDocumentAvailable } from \"../Misc/domManagement\";\r\nimport type { Nullable } from \"../types\";\r\nimport { AbstractEngine } from \"./abstractEngine\";\r\nimport type { AbstractEngineOptions } from \"./abstractEngine\";\r\nimport { EngineStore } from \"./engineStore\";\r\n\r\n/** @internal */\r\nfunction _DisableTouchAction(canvas: Nullable<HTMLCanvasElement>): void {\r\n    if (!canvas || !canvas.setAttribute) {\r\n        return;\r\n    }\r\n\r\n    canvas.setAttribute(\"touch-action\", \"none\");\r\n    canvas.style.touchAction = \"none\";\r\n    (canvas.style as any).webkitTapHighlightColor = \"transparent\";\r\n}\r\n\r\n/** @internal */\r\nexport function _CommonInit(commonEngine: AbstractEngine, canvas: HTMLCanvasElement, creationOptions: AbstractEngineOptions) {\r\n    commonEngine._onCanvasFocus = () => {\r\n        commonEngine.onCanvasFocusObservable.notifyObservers(commonEngine);\r\n    };\r\n\r\n    commonEngine._onCanvasBlur = () => {\r\n        commonEngine.onCanvasBlurObservable.notifyObservers(commonEngine);\r\n    };\r\n\r\n    commonEngine._onCanvasContextMenu = (evt: Event) => {\r\n        if (commonEngine.disableContextMenu) {\r\n            evt.preventDefault();\r\n        }\r\n    };\r\n\r\n    canvas.addEventListener(\"focus\", commonEngine._onCanvasFocus);\r\n    canvas.addEventListener(\"blur\", commonEngine._onCanvasBlur);\r\n    canvas.addEventListener(\"contextmenu\", commonEngine._onCanvasContextMenu);\r\n\r\n    commonEngine._onBlur = () => {\r\n        if (commonEngine.disablePerformanceMonitorInBackground) {\r\n            commonEngine.performanceMonitor.disable();\r\n        }\r\n        commonEngine._windowIsBackground = true;\r\n    };\r\n\r\n    commonEngine._onFocus = () => {\r\n        if (commonEngine.disablePerformanceMonitorInBackground) {\r\n            commonEngine.performanceMonitor.enable();\r\n        }\r\n        commonEngine._windowIsBackground = false;\r\n    };\r\n\r\n    commonEngine._onCanvasPointerOut = (ev) => {\r\n        // Check that the element at the point of the pointer out isn't the canvas and if it isn't, notify observers\r\n        // Note: This is a workaround for a bug with Safari\r\n        if (document.elementFromPoint(ev.clientX, ev.clientY) !== canvas) {\r\n            commonEngine.onCanvasPointerOutObservable.notifyObservers(ev);\r\n        }\r\n    };\r\n\r\n    const hostWindow = commonEngine.getHostWindow(); // it calls IsWindowObjectExist()\r\n    if (hostWindow && typeof hostWindow.addEventListener === \"function\") {\r\n        hostWindow.addEventListener(\"blur\", commonEngine._onBlur);\r\n        hostWindow.addEventListener(\"focus\", commonEngine._onFocus);\r\n    }\r\n\r\n    canvas.addEventListener(\"pointerout\", commonEngine._onCanvasPointerOut);\r\n\r\n    if (!creationOptions.doNotHandleTouchAction) {\r\n        _DisableTouchAction(canvas);\r\n    }\r\n\r\n    // Create Audio Engine if needed.\r\n    if (!AbstractEngine.audioEngine && creationOptions.audioEngine && AbstractEngine.AudioEngineFactory) {\r\n        AbstractEngine.audioEngine = AbstractEngine.AudioEngineFactory(commonEngine.getRenderingCanvas(), commonEngine.getAudioContext(), commonEngine.getAudioDestination());\r\n    }\r\n    if (IsDocumentAvailable()) {\r\n        // Fullscreen\r\n        commonEngine._onFullscreenChange = () => {\r\n            commonEngine.isFullscreen = !!document.fullscreenElement;\r\n\r\n            // Pointer lock\r\n            if (commonEngine.isFullscreen && commonEngine._pointerLockRequested && canvas) {\r\n                RequestPointerlock(canvas);\r\n            }\r\n        };\r\n\r\n        document.addEventListener(\"fullscreenchange\", commonEngine._onFullscreenChange, false);\r\n        document.addEventListener(\"webkitfullscreenchange\", commonEngine._onFullscreenChange, false);\r\n\r\n        // Pointer lock\r\n        commonEngine._onPointerLockChange = () => {\r\n            commonEngine.isPointerLock = document.pointerLockElement === canvas;\r\n        };\r\n\r\n        document.addEventListener(\"pointerlockchange\", commonEngine._onPointerLockChange, false);\r\n        document.addEventListener(\"webkitpointerlockchange\", commonEngine._onPointerLockChange, false);\r\n    }\r\n\r\n    commonEngine.enableOfflineSupport = AbstractEngine.OfflineProviderFactory !== undefined;\r\n\r\n    commonEngine._deterministicLockstep = !!creationOptions.deterministicLockstep;\r\n    commonEngine._lockstepMaxSteps = creationOptions.lockstepMaxSteps || 0;\r\n    commonEngine._timeStep = creationOptions.timeStep || 1 / 60;\r\n}\r\n\r\n/** @internal */\r\nexport function _CommonDispose(commonEngine: AbstractEngine, canvas: Nullable<HTMLCanvasElement>) {\r\n    // Release audio engine\r\n    if (EngineStore.Instances.length === 1 && AbstractEngine.audioEngine) {\r\n        AbstractEngine.audioEngine.dispose();\r\n        AbstractEngine.audioEngine = null;\r\n    }\r\n\r\n    // Events\r\n    const hostWindow = commonEngine.getHostWindow(); // it calls IsWindowObjectExist()\r\n    if (hostWindow && typeof hostWindow.removeEventListener === \"function\") {\r\n        hostWindow.removeEventListener(\"blur\", commonEngine._onBlur);\r\n        hostWindow.removeEventListener(\"focus\", commonEngine._onFocus);\r\n    }\r\n\r\n    if (canvas) {\r\n        canvas.removeEventListener(\"focus\", commonEngine._onCanvasFocus);\r\n        canvas.removeEventListener(\"blur\", commonEngine._onCanvasBlur);\r\n        canvas.removeEventListener(\"pointerout\", commonEngine._onCanvasPointerOut);\r\n        canvas.removeEventListener(\"contextmenu\", commonEngine._onCanvasContextMenu);\r\n    }\r\n\r\n    if (IsDocumentAvailable()) {\r\n        document.removeEventListener(\"fullscreenchange\", commonEngine._onFullscreenChange);\r\n        document.removeEventListener(\"mozfullscreenchange\", commonEngine._onFullscreenChange);\r\n        document.removeEventListener(\"webkitfullscreenchange\", commonEngine._onFullscreenChange);\r\n        document.removeEventListener(\"msfullscreenchange\", commonEngine._onFullscreenChange);\r\n        document.removeEventListener(\"pointerlockchange\", commonEngine._onPointerLockChange);\r\n        document.removeEventListener(\"mspointerlockchange\", commonEngine._onPointerLockChange);\r\n        document.removeEventListener(\"mozpointerlockchange\", commonEngine._onPointerLockChange);\r\n        document.removeEventListener(\"webkitpointerlockchange\", commonEngine._onPointerLockChange);\r\n    }\r\n}\r\n\r\n/**\r\n * Get Font size information\r\n * @param font font name\r\n * @returns an object containing ascent, height and descent\r\n */\r\nexport function GetFontOffset(font: string): { ascent: number; height: number; descent: number } {\r\n    const text = document.createElement(\"span\");\r\n    text.textContent = \"Hg\";\r\n    text.style.font = font;\r\n\r\n    const block = document.createElement(\"div\");\r\n    block.style.display = \"inline-block\";\r\n    block.style.width = \"1px\";\r\n    block.style.height = \"0px\";\r\n    block.style.verticalAlign = \"bottom\";\r\n\r\n    const div = document.createElement(\"div\");\r\n    div.style.whiteSpace = \"nowrap\";\r\n    div.appendChild(text);\r\n    div.appendChild(block);\r\n\r\n    document.body.appendChild(div);\r\n\r\n    let fontAscent = 0;\r\n    let fontHeight = 0;\r\n    try {\r\n        fontHeight = block.getBoundingClientRect().top - text.getBoundingClientRect().top;\r\n        block.style.verticalAlign = \"baseline\";\r\n        fontAscent = block.getBoundingClientRect().top - text.getBoundingClientRect().top;\r\n    } finally {\r\n        document.body.removeChild(div);\r\n    }\r\n    return { ascent: fontAscent, height: fontHeight, descent: fontHeight - fontAscent };\r\n}\r\n\r\n/** @internal */\r\nexport function CreateImageBitmapFromSource(engine: AbstractEngine, imageSource: string, options?: ImageBitmapOptions): Promise<ImageBitmap> {\r\n    const promise = new Promise<ImageBitmap>((resolve, reject) => {\r\n        const image = new Image();\r\n        image.onload = () => {\r\n            image.decode().then(() => {\r\n                engine.createImageBitmap(image, options).then((imageBitmap) => {\r\n                    resolve(imageBitmap);\r\n                });\r\n            });\r\n        };\r\n        image.onerror = () => {\r\n            reject(`Error loading image ${image.src}`);\r\n        };\r\n\r\n        image.src = imageSource;\r\n    });\r\n\r\n    return promise;\r\n}\r\n\r\n/** @internal */\r\nexport function ResizeImageBitmap(engine: AbstractEngine, image: HTMLImageElement | ImageBitmap, bufferWidth: number, bufferHeight: number): Uint8Array {\r\n    const canvas = engine.createCanvas(bufferWidth, bufferHeight);\r\n    const context = canvas.getContext(\"2d\");\r\n\r\n    if (!context) {\r\n        throw new Error(\"Unable to get 2d context for resizeImageBitmap\");\r\n    }\r\n\r\n    context.drawImage(image, 0, 0);\r\n\r\n    // Create VertexData from map data\r\n    // Cast is due to wrong definition in lib.d.ts from ts 1.3 - https://github.com/Microsoft/TypeScript/issues/949\r\n    const buffer = <Uint8Array>(<any>context.getImageData(0, 0, bufferWidth, bufferHeight).data);\r\n    return buffer;\r\n}\r\n\r\n/**\r\n * Ask the browser to promote the current element to fullscreen rendering mode\r\n * @param element defines the DOM element to promote\r\n */\r\nexport function RequestFullscreen(element: HTMLElement): void {\r\n    const requestFunction = element.requestFullscreen || (<any>element).webkitRequestFullscreen;\r\n    if (!requestFunction) {\r\n        return;\r\n    }\r\n    requestFunction.call(element);\r\n}\r\n\r\n/**\r\n * Asks the browser to exit fullscreen mode\r\n */\r\nexport function ExitFullscreen(): void {\r\n    const anyDoc = document as any;\r\n\r\n    if (document.exitFullscreen) {\r\n        document.exitFullscreen();\r\n    } else if (anyDoc.webkitCancelFullScreen) {\r\n        anyDoc.webkitCancelFullScreen();\r\n    }\r\n}\r\n\r\n/**\r\n * Ask the browser to promote the current element to pointerlock mode\r\n * @param element defines the DOM element to promote\r\n */\r\nexport function RequestPointerlock(element: HTMLElement): void {\r\n    if (element.requestPointerLock) {\r\n        // In some browsers, requestPointerLock returns a promise.\r\n        // Handle possible rejections to avoid an unhandled top-level exception.\r\n        const promise: unknown = element.requestPointerLock();\r\n        if (promise instanceof Promise)\r\n            promise\r\n                .then(() => {\r\n                    element.focus();\r\n                })\r\n                .catch(() => {});\r\n        else element.focus();\r\n    }\r\n}\r\n\r\n/**\r\n * Asks the browser to exit pointerlock mode\r\n */\r\nexport function ExitPointerlock(): void {\r\n    if (document.exitPointerLock) {\r\n        document.exitPointerLock();\r\n    }\r\n}\r\n", "import type { Analyser } from \"./analyser\";\r\n\r\nimport type { Nullable } from \"../types\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { AbstractEngine } from \"../Engines/abstractEngine\";\r\nimport type { IAudioEngine } from \"./Interfaces/IAudioEngine\";\r\nimport { IsWindowObjectExist } from \"../Misc/domManagement\";\r\n\r\n// Sets the default audio engine to Babylon.js\r\nAbstractEngine.AudioEngineFactory = (\r\n    hostElement: Nullable<HTMLElement>,\r\n    audioContext: Nullable<AudioContext>,\r\n    audioDestination: Nullable<AudioDestinationNode | MediaStreamAudioDestinationNode>\r\n) => {\r\n    return new AudioEngine(hostElement, audioContext, audioDestination);\r\n};\r\n\r\n/**\r\n * This represents the default audio engine used in babylon.\r\n * It is responsible to play, synchronize and analyse sounds throughout the  application.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic\r\n */\r\nexport class AudioEngine implements IAudioEngine {\r\n    private _audioContext: Nullable<AudioContext> = null;\r\n    private _audioContextInitialized = false;\r\n    private _muteButton: Nullable<HTMLButtonElement> = null;\r\n    private _hostElement: Nullable<HTMLElement>;\r\n    private _audioDestination: Nullable<AudioDestinationNode | MediaStreamAudioDestinationNode> = null;\r\n\r\n    /**\r\n     * Gets whether the current host supports Web Audio and thus could create AudioContexts.\r\n     */\r\n    public canUseWebAudio: boolean = false;\r\n\r\n    /**\r\n     * The master gain node defines the global audio volume of your audio engine.\r\n     */\r\n    public masterGain: GainNode;\r\n\r\n    /**\r\n     * Defines if Babylon should emit a warning if WebAudio is not supported.\r\n     * @ignoreNaming\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public WarnedWebAudioUnsupported: boolean = false;\r\n\r\n    /**\r\n     * Gets whether or not mp3 are supported by your browser.\r\n     */\r\n    public isMP3supported: boolean = false;\r\n\r\n    /**\r\n     * Gets whether or not ogg are supported by your browser.\r\n     */\r\n    public isOGGsupported: boolean = false;\r\n\r\n    /**\r\n     * Gets whether audio has been unlocked on the device.\r\n     * Some Browsers have strong restrictions about Audio and won't autoplay unless\r\n     * a user interaction has happened.\r\n     */\r\n    public unlocked: boolean = false;\r\n\r\n    /**\r\n     * Defines if the audio engine relies on a custom unlocked button.\r\n     * In this case, the embedded button will not be displayed.\r\n     */\r\n    public useCustomUnlockedButton: boolean = false;\r\n\r\n    /**\r\n     * Event raised when audio has been unlocked on the browser.\r\n     */\r\n    public onAudioUnlockedObservable = new Observable<IAudioEngine>();\r\n\r\n    /**\r\n     * Event raised when audio has been locked on the browser.\r\n     */\r\n    public onAudioLockedObservable = new Observable<IAudioEngine>();\r\n\r\n    /**\r\n     * Gets the current AudioContext if available.\r\n     */\r\n    public get audioContext(): Nullable<AudioContext> {\r\n        if (!this._audioContextInitialized) {\r\n            this._initializeAudioContext();\r\n        }\r\n        return this._audioContext;\r\n    }\r\n\r\n    private _connectedAnalyser: Nullable<Analyser>;\r\n\r\n    /**\r\n     * Instantiates a new audio engine.\r\n     *\r\n     * There should be only one per page as some browsers restrict the number\r\n     * of audio contexts you can create.\r\n     * @param hostElement defines the host element where to display the mute icon if necessary\r\n     * @param audioContext defines the audio context to be used by the audio engine\r\n     * @param audioDestination defines the audio destination node to be used by audio engine\r\n     */\r\n    constructor(\r\n        hostElement: Nullable<HTMLElement> = null,\r\n        audioContext: Nullable<AudioContext> = null,\r\n        audioDestination: Nullable<AudioDestinationNode | MediaStreamAudioDestinationNode> = null\r\n    ) {\r\n        if (!IsWindowObjectExist()) {\r\n            return;\r\n        }\r\n        if (typeof window.AudioContext !== \"undefined\") {\r\n            this.canUseWebAudio = true;\r\n        }\r\n\r\n        const audioElem = document.createElement(\"audio\");\r\n        this._hostElement = hostElement;\r\n        this._audioContext = audioContext;\r\n        this._audioDestination = audioDestination;\r\n\r\n        try {\r\n            if (\r\n                audioElem &&\r\n                !!audioElem.canPlayType &&\r\n                (audioElem.canPlayType('audio/mpeg; codecs=\"mp3\"').replace(/^no$/, \"\") || audioElem.canPlayType(\"audio/mp3\").replace(/^no$/, \"\"))\r\n            ) {\r\n                this.isMP3supported = true;\r\n            }\r\n        } catch (e) {\r\n            // protect error during capability check.\r\n        }\r\n\r\n        try {\r\n            if (audioElem && !!audioElem.canPlayType && audioElem.canPlayType('audio/ogg; codecs=\"vorbis\"').replace(/^no$/, \"\")) {\r\n                this.isOGGsupported = true;\r\n            }\r\n        } catch (e) {\r\n            // protect error during capability check.\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Flags the audio engine in Locked state.\r\n     * This happens due to new browser policies preventing audio to autoplay.\r\n     */\r\n    public lock() {\r\n        this._triggerSuspendedState();\r\n    }\r\n\r\n    /**\r\n     * Unlocks the audio engine once a user action has been done on the dom.\r\n     * This is helpful to resume play once browser policies have been satisfied.\r\n     */\r\n    public unlock() {\r\n        if (this._audioContext?.state === \"running\") {\r\n            this._hideMuteButton();\r\n\r\n            if (!this.unlocked) {\r\n                // Notify users that the audio stack is unlocked/unmuted\r\n                this.unlocked = true;\r\n                this.onAudioUnlockedObservable.notifyObservers(this);\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        // On iOS, if the audio context resume request was sent from an event other than a `click` event, then\r\n        // the resume promise will never resolve and the only way to get the audio context unstuck is to\r\n        // suspend it and make another resume request.\r\n        if (this._tryToRun) {\r\n            this._audioContext?.suspend().then(() => {\r\n                this._tryToRun = false;\r\n                this._triggerRunningState();\r\n            });\r\n        } else {\r\n            this._triggerRunningState();\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _resumeAudioContextOnStateChange(): void {\r\n        this._audioContext?.addEventListener(\r\n            \"statechange\",\r\n            () => {\r\n                if (this.unlocked && this._audioContext?.state !== \"running\") {\r\n                    this._resumeAudioContext();\r\n                }\r\n            },\r\n            {\r\n                once: true,\r\n                passive: true,\r\n                signal: AbortSignal.timeout(3000),\r\n            }\r\n        );\r\n    }\r\n\r\n    private _resumeAudioContext(): Promise<void> {\r\n        if (this._audioContext?.resume) {\r\n            return this._audioContext.resume();\r\n        }\r\n        return Promise.resolve();\r\n    }\r\n\r\n    private _initializeAudioContext() {\r\n        try {\r\n            if (this.canUseWebAudio) {\r\n                if (!this._audioContext) {\r\n                    this._audioContext = new AudioContext();\r\n                }\r\n                // create a global volume gain node\r\n                this.masterGain = this._audioContext.createGain();\r\n                this.masterGain.gain.value = 1;\r\n                if (!this._audioDestination) {\r\n                    this._audioDestination = this._audioContext.destination;\r\n                }\r\n                this.masterGain.connect(this._audioDestination);\r\n                this._audioContextInitialized = true;\r\n                if (this._audioContext.state === \"running\") {\r\n                    // Do not wait for the promise to unlock.\r\n                    this._triggerRunningState();\r\n                }\r\n            }\r\n        } catch (e) {\r\n            this.canUseWebAudio = false;\r\n            Logger.Error(\"Web Audio: \" + e.message);\r\n        }\r\n    }\r\n\r\n    private _tryToRun = false;\r\n    private _triggerRunningState() {\r\n        if (this._tryToRun) {\r\n            return;\r\n        }\r\n        this._tryToRun = true;\r\n\r\n        this._resumeAudioContext()\r\n            .then(() => {\r\n                this._tryToRun = false;\r\n                if (this._muteButton) {\r\n                    this._hideMuteButton();\r\n                }\r\n                // Notify users that the audio stack is unlocked/unmuted\r\n                this.unlocked = true;\r\n                this.onAudioUnlockedObservable.notifyObservers(this);\r\n            })\r\n            .catch(() => {\r\n                this._tryToRun = false;\r\n                this.unlocked = false;\r\n            });\r\n    }\r\n\r\n    private _triggerSuspendedState() {\r\n        this.unlocked = false;\r\n        this.onAudioLockedObservable.notifyObservers(this);\r\n        this._displayMuteButton();\r\n    }\r\n\r\n    private _displayMuteButton() {\r\n        if (this.useCustomUnlockedButton || this._muteButton) {\r\n            return;\r\n        }\r\n\r\n        this._muteButton = <HTMLButtonElement>document.createElement(\"BUTTON\");\r\n        this._muteButton.className = \"babylonUnmuteIcon\";\r\n        this._muteButton.id = \"babylonUnmuteIconBtn\";\r\n        this._muteButton.title = \"Unmute\";\r\n        const imageUrl = !window.SVGSVGElement\r\n            ? \"https://cdn.babylonjs.com/Assets/audio.png\"\r\n            : \"data:image/svg+xml;charset=UTF-8,%3Csvg%20version%3D%221.1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2239%22%20height%3D%2232%22%20viewBox%3D%220%200%2039%2032%22%3E%3Cpath%20fill%3D%22white%22%20d%3D%22M9.625%2018.938l-0.031%200.016h-4.953q-0.016%200-0.031-0.016v-12.453q0-0.016%200.031-0.016h4.953q0.031%200%200.031%200.016v12.453zM12.125%207.688l8.719-8.703v27.453l-8.719-8.719-0.016-0.047v-9.938zM23.359%207.875l1.406-1.406%204.219%204.203%204.203-4.203%201.422%201.406-4.219%204.219%204.219%204.203-1.484%201.359-4.141-4.156-4.219%204.219-1.406-1.422%204.219-4.203z%22%3E%3C%2Fpath%3E%3C%2Fsvg%3E\";\r\n\r\n        const css =\r\n            \".babylonUnmuteIcon { position: absolute; left: 20px; top: 20px; height: 40px; width: 60px; background-color: rgba(51,51,51,0.7); background-image: url(\" +\r\n            imageUrl +\r\n            \");  background-size: 80%; background-repeat:no-repeat; background-position: center; background-position-y: 4px; border: none; outline: none; transition: transform 0.125s ease-out; cursor: pointer; z-index: 9999; } .babylonUnmuteIcon:hover { transform: scale(1.05) } .babylonUnmuteIcon:active { background-color: rgba(51,51,51,1) }\";\r\n\r\n        const style = document.createElement(\"style\");\r\n        style.appendChild(document.createTextNode(css));\r\n        document.getElementsByTagName(\"head\")[0].appendChild(style);\r\n\r\n        document.body.appendChild(this._muteButton);\r\n\r\n        this._moveButtonToTopLeft();\r\n\r\n        this._muteButton.addEventListener(\r\n            \"touchend\",\r\n            () => {\r\n                this._triggerRunningState();\r\n            },\r\n            true\r\n        );\r\n        this._muteButton.addEventListener(\r\n            \"click\",\r\n            () => {\r\n                this.unlock();\r\n            },\r\n            true\r\n        );\r\n\r\n        window.addEventListener(\"resize\", this._onResize);\r\n    }\r\n\r\n    private _moveButtonToTopLeft() {\r\n        if (this._hostElement && this._muteButton) {\r\n            this._muteButton.style.top = this._hostElement.offsetTop + 20 + \"px\";\r\n            this._muteButton.style.left = this._hostElement.offsetLeft + 20 + \"px\";\r\n        }\r\n    }\r\n\r\n    private _onResize = () => {\r\n        this._moveButtonToTopLeft();\r\n    };\r\n\r\n    private _hideMuteButton() {\r\n        if (this._muteButton) {\r\n            document.body.removeChild(this._muteButton);\r\n            this._muteButton = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Destroy and release the resources associated with the audio context.\r\n     */\r\n    public dispose(): void {\r\n        if (this.canUseWebAudio && this._audioContextInitialized) {\r\n            if (this._connectedAnalyser && this._audioContext) {\r\n                this._connectedAnalyser.stopDebugCanvas();\r\n                this._connectedAnalyser.dispose();\r\n                this.masterGain.disconnect();\r\n                this.masterGain.connect(this._audioContext.destination);\r\n                this._connectedAnalyser = null;\r\n            }\r\n            this.masterGain.gain.value = 1;\r\n        }\r\n        this.WarnedWebAudioUnsupported = false;\r\n        this._hideMuteButton();\r\n        window.removeEventListener(\"resize\", this._onResize);\r\n\r\n        this.onAudioUnlockedObservable.clear();\r\n        this.onAudioLockedObservable.clear();\r\n    }\r\n\r\n    /**\r\n     * Gets the global volume sets on the master gain.\r\n     * @returns the global volume if set or -1 otherwise\r\n     */\r\n    public getGlobalVolume(): number {\r\n        if (this.canUseWebAudio && this._audioContextInitialized) {\r\n            return this.masterGain.gain.value;\r\n        } else {\r\n            return -1;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the global volume of your experience (sets on the master gain).\r\n     * @param newVolume Defines the new global volume of the application\r\n     */\r\n    public setGlobalVolume(newVolume: number): void {\r\n        if (this.canUseWebAudio && this._audioContextInitialized) {\r\n            this.masterGain.gain.value = newVolume;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Connect the audio engine to an audio analyser allowing some amazing\r\n     * synchronization between the sounds/music and your visualization (VuMeter for instance).\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#using-the-analyser\r\n     * @param analyser The analyser to connect to the engine\r\n     */\r\n    public connectToAnalyser(analyser: Analyser): void {\r\n        if (this._connectedAnalyser) {\r\n            this._connectedAnalyser.stopDebugCanvas();\r\n        }\r\n        if (this.canUseWebAudio && this._audioContextInitialized && this._audioContext) {\r\n            this._connectedAnalyser = analyser;\r\n            this.masterGain.disconnect();\r\n            this._connectedAnalyser.connectAudioNodes(this.masterGain, this._audioContext.destination);\r\n        }\r\n    }\r\n}\r\n", "import { ThinEngine } from \"../../Engines/thinEngine\";\r\nimport { Constants } from \"../constants\";\r\n\r\ndeclare module \"../abstractEngine\" {\r\n    export interface AbstractEngine {\r\n        /**\r\n         * Sets the current alpha mode\r\n         * @param mode defines the mode to use (one of the Engine.ALPHA_XXX)\r\n         * @param noDepthWriteChange defines if depth writing state should remains unchanged (false by default)\r\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/advanced/transparent_rendering\r\n         */\r\n        setAlphaMode(mode: number, noDepthWriteChange?: boolean): void;\r\n    }\r\n}\r\n\r\nThinEngine.prototype.setAlphaMode = function (mode: number, noDepthWriteChange: boolean = false): void {\r\n    if (this._alphaMode === mode) {\r\n        if (!noDepthWriteChange) {\r\n            // Make sure we still have the correct depth mask according to the alpha mode (a transparent material could have forced writting to the depth buffer, for instance)\r\n            const depthMask = mode === Constants.ALPHA_DISABLE;\r\n            if (this.depthCullingState.depthMask !== depthMask) {\r\n                this.depthCullingState.depthMask = depthMask;\r\n            }\r\n        }\r\n        return;\r\n    }\r\n\r\n    switch (mode) {\r\n        case Constants.ALPHA_DISABLE:\r\n            this._alphaState.alphaBlend = false;\r\n            break;\r\n        case Constants.ALPHA_PREMULTIPLIED:\r\n            this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA, this._gl.ONE, this._gl.ONE);\r\n            this._alphaState.alphaBlend = true;\r\n            break;\r\n        case Constants.ALPHA_PREMULTIPLIED_PORTERDUFF:\r\n            this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA, this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA);\r\n            this._alphaState.alphaBlend = true;\r\n            break;\r\n        case Constants.ALPHA_COMBINE:\r\n            this._alphaState.setAlphaBlendFunctionParameters(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_ALPHA, this._gl.ONE, this._gl.ONE);\r\n            this._alphaState.alphaBlend = true;\r\n            break;\r\n        case Constants.ALPHA_ONEONE:\r\n            this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE, this._gl.ZERO, this._gl.ONE);\r\n            this._alphaState.alphaBlend = true;\r\n            break;\r\n        case Constants.ALPHA_ADD:\r\n            this._alphaState.setAlphaBlendFunctionParameters(this._gl.SRC_ALPHA, this._gl.ONE, this._gl.ZERO, this._gl.ONE);\r\n            this._alphaState.alphaBlend = true;\r\n            break;\r\n        case Constants.ALPHA_SUBTRACT:\r\n            this._alphaState.setAlphaBlendFunctionParameters(this._gl.ZERO, this._gl.ONE_MINUS_SRC_COLOR, this._gl.ONE, this._gl.ONE);\r\n            this._alphaState.alphaBlend = true;\r\n            break;\r\n        case Constants.ALPHA_MULTIPLY:\r\n            this._alphaState.setAlphaBlendFunctionParameters(this._gl.DST_COLOR, this._gl.ZERO, this._gl.ONE, this._gl.ONE);\r\n            this._alphaState.alphaBlend = true;\r\n            break;\r\n        case Constants.ALPHA_MAXIMIZED:\r\n            this._alphaState.setAlphaBlendFunctionParameters(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_COLOR, this._gl.ONE, this._gl.ONE);\r\n            this._alphaState.alphaBlend = true;\r\n            break;\r\n        case Constants.ALPHA_INTERPOLATE:\r\n            this._alphaState.setAlphaBlendFunctionParameters(\r\n                this._gl.CONSTANT_COLOR,\r\n                this._gl.ONE_MINUS_CONSTANT_COLOR,\r\n                this._gl.CONSTANT_ALPHA,\r\n                this._gl.ONE_MINUS_CONSTANT_ALPHA\r\n            );\r\n            this._alphaState.alphaBlend = true;\r\n            break;\r\n        case Constants.ALPHA_SCREENMODE:\r\n            this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE_MINUS_SRC_COLOR, this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA);\r\n            this._alphaState.alphaBlend = true;\r\n            break;\r\n        case Constants.ALPHA_ONEONE_ONEONE:\r\n            this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE, this._gl.ONE, this._gl.ONE);\r\n            this._alphaState.alphaBlend = true;\r\n            break;\r\n        case Constants.ALPHA_ALPHATOCOLOR:\r\n            this._alphaState.setAlphaBlendFunctionParameters(this._gl.DST_ALPHA, this._gl.ONE, this._gl.ZERO, this._gl.ZERO);\r\n            this._alphaState.alphaBlend = true;\r\n            break;\r\n        case Constants.ALPHA_REVERSEONEMINUS:\r\n            this._alphaState.setAlphaBlendFunctionParameters(\r\n                this._gl.ONE_MINUS_DST_COLOR,\r\n                this._gl.ONE_MINUS_SRC_COLOR,\r\n                this._gl.ONE_MINUS_DST_ALPHA,\r\n                this._gl.ONE_MINUS_SRC_ALPHA\r\n            );\r\n            this._alphaState.alphaBlend = true;\r\n            break;\r\n        case Constants.ALPHA_SRC_DSTONEMINUSSRCALPHA:\r\n            this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA, this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA);\r\n            this._alphaState.alphaBlend = true;\r\n            break;\r\n        case Constants.ALPHA_ONEONE_ONEZERO:\r\n            this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE, this._gl.ONE, this._gl.ZERO);\r\n            this._alphaState.alphaBlend = true;\r\n            break;\r\n        case Constants.ALPHA_EXCLUSION:\r\n            this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE_MINUS_DST_COLOR, this._gl.ONE_MINUS_SRC_COLOR, this._gl.ZERO, this._gl.ONE);\r\n            this._alphaState.alphaBlend = true;\r\n            break;\r\n        case Constants.ALPHA_LAYER_ACCUMULATE:\r\n            // Same as ALPHA_COMBINE but accumulates (1 - alpha) values in the alpha channel for a later readout in order independant transparency\r\n            this._alphaState.setAlphaBlendFunctionParameters(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_ALPHA, this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA);\r\n            this._alphaState.alphaBlend = true;\r\n            break;\r\n    }\r\n    if (!noDepthWriteChange) {\r\n        this.depthCullingState.depthMask = mode === Constants.ALPHA_DISABLE;\r\n    }\r\n    this._alphaMode = mode;\r\n};\r\n", "import type { Nullable } from \"../../types\";\r\nimport { InternalTexture, InternalTextureSource } from \"../../Materials/Textures/internalTexture\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Constants } from \"../constants\";\r\nimport { ThinEngine } from \"../thinEngine\";\r\nimport type { IWebRequest } from \"../../Misc/interfaces/iWebRequest\";\r\nimport { IsExponentOfTwo } from \"../../Misc/tools.functions\";\r\n\r\ndeclare module \"../abstractEngine\" {\r\n    export interface AbstractEngine {\r\n        /**\r\n         * Update a raw texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store in the texture\r\n         * @param format defines the format of the data\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         */\r\n        updateRawTexture(texture: Nullable<InternalTexture>, data: Nullable<ArrayBufferView>, format: number, invertY: boolean): void;\r\n\r\n        /**\r\n         * Update a raw texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store in the texture\r\n         * @param format defines the format of the data\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param compression defines the compression used (null by default)\r\n         * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_BYTE by default)\r\n         * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\r\n         */\r\n        updateRawTexture(\r\n            texture: Nullable<InternalTexture>,\r\n            data: Nullable<ArrayBufferView>,\r\n            format: number,\r\n            invertY: boolean,\r\n            compression: Nullable<string>,\r\n            type: number,\r\n            useSRGBBuffer: boolean\r\n        ): void;\r\n        /**\r\n         * Update a raw cube texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store\r\n         * @param format defines the data format\r\n         * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_BYTE by default)\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         */\r\n        updateRawCubeTexture(texture: InternalTexture, data: ArrayBufferView[], format: number, type: number, invertY: boolean): void;\r\n\r\n        /**\r\n         * Update a raw cube texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store\r\n         * @param format defines the data format\r\n         * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_BYTE by default)\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param compression defines the compression used (null by default)\r\n         */\r\n        updateRawCubeTexture(texture: InternalTexture, data: ArrayBufferView[], format: number, type: number, invertY: boolean, compression: Nullable<string>): void;\r\n\r\n        /**\r\n         * Update a raw cube texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store\r\n         * @param format defines the data format\r\n         * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_BYTE by default)\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param compression defines the compression used (null by default)\r\n         * @param level defines which level of the texture to update\r\n         */\r\n        updateRawCubeTexture(texture: InternalTexture, data: ArrayBufferView[], format: number, type: number, invertY: boolean, compression: Nullable<string>, level: number): void;\r\n\r\n        /**\r\n         * Creates a new raw cube texture from a specified url\r\n         * @param url defines the url where the data is located\r\n         * @param scene defines the current scene\r\n         * @param size defines the size of the textures\r\n         * @param format defines the format of the data\r\n         * @param type defines the type fo the data (like Engine.TEXTURETYPE_UNSIGNED_BYTE)\r\n         * @param noMipmap defines if the engine should avoid generating the mip levels\r\n         * @param callback defines a callback used to extract texture data from loaded data\r\n         * @param mipmapGenerator defines to provide an optional tool to generate mip levels\r\n         * @param onLoad defines a callback called when texture is loaded\r\n         * @param onError defines a callback called if there is an error\r\n         * @returns the cube texture as an InternalTexture\r\n         */\r\n        createRawCubeTextureFromUrl(\r\n            url: string,\r\n            scene: Nullable<Scene>,\r\n            size: number,\r\n            format: number,\r\n            type: number,\r\n            noMipmap: boolean,\r\n            callback: (ArrayBuffer: ArrayBuffer) => Nullable<ArrayBufferView[]>,\r\n            mipmapGenerator: Nullable<(faces: ArrayBufferView[]) => ArrayBufferView[][]>,\r\n            onLoad: Nullable<() => void>,\r\n            onError: Nullable<(message?: string, exception?: any) => void>\r\n        ): InternalTexture;\r\n\r\n        /**\r\n         * Creates a new raw cube texture from a specified url\r\n         * @param url defines the url where the data is located\r\n         * @param scene defines the current scene\r\n         * @param size defines the size of the textures\r\n         * @param format defines the format of the data\r\n         * @param type defines the type fo the data (like Engine.TEXTURETYPE_UNSIGNED_BYTE)\r\n         * @param noMipmap defines if the engine should avoid generating the mip levels\r\n         * @param callback defines a callback used to extract texture data from loaded data\r\n         * @param mipmapGenerator defines to provide an optional tool to generate mip levels\r\n         * @param onLoad defines a callback called when texture is loaded\r\n         * @param onError defines a callback called if there is an error\r\n         * @param samplingMode defines the required sampling mode (like Texture.NEAREST_SAMPLINGMODE)\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @returns the cube texture as an InternalTexture\r\n         */\r\n        createRawCubeTextureFromUrl(\r\n            url: string,\r\n            scene: Nullable<Scene>,\r\n            size: number,\r\n            format: number,\r\n            type: number,\r\n            noMipmap: boolean,\r\n            callback: (ArrayBuffer: ArrayBuffer) => Nullable<ArrayBufferView[]>,\r\n            mipmapGenerator: Nullable<(faces: ArrayBufferView[]) => ArrayBufferView[][]>,\r\n            onLoad: Nullable<() => void>,\r\n            onError: Nullable<(message?: string, exception?: any) => void>,\r\n            samplingMode: number,\r\n            invertY: boolean\r\n        ): InternalTexture;\r\n\r\n        /**\r\n         * Update a raw 3D texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store\r\n         * @param format defines the data format\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         */\r\n        updateRawTexture3D(texture: InternalTexture, data: Nullable<ArrayBufferView>, format: number, invertY: boolean): void;\r\n\r\n        /**\r\n         * Update a raw 3D texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store\r\n         * @param format defines the data format\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param compression defines the used compression (can be null)\r\n         * @param textureType defines the texture Type (Engine.TEXTURETYPE_UNSIGNED_BYTE, Engine.TEXTURETYPE_FLOAT...)\r\n         */\r\n        updateRawTexture3D(texture: InternalTexture, data: Nullable<ArrayBufferView>, format: number, invertY: boolean, compression: Nullable<string>, textureType: number): void;\r\n\r\n        /**\r\n         * Update a raw 2D array texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store\r\n         * @param format defines the data format\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         */\r\n        updateRawTexture2DArray(texture: InternalTexture, data: Nullable<ArrayBufferView>, format: number, invertY: boolean): void;\r\n\r\n        /**\r\n         * Update a raw 2D array texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store\r\n         * @param format defines the data format\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param compression defines the used compression (can be null)\r\n         * @param textureType defines the texture Type (Engine.TEXTURETYPE_UNSIGNED_BYTE, Engine.TEXTURETYPE_FLOAT...)\r\n         */\r\n        updateRawTexture2DArray(\r\n            texture: InternalTexture,\r\n            data: Nullable<ArrayBufferView>,\r\n            format: number,\r\n            invertY: boolean,\r\n            compression: Nullable<string>,\r\n            textureType: number\r\n        ): void;\r\n    }\r\n}\r\n\r\nThinEngine.prototype.updateRawTexture = function (\r\n    texture: Nullable<InternalTexture>,\r\n    data: Nullable<ArrayBufferView>,\r\n    format: number,\r\n    invertY: boolean,\r\n    compression: Nullable<string> = null,\r\n    type: number = Constants.TEXTURETYPE_UNSIGNED_BYTE,\r\n    useSRGBBuffer: boolean = false\r\n): void {\r\n    if (!texture) {\r\n        return;\r\n    }\r\n    // Babylon's internalSizedFomat but gl's texImage2D internalFormat\r\n    const internalSizedFomat = this._getRGBABufferInternalSizedFormat(type, format, useSRGBBuffer);\r\n\r\n    // Babylon's internalFormat but gl's texImage2D format\r\n    const internalFormat = this._getInternalFormat(format);\r\n    const textureType = this._getWebGLTextureType(type);\r\n    this._bindTextureDirectly(this._gl.TEXTURE_2D, texture, true);\r\n    this._unpackFlipY(invertY === undefined ? true : invertY ? true : false);\r\n\r\n    if (!this._doNotHandleContextLost) {\r\n        texture._bufferView = data;\r\n        texture.format = format;\r\n        texture.type = type;\r\n        texture.invertY = invertY;\r\n        texture._compression = compression;\r\n    }\r\n\r\n    if (texture.width % 4 !== 0) {\r\n        this._gl.pixelStorei(this._gl.UNPACK_ALIGNMENT, 1);\r\n    }\r\n\r\n    if (compression && data) {\r\n        this._gl.compressedTexImage2D(this._gl.TEXTURE_2D, 0, (<any>this.getCaps().s3tc)[compression], texture.width, texture.height, 0, <DataView>data);\r\n    } else {\r\n        this._gl.texImage2D(this._gl.TEXTURE_2D, 0, internalSizedFomat, texture.width, texture.height, 0, internalFormat, textureType, data);\r\n    }\r\n\r\n    if (texture.generateMipMaps) {\r\n        this._gl.generateMipmap(this._gl.TEXTURE_2D);\r\n    }\r\n    this._bindTextureDirectly(this._gl.TEXTURE_2D, null);\r\n    //  this.resetTextureCache();\r\n    texture.isReady = true;\r\n};\r\n\r\nThinEngine.prototype.createRawTexture = function (\r\n    data: Nullable<ArrayBufferView>,\r\n    width: number,\r\n    height: number,\r\n    format: number,\r\n    generateMipMaps: boolean,\r\n    invertY: boolean,\r\n    samplingMode: number,\r\n    compression: Nullable<string> = null,\r\n    type: number = Constants.TEXTURETYPE_UNSIGNED_BYTE,\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    creationFlags = 0,\r\n    useSRGBBuffer = false\r\n): InternalTexture {\r\n    const texture = new InternalTexture(this, InternalTextureSource.Raw);\r\n    texture.baseWidth = width;\r\n    texture.baseHeight = height;\r\n    texture.width = width;\r\n    texture.height = height;\r\n    texture.format = format;\r\n    texture.generateMipMaps = generateMipMaps;\r\n    texture.samplingMode = samplingMode;\r\n    texture.invertY = invertY;\r\n    texture._compression = compression;\r\n    texture.type = type;\r\n    texture._useSRGBBuffer = this._getUseSRGBBuffer(useSRGBBuffer, !generateMipMaps);\r\n\r\n    if (!this._doNotHandleContextLost) {\r\n        texture._bufferView = data;\r\n    }\r\n\r\n    this.updateRawTexture(texture, data, format, invertY, compression, type, texture._useSRGBBuffer);\r\n    this._bindTextureDirectly(this._gl.TEXTURE_2D, texture, true);\r\n\r\n    // Filters\r\n    const filters = this._getSamplingParameters(samplingMode, generateMipMaps);\r\n\r\n    this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, filters.mag);\r\n    this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, filters.min);\r\n\r\n    if (generateMipMaps) {\r\n        this._gl.generateMipmap(this._gl.TEXTURE_2D);\r\n    }\r\n\r\n    this._bindTextureDirectly(this._gl.TEXTURE_2D, null);\r\n\r\n    this._internalTexturesCache.push(texture);\r\n\r\n    return texture;\r\n};\r\n\r\nThinEngine.prototype.createRawCubeTexture = function (\r\n    data: Nullable<ArrayBufferView[]>,\r\n    size: number,\r\n    format: number,\r\n    type: number,\r\n    generateMipMaps: boolean,\r\n    invertY: boolean,\r\n    samplingMode: number,\r\n    compression: Nullable<string> = null\r\n): InternalTexture {\r\n    const gl = this._gl;\r\n    const texture = new InternalTexture(this, InternalTextureSource.CubeRaw);\r\n    texture.isCube = true;\r\n    texture.format = format;\r\n    texture.type = type;\r\n    if (!this._doNotHandleContextLost) {\r\n        texture._bufferViewArray = data;\r\n    }\r\n\r\n    const textureType = this._getWebGLTextureType(type);\r\n    let internalFormat = this._getInternalFormat(format);\r\n\r\n    if (internalFormat === gl.RGB) {\r\n        internalFormat = gl.RGBA;\r\n    }\r\n\r\n    // Mipmap generation needs a sized internal format that is both color-renderable and texture-filterable\r\n    if (textureType === gl.FLOAT && !this._caps.textureFloatLinearFiltering) {\r\n        generateMipMaps = false;\r\n        samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        Logger.Warn(\"Float texture filtering is not supported. Mipmap generation and sampling mode are forced to false and TEXTURE_NEAREST_SAMPLINGMODE, respectively.\");\r\n    } else if (textureType === this._gl.HALF_FLOAT_OES && !this._caps.textureHalfFloatLinearFiltering) {\r\n        generateMipMaps = false;\r\n        samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        Logger.Warn(\"Half float texture filtering is not supported. Mipmap generation and sampling mode are forced to false and TEXTURE_NEAREST_SAMPLINGMODE, respectively.\");\r\n    } else if (textureType === gl.FLOAT && !this._caps.textureFloatRender) {\r\n        generateMipMaps = false;\r\n        Logger.Warn(\"Render to float textures is not supported. Mipmap generation forced to false.\");\r\n    } else if (textureType === gl.HALF_FLOAT && !this._caps.colorBufferFloat) {\r\n        generateMipMaps = false;\r\n        Logger.Warn(\"Render to half float textures is not supported. Mipmap generation forced to false.\");\r\n    }\r\n\r\n    const width = size;\r\n    const height = width;\r\n\r\n    texture.width = width;\r\n    texture.height = height;\r\n    texture.invertY = invertY;\r\n    texture._compression = compression;\r\n\r\n    // Double check on POT to generate Mips.\r\n    const isPot = !this.needPOTTextures || (IsExponentOfTwo(texture.width) && IsExponentOfTwo(texture.height));\r\n    if (!isPot) {\r\n        generateMipMaps = false;\r\n    }\r\n\r\n    // Upload data if needed. The texture won't be ready until then.\r\n    if (data) {\r\n        this.updateRawCubeTexture(texture, data, format, type, invertY, compression);\r\n    } else {\r\n        const internalSizedFomat = this._getRGBABufferInternalSizedFormat(type);\r\n        const level = 0;\r\n\r\n        this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);\r\n\r\n        for (let faceIndex = 0; faceIndex < 6; faceIndex++) {\r\n            if (compression) {\r\n                gl.compressedTexImage2D(\r\n                    gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex,\r\n                    level,\r\n                    (<any>this.getCaps().s3tc)[compression],\r\n                    texture.width,\r\n                    texture.height,\r\n                    0,\r\n                    undefined as any\r\n                );\r\n            } else {\r\n                gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, level, internalSizedFomat, texture.width, texture.height, 0, internalFormat, textureType, null);\r\n            }\r\n        }\r\n\r\n        this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null);\r\n    }\r\n\r\n    this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, texture, true);\r\n\r\n    // Filters\r\n    if (data && generateMipMaps) {\r\n        this._gl.generateMipmap(this._gl.TEXTURE_CUBE_MAP);\r\n    }\r\n\r\n    const filters = this._getSamplingParameters(samplingMode, generateMipMaps);\r\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, filters.mag);\r\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, filters.min);\r\n\r\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n    this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);\r\n\r\n    texture.generateMipMaps = generateMipMaps;\r\n    texture.samplingMode = samplingMode;\r\n    texture.isReady = true;\r\n\r\n    return texture;\r\n};\r\n\r\nThinEngine.prototype.updateRawCubeTexture = function (\r\n    texture: InternalTexture,\r\n    data: ArrayBufferView[],\r\n    format: number,\r\n    type: number,\r\n    invertY: boolean,\r\n    compression: Nullable<string> = null,\r\n    level: number = 0\r\n): void {\r\n    texture._bufferViewArray = data;\r\n    texture.format = format;\r\n    texture.type = type;\r\n    texture.invertY = invertY;\r\n    texture._compression = compression;\r\n\r\n    const gl = this._gl;\r\n    const textureType = this._getWebGLTextureType(type);\r\n    let internalFormat = this._getInternalFormat(format);\r\n    const internalSizedFomat = this._getRGBABufferInternalSizedFormat(type);\r\n\r\n    let needConversion = false;\r\n    if (internalFormat === gl.RGB) {\r\n        internalFormat = gl.RGBA;\r\n        needConversion = true;\r\n    }\r\n\r\n    this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);\r\n    this._unpackFlipY(invertY === undefined ? true : invertY ? true : false);\r\n\r\n    if (texture.width % 4 !== 0) {\r\n        gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);\r\n    }\r\n\r\n    // Data are known to be in +X +Y +Z -X -Y -Z\r\n    for (let faceIndex = 0; faceIndex < 6; faceIndex++) {\r\n        let faceData = data[faceIndex];\r\n\r\n        if (compression) {\r\n            gl.compressedTexImage2D(\r\n                gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex,\r\n                level,\r\n                (<any>this.getCaps().s3tc)[compression],\r\n                texture.width,\r\n                texture.height,\r\n                0,\r\n                <DataView>faceData\r\n            );\r\n        } else {\r\n            if (needConversion) {\r\n                faceData = _convertRGBtoRGBATextureData(faceData, texture.width, texture.height, type);\r\n            }\r\n            gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, level, internalSizedFomat, texture.width, texture.height, 0, internalFormat, textureType, faceData);\r\n        }\r\n    }\r\n\r\n    const isPot = !this.needPOTTextures || (IsExponentOfTwo(texture.width) && IsExponentOfTwo(texture.height));\r\n    if (isPot && texture.generateMipMaps && level === 0) {\r\n        this._gl.generateMipmap(this._gl.TEXTURE_CUBE_MAP);\r\n    }\r\n    this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null);\r\n\r\n    // this.resetTextureCache();\r\n    texture.isReady = true;\r\n};\r\n\r\nThinEngine.prototype.createRawCubeTextureFromUrl = function (\r\n    url: string,\r\n    scene: Nullable<Scene>,\r\n    size: number,\r\n    format: number,\r\n    type: number,\r\n    noMipmap: boolean,\r\n    callback: (ArrayBuffer: ArrayBuffer) => Nullable<ArrayBufferView[]>,\r\n    mipmapGenerator: Nullable<(faces: ArrayBufferView[]) => ArrayBufferView[][]>,\r\n    onLoad: Nullable<() => void> = null,\r\n    onError: Nullable<(message?: string, exception?: any) => void> = null,\r\n    samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n    invertY: boolean = false\r\n): InternalTexture {\r\n    const gl = this._gl;\r\n    const texture = this.createRawCubeTexture(null, size, format, type, !noMipmap, invertY, samplingMode, null);\r\n    scene?.addPendingData(texture);\r\n    texture.url = url;\r\n    texture.isReady = false;\r\n    this._internalTexturesCache.push(texture);\r\n\r\n    const onerror = (request?: IWebRequest, exception?: any) => {\r\n        scene?.removePendingData(texture);\r\n        if (onError && request) {\r\n            onError(request.status + \" \" + request.statusText, exception);\r\n        }\r\n    };\r\n\r\n    const internalCallback = (data: any) => {\r\n        // If the texture has been disposed\r\n        if (!texture._hardwareTexture) {\r\n            return;\r\n        }\r\n\r\n        const width = texture.width;\r\n        const faceDataArrays = callback(data);\r\n\r\n        if (!faceDataArrays) {\r\n            return;\r\n        }\r\n\r\n        if (mipmapGenerator) {\r\n            const textureType = this._getWebGLTextureType(type);\r\n            let internalFormat = this._getInternalFormat(format);\r\n            const internalSizedFomat = this._getRGBABufferInternalSizedFormat(type);\r\n\r\n            let needConversion = false;\r\n            if (internalFormat === gl.RGB) {\r\n                internalFormat = gl.RGBA;\r\n                needConversion = true;\r\n            }\r\n\r\n            this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);\r\n            this._unpackFlipY(false);\r\n\r\n            const mipData = mipmapGenerator(faceDataArrays);\r\n            for (let level = 0; level < mipData.length; level++) {\r\n                const mipSize = width >> level;\r\n\r\n                for (let faceIndex = 0; faceIndex < 6; faceIndex++) {\r\n                    let mipFaceData = mipData[level][faceIndex];\r\n                    if (needConversion) {\r\n                        mipFaceData = _convertRGBtoRGBATextureData(mipFaceData, mipSize, mipSize, type);\r\n                    }\r\n                    gl.texImage2D(faceIndex, level, internalSizedFomat, mipSize, mipSize, 0, internalFormat, textureType, mipFaceData);\r\n                }\r\n            }\r\n\r\n            this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);\r\n        } else {\r\n            this.updateRawCubeTexture(texture, faceDataArrays, format, type, invertY);\r\n        }\r\n\r\n        texture.isReady = true;\r\n        // this.resetTextureCache();\r\n        scene?.removePendingData(texture);\r\n\r\n        texture.onLoadedObservable.notifyObservers(texture);\r\n        texture.onLoadedObservable.clear();\r\n\r\n        if (onLoad) {\r\n            onLoad();\r\n        }\r\n    };\r\n\r\n    this._loadFile(\r\n        url,\r\n        (data) => {\r\n            internalCallback(data);\r\n        },\r\n        undefined,\r\n        scene?.offlineProvider,\r\n        true,\r\n        onerror\r\n    );\r\n\r\n    return texture;\r\n};\r\n\r\n/**\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nfunction _convertRGBtoRGBATextureData(rgbData: any, width: number, height: number, textureType: number): ArrayBufferView {\r\n    // Create new RGBA data container.\r\n    let rgbaData: any;\r\n    let val1 = 1;\r\n    if (textureType === Constants.TEXTURETYPE_FLOAT) {\r\n        rgbaData = new Float32Array(width * height * 4);\r\n    } else if (textureType === Constants.TEXTURETYPE_HALF_FLOAT) {\r\n        rgbaData = new Uint16Array(width * height * 4);\r\n        val1 = 15360; // 15360 is the encoding of 1 in half float\r\n    } else if (textureType === Constants.TEXTURETYPE_UNSIGNED_INTEGER) {\r\n        rgbaData = new Uint32Array(width * height * 4);\r\n    } else {\r\n        rgbaData = new Uint8Array(width * height * 4);\r\n    }\r\n\r\n    // Convert each pixel.\r\n    for (let x = 0; x < width; x++) {\r\n        for (let y = 0; y < height; y++) {\r\n            const index = (y * width + x) * 3;\r\n            const newIndex = (y * width + x) * 4;\r\n\r\n            // Map Old Value to new value.\r\n            rgbaData[newIndex + 0] = rgbData[index + 0];\r\n            rgbaData[newIndex + 1] = rgbData[index + 1];\r\n            rgbaData[newIndex + 2] = rgbData[index + 2];\r\n\r\n            // Add fully opaque alpha channel.\r\n            rgbaData[newIndex + 3] = val1;\r\n        }\r\n    }\r\n\r\n    return rgbaData;\r\n}\r\n\r\n/**\r\n * Create a function for createRawTexture3D/createRawTexture2DArray\r\n * @param is3D true for TEXTURE_3D and false for TEXTURE_2D_ARRAY\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nfunction _makeCreateRawTextureFunction(is3D: boolean) {\r\n    return function (\r\n        this: ThinEngine,\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        depth: number,\r\n        format: number,\r\n        generateMipMaps: boolean,\r\n        invertY: boolean,\r\n        samplingMode: number,\r\n        compression: Nullable<string> = null,\r\n        textureType: number = Constants.TEXTURETYPE_UNSIGNED_BYTE\r\n    ): InternalTexture {\r\n        const target = is3D ? this._gl.TEXTURE_3D : this._gl.TEXTURE_2D_ARRAY;\r\n        const source = is3D ? InternalTextureSource.Raw3D : InternalTextureSource.Raw2DArray;\r\n        const texture = new InternalTexture(this, source);\r\n        texture.baseWidth = width;\r\n        texture.baseHeight = height;\r\n        texture.baseDepth = depth;\r\n        texture.width = width;\r\n        texture.height = height;\r\n        texture.depth = depth;\r\n        texture.format = format;\r\n        texture.type = textureType;\r\n        texture.generateMipMaps = generateMipMaps;\r\n        texture.samplingMode = samplingMode;\r\n        if (is3D) {\r\n            texture.is3D = true;\r\n        } else {\r\n            texture.is2DArray = true;\r\n        }\r\n\r\n        if (!this._doNotHandleContextLost) {\r\n            texture._bufferView = data;\r\n        }\r\n\r\n        if (is3D) {\r\n            this.updateRawTexture3D(texture, data, format, invertY, compression, textureType);\r\n        } else {\r\n            this.updateRawTexture2DArray(texture, data, format, invertY, compression, textureType);\r\n        }\r\n        this._bindTextureDirectly(target, texture, true);\r\n\r\n        // Filters\r\n        const filters = this._getSamplingParameters(samplingMode, generateMipMaps);\r\n\r\n        this._gl.texParameteri(target, this._gl.TEXTURE_MAG_FILTER, filters.mag);\r\n        this._gl.texParameteri(target, this._gl.TEXTURE_MIN_FILTER, filters.min);\r\n\r\n        if (generateMipMaps) {\r\n            this._gl.generateMipmap(target);\r\n        }\r\n\r\n        this._bindTextureDirectly(target, null);\r\n\r\n        this._internalTexturesCache.push(texture);\r\n\r\n        return texture;\r\n    };\r\n}\r\n\r\nThinEngine.prototype.createRawTexture2DArray = _makeCreateRawTextureFunction(false);\r\nThinEngine.prototype.createRawTexture3D = _makeCreateRawTextureFunction(true);\r\n\r\n/**\r\n * Create a function for updateRawTexture3D/updateRawTexture2DArray\r\n * @param is3D true for TEXTURE_3D and false for TEXTURE_2D_ARRAY\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nfunction _makeUpdateRawTextureFunction(is3D: boolean) {\r\n    return function (\r\n        this: ThinEngine,\r\n        texture: InternalTexture,\r\n        data: Nullable<ArrayBufferView>,\r\n        format: number,\r\n        invertY: boolean,\r\n        compression: Nullable<string> = null,\r\n        textureType: number = Constants.TEXTURETYPE_UNSIGNED_BYTE\r\n    ): void {\r\n        const target = is3D ? this._gl.TEXTURE_3D : this._gl.TEXTURE_2D_ARRAY;\r\n        const internalType = this._getWebGLTextureType(textureType);\r\n        const internalFormat = this._getInternalFormat(format);\r\n        const internalSizedFomat = this._getRGBABufferInternalSizedFormat(textureType, format);\r\n\r\n        this._bindTextureDirectly(target, texture, true);\r\n        this._unpackFlipY(invertY === undefined ? true : invertY ? true : false);\r\n\r\n        if (!this._doNotHandleContextLost) {\r\n            texture._bufferView = data;\r\n            texture.format = format;\r\n            texture.invertY = invertY;\r\n            texture._compression = compression;\r\n        }\r\n\r\n        if (texture.width % 4 !== 0) {\r\n            this._gl.pixelStorei(this._gl.UNPACK_ALIGNMENT, 1);\r\n        }\r\n\r\n        if (compression && data) {\r\n            this._gl.compressedTexImage3D(target, 0, (<any>this.getCaps().s3tc)[compression], texture.width, texture.height, texture.depth, 0, data);\r\n        } else {\r\n            this._gl.texImage3D(target, 0, internalSizedFomat, texture.width, texture.height, texture.depth, 0, internalFormat, internalType, data);\r\n        }\r\n\r\n        if (texture.generateMipMaps) {\r\n            this._gl.generateMipmap(target);\r\n        }\r\n        this._bindTextureDirectly(target, null);\r\n        // this.resetTextureCache();\r\n        texture.isReady = true;\r\n    };\r\n}\r\n\r\nThinEngine.prototype.updateRawTexture2DArray = _makeUpdateRawTextureFunction(false);\r\nThinEngine.prototype.updateRawTexture3D = _makeUpdateRawTextureFunction(true);\r\n", "import { ThinEngine } from \"../../Engines/thinEngine\";\r\nimport type { DataBuffer } from \"../../Buffers/dataBuffer\";\r\nimport type { IndicesArray, DataArray } from \"../../types\";\r\n\r\ndeclare module \"../../Engines/abstractEngine\" {\r\n    export interface AbstractEngine {\r\n        /**\r\n         * Update a dynamic index buffer\r\n         * @param indexBuffer defines the target index buffer\r\n         * @param indices defines the data to update\r\n         * @param offset defines the offset in the target index buffer where update should start\r\n         */\r\n        updateDynamicIndexBuffer(indexBuffer: DataBuffer, indices: IndicesArray, offset?: number): void;\r\n\r\n        /**\r\n         * Updates a dynamic vertex buffer.\r\n         * @param vertexBuffer the vertex buffer to update\r\n         * @param data the data used to update the vertex buffer\r\n         * @param byteOffset the byte offset of the data\r\n         * @param byteLength the byte length of the data\r\n         */\r\n        updateDynamicVertexBuffer(vertexBuffer: DataBuffer, data: DataArray, byteOffset?: number, byteLength?: number): void;\r\n    }\r\n}\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\r\nThinEngine.prototype.updateDynamicIndexBuffer = function (this: ThinEngine, indexBuffer: DataBuffer, indices: IndicesArray, offset: number = 0): void {\r\n    // Force cache update\r\n    this._currentBoundBuffer[this._gl.ELEMENT_ARRAY_BUFFER] = null;\r\n    this.bindIndexBuffer(indexBuffer);\r\n\r\n    let view: ArrayBufferView;\r\n    if (indexBuffer.is32Bits) {\r\n        // anything else than Uint32Array needs to be converted to Uint32Array\r\n        view = indices instanceof Uint32Array ? indices : new Uint32Array(indices);\r\n    } else {\r\n        // anything else than Uint16Array needs to be converted to Uint16Array\r\n        view = indices instanceof Uint16Array ? indices : new Uint16Array(indices);\r\n    }\r\n\r\n    this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER, view, this._gl.DYNAMIC_DRAW);\r\n\r\n    this._resetIndexBufferBinding();\r\n};\r\n\r\nThinEngine.prototype.updateDynamicVertexBuffer = function (this: ThinEngine, vertexBuffer: DataBuffer, data: DataArray, byteOffset?: number, byteLength?: number): void {\r\n    this.bindArrayBuffer(vertexBuffer);\r\n\r\n    if (byteOffset === undefined) {\r\n        byteOffset = 0;\r\n    }\r\n\r\n    const dataLength = (data as ArrayBuffer).byteLength || (data as number[]).length;\r\n\r\n    if (byteLength === undefined || (byteLength >= dataLength && byteOffset === 0)) {\r\n        if (data instanceof Array) {\r\n            this._gl.bufferSubData(this._gl.ARRAY_BUFFER, byteOffset, new Float32Array(data));\r\n        } else {\r\n            this._gl.bufferSubData(this._gl.ARRAY_BUFFER, byteOffset, data);\r\n        }\r\n    } else {\r\n        if (data instanceof Array) {\r\n            this._gl.bufferSubData(this._gl.ARRAY_BUFFER, byteOffset, new Float32Array(data).subarray(0, byteLength / 4));\r\n        } else {\r\n            if (data instanceof ArrayBuffer) {\r\n                data = new Uint8Array(data, 0, byteLength);\r\n            } else {\r\n                data = new Uint8Array(data.buffer, data.byteOffset, byteLength);\r\n            }\r\n\r\n            this._gl.bufferSubData(this._gl.ARRAY_BUFFER, byteOffset, data);\r\n        }\r\n    }\r\n\r\n    this._resetVertexBufferBinding();\r\n};\r\n", "import { ThinEngine } from \"../../Engines/thinEngine\";\r\nimport { InternalTexture, InternalTextureSource } from \"../../Materials/Textures/internalTexture\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Constants } from \"../constants\";\r\nimport type { DepthTextureCreationOptions } from \"../../Materials/Textures/textureCreationOptions\";\r\nimport { GetExponentOfTwo } from \"../../Misc/tools.functions\";\r\n\r\ndeclare module \"../../Engines/abstractEngine\" {\r\n    export interface AbstractEngine {\r\n        /**\r\n         * @internal\r\n         */\r\n        _setCubeMapTextureParams(texture: InternalTexture, loadMipmap: boolean, maxLevel?: number): void;\r\n        /**\r\n         * Creates a depth stencil cube texture.\r\n         * This is only available in WebGL 2.\r\n         * @param size The size of face edge in the cube texture.\r\n         * @param options The options defining the cube texture.\r\n         * @returns The cube texture\r\n         */\r\n        _createDepthStencilCubeTexture(size: number, options: DepthTextureCreationOptions): InternalTexture;\r\n\r\n        /**\r\n         * Creates a cube texture\r\n         * @param rootUrl defines the url where the files to load is located\r\n         * @param scene defines the current scene\r\n         * @param files defines the list of files to load (1 per face)\r\n         * @param noMipmap defines a boolean indicating that no mipmaps shall be generated (false by default)\r\n         * @param onLoad defines an optional callback raised when the texture is loaded\r\n         * @param onError defines an optional callback raised if there is an issue to load the texture\r\n         * @param format defines the format of the data\r\n         * @param forcedExtension defines the extension to use to pick the right loader\r\n         * @param createPolynomials if a polynomial sphere should be created for the cube texture\r\n         * @param lodScale defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness\r\n         * @param lodOffset defines the offset applied to environment texture. This manages first LOD level used for IBL according to the roughness\r\n         * @param fallback defines texture to use while falling back when (compressed) texture file not found.\r\n         * @param loaderOptions options to be passed to the loader\r\n         * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\r\n         * @param buffer defines the data buffer to load instead of loading the rootUrl\r\n         * @returns the cube texture as an InternalTexture\r\n         */\r\n        createCubeTexture(\r\n            rootUrl: string,\r\n            scene: Nullable<Scene>,\r\n            files: Nullable<string[]>,\r\n            noMipmap: boolean | undefined,\r\n            onLoad: Nullable<(data?: any) => void>,\r\n            onError: Nullable<(message?: string, exception?: any) => void>,\r\n            format: number | undefined,\r\n            forcedExtension: any,\r\n            createPolynomials: boolean,\r\n            lodScale: number,\r\n            lodOffset: number,\r\n            fallback: Nullable<InternalTexture>,\r\n            loaderOptions: any,\r\n            useSRGBBuffer: boolean,\r\n            buffer: Nullable<ArrayBufferView>\r\n        ): InternalTexture;\r\n\r\n        /**\r\n         * Creates a cube texture\r\n         * @param rootUrl defines the url where the files to load is located\r\n         * @param scene defines the current scene\r\n         * @param files defines the list of files to load (1 per face)\r\n         * @param noMipmap defines a boolean indicating that no mipmaps shall be generated (false by default)\r\n         * @param onLoad defines an optional callback raised when the texture is loaded\r\n         * @param onError defines an optional callback raised if there is an issue to load the texture\r\n         * @param format defines the format of the data\r\n         * @param forcedExtension defines the extension to use to pick the right loader\r\n         * @returns the cube texture as an InternalTexture\r\n         */\r\n        createCubeTexture(\r\n            rootUrl: string,\r\n            scene: Nullable<Scene>,\r\n            files: Nullable<string[]>,\r\n            noMipmap: boolean,\r\n            onLoad: Nullable<(data?: any) => void>,\r\n            onError: Nullable<(message?: string, exception?: any) => void>,\r\n            format: number | undefined,\r\n            forcedExtension: any\r\n        ): InternalTexture;\r\n\r\n        /**\r\n         * Creates a cube texture\r\n         * @param rootUrl defines the url where the files to load is located\r\n         * @param scene defines the current scene\r\n         * @param files defines the list of files to load (1 per face)\r\n         * @param noMipmap defines a boolean indicating that no mipmaps shall be generated (false by default)\r\n         * @param onLoad defines an optional callback raised when the texture is loaded\r\n         * @param onError defines an optional callback raised if there is an issue to load the texture\r\n         * @param format defines the format of the data\r\n         * @param forcedExtension defines the extension to use to pick the right loader\r\n         * @param createPolynomials if a polynomial sphere should be created for the cube texture\r\n         * @param lodScale defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness\r\n         * @param lodOffset defines the offset applied to environment texture. This manages first LOD level used for IBL according to the roughness\r\n         * @returns the cube texture as an InternalTexture\r\n         */\r\n        createCubeTexture(\r\n            rootUrl: string,\r\n            scene: Nullable<Scene>,\r\n            files: Nullable<string[]>,\r\n            noMipmap: boolean,\r\n            onLoad: Nullable<(data?: any) => void>,\r\n            onError: Nullable<(message?: string, exception?: any) => void>,\r\n            format: number | undefined,\r\n            forcedExtension: any,\r\n            createPolynomials: boolean,\r\n            lodScale: number,\r\n            lodOffset: number\r\n        ): InternalTexture;\r\n\r\n        /** @internal */\r\n        createCubeTextureBase(\r\n            rootUrl: string,\r\n            scene: Nullable<Scene>,\r\n            files: Nullable<string[]>,\r\n            noMipmap: boolean,\r\n            onLoad: Nullable<(data?: any) => void>,\r\n            onError: Nullable<(message?: string, exception?: any) => void>,\r\n            format: number | undefined,\r\n            forcedExtension: any,\r\n            createPolynomials: boolean,\r\n            lodScale: number,\r\n            lodOffset: number,\r\n            fallback: Nullable<InternalTexture>,\r\n            beforeLoadCubeDataCallback: Nullable<(texture: InternalTexture, data: ArrayBufferView | ArrayBufferView[]) => void>,\r\n            imageHandler: Nullable<(texture: InternalTexture, imgs: HTMLImageElement[] | ImageBitmap[]) => void>,\r\n            useSRGBBuffer: boolean,\r\n            buffer: ArrayBufferView\r\n        ): InternalTexture;\r\n\r\n        /**\r\n         * Force the mipmap generation for the given render target texture\r\n         * @param texture defines the render target texture to use\r\n         * @param unbind defines whether or not to unbind the texture after generation. Defaults to true.\r\n         */\r\n        generateMipMapsForCubemap(texture: InternalTexture, unbind?: boolean): void;\r\n    }\r\n}\r\n\r\nThinEngine.prototype._createDepthStencilCubeTexture = function (size: number, options: DepthTextureCreationOptions): InternalTexture {\r\n    const internalTexture = new InternalTexture(this, InternalTextureSource.DepthStencil);\r\n    internalTexture.isCube = true;\r\n\r\n    if (this.webGLVersion === 1) {\r\n        Logger.Error(\"Depth cube texture is not supported by WebGL 1.\");\r\n        return internalTexture;\r\n    }\r\n\r\n    const internalOptions = {\r\n        bilinearFiltering: false,\r\n        comparisonFunction: 0,\r\n        generateStencil: false,\r\n        ...options,\r\n    };\r\n\r\n    const gl = this._gl;\r\n    this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, internalTexture, true);\r\n\r\n    this._setupDepthStencilTexture(internalTexture, size, internalOptions.bilinearFiltering, internalOptions.comparisonFunction);\r\n\r\n    // Create the depth/stencil buffer\r\n    for (let face = 0; face < 6; face++) {\r\n        if (internalOptions.generateStencil) {\r\n            gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, 0, gl.DEPTH24_STENCIL8, size, size, 0, gl.DEPTH_STENCIL, gl.UNSIGNED_INT_24_8, null);\r\n        } else {\r\n            gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, 0, gl.DEPTH_COMPONENT24, size, size, 0, gl.DEPTH_COMPONENT, gl.UNSIGNED_INT, null);\r\n        }\r\n    }\r\n\r\n    this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);\r\n\r\n    this._internalTexturesCache.push(internalTexture);\r\n\r\n    return internalTexture;\r\n};\r\n\r\nThinEngine.prototype._setCubeMapTextureParams = function (texture: InternalTexture, loadMipmap: boolean, maxLevel?: number): void {\r\n    const gl = this._gl;\r\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\r\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, loadMipmap ? gl.LINEAR_MIPMAP_LINEAR : gl.LINEAR);\r\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n    texture.samplingMode = loadMipmap ? Constants.TEXTURE_TRILINEAR_SAMPLINGMODE : Constants.TEXTURE_LINEAR_LINEAR;\r\n\r\n    if (loadMipmap && this.getCaps().textureMaxLevel && maxLevel !== undefined && maxLevel > 0) {\r\n        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAX_LEVEL, maxLevel);\r\n        texture._maxLodLevel = maxLevel;\r\n    }\r\n\r\n    this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);\r\n};\r\n\r\nThinEngine.prototype.createCubeTexture = function (\r\n    rootUrl: string,\r\n    scene: Nullable<Scene>,\r\n    files: Nullable<string[]>,\r\n    noMipmap?: boolean,\r\n    onLoad: Nullable<(data?: any) => void> = null,\r\n    onError: Nullable<(message?: string, exception?: any) => void> = null,\r\n    format?: number,\r\n    forcedExtension: any = null,\r\n    createPolynomials: boolean = false,\r\n    lodScale: number = 0,\r\n    lodOffset: number = 0,\r\n    fallback: Nullable<InternalTexture> = null,\r\n    loaderOptions?: any,\r\n    useSRGBBuffer = false,\r\n    buffer: Nullable<ArrayBufferView> = null\r\n): InternalTexture {\r\n    const gl = this._gl;\r\n\r\n    return this.createCubeTextureBase(\r\n        rootUrl,\r\n        scene,\r\n        files,\r\n        !!noMipmap,\r\n        onLoad,\r\n        onError,\r\n        format,\r\n        forcedExtension,\r\n        createPolynomials,\r\n        lodScale,\r\n        lodOffset,\r\n        fallback,\r\n        (texture: InternalTexture) => this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true),\r\n        (texture: InternalTexture, imgs: HTMLImageElement[] | ImageBitmap[]) => {\r\n            const width = this.needPOTTextures ? GetExponentOfTwo(imgs[0].width, this._caps.maxCubemapTextureSize) : imgs[0].width;\r\n            const height = width;\r\n\r\n            const faces = [\r\n                gl.TEXTURE_CUBE_MAP_POSITIVE_X,\r\n                gl.TEXTURE_CUBE_MAP_POSITIVE_Y,\r\n                gl.TEXTURE_CUBE_MAP_POSITIVE_Z,\r\n                gl.TEXTURE_CUBE_MAP_NEGATIVE_X,\r\n                gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,\r\n                gl.TEXTURE_CUBE_MAP_NEGATIVE_Z,\r\n            ];\r\n\r\n            this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);\r\n            this._unpackFlipY(false);\r\n\r\n            const internalFormat = format ? this._getInternalFormat(format, texture._useSRGBBuffer) : texture._useSRGBBuffer ? this._glSRGBExtensionValues.SRGB8_ALPHA8 : gl.RGBA;\r\n            let texelFormat = format ? this._getInternalFormat(format) : gl.RGBA;\r\n\r\n            if (texture._useSRGBBuffer && this.webGLVersion === 1) {\r\n                texelFormat = internalFormat;\r\n            }\r\n\r\n            for (let index = 0; index < faces.length; index++) {\r\n                if (imgs[index].width !== width || imgs[index].height !== height) {\r\n                    this._prepareWorkingCanvas();\r\n\r\n                    if (!this._workingCanvas || !this._workingContext) {\r\n                        Logger.Warn(\"Cannot create canvas to resize texture.\");\r\n                        return;\r\n                    }\r\n                    this._workingCanvas.width = width;\r\n                    this._workingCanvas.height = height;\r\n\r\n                    this._workingContext.drawImage(imgs[index], 0, 0, imgs[index].width, imgs[index].height, 0, 0, width, height);\r\n                    gl.texImage2D(faces[index], 0, internalFormat, texelFormat, gl.UNSIGNED_BYTE, this._workingCanvas as TexImageSource);\r\n                } else {\r\n                    gl.texImage2D(faces[index], 0, internalFormat, texelFormat, gl.UNSIGNED_BYTE, imgs[index]);\r\n                }\r\n            }\r\n\r\n            if (!noMipmap) {\r\n                gl.generateMipmap(gl.TEXTURE_CUBE_MAP);\r\n            }\r\n\r\n            this._setCubeMapTextureParams(texture, !noMipmap);\r\n\r\n            texture.width = width;\r\n            texture.height = height;\r\n            texture.isReady = true;\r\n            if (format) {\r\n                texture.format = format;\r\n            }\r\n\r\n            texture.onLoadedObservable.notifyObservers(texture);\r\n            texture.onLoadedObservable.clear();\r\n\r\n            if (onLoad) {\r\n                onLoad();\r\n            }\r\n        },\r\n        !!useSRGBBuffer,\r\n        buffer\r\n    );\r\n};\r\n\r\nThinEngine.prototype.generateMipMapsForCubemap = function (texture: InternalTexture, unbind = true) {\r\n    if (texture.generateMipMaps) {\r\n        const gl = this._gl;\r\n        this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);\r\n        gl.generateMipmap(gl.TEXTURE_CUBE_MAP);\r\n        if (unbind) {\r\n            this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);\r\n        }\r\n    }\r\n};\r\n", "import type { InternalTexture } from \"../../Materials/Textures/internalTexture\";\r\nimport type { TextureSize } from \"../../Materials/Textures/textureCreationOptions\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Constants } from \"../constants\";\r\nimport type { Engine } from \"../engine\";\r\nimport { RenderTargetWrapper } from \"../renderTargetWrapper\";\r\nimport type { ThinEngine } from \"../thinEngine\";\r\nimport type { WebGLHardwareTexture } from \"./webGLHardwareTexture\";\r\nimport { HasStencilAspect } from \"core/Materials/Textures/textureHelper.functions\";\r\n\r\n/** @internal */\r\nexport class WebGLRenderTargetWrapper extends RenderTargetWrapper {\r\n    private _context: WebGLRenderingContext;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _framebuffer: Nullable<WebGLFramebuffer> = null;\r\n    /**\r\n     * @internal\r\n     */\r\n    public _depthStencilBuffer: Nullable<WebGLRenderbuffer> = null;\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public _MSAAFramebuffer: Nullable<WebGLFramebuffer> = null;\r\n\r\n    // Multiview\r\n    /**\r\n     * @internal\r\n     */\r\n    public _colorTextureArray: Nullable<WebGLTexture> = null;\r\n    /**\r\n     * @internal\r\n     */\r\n    public _depthStencilTextureArray: Nullable<WebGLTexture> = null;\r\n    /**\r\n     * @internal\r\n     */\r\n    public _disposeOnlyFramebuffers = false;\r\n    /**\r\n     * @internal\r\n     */\r\n    public _currentLOD = 0;\r\n\r\n    public override setDepthStencilTexture(texture: Nullable<InternalTexture>, disposeExisting = true) {\r\n        super.setDepthStencilTexture(texture, disposeExisting);\r\n\r\n        if (!texture) {\r\n            return;\r\n        }\r\n\r\n        const engine = this._engine as ThinEngine;\r\n        const gl = this._context as WebGL2RenderingContext;\r\n        const hardwareTexture = texture._hardwareTexture as Nullable<WebGLHardwareTexture>;\r\n\r\n        if (hardwareTexture && texture._autoMSAAManagement && this._MSAAFramebuffer) {\r\n            const currentFB = engine._currentFramebuffer;\r\n            engine._bindUnboundFramebuffer(this._MSAAFramebuffer);\r\n            gl.framebufferRenderbuffer(\r\n                gl.FRAMEBUFFER,\r\n                HasStencilAspect(texture.format) ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT,\r\n                gl.RENDERBUFFER,\r\n                hardwareTexture.getMSAARenderBuffer()\r\n            );\r\n            engine._bindUnboundFramebuffer(currentFB);\r\n        }\r\n    }\r\n\r\n    constructor(isMulti: boolean, isCube: boolean, size: TextureSize, engine: ThinEngine, context: WebGLRenderingContext) {\r\n        super(isMulti, isCube, size, engine);\r\n\r\n        this._context = context;\r\n    }\r\n\r\n    protected override _cloneRenderTargetWrapper(): Nullable<RenderTargetWrapper> {\r\n        let rtw: Nullable<RenderTargetWrapper> = null;\r\n\r\n        if (this._colorTextureArray && this._depthStencilTextureArray) {\r\n            rtw = (this._engine as Engine).createMultiviewRenderTargetTexture(this.width, this.height);\r\n            rtw.texture!.isReady = true;\r\n        } else {\r\n            rtw = super._cloneRenderTargetWrapper();\r\n        }\r\n\r\n        return rtw;\r\n    }\r\n\r\n    protected override _swapRenderTargetWrapper(target: WebGLRenderTargetWrapper): void {\r\n        super._swapRenderTargetWrapper(target);\r\n\r\n        target._framebuffer = this._framebuffer;\r\n        target._depthStencilBuffer = this._depthStencilBuffer;\r\n        target._MSAAFramebuffer = this._MSAAFramebuffer;\r\n        target._colorTextureArray = this._colorTextureArray;\r\n        target._depthStencilTextureArray = this._depthStencilTextureArray;\r\n\r\n        this._framebuffer = this._depthStencilBuffer = this._MSAAFramebuffer = this._colorTextureArray = this._depthStencilTextureArray = null;\r\n    }\r\n\r\n    /**\r\n     * Creates the depth/stencil texture\r\n     * @param comparisonFunction Comparison function to use for the texture\r\n     * @param bilinearFiltering true if bilinear filtering should be used when sampling the texture\r\n     * @param generateStencil true if the stencil aspect should also be created\r\n     * @param samples sample count to use when creating the texture\r\n     * @param format format of the depth texture\r\n     * @param label defines the label to use for the texture (for debugging purpose only)\r\n     * @returns the depth/stencil created texture\r\n     */\r\n    public override createDepthStencilTexture(\r\n        comparisonFunction: number = 0,\r\n        bilinearFiltering: boolean = true,\r\n        generateStencil: boolean = false,\r\n        samples: number = 1,\r\n        format: number = Constants.TEXTUREFORMAT_DEPTH32_FLOAT,\r\n        label?: string\r\n    ): InternalTexture {\r\n        if (this._depthStencilBuffer) {\r\n            const engine = this._engine as ThinEngine;\r\n            // Dispose previous depth/stencil render buffers and clear the corresponding attachment.\r\n            // Next time this framebuffer is bound, the new depth/stencil texture will be attached.\r\n            const currentFrameBuffer = engine._currentFramebuffer;\r\n            const gl = this._context;\r\n\r\n            engine._bindUnboundFramebuffer(this._framebuffer);\r\n            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, null);\r\n            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, null);\r\n            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.STENCIL_ATTACHMENT, gl.RENDERBUFFER, null);\r\n            engine._bindUnboundFramebuffer(currentFrameBuffer);\r\n            gl.deleteRenderbuffer(this._depthStencilBuffer);\r\n\r\n            this._depthStencilBuffer = null;\r\n        }\r\n\r\n        return super.createDepthStencilTexture(comparisonFunction, bilinearFiltering, generateStencil, samples, format, label);\r\n    }\r\n\r\n    /**\r\n     * Shares the depth buffer of this render target with another render target.\r\n     * @param renderTarget Destination renderTarget\r\n     */\r\n    public override shareDepth(renderTarget: WebGLRenderTargetWrapper): void {\r\n        super.shareDepth(renderTarget);\r\n\r\n        const gl = this._context;\r\n        const depthbuffer = this._depthStencilBuffer;\r\n        const framebuffer = renderTarget._MSAAFramebuffer || renderTarget._framebuffer;\r\n        const engine = this._engine as ThinEngine;\r\n\r\n        if (renderTarget._depthStencilBuffer && renderTarget._depthStencilBuffer !== depthbuffer) {\r\n            gl.deleteRenderbuffer(renderTarget._depthStencilBuffer);\r\n        }\r\n        renderTarget._depthStencilBuffer = depthbuffer;\r\n        const attachment = renderTarget._generateStencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;\r\n        engine._bindUnboundFramebuffer(framebuffer);\r\n        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, attachment, gl.RENDERBUFFER, depthbuffer);\r\n        engine._bindUnboundFramebuffer(null);\r\n    }\r\n\r\n    /**\r\n     * Binds a texture to this render target on a specific attachment\r\n     * @param texture The texture to bind to the framebuffer\r\n     * @param attachmentIndex Index of the attachment\r\n     * @param faceIndexOrLayer The face or layer of the texture to render to in case of cube texture or array texture\r\n     * @param lodLevel defines the lod level to bind to the frame buffer\r\n     */\r\n    private _bindTextureRenderTarget(texture: InternalTexture, attachmentIndex: number = 0, faceIndexOrLayer?: number, lodLevel: number = 0) {\r\n        const hardwareTexture = texture._hardwareTexture as WebGLHardwareTexture;\r\n        if (!hardwareTexture) {\r\n            return;\r\n        }\r\n\r\n        const framebuffer = this._framebuffer;\r\n        const engine = this._engine as ThinEngine;\r\n        const currentFB = engine._currentFramebuffer;\r\n        engine._bindUnboundFramebuffer(framebuffer);\r\n\r\n        let attachment: any;\r\n        if (engine.webGLVersion > 1) {\r\n            const gl = this._context as WebGL2RenderingContext;\r\n\r\n            attachment = (<any>gl)[\"COLOR_ATTACHMENT\" + attachmentIndex];\r\n            if (texture.is2DArray || texture.is3D) {\r\n                faceIndexOrLayer = faceIndexOrLayer ?? this.layerIndices?.[attachmentIndex] ?? 0;\r\n                gl.framebufferTextureLayer(gl.FRAMEBUFFER, attachment, hardwareTexture.underlyingResource, lodLevel, faceIndexOrLayer);\r\n            } else if (texture.isCube) {\r\n                // if face index is not specified, try to query it from faceIndices\r\n                // default is face 0\r\n                faceIndexOrLayer = faceIndexOrLayer ?? this.faceIndices?.[attachmentIndex] ?? 0;\r\n                gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndexOrLayer, hardwareTexture.underlyingResource, lodLevel);\r\n            } else {\r\n                gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, gl.TEXTURE_2D, hardwareTexture.underlyingResource, lodLevel);\r\n            }\r\n        } else {\r\n            // Default behavior (WebGL)\r\n            const gl = this._context;\r\n\r\n            attachment = (<any>gl)[\"COLOR_ATTACHMENT\" + attachmentIndex + \"_WEBGL\"];\r\n            const target = faceIndexOrLayer !== undefined ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndexOrLayer : gl.TEXTURE_2D;\r\n\r\n            gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, target, hardwareTexture.underlyingResource, lodLevel);\r\n        }\r\n\r\n        if (texture._autoMSAAManagement && this._MSAAFramebuffer) {\r\n            const gl = this._context;\r\n            engine._bindUnboundFramebuffer(this._MSAAFramebuffer);\r\n            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, attachment, gl.RENDERBUFFER, hardwareTexture.getMSAARenderBuffer());\r\n        }\r\n\r\n        engine._bindUnboundFramebuffer(currentFB);\r\n    }\r\n\r\n    /**\r\n     * Set a texture in the textures array\r\n     * @param texture the texture to set\r\n     * @param index the index in the textures array to set\r\n     * @param disposePrevious If this function should dispose the previous texture\r\n     */\r\n    public override setTexture(texture: InternalTexture, index: number = 0, disposePrevious: boolean = true) {\r\n        super.setTexture(texture, index, disposePrevious);\r\n        this._bindTextureRenderTarget(texture, index);\r\n    }\r\n\r\n    /**\r\n     * Sets the layer and face indices of every render target texture\r\n     * @param layers The layer of the texture to be set (make negative to not modify)\r\n     * @param faces The face of the texture to be set (make negative to not modify)\r\n     */\r\n    public override setLayerAndFaceIndices(layers: number[], faces: number[]) {\r\n        super.setLayerAndFaceIndices(layers, faces);\r\n\r\n        if (!this.textures || !this.layerIndices || !this.faceIndices) {\r\n            return;\r\n        }\r\n\r\n        // the length of this._attachments is the right one as it does not count the depth texture, in case we generated it\r\n        const textureCount = this._attachments?.length ?? this.textures.length;\r\n        for (let index = 0; index < textureCount; index++) {\r\n            const texture = this.textures[index];\r\n            if (!texture) {\r\n                // The target type was probably -1 at creation time and setTexture has not been called yet for this index\r\n                continue;\r\n            }\r\n            if (texture.is2DArray || texture.is3D) {\r\n                this._bindTextureRenderTarget(texture, index, this.layerIndices[index]);\r\n            } else if (texture.isCube) {\r\n                this._bindTextureRenderTarget(texture, index, this.faceIndices[index]);\r\n            } else {\r\n                this._bindTextureRenderTarget(texture, index);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the face and layer indices of a texture in the textures array\r\n     * @param index The index of the texture in the textures array to modify\r\n     * @param layer The layer of the texture to be set\r\n     * @param face The face of the texture to be set\r\n     */\r\n    public override setLayerAndFaceIndex(index: number = 0, layer?: number, face?: number): void {\r\n        super.setLayerAndFaceIndex(index, layer, face);\r\n\r\n        if (!this.textures || !this.layerIndices || !this.faceIndices) {\r\n            return;\r\n        }\r\n\r\n        const texture = this.textures[index];\r\n        if (texture.is2DArray || texture.is3D) {\r\n            this._bindTextureRenderTarget(this.textures[index], index, this.layerIndices[index]);\r\n        } else if (texture.isCube) {\r\n            this._bindTextureRenderTarget(this.textures[index], index, this.faceIndices[index]);\r\n        }\r\n    }\r\n\r\n    public override resolveMSAATextures(): void {\r\n        const engine = this._engine as ThinEngine;\r\n        const currentFramebuffer = engine._currentFramebuffer;\r\n\r\n        engine._bindUnboundFramebuffer(this._MSAAFramebuffer);\r\n\r\n        super.resolveMSAATextures();\r\n\r\n        engine._bindUnboundFramebuffer(currentFramebuffer);\r\n    }\r\n\r\n    public override dispose(disposeOnlyFramebuffers = this._disposeOnlyFramebuffers): void {\r\n        const gl = this._context;\r\n\r\n        if (!disposeOnlyFramebuffers) {\r\n            if (this._colorTextureArray) {\r\n                this._context.deleteTexture(this._colorTextureArray);\r\n                this._colorTextureArray = null;\r\n            }\r\n            if (this._depthStencilTextureArray) {\r\n                this._context.deleteTexture(this._depthStencilTextureArray);\r\n                this._depthStencilTextureArray = null;\r\n            }\r\n        }\r\n\r\n        if (this._framebuffer) {\r\n            gl.deleteFramebuffer(this._framebuffer);\r\n            this._framebuffer = null;\r\n        }\r\n\r\n        if (this._depthStencilBuffer) {\r\n            gl.deleteRenderbuffer(this._depthStencilBuffer);\r\n            this._depthStencilBuffer = null;\r\n        }\r\n\r\n        if (this._MSAAFramebuffer) {\r\n            gl.deleteFramebuffer(this._MSAAFramebuffer);\r\n            this._MSAAFramebuffer = null;\r\n        }\r\n\r\n        super.dispose(disposeOnlyFramebuffers);\r\n    }\r\n}\r\n", "import type { DepthTextureCreationOptions, TextureSize } from \"../../Materials/Textures/textureCreationOptions\";\r\nimport { AbstractEngine } from \"../abstractEngine\";\r\nimport type { RenderTargetWrapper } from \"../renderTargetWrapper\";\r\nimport type { InternalTexture } from \"../../Materials/Textures/internalTexture\";\r\n\r\ndeclare module \"../../Engines/abstractEngine\" {\r\n    export interface AbstractEngine {\r\n        /**\r\n         * Creates a depth stencil texture.\r\n         * This is only available in WebGL 2 or with the depth texture extension available.\r\n         * @param size The size of face edge in the texture.\r\n         * @param options The options defining the texture.\r\n         * @param rtWrapper The render target wrapper for which the depth/stencil texture must be created\r\n         * @returns The texture\r\n         */\r\n        createDepthStencilTexture(size: TextureSize, options: DepthTextureCreationOptions, rtWrapper: RenderTargetWrapper): InternalTexture;\r\n    }\r\n}\r\n\r\nAbstractEngine.prototype.createDepthStencilTexture = function (size: TextureSize, options: DepthTextureCreationOptions, rtWrapper: RenderTargetWrapper): InternalTexture {\r\n    if (options.isCube) {\r\n        const width = (<{ width: number; height: number }>size).width || <number>size;\r\n        return this._createDepthStencilCubeTexture(width, options);\r\n    } else {\r\n        return this._createDepthStencilTexture(size, options, rtWrapper);\r\n    }\r\n};\r\n", "import { InternalTexture, InternalTextureSource } from \"../../Materials/Textures/internalTexture\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport type { RenderTargetCreationOptions, DepthTextureCreationOptions, TextureSize } from \"../../Materials/Textures/textureCreationOptions\";\r\nimport { ThinEngine } from \"../thinEngine\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { RenderTargetWrapper } from \"../renderTargetWrapper\";\r\nimport { WebGLRenderTargetWrapper } from \"../WebGL/webGLRenderTargetWrapper\";\r\nimport type { WebGLHardwareTexture } from \"../WebGL/webGLHardwareTexture\";\r\nimport { HasStencilAspect } from \"core/Materials/Textures/textureHelper.functions\";\r\n\r\nimport { Constants } from \"../constants\";\r\n\r\nimport \"../AbstractEngine/abstractEngine.texture\";\r\n\r\n/**\r\n * Type used to define a texture size (either with a number or with a rect width and height)\r\n * @deprecated please use TextureSize instead\r\n */\r\nexport type RenderTargetTextureSize = TextureSize;\r\n\r\ndeclare module \"../../Engines/abstractEngine\" {\r\n    export interface AbstractEngine {\r\n        /**\r\n         * Creates a new render target texture\r\n         * @param size defines the size of the texture\r\n         * @param options defines the options used to create the texture\r\n         * @returns a new render target wrapper ready to render texture\r\n         */\r\n        createRenderTargetTexture(size: TextureSize, options: boolean | RenderTargetCreationOptions): RenderTargetWrapper;\r\n\r\n        /**\r\n         * Updates the sample count of a render target texture\r\n         * @see https://doc.babylonjs.com/setup/support/webGL2#multisample-render-targets\r\n         * @param rtWrapper defines the render target wrapper to update\r\n         * @param samples defines the sample count to set\r\n         * @returns the effective sample count (could be 0 if multisample render targets are not supported)\r\n         */\r\n        updateRenderTargetTextureSampleCount(rtWrapper: Nullable<RenderTargetWrapper>, samples: number): number;\r\n\r\n        /** @internal */\r\n        _createDepthStencilTexture(size: TextureSize, options: DepthTextureCreationOptions, rtWrapper: RenderTargetWrapper): InternalTexture;\r\n\r\n        /** @internal */\r\n        _createHardwareRenderTargetWrapper(isMulti: boolean, isCube: boolean, size: TextureSize): RenderTargetWrapper;\r\n\r\n        /** @internal */\r\n        _setupDepthStencilTexture(internalTexture: InternalTexture, size: TextureSize, bilinearFiltering: boolean, comparisonFunction: number, samples?: number): void;\r\n    }\r\n}\r\n\r\nThinEngine.prototype._createHardwareRenderTargetWrapper = function (isMulti: boolean, isCube: boolean, size: TextureSize): RenderTargetWrapper {\r\n    const rtWrapper = new WebGLRenderTargetWrapper(isMulti, isCube, size, this, this._gl);\r\n    this._renderTargetWrapperCache.push(rtWrapper);\r\n    return rtWrapper;\r\n};\r\n\r\nThinEngine.prototype.createRenderTargetTexture = function (this: ThinEngine, size: TextureSize, options: boolean | RenderTargetCreationOptions): RenderTargetWrapper {\r\n    const rtWrapper = this._createHardwareRenderTargetWrapper(false, false, size) as WebGLRenderTargetWrapper;\r\n\r\n    let generateDepthBuffer = true;\r\n    let generateStencilBuffer = false;\r\n    let noColorAttachment = false;\r\n    let colorAttachment: InternalTexture | undefined = undefined;\r\n    let samples = 1;\r\n    let label: string | undefined = undefined;\r\n    if (options !== undefined && typeof options === \"object\") {\r\n        generateDepthBuffer = options.generateDepthBuffer ?? true;\r\n        generateStencilBuffer = !!options.generateStencilBuffer;\r\n        noColorAttachment = !!options.noColorAttachment;\r\n        colorAttachment = options.colorAttachment;\r\n        samples = options.samples ?? 1;\r\n        label = options.label;\r\n    }\r\n\r\n    const texture = colorAttachment || (noColorAttachment ? null : this._createInternalTexture(size, options, true, InternalTextureSource.RenderTarget));\r\n    const width = (<{ width: number; height: number; layers?: number }>size).width || <number>size;\r\n    const height = (<{ width: number; height: number; layers?: number }>size).height || <number>size;\r\n\r\n    const currentFrameBuffer = this._currentFramebuffer;\r\n    const gl = this._gl;\r\n\r\n    // Create the framebuffer\r\n    const framebuffer = gl.createFramebuffer();\r\n    this._bindUnboundFramebuffer(framebuffer);\r\n    rtWrapper._depthStencilBuffer = this._setupFramebufferDepthAttachments(generateStencilBuffer, generateDepthBuffer, width, height);\r\n\r\n    // No need to rebind on every frame\r\n    if (texture && !texture.is2DArray && !texture.is3D) {\r\n        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture._hardwareTexture!.underlyingResource, 0);\r\n    }\r\n\r\n    this._bindUnboundFramebuffer(currentFrameBuffer);\r\n\r\n    rtWrapper.label = label ?? \"RenderTargetWrapper\";\r\n    rtWrapper._framebuffer = framebuffer;\r\n    rtWrapper._generateDepthBuffer = generateDepthBuffer;\r\n    rtWrapper._generateStencilBuffer = generateStencilBuffer;\r\n\r\n    rtWrapper.setTextures(texture);\r\n\r\n    if (!colorAttachment) {\r\n        this.updateRenderTargetTextureSampleCount(rtWrapper, samples);\r\n    } else {\r\n        rtWrapper._samples = colorAttachment.samples;\r\n        if (colorAttachment.samples > 1) {\r\n            const msaaRenderBuffer = (colorAttachment._hardwareTexture as WebGLHardwareTexture).getMSAARenderBuffer(0);\r\n\r\n            rtWrapper._MSAAFramebuffer = gl.createFramebuffer();\r\n\r\n            this._bindUnboundFramebuffer(rtWrapper._MSAAFramebuffer!);\r\n            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, msaaRenderBuffer);\r\n            this._bindUnboundFramebuffer(null);\r\n        }\r\n    }\r\n\r\n    return rtWrapper;\r\n};\r\n\r\nThinEngine.prototype._createDepthStencilTexture = function (size: TextureSize, options: DepthTextureCreationOptions, rtWrapper: WebGLRenderTargetWrapper): InternalTexture {\r\n    const gl = this._gl;\r\n    const layers = (<{ width: number; height: number; depth?: number; layers?: number }>size).layers || 0;\r\n    const depth = (<{ width: number; height: number; depth?: number; layers?: number }>size).depth || 0;\r\n    let target: number = gl.TEXTURE_2D;\r\n    if (layers !== 0) {\r\n        target = gl.TEXTURE_2D_ARRAY;\r\n    } else if (depth !== 0) {\r\n        target = gl.TEXTURE_3D;\r\n    }\r\n    const internalTexture = new InternalTexture(this, InternalTextureSource.DepthStencil);\r\n    internalTexture.label = options.label;\r\n    if (!this._caps.depthTextureExtension) {\r\n        Logger.Error(\"Depth texture is not supported by your browser or hardware.\");\r\n        return internalTexture;\r\n    }\r\n\r\n    const internalOptions = {\r\n        bilinearFiltering: false,\r\n        comparisonFunction: 0,\r\n        generateStencil: false,\r\n        ...options,\r\n    };\r\n\r\n    this._bindTextureDirectly(target, internalTexture, true);\r\n\r\n    this._setupDepthStencilTexture(\r\n        internalTexture,\r\n        size,\r\n        internalOptions.comparisonFunction === 0 ? false : internalOptions.bilinearFiltering,\r\n        internalOptions.comparisonFunction,\r\n        internalOptions.samples\r\n    );\r\n\r\n    if (internalOptions.depthTextureFormat !== undefined) {\r\n        if (\r\n            internalOptions.depthTextureFormat !== Constants.TEXTUREFORMAT_DEPTH16 &&\r\n            internalOptions.depthTextureFormat !== Constants.TEXTUREFORMAT_DEPTH24 &&\r\n            internalOptions.depthTextureFormat !== Constants.TEXTUREFORMAT_DEPTH24UNORM_STENCIL8 &&\r\n            internalOptions.depthTextureFormat !== Constants.TEXTUREFORMAT_DEPTH24_STENCIL8 &&\r\n            internalOptions.depthTextureFormat !== Constants.TEXTUREFORMAT_DEPTH32_FLOAT &&\r\n            internalOptions.depthTextureFormat !== Constants.TEXTUREFORMAT_DEPTH32FLOAT_STENCIL8\r\n        ) {\r\n            Logger.Error(`Depth texture ${internalOptions.depthTextureFormat} format is not supported.`);\r\n            return internalTexture;\r\n        }\r\n        internalTexture.format = internalOptions.depthTextureFormat;\r\n    } else {\r\n        internalTexture.format = internalOptions.generateStencil ? Constants.TEXTUREFORMAT_DEPTH24_STENCIL8 : Constants.TEXTUREFORMAT_DEPTH24;\r\n    }\r\n\r\n    const hasStencil = HasStencilAspect(internalTexture.format);\r\n    const type = this._getWebGLTextureTypeFromDepthTextureFormat(internalTexture.format);\r\n    const format = hasStencil ? gl.DEPTH_STENCIL : gl.DEPTH_COMPONENT;\r\n    const internalFormat = this._getInternalFormatFromDepthTextureFormat(internalTexture.format, true, hasStencil);\r\n\r\n    if (internalTexture.is2DArray) {\r\n        gl.texImage3D(target, 0, internalFormat, internalTexture.width, internalTexture.height, layers, 0, format, type, null);\r\n    } else if (internalTexture.is3D) {\r\n        gl.texImage3D(target, 0, internalFormat, internalTexture.width, internalTexture.height, depth, 0, format, type, null);\r\n    } else {\r\n        gl.texImage2D(target, 0, internalFormat, internalTexture.width, internalTexture.height, 0, format, type, null);\r\n    }\r\n\r\n    this._bindTextureDirectly(target, null);\r\n\r\n    this._internalTexturesCache.push(internalTexture);\r\n\r\n    if (rtWrapper._depthStencilBuffer) {\r\n        gl.deleteRenderbuffer(rtWrapper._depthStencilBuffer);\r\n        rtWrapper._depthStencilBuffer = null;\r\n    }\r\n\r\n    this._bindUnboundFramebuffer(rtWrapper._MSAAFramebuffer ?? rtWrapper._framebuffer);\r\n\r\n    rtWrapper._generateStencilBuffer = hasStencil;\r\n    rtWrapper._depthStencilTextureWithStencil = hasStencil;\r\n\r\n    rtWrapper._depthStencilBuffer = this._setupFramebufferDepthAttachments(\r\n        rtWrapper._generateStencilBuffer,\r\n        rtWrapper._generateDepthBuffer,\r\n        rtWrapper.width,\r\n        rtWrapper.height,\r\n        rtWrapper.samples,\r\n        internalTexture.format\r\n    );\r\n\r\n    this._bindUnboundFramebuffer(null);\r\n\r\n    return internalTexture;\r\n};\r\n\r\nThinEngine.prototype.updateRenderTargetTextureSampleCount = function (rtWrapper: Nullable<WebGLRenderTargetWrapper>, samples: number): number {\r\n    if (this.webGLVersion < 2 || !rtWrapper) {\r\n        return 1;\r\n    }\r\n\r\n    if (rtWrapper.samples === samples) {\r\n        return samples;\r\n    }\r\n\r\n    const gl = this._gl;\r\n\r\n    samples = Math.min(samples, this.getCaps().maxMSAASamples);\r\n\r\n    // Dispose previous render buffers\r\n    if (rtWrapper._depthStencilBuffer) {\r\n        gl.deleteRenderbuffer(rtWrapper._depthStencilBuffer);\r\n        rtWrapper._depthStencilBuffer = null;\r\n    }\r\n\r\n    if (rtWrapper._MSAAFramebuffer) {\r\n        gl.deleteFramebuffer(rtWrapper._MSAAFramebuffer);\r\n        rtWrapper._MSAAFramebuffer = null;\r\n    }\r\n\r\n    const hardwareTexture = rtWrapper.texture?._hardwareTexture as Nullable<WebGLHardwareTexture>;\r\n    hardwareTexture?.releaseMSAARenderBuffers();\r\n\r\n    if (rtWrapper.texture && samples > 1 && typeof gl.renderbufferStorageMultisample === \"function\") {\r\n        const framebuffer = gl.createFramebuffer();\r\n\r\n        if (!framebuffer) {\r\n            throw new Error(\"Unable to create multi sampled framebuffer\");\r\n        }\r\n\r\n        rtWrapper._MSAAFramebuffer = framebuffer;\r\n        this._bindUnboundFramebuffer(rtWrapper._MSAAFramebuffer);\r\n\r\n        const colorRenderbuffer = this._createRenderBuffer(\r\n            rtWrapper.texture.width,\r\n            rtWrapper.texture.height,\r\n            samples,\r\n            -1 /* not used */,\r\n            this._getRGBABufferInternalSizedFormat(rtWrapper.texture.type, rtWrapper.texture.format, rtWrapper.texture._useSRGBBuffer),\r\n            gl.COLOR_ATTACHMENT0,\r\n            false\r\n        );\r\n\r\n        if (!colorRenderbuffer) {\r\n            throw new Error(\"Unable to create multi sampled framebuffer\");\r\n        }\r\n\r\n        hardwareTexture?.addMSAARenderBuffer(colorRenderbuffer);\r\n    }\r\n\r\n    this._bindUnboundFramebuffer(rtWrapper._MSAAFramebuffer ?? rtWrapper._framebuffer);\r\n\r\n    if (rtWrapper.texture) {\r\n        rtWrapper.texture.samples = samples;\r\n    }\r\n\r\n    rtWrapper._samples = samples;\r\n\r\n    const depthFormat = rtWrapper._depthStencilTexture ? rtWrapper._depthStencilTexture.format : undefined;\r\n\r\n    rtWrapper._depthStencilBuffer = this._setupFramebufferDepthAttachments(\r\n        rtWrapper._generateStencilBuffer,\r\n        rtWrapper._generateDepthBuffer,\r\n        rtWrapper.width,\r\n        rtWrapper.height,\r\n        samples,\r\n        depthFormat\r\n    );\r\n\r\n    this._bindUnboundFramebuffer(null);\r\n\r\n    return samples;\r\n};\r\n\r\nThinEngine.prototype._setupDepthStencilTexture = function (\r\n    internalTexture: InternalTexture,\r\n    size: TextureSize,\r\n    bilinearFiltering: boolean,\r\n    comparisonFunction: number,\r\n    samples = 1\r\n) {\r\n    const width = (<{ width: number; height: number; layers?: number }>size).width ?? <number>size;\r\n    const height = (<{ width: number; height: number; layers?: number }>size).height ?? <number>size;\r\n    const layers = (<{ width: number; height: number; depth?: number; layers?: number }>size).layers || 0;\r\n    const depth = (<{ width: number; height: number; depth?: number; layers?: number }>size).depth || 0;\r\n\r\n    internalTexture.baseWidth = width;\r\n    internalTexture.baseHeight = height;\r\n    internalTexture.width = width;\r\n    internalTexture.height = height;\r\n    internalTexture.is2DArray = layers > 0;\r\n    internalTexture.depth = layers || depth;\r\n    internalTexture.isReady = true;\r\n    internalTexture.samples = samples;\r\n    internalTexture.generateMipMaps = false;\r\n    internalTexture.samplingMode = bilinearFiltering ? Constants.TEXTURE_BILINEAR_SAMPLINGMODE : Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n    internalTexture.type = Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n    internalTexture._comparisonFunction = comparisonFunction;\r\n\r\n    const gl = this._gl;\r\n    const target = this._getTextureTarget(internalTexture);\r\n    const samplingParameters = this._getSamplingParameters(internalTexture.samplingMode, false);\r\n    gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, samplingParameters.mag);\r\n    gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, samplingParameters.min);\r\n    gl.texParameteri(target, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n    gl.texParameteri(target, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n\r\n    // TEXTURE_COMPARE_FUNC/MODE are only availble in WebGL2.\r\n    if (this.webGLVersion > 1) {\r\n        if (comparisonFunction === 0) {\r\n            gl.texParameteri(target, gl.TEXTURE_COMPARE_FUNC, Constants.LEQUAL);\r\n            gl.texParameteri(target, gl.TEXTURE_COMPARE_MODE, gl.NONE);\r\n        } else {\r\n            gl.texParameteri(target, gl.TEXTURE_COMPARE_FUNC, comparisonFunction);\r\n            gl.texParameteri(target, gl.TEXTURE_COMPARE_MODE, gl.COMPARE_REF_TO_TEXTURE);\r\n        }\r\n    }\r\n};\r\n", "import type { Nullable } from \"../../types\";\r\nimport { ThinEngine } from \"../../Engines/thinEngine\";\r\nimport type { RenderTargetTexture } from \"../../Materials/Textures/renderTargetTexture\";\r\n\r\ndeclare module \"../../Engines/abstractEngine\" {\r\n    export interface AbstractEngine {\r\n        /**\r\n         * Sets a depth stencil texture from a render target to the according uniform.\r\n         * @param channel The texture channel\r\n         * @param uniform The uniform to set\r\n         * @param texture The render target texture containing the depth stencil texture to apply\r\n         * @param name The texture name\r\n         */\r\n        setDepthStencilTexture(channel: number, uniform: Nullable<WebGLUniformLocation>, texture: Nullable<RenderTargetTexture>, name?: string): void;\r\n    }\r\n}\r\n\r\nThinEngine.prototype.setDepthStencilTexture = function (channel: number, uniform: Nullable<WebGLUniformLocation>, texture: Nullable<RenderTargetTexture>, name?: string): void {\r\n    if (channel === undefined) {\r\n        return;\r\n    }\r\n\r\n    if (uniform) {\r\n        this._boundUniforms[channel] = uniform;\r\n    }\r\n\r\n    if (!texture || !texture.depthStencilTexture) {\r\n        this._setTexture(channel, null, undefined, undefined, name);\r\n    } else {\r\n        this._setTexture(channel, texture, false, true, name);\r\n    }\r\n};\r\n", "import { InternalTexture, InternalTextureSource } from \"../../Materials/Textures/internalTexture\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport { Constants } from \"../constants\";\r\nimport { ThinEngine } from \"../thinEngine\";\r\nimport type { RenderTargetWrapper } from \"../renderTargetWrapper\";\r\nimport type { WebGLRenderTargetWrapper } from \"../WebGL/webGLRenderTargetWrapper\";\r\nimport type { RenderTargetCreationOptions } from \"../../Materials/Textures/textureCreationOptions\";\r\n\r\ndeclare module \"../../Engines/abstractEngine\" {\r\n    export interface AbstractEngine {\r\n        /**\r\n         * Creates a new render target cube wrapper\r\n         * @param size defines the size of the texture\r\n         * @param options defines the options used to create the texture\r\n         * @returns a new render target cube wrapper\r\n         */\r\n        createRenderTargetCubeTexture(size: number, options?: RenderTargetCreationOptions): RenderTargetWrapper;\r\n    }\r\n}\r\n\r\nThinEngine.prototype.createRenderTargetCubeTexture = function (size: number, options?: RenderTargetCreationOptions): RenderTargetWrapper {\r\n    const rtWrapper = this._createHardwareRenderTargetWrapper(false, true, size) as WebGLRenderTargetWrapper;\r\n\r\n    const fullOptions = {\r\n        generateMipMaps: true,\r\n        generateDepthBuffer: true,\r\n        generateStencilBuffer: false,\r\n        type: Constants.TEXTURETYPE_UNSIGNED_BYTE,\r\n        samplingMode: Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n        format: Constants.TEXTUREFORMAT_RGBA,\r\n        ...options,\r\n    };\r\n    fullOptions.generateStencilBuffer = fullOptions.generateDepthBuffer && fullOptions.generateStencilBuffer;\r\n\r\n    if (fullOptions.type === Constants.TEXTURETYPE_FLOAT && !this._caps.textureFloatLinearFiltering) {\r\n        // if floating point linear (gl.FLOAT) then force to NEAREST_SAMPLINGMODE\r\n        fullOptions.samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n    } else if (fullOptions.type === Constants.TEXTURETYPE_HALF_FLOAT && !this._caps.textureHalfFloatLinearFiltering) {\r\n        // if floating point linear (HALF_FLOAT) then force to NEAREST_SAMPLINGMODE\r\n        fullOptions.samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n    }\r\n    const gl = this._gl;\r\n\r\n    const texture = new InternalTexture(this, InternalTextureSource.RenderTarget);\r\n    this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);\r\n\r\n    const filters = this._getSamplingParameters(fullOptions.samplingMode, fullOptions.generateMipMaps);\r\n\r\n    if (fullOptions.type === Constants.TEXTURETYPE_FLOAT && !this._caps.textureFloat) {\r\n        fullOptions.type = Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n        Logger.Warn(\"Float textures are not supported. Cube render target forced to TEXTURETYPE_UNESIGNED_BYTE type\");\r\n    }\r\n\r\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, filters.mag);\r\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, filters.min);\r\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n\r\n    for (let face = 0; face < 6; face++) {\r\n        gl.texImage2D(\r\n            gl.TEXTURE_CUBE_MAP_POSITIVE_X + face,\r\n            0,\r\n            this._getRGBABufferInternalSizedFormat(fullOptions.type, fullOptions.format),\r\n            size,\r\n            size,\r\n            0,\r\n            this._getInternalFormat(fullOptions.format),\r\n            this._getWebGLTextureType(fullOptions.type),\r\n            null\r\n        );\r\n    }\r\n\r\n    // Create the framebuffer\r\n    const framebuffer = gl.createFramebuffer();\r\n    this._bindUnboundFramebuffer(framebuffer);\r\n\r\n    rtWrapper._depthStencilBuffer = this._setupFramebufferDepthAttachments(fullOptions.generateStencilBuffer, fullOptions.generateDepthBuffer, size, size);\r\n\r\n    // MipMaps\r\n    if (fullOptions.generateMipMaps) {\r\n        gl.generateMipmap(gl.TEXTURE_CUBE_MAP);\r\n    }\r\n\r\n    // Unbind\r\n    this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);\r\n    this._bindUnboundFramebuffer(null);\r\n\r\n    rtWrapper._framebuffer = framebuffer;\r\n    rtWrapper._generateDepthBuffer = fullOptions.generateDepthBuffer;\r\n    rtWrapper._generateStencilBuffer = fullOptions.generateStencilBuffer;\r\n\r\n    texture.width = size;\r\n    texture.height = size;\r\n    texture.isReady = true;\r\n    texture.isCube = true;\r\n    texture.samples = 1;\r\n    texture.generateMipMaps = fullOptions.generateMipMaps;\r\n    texture.samplingMode = fullOptions.samplingMode;\r\n    texture.type = fullOptions.type;\r\n    texture.format = fullOptions.format;\r\n\r\n    this._internalTexturesCache.push(texture);\r\n    rtWrapper.setTextures(texture);\r\n\r\n    return rtWrapper;\r\n};\r\n", "import { ThinEngine } from \"../../Engines/thinEngine\";\r\nimport { InternalTexture, InternalTextureSource } from \"../../Materials/Textures/internalTexture\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Constants } from \"../constants\";\r\nimport { SphericalPolynomial } from \"core/Maths/sphericalPolynomial\";\r\nimport { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport type { DDSInfo } from \"core/Misc/dds\";\r\n\r\ndeclare module \"../../Engines/abstractEngine\" {\r\n    export interface AbstractEngine {\r\n        /**\r\n         * Create a cube texture from prefiltered data (ie. the mipmaps contain ready to use data for PBR reflection)\r\n         * @param rootUrl defines the url where the file to load is located\r\n         * @param scene defines the current scene\r\n         * @param lodScale defines scale to apply to the mip map selection\r\n         * @param lodOffset defines offset to apply to the mip map selection\r\n         * @param onLoad defines an optional callback raised when the texture is loaded\r\n         * @param onError defines an optional callback raised if there is an issue to load the texture\r\n         * @param format defines the format of the data\r\n         * @param forcedExtension defines the extension to use to pick the right loader\r\n         * @param createPolynomials defines wheter or not to create polynomails harmonics for the texture\r\n         * @returns the cube texture as an InternalTexture\r\n         */\r\n        createPrefilteredCubeTexture(\r\n            rootUrl: string,\r\n            scene: Nullable<Scene>,\r\n            lodScale: number,\r\n            lodOffset: number,\r\n            onLoad?: Nullable<(internalTexture: Nullable<InternalTexture>) => void>,\r\n            onError?: Nullable<(message?: string, exception?: any) => void>,\r\n            format?: number,\r\n            forcedExtension?: any,\r\n            createPolynomials?: boolean\r\n        ): InternalTexture;\r\n    }\r\n}\r\n\r\nThinEngine.prototype.createPrefilteredCubeTexture = function (\r\n    rootUrl: string,\r\n    scene: Nullable<Scene>,\r\n    lodScale: number,\r\n    lodOffset: number,\r\n    onLoad: Nullable<(internalTexture: Nullable<InternalTexture>) => void> = null,\r\n    onError: Nullable<(message?: string, exception?: any) => void> = null,\r\n    format?: number,\r\n    forcedExtension: any = null,\r\n    createPolynomials: boolean = true\r\n): InternalTexture {\r\n    const callback = async (loadData: any) => {\r\n        if (!loadData) {\r\n            if (onLoad) {\r\n                onLoad(null);\r\n            }\r\n            return;\r\n        }\r\n\r\n        const texture = loadData.texture as InternalTexture;\r\n        if (!createPolynomials) {\r\n            texture._sphericalPolynomial = new SphericalPolynomial();\r\n        } else if (loadData.info.sphericalPolynomial) {\r\n            texture._sphericalPolynomial = loadData.info.sphericalPolynomial;\r\n        }\r\n        texture._source = InternalTextureSource.CubePrefiltered;\r\n\r\n        if (this.getCaps().textureLOD) {\r\n            // Do not add extra process if texture lod is supported.\r\n            if (onLoad) {\r\n                onLoad(texture);\r\n            }\r\n            return;\r\n        }\r\n\r\n        const mipSlices = 3;\r\n\r\n        const gl = this._gl;\r\n        const width = loadData.width;\r\n        if (!width) {\r\n            return;\r\n        }\r\n\r\n        // eslint-disable-next-line @typescript-eslint/naming-convention\r\n        const { DDSTools } = await import(\"core/Misc/dds\");\r\n\r\n        const textures: BaseTexture[] = [];\r\n        for (let i = 0; i < mipSlices; i++) {\r\n            //compute LOD from even spacing in smoothness (matching shader calculation)\r\n            const smoothness = i / (mipSlices - 1);\r\n            const roughness = 1 - smoothness;\r\n\r\n            const minLODIndex = lodOffset; // roughness = 0\r\n            const maxLODIndex = Math.log2(width) * lodScale + lodOffset; // roughness = 1\r\n\r\n            const lodIndex = minLODIndex + (maxLODIndex - minLODIndex) * roughness;\r\n            const mipmapIndex = Math.round(Math.min(Math.max(lodIndex, 0), maxLODIndex));\r\n\r\n            const glTextureFromLod = new InternalTexture(this, InternalTextureSource.Temp);\r\n            glTextureFromLod.type = texture.type;\r\n            glTextureFromLod.format = texture.format;\r\n            glTextureFromLod.width = Math.pow(2, Math.max(Math.log2(width) - mipmapIndex, 0));\r\n            glTextureFromLod.height = glTextureFromLod.width;\r\n            glTextureFromLod.isCube = true;\r\n            glTextureFromLod._cachedWrapU = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n            glTextureFromLod._cachedWrapV = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n            this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, glTextureFromLod, true);\r\n\r\n            glTextureFromLod.samplingMode = Constants.TEXTURE_LINEAR_LINEAR;\r\n            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\r\n            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\r\n            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n\r\n            if (loadData.isDDS) {\r\n                const info: DDSInfo = loadData.info;\r\n                const data: any = loadData.data;\r\n                this._unpackFlipY(info.isCompressed);\r\n\r\n                DDSTools.UploadDDSLevels(this, glTextureFromLod, data, info, true, 6, mipmapIndex);\r\n            } else {\r\n                Logger.Warn(\"DDS is the only prefiltered cube map supported so far.\");\r\n            }\r\n\r\n            this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);\r\n\r\n            // Wrap in a base texture for easy binding.\r\n            const lodTexture = new BaseTexture(scene);\r\n            lodTexture._isCube = true;\r\n            lodTexture._texture = glTextureFromLod;\r\n\r\n            glTextureFromLod.isReady = true;\r\n            textures.push(lodTexture);\r\n        }\r\n\r\n        texture._lodTextureHigh = textures[2];\r\n        texture._lodTextureMid = textures[1];\r\n        texture._lodTextureLow = textures[0];\r\n\r\n        if (onLoad) {\r\n            onLoad(texture);\r\n        }\r\n    };\r\n\r\n    return this.createCubeTexture(rootUrl, scene, null, false, callback, onError, format, forcedExtension, createPolynomials, lodScale, lodOffset);\r\n};\r\n", "import { ThinEngine } from \"../../Engines/thinEngine\";\r\nimport type { FloatArray, Nullable } from \"../../types\";\r\nimport type { DataBuffer } from \"../../Buffers/dataBuffer\";\r\nimport { WebGLDataBuffer } from \"../../Meshes/WebGL/webGLDataBuffer\";\r\nimport type { IPipelineContext } from \"../IPipelineContext\";\r\nimport type { WebGLPipelineContext } from \"../WebGL/webGLPipelineContext\";\r\n\r\ndeclare module \"../../Engines/thinEngine\" {\r\n    export interface ThinEngine {\r\n        /**\r\n         * Create an uniform buffer\r\n         * @see https://doc.babylonjs.com/setup/support/webGL2#uniform-buffer-objets\r\n         * @param elements defines the content of the uniform buffer\r\n         * @param label defines a name for the buffer (for debugging purpose)\r\n         * @returns the webGL uniform buffer\r\n         */\r\n        createUniformBuffer(elements: FloatArray, label?: string): DataBuffer;\r\n\r\n        /**\r\n         * Create a dynamic uniform buffer\r\n         * @see https://doc.babylonjs.com/setup/support/webGL2#uniform-buffer-objets\r\n         * @param elements defines the content of the uniform buffer\r\n         * @param label defines a name for the buffer (for debugging purpose)\r\n         * @returns the webGL uniform buffer\r\n         */\r\n        createDynamicUniformBuffer(elements: FloatArray, label?: string): DataBuffer;\r\n\r\n        /**\r\n         * Update an existing uniform buffer\r\n         * @see https://doc.babylonjs.com/setup/support/webGL2#uniform-buffer-objets\r\n         * @param uniformBuffer defines the target uniform buffer\r\n         * @param elements defines the content to update\r\n         * @param offset defines the offset in the uniform buffer where update should start\r\n         * @param count defines the size of the data to update\r\n         */\r\n        updateUniformBuffer(uniformBuffer: DataBuffer, elements: FloatArray, offset?: number, count?: number): void;\r\n\r\n        /**\r\n         * Bind an uniform buffer to the current webGL context\r\n         * @param buffer defines the buffer to bind\r\n         */\r\n        bindUniformBuffer(buffer: Nullable<DataBuffer>): void;\r\n\r\n        /**\r\n         * Bind a buffer to the current webGL context at a given location\r\n         * @param buffer defines the buffer to bind\r\n         * @param location defines the index where to bind the buffer\r\n         * @param name Name of the uniform variable to bind\r\n         */\r\n        bindUniformBufferBase(buffer: DataBuffer, location: number, name: string): void;\r\n\r\n        /**\r\n         * Bind a specific block at a given index in a specific shader program\r\n         * @param pipelineContext defines the pipeline context to use\r\n         * @param blockName defines the block name\r\n         * @param index defines the index where to bind the block\r\n         */\r\n        bindUniformBlock(pipelineContext: IPipelineContext, blockName: string, index: number): void;\r\n    }\r\n}\r\n\r\nThinEngine.prototype.createUniformBuffer = function (elements: FloatArray, _label?: string): DataBuffer {\r\n    const ubo = this._gl.createBuffer();\r\n\r\n    if (!ubo) {\r\n        throw new Error(\"Unable to create uniform buffer\");\r\n    }\r\n    const result = new WebGLDataBuffer(ubo);\r\n\r\n    this.bindUniformBuffer(result);\r\n\r\n    if (elements instanceof Float32Array) {\r\n        this._gl.bufferData(this._gl.UNIFORM_BUFFER, <Float32Array>elements, this._gl.STATIC_DRAW);\r\n    } else {\r\n        this._gl.bufferData(this._gl.UNIFORM_BUFFER, new Float32Array(<number[]>elements), this._gl.STATIC_DRAW);\r\n    }\r\n\r\n    this.bindUniformBuffer(null);\r\n\r\n    result.references = 1;\r\n    return result;\r\n};\r\n\r\nThinEngine.prototype.createDynamicUniformBuffer = function (elements: FloatArray, _label?: string): DataBuffer {\r\n    const ubo = this._gl.createBuffer();\r\n\r\n    if (!ubo) {\r\n        throw new Error(\"Unable to create dynamic uniform buffer\");\r\n    }\r\n\r\n    const result = new WebGLDataBuffer(ubo);\r\n    this.bindUniformBuffer(result);\r\n\r\n    if (elements instanceof Float32Array) {\r\n        this._gl.bufferData(this._gl.UNIFORM_BUFFER, <Float32Array>elements, this._gl.DYNAMIC_DRAW);\r\n    } else {\r\n        this._gl.bufferData(this._gl.UNIFORM_BUFFER, new Float32Array(<number[]>elements), this._gl.DYNAMIC_DRAW);\r\n    }\r\n\r\n    this.bindUniformBuffer(null);\r\n\r\n    result.references = 1;\r\n    return result;\r\n};\r\n\r\nThinEngine.prototype.updateUniformBuffer = function (uniformBuffer: DataBuffer, elements: FloatArray, offset?: number, count?: number): void {\r\n    this.bindUniformBuffer(uniformBuffer);\r\n\r\n    if (offset === undefined) {\r\n        offset = 0;\r\n    }\r\n\r\n    if (count === undefined) {\r\n        if (elements instanceof Float32Array) {\r\n            this._gl.bufferSubData(this._gl.UNIFORM_BUFFER, offset, <Float32Array>elements);\r\n        } else {\r\n            this._gl.bufferSubData(this._gl.UNIFORM_BUFFER, offset, new Float32Array(<number[]>elements));\r\n        }\r\n    } else {\r\n        if (elements instanceof Float32Array) {\r\n            this._gl.bufferSubData(this._gl.UNIFORM_BUFFER, 0, <Float32Array>elements.subarray(offset, offset + count));\r\n        } else {\r\n            this._gl.bufferSubData(this._gl.UNIFORM_BUFFER, 0, new Float32Array(<number[]>elements).subarray(offset, offset + count));\r\n        }\r\n    }\r\n\r\n    this.bindUniformBuffer(null);\r\n};\r\n\r\nThinEngine.prototype.bindUniformBuffer = function (buffer: Nullable<DataBuffer>): void {\r\n    this._gl.bindBuffer(this._gl.UNIFORM_BUFFER, buffer ? buffer.underlyingResource : null);\r\n};\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\r\nThinEngine.prototype.bindUniformBufferBase = function (buffer: DataBuffer, location: number, name: string): void {\r\n    this._gl.bindBufferBase(this._gl.UNIFORM_BUFFER, location, buffer ? buffer.underlyingResource : null);\r\n};\r\n\r\nThinEngine.prototype.bindUniformBlock = function (pipelineContext: IPipelineContext, blockName: string, index: number): void {\r\n    const program = (pipelineContext as WebGLPipelineContext).program!;\r\n\r\n    const uniformLocation = this._gl.getUniformBlockIndex(program, blockName);\r\n\r\n    if (uniformLocation !== 0xffffffff) {\r\n        this._gl.uniformBlockBinding(program, uniformLocation, index);\r\n    }\r\n};\r\n", "import { IsWindowObjectExist } from \"../../Misc/domManagement\";\r\nimport type { ILoadingScreen } from \"../../Loading/loadingScreen\";\r\nimport { AbstractEngine } from \"../abstractEngine\";\r\n\r\ndeclare module \"../../Engines/abstractEngine\" {\r\n    export interface AbstractEngine {\r\n        /**\r\n         * Display the loading screen\r\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/customLoadingScreen\r\n         */\r\n        displayLoadingUI(): void;\r\n\r\n        /**\r\n         * Hide the loading screen\r\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/customLoadingScreen\r\n         */\r\n        hideLoadingUI(): void;\r\n\r\n        /**\r\n         * Gets or sets the current loading screen object\r\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/customLoadingScreen\r\n         */\r\n        loadingScreen: ILoadingScreen;\r\n\r\n        /**\r\n         * Sets the current loading screen text\r\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/customLoadingScreen\r\n         */\r\n        loadingUIText: string;\r\n\r\n        /**\r\n         * Sets the current loading screen background color\r\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/customLoadingScreen\r\n         */\r\n        loadingUIBackgroundColor: string;\r\n    }\r\n}\r\n\r\nAbstractEngine.prototype.displayLoadingUI = function (): void {\r\n    if (!IsWindowObjectExist()) {\r\n        return;\r\n    }\r\n    const loadingScreen = this.loadingScreen;\r\n    if (loadingScreen) {\r\n        loadingScreen.displayLoadingUI();\r\n    }\r\n};\r\n\r\nAbstractEngine.prototype.hideLoadingUI = function (): void {\r\n    if (!IsWindowObjectExist()) {\r\n        return;\r\n    }\r\n    const loadingScreen = this._loadingScreen;\r\n    if (loadingScreen) {\r\n        loadingScreen.hideLoadingUI();\r\n    }\r\n};\r\n\r\nObject.defineProperty(AbstractEngine.prototype, \"loadingScreen\", {\r\n    get: function (this: AbstractEngine) {\r\n        if (!this._loadingScreen && this._renderingCanvas) {\r\n            this._loadingScreen = AbstractEngine.DefaultLoadingScreenFactory(this._renderingCanvas);\r\n        }\r\n        return this._loadingScreen;\r\n    },\r\n    set: function (this: AbstractEngine, value: ILoadingScreen) {\r\n        this._loadingScreen = value;\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n\r\nObject.defineProperty(AbstractEngine.prototype, \"loadingUIText\", {\r\n    set: function (this: AbstractEngine, value: string) {\r\n        this.loadingScreen.loadingUIText = value;\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n\r\nObject.defineProperty(AbstractEngine.prototype, \"loadingUIBackgroundColor\", {\r\n    set: function (this: AbstractEngine, value: string) {\r\n        this.loadingScreen.loadingUIBackgroundColor = value;\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n", "import type { IViewportLike } from \"../../Maths/math.like\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { AbstractEngine } from \"../abstractEngine\";\r\n\r\n/**\r\n * Defines the interface used by objects containing a viewport (like a camera)\r\n */\r\ninterface IViewportOwnerLike {\r\n    /**\r\n     * Gets or sets the viewport\r\n     */\r\n    viewport: IViewportLike;\r\n}\r\n\r\ndeclare module \"../../Engines/abstractEngine\" {\r\n    export interface AbstractEngine {\r\n        /**\r\n         * Gets the HTML element used to attach event listeners\r\n         * @returns a HTML element\r\n         */\r\n        getInputElement(): Nullable<HTMLElement>;\r\n\r\n        /**\r\n         * Gets the client rect of the HTML canvas attached with the current webGL context\r\n         * @returns a client rectangle\r\n         */\r\n        getRenderingCanvasClientRect(): Nullable<ClientRect>;\r\n\r\n        /**\r\n         * Gets the client rect of the HTML element used for events\r\n         * @returns a client rectangle\r\n         */\r\n        getInputElementClientRect(): Nullable<ClientRect>;\r\n\r\n        /**\r\n         * Gets current aspect ratio\r\n         * @param viewportOwner defines the camera to use to get the aspect ratio\r\n         * @param useScreen defines if screen size must be used (or the current render target if any)\r\n         * @returns a number defining the aspect ratio\r\n         */\r\n        getAspectRatio(viewportOwner: IViewportOwnerLike, useScreen?: boolean): number;\r\n\r\n        /**\r\n         * Gets current screen aspect ratio\r\n         * @returns a number defining the aspect ratio\r\n         */\r\n        getScreenAspectRatio(): number;\r\n\r\n        /**\r\n         * Toggle full screen mode\r\n         * @param requestPointerLock defines if a pointer lock should be requested from the user\r\n         */\r\n        switchFullscreen(requestPointerLock: boolean): void;\r\n\r\n        /**\r\n         * Enters full screen mode\r\n         * @param requestPointerLock defines if a pointer lock should be requested from the user\r\n         */\r\n        enterFullscreen(requestPointerLock: boolean): void;\r\n\r\n        /**\r\n         * Exits full screen mode\r\n         */\r\n        exitFullscreen(): void;\r\n\r\n        /** @internal */\r\n        _onPointerLockChange: () => void;\r\n\r\n        /** @internal */\r\n        _verifyPointerLock(): void;\r\n    }\r\n}\r\n\r\nAbstractEngine.prototype.getInputElement = function (): Nullable<HTMLElement> {\r\n    return this._renderingCanvas;\r\n};\r\n\r\nAbstractEngine.prototype.getRenderingCanvasClientRect = function (): Nullable<ClientRect> {\r\n    if (!this._renderingCanvas) {\r\n        return null;\r\n    }\r\n    return this._renderingCanvas.getBoundingClientRect();\r\n};\r\n\r\nAbstractEngine.prototype.getInputElementClientRect = function (): Nullable<ClientRect> {\r\n    if (!this._renderingCanvas) {\r\n        return null;\r\n    }\r\n    return this.getInputElement()!.getBoundingClientRect();\r\n};\r\n\r\nAbstractEngine.prototype.getAspectRatio = function (viewportOwner: IViewportOwnerLike, useScreen = false): number {\r\n    const viewport = viewportOwner.viewport;\r\n    return (this.getRenderWidth(useScreen) * viewport.width) / (this.getRenderHeight(useScreen) * viewport.height);\r\n};\r\n\r\nAbstractEngine.prototype.getScreenAspectRatio = function (): number {\r\n    return this.getRenderWidth(true) / this.getRenderHeight(true);\r\n};\r\n\r\nAbstractEngine.prototype._verifyPointerLock = function (): void {\r\n    this._onPointerLockChange?.();\r\n};\r\n", "import { AbstractEngine } from \"../abstractEngine\";\r\nimport { Constants } from \"../constants\";\r\n\r\ndeclare module \"../abstractEngine\" {\r\n    export interface AbstractEngine {\r\n        /**\r\n         * Sets the current alpha equation\r\n         * @param equation defines the equation to use (one of the Engine.ALPHA_EQUATION_XXX)\r\n         */\r\n        setAlphaEquation(equation: number): void;\r\n    }\r\n}\r\n\r\nAbstractEngine.prototype.setAlphaEquation = function (equation: number): void {\r\n    if (this._alphaEquation === equation) {\r\n        return;\r\n    }\r\n\r\n    switch (equation) {\r\n        case Constants.ALPHA_EQUATION_ADD:\r\n            this._alphaState.setAlphaEquationParameters(Constants.GL_ALPHA_EQUATION_ADD, Constants.GL_ALPHA_EQUATION_ADD);\r\n            break;\r\n        case Constants.ALPHA_EQUATION_SUBSTRACT:\r\n            this._alphaState.setAlphaEquationParameters(Constants.GL_ALPHA_EQUATION_SUBTRACT, Constants.GL_ALPHA_EQUATION_SUBTRACT);\r\n            break;\r\n        case Constants.ALPHA_EQUATION_REVERSE_SUBTRACT:\r\n            this._alphaState.setAlphaEquationParameters(Constants.GL_ALPHA_EQUATION_REVERSE_SUBTRACT, Constants.GL_ALPHA_EQUATION_REVERSE_SUBTRACT);\r\n            break;\r\n        case Constants.ALPHA_EQUATION_MAX:\r\n            this._alphaState.setAlphaEquationParameters(Constants.GL_ALPHA_EQUATION_MAX, Constants.GL_ALPHA_EQUATION_MAX);\r\n            break;\r\n        case Constants.ALPHA_EQUATION_MIN:\r\n            this._alphaState.setAlphaEquationParameters(Constants.GL_ALPHA_EQUATION_MIN, Constants.GL_ALPHA_EQUATION_MIN);\r\n            break;\r\n        case Constants.ALPHA_EQUATION_DARKEN:\r\n            this._alphaState.setAlphaEquationParameters(Constants.GL_ALPHA_EQUATION_MIN, Constants.GL_ALPHA_EQUATION_ADD);\r\n            break;\r\n    }\r\n    this._alphaEquation = equation;\r\n};\r\n", "import type { Nullable } from \"../../types\";\r\nimport { AbstractEngine } from \"../abstractEngine\";\r\nimport { Constants } from \"../constants\";\r\n\r\nimport \"./abstractEngine.alpha\";\r\n\r\ndeclare module \"../../Engines/abstractEngine\" {\r\n    export interface AbstractEngine {\r\n        /** @internal */\r\n        _cachedStencilBuffer: boolean;\r\n        /** @internal */\r\n        _cachedStencilFunction: number;\r\n        /** @internal */\r\n        _cachedStencilMask: number;\r\n        /** @internal */\r\n        _cachedStencilOperationPass: number;\r\n        /** @internal */\r\n        _cachedStencilOperationFail: number;\r\n        /** @internal */\r\n        _cachedStencilOperationDepthFail: number;\r\n        /** @internal */\r\n        _cachedStencilReference: number;\r\n\r\n        /**\r\n         * Gets the current depth function\r\n         * @returns a number defining the depth function\r\n         */\r\n        getDepthFunction(): Nullable<number>;\r\n\r\n        /**\r\n         * Sets the current depth function\r\n         * @param depthFunc defines the function to use\r\n         */\r\n        setDepthFunction(depthFunc: number): void;\r\n\r\n        /**\r\n         * Sets the current depth function to GREATER\r\n         */\r\n        setDepthFunctionToGreater(): void;\r\n\r\n        /**\r\n         * Sets the current depth function to GEQUAL\r\n         */\r\n        setDepthFunctionToGreaterOrEqual(): void;\r\n\r\n        /**\r\n         * Sets the current depth function to LESS\r\n         */\r\n        setDepthFunctionToLess(): void;\r\n\r\n        /**\r\n         * Sets the current depth function to LEQUAL\r\n         */\r\n        setDepthFunctionToLessOrEqual(): void;\r\n\r\n        /**\r\n         * Gets a boolean indicating if depth writing is enabled\r\n         * @returns the current depth writing state\r\n         */\r\n        getDepthWrite(): boolean;\r\n\r\n        /**\r\n         * Enable or disable depth writing\r\n         * @param enable defines the state to set\r\n         */\r\n        setDepthWrite(enable: boolean): void;\r\n\r\n        /**\r\n         * Gets the current stencil operation when stencil passes\r\n         * @returns a number defining stencil operation to use when stencil passes\r\n         */\r\n        getStencilOperationPass(): number;\r\n\r\n        /**\r\n         * Gets a boolean indicating if stencil buffer is enabled\r\n         * @returns the current stencil buffer state\r\n         */\r\n        getStencilBuffer(): boolean;\r\n\r\n        /**\r\n         * Enable or disable the stencil buffer\r\n         * @param enable defines if the stencil buffer must be enabled or disabled\r\n         */\r\n        setStencilBuffer(enable: boolean): void;\r\n\r\n        /**\r\n         * Gets the current stencil mask\r\n         * @returns a number defining the new stencil mask to use\r\n         */\r\n        getStencilMask(): number;\r\n        /**\r\n         * Sets the current stencil mask\r\n         * @param mask defines the new stencil mask to use\r\n         */\r\n        setStencilMask(mask: number): void;\r\n\r\n        /**\r\n         * Gets the current stencil function\r\n         * @returns a number defining the stencil function to use\r\n         */\r\n        getStencilFunction(): number;\r\n\r\n        /**\r\n         * Gets the current stencil reference value\r\n         * @returns a number defining the stencil reference value to use\r\n         */\r\n        getStencilFunctionReference(): number;\r\n\r\n        /**\r\n         * Gets the current stencil mask\r\n         * @returns a number defining the stencil mask to use\r\n         */\r\n        getStencilFunctionMask(): number;\r\n\r\n        /**\r\n         * Sets the current stencil function\r\n         * @param stencilFunc defines the new stencil function to use\r\n         */\r\n        setStencilFunction(stencilFunc: number): void;\r\n\r\n        /**\r\n         * Sets the current stencil reference\r\n         * @param reference defines the new stencil reference to use\r\n         */\r\n        setStencilFunctionReference(reference: number): void;\r\n\r\n        /**\r\n         * Sets the current stencil mask\r\n         * @param mask defines the new stencil mask to use\r\n         */\r\n        setStencilFunctionMask(mask: number): void;\r\n\r\n        /**\r\n         * Gets the current stencil operation when stencil fails\r\n         * @returns a number defining stencil operation to use when stencil fails\r\n         */\r\n        getStencilOperationFail(): number;\r\n\r\n        /**\r\n         * Gets the current stencil operation when depth fails\r\n         * @returns a number defining stencil operation to use when depth fails\r\n         */\r\n        getStencilOperationDepthFail(): number;\r\n\r\n        /**\r\n         * Sets the stencil operation to use when stencil fails\r\n         * @param operation defines the stencil operation to use when stencil fails\r\n         */\r\n        setStencilOperationFail(operation: number): void;\r\n\r\n        /**\r\n         * Sets the stencil operation to use when depth fails\r\n         * @param operation defines the stencil operation to use when depth fails\r\n         */\r\n        setStencilOperationDepthFail(operation: number): void;\r\n\r\n        /**\r\n         * Sets the stencil operation to use when stencil passes\r\n         * @param operation defines the stencil operation to use when stencil passes\r\n         */\r\n        setStencilOperationPass(operation: number): void;\r\n\r\n        /**\r\n         * Caches the state of the stencil buffer\r\n         */\r\n        cacheStencilState(): void;\r\n\r\n        /**\r\n         * Restores the state of the stencil buffer\r\n         */\r\n        restoreStencilState(): void;\r\n\r\n        /**\r\n         * Sets alpha constants used by some alpha blending modes\r\n         * @param r defines the red component\r\n         * @param g defines the green component\r\n         * @param b defines the blue component\r\n         * @param a defines the alpha component\r\n         */\r\n        setAlphaConstants(r: number, g: number, b: number, a: number): void;\r\n\r\n        /**\r\n         * Gets the current alpha mode\r\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/advanced/transparent_rendering\r\n         * @returns the current alpha mode\r\n         */\r\n        getAlphaMode(): number;\r\n\r\n        /**\r\n         * Gets the current alpha equation.\r\n         * @returns the current alpha equation\r\n         */\r\n        getAlphaEquation(): number;\r\n    }\r\n}\r\n\r\nAbstractEngine.prototype.getInputElement = function (): Nullable<HTMLElement> {\r\n    return this._renderingCanvas;\r\n};\r\n\r\nAbstractEngine.prototype.getDepthFunction = function (): Nullable<number> {\r\n    return this._depthCullingState.depthFunc;\r\n};\r\n\r\nAbstractEngine.prototype.setDepthFunction = function (depthFunc: number) {\r\n    this._depthCullingState.depthFunc = depthFunc;\r\n};\r\n\r\nAbstractEngine.prototype.setDepthFunctionToGreater = function (): void {\r\n    this.setDepthFunction(Constants.GREATER);\r\n};\r\n\r\nAbstractEngine.prototype.setDepthFunctionToGreaterOrEqual = function (): void {\r\n    this.setDepthFunction(Constants.GEQUAL);\r\n};\r\n\r\nAbstractEngine.prototype.setDepthFunctionToLess = function (): void {\r\n    this.setDepthFunction(Constants.LESS);\r\n};\r\nAbstractEngine.prototype.setDepthFunctionToLessOrEqual = function (): void {\r\n    this.setDepthFunction(Constants.LEQUAL);\r\n};\r\n\r\nAbstractEngine.prototype.getDepthWrite = function (): boolean {\r\n    return this._depthCullingState.depthMask;\r\n};\r\n\r\nAbstractEngine.prototype.setDepthWrite = function (enable: boolean): void {\r\n    this._depthCullingState.depthMask = enable;\r\n};\r\n\r\nAbstractEngine.prototype.getStencilBuffer = function (): boolean {\r\n    return this._stencilState.stencilTest;\r\n};\r\n\r\nAbstractEngine.prototype.setStencilBuffer = function (enable: boolean): void {\r\n    this._stencilState.stencilTest = enable;\r\n};\r\n\r\nAbstractEngine.prototype.getStencilMask = function (): number {\r\n    return this._stencilState.stencilMask;\r\n};\r\n\r\nAbstractEngine.prototype.setStencilMask = function (mask: number): void {\r\n    this._stencilState.stencilMask = mask;\r\n};\r\n\r\nAbstractEngine.prototype.getStencilFunction = function (): number {\r\n    return this._stencilState.stencilFunc;\r\n};\r\n\r\nAbstractEngine.prototype.getStencilFunctionReference = function (): number {\r\n    return this._stencilState.stencilFuncRef;\r\n};\r\n\r\nAbstractEngine.prototype.getStencilFunctionMask = function (): number {\r\n    return this._stencilState.stencilFuncMask;\r\n};\r\n\r\nAbstractEngine.prototype.setStencilFunction = function (stencilFunc: number) {\r\n    this._stencilState.stencilFunc = stencilFunc;\r\n};\r\n\r\nAbstractEngine.prototype.setStencilFunctionReference = function (reference: number): void {\r\n    this._stencilState.stencilFuncRef = reference;\r\n};\r\n\r\nAbstractEngine.prototype.setStencilFunctionMask = function (mask: number): void {\r\n    this._stencilState.stencilFuncMask = mask;\r\n};\r\n\r\nAbstractEngine.prototype.getStencilOperationFail = function (): number {\r\n    return this._stencilState.stencilOpStencilFail;\r\n};\r\n\r\nAbstractEngine.prototype.getStencilOperationDepthFail = function (): number {\r\n    return this._stencilState.stencilOpDepthFail;\r\n};\r\n\r\nAbstractEngine.prototype.getStencilOperationPass = function (): number {\r\n    return this._stencilState.stencilOpStencilDepthPass;\r\n};\r\n\r\nAbstractEngine.prototype.setStencilOperationFail = function (operation: number): void {\r\n    this._stencilState.stencilOpStencilFail = operation;\r\n};\r\n\r\nAbstractEngine.prototype.setStencilOperationDepthFail = function (operation: number): void {\r\n    this._stencilState.stencilOpDepthFail = operation;\r\n};\r\n\r\nAbstractEngine.prototype.setStencilOperationPass = function (operation: number): void {\r\n    this._stencilState.stencilOpStencilDepthPass = operation;\r\n};\r\n\r\nAbstractEngine.prototype.cacheStencilState = function (): void {\r\n    this._cachedStencilBuffer = this.getStencilBuffer();\r\n    this._cachedStencilFunction = this.getStencilFunction();\r\n    this._cachedStencilMask = this.getStencilMask();\r\n    this._cachedStencilOperationPass = this.getStencilOperationPass();\r\n    this._cachedStencilOperationFail = this.getStencilOperationFail();\r\n    this._cachedStencilOperationDepthFail = this.getStencilOperationDepthFail();\r\n    this._cachedStencilReference = this.getStencilFunctionReference();\r\n};\r\n\r\nAbstractEngine.prototype.restoreStencilState = function (): void {\r\n    this.setStencilFunction(this._cachedStencilFunction);\r\n    this.setStencilMask(this._cachedStencilMask);\r\n    this.setStencilBuffer(this._cachedStencilBuffer);\r\n    this.setStencilOperationPass(this._cachedStencilOperationPass);\r\n    this.setStencilOperationFail(this._cachedStencilOperationFail);\r\n    this.setStencilOperationDepthFail(this._cachedStencilOperationDepthFail);\r\n    this.setStencilFunctionReference(this._cachedStencilReference);\r\n};\r\n\r\nAbstractEngine.prototype.setAlphaConstants = function (r: number, g: number, b: number, a: number): void {\r\n    this._alphaState.setAlphaBlendConstants(r, g, b, a);\r\n};\r\n\r\nAbstractEngine.prototype.getAlphaMode = function (): number {\r\n    return this._alphaMode;\r\n};\r\n\r\nAbstractEngine.prototype.getAlphaEquation = function (): number {\r\n    return this._alphaEquation;\r\n};\r\n", "import { AbstractEngine } from \"../abstractEngine\";\r\n\r\ndeclare module \"../../Engines/abstractEngine\" {\r\n    export interface AbstractEngine {\r\n        /**\r\n         * Gets the names of the render passes that are currently created\r\n         * @returns list of the render pass names\r\n         */\r\n        getRenderPassNames(): string[];\r\n\r\n        /**\r\n         * Gets the name of the current render pass\r\n         * @returns name of the current render pass\r\n         */\r\n        getCurrentRenderPassName(): string;\r\n\r\n        /**\r\n         * Creates a render pass id\r\n         * @param name Name of the render pass (for debug purpose only)\r\n         * @returns the id of the new render pass\r\n         */\r\n        createRenderPassId(name?: string): number;\r\n\r\n        /**\r\n         * Releases a render pass id\r\n         * @param id id of the render pass to release\r\n         */\r\n        releaseRenderPassId(id: number): void;\r\n    }\r\n}\r\n\r\nAbstractEngine.prototype.getRenderPassNames = function (): string[] {\r\n    return this._renderPassNames;\r\n};\r\n\r\nAbstractEngine.prototype.getCurrentRenderPassName = function (): string {\r\n    return this._renderPassNames[this.currentRenderPassId];\r\n};\r\n\r\nAbstractEngine.prototype.createRenderPassId = function (name?: string): number {\r\n    // Note: render pass id == 0 is always for the main render pass\r\n    const id = ++AbstractEngine._RenderPassIdCounter;\r\n    this._renderPassNames[id] = name ?? \"NONAME\";\r\n    return id;\r\n};\r\n\r\nAbstractEngine.prototype.releaseRenderPassId = function (id: number): void {\r\n    this._renderPassNames[id] = undefined as any;\r\n\r\n    for (let s = 0; s < this.scenes.length; ++s) {\r\n        const scene = this.scenes[s];\r\n        for (let m = 0; m < scene.meshes.length; ++m) {\r\n            const mesh = scene.meshes[m];\r\n            if (mesh.subMeshes) {\r\n                for (let b = 0; b < mesh.subMeshes.length; ++b) {\r\n                    const subMesh = mesh.subMeshes[b];\r\n                    subMesh._removeDrawWrapper(id);\r\n                }\r\n            }\r\n        }\r\n    }\r\n};\r\n", "import type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport { InternalTexture, InternalTextureSource } from \"../Materials/Textures/internalTexture\";\r\nimport type { IOfflineProvider } from \"../Offline/IOfflineProvider\";\r\nimport type { ILoadingScreen } from \"../Loading/loadingScreen\";\r\nimport { EngineStore } from \"./engineStore\";\r\nimport type { WebGLPipelineContext } from \"./WebGL/webGLPipelineContext\";\r\nimport type { IPipelineContext } from \"./IPipelineContext\";\r\nimport type { ICustomAnimationFrameRequester } from \"../Misc/customAnimationFrameRequester\";\r\nimport type { EngineOptions } from \"./thinEngine\";\r\nimport { ThinEngine } from \"./thinEngine\";\r\nimport { Constants } from \"./constants\";\r\nimport type { IViewportLike, IColor4Like } from \"../Maths/math.like\";\r\nimport { PerformanceMonitor } from \"../Misc/performanceMonitor\";\r\nimport type { DataBuffer } from \"../Buffers/dataBuffer\";\r\nimport { WebGLDataBuffer } from \"../Meshes/WebGL/webGLDataBuffer\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport type { RenderTargetWrapper } from \"./renderTargetWrapper\";\r\nimport { WebGLHardwareTexture } from \"./WebGL/webGLHardwareTexture\";\r\n\r\nimport \"./Extensions/engine.alpha\";\r\nimport \"./Extensions/engine.rawTexture\";\r\nimport \"./Extensions/engine.readTexture\";\r\nimport \"./Extensions/engine.dynamicBuffer\";\r\nimport \"./Extensions/engine.cubeTexture\";\r\nimport \"./Extensions/engine.renderTarget\";\r\nimport \"./Extensions/engine.renderTargetTexture\";\r\nimport \"./Extensions/engine.renderTargetCube\";\r\nimport \"./Extensions/engine.prefilteredCubeTexture\";\r\nimport \"./Extensions/engine.uniformBuffer\";\r\nimport \"./AbstractEngine/abstractEngine.loadingScreen\";\r\nimport \"./AbstractEngine/abstractEngine.dom\";\r\nimport \"./AbstractEngine/abstractEngine.states\";\r\nimport \"./AbstractEngine/abstractEngine.renderPass\";\r\nimport \"./AbstractEngine/abstractEngine.texture\";\r\n\r\nimport type { PostProcess } from \"../PostProcesses/postProcess\";\r\nimport { AbstractEngine } from \"./abstractEngine\";\r\nimport {\r\n    CreateImageBitmapFromSource,\r\n    ExitFullscreen,\r\n    ExitPointerlock,\r\n    GetFontOffset,\r\n    RequestFullscreen,\r\n    RequestPointerlock,\r\n    ResizeImageBitmap,\r\n    _CommonDispose,\r\n    _CommonInit,\r\n} from \"./engine.common\";\r\nimport { PerfCounter } from \"../Misc/perfCounter\";\r\nimport \"../Audio/audioEngine\";\r\nimport { _retryWithInterval } from \"core/Misc/timingTools\";\r\n\r\n/**\r\n * The engine class is responsible for interfacing with all lower-level APIs such as WebGL and Audio\r\n */\r\nexport class Engine extends ThinEngine {\r\n    // Const statics\r\n\r\n    /** Defines that alpha blending is disabled */\r\n    public static readonly ALPHA_DISABLE = Constants.ALPHA_DISABLE;\r\n    /** Defines that alpha blending to SRC ALPHA * SRC + DEST */\r\n    public static readonly ALPHA_ADD = Constants.ALPHA_ADD;\r\n    /** Defines that alpha blending to SRC ALPHA * SRC + (1 - SRC ALPHA) * DEST */\r\n    public static readonly ALPHA_COMBINE = Constants.ALPHA_COMBINE;\r\n    /** Defines that alpha blending to DEST - SRC * DEST */\r\n    public static readonly ALPHA_SUBTRACT = Constants.ALPHA_SUBTRACT;\r\n    /** Defines that alpha blending to SRC * DEST */\r\n    public static readonly ALPHA_MULTIPLY = Constants.ALPHA_MULTIPLY;\r\n    /** Defines that alpha blending to SRC ALPHA * SRC + (1 - SRC) * DEST */\r\n    public static readonly ALPHA_MAXIMIZED = Constants.ALPHA_MAXIMIZED;\r\n    /** Defines that alpha blending to SRC + DEST */\r\n    public static readonly ALPHA_ONEONE = Constants.ALPHA_ONEONE;\r\n    /** Defines that alpha blending to SRC + (1 - SRC ALPHA) * DEST */\r\n    public static readonly ALPHA_PREMULTIPLIED = Constants.ALPHA_PREMULTIPLIED;\r\n    /**\r\n     * Defines that alpha blending to SRC + (1 - SRC ALPHA) * DEST\r\n     * Alpha will be set to (1 - SRC ALPHA) * DEST ALPHA\r\n     */\r\n    public static readonly ALPHA_PREMULTIPLIED_PORTERDUFF = Constants.ALPHA_PREMULTIPLIED_PORTERDUFF;\r\n    /** Defines that alpha blending to CST * SRC + (1 - CST) * DEST */\r\n    public static readonly ALPHA_INTERPOLATE = Constants.ALPHA_INTERPOLATE;\r\n    /**\r\n     * Defines that alpha blending to SRC + (1 - SRC) * DEST\r\n     * Alpha will be set to SRC ALPHA + (1 - SRC ALPHA) * DEST ALPHA\r\n     */\r\n    public static readonly ALPHA_SCREENMODE = Constants.ALPHA_SCREENMODE;\r\n\r\n    /** Defines that the resource is not delayed*/\r\n    public static readonly DELAYLOADSTATE_NONE = Constants.DELAYLOADSTATE_NONE;\r\n    /** Defines that the resource was successfully delay loaded */\r\n    public static readonly DELAYLOADSTATE_LOADED = Constants.DELAYLOADSTATE_LOADED;\r\n    /** Defines that the resource is currently delay loading */\r\n    public static readonly DELAYLOADSTATE_LOADING = Constants.DELAYLOADSTATE_LOADING;\r\n    /** Defines that the resource is delayed and has not started loading */\r\n    public static readonly DELAYLOADSTATE_NOTLOADED = Constants.DELAYLOADSTATE_NOTLOADED;\r\n\r\n    // Depht or Stencil test Constants.\r\n    /** Passed to depthFunction or stencilFunction to specify depth or stencil tests will never pass. i.e. Nothing will be drawn */\r\n    public static readonly NEVER = Constants.NEVER;\r\n    /** Passed to depthFunction or stencilFunction to specify depth or stencil tests will always pass. i.e. Pixels will be drawn in the order they are drawn */\r\n    public static readonly ALWAYS = Constants.ALWAYS;\r\n    /** Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is less than the stored value */\r\n    public static readonly LESS = Constants.LESS;\r\n    /** Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is equals to the stored value */\r\n    public static readonly EQUAL = Constants.EQUAL;\r\n    /** Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is less than or equal to the stored value */\r\n    public static readonly LEQUAL = Constants.LEQUAL;\r\n    /** Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is greater than the stored value */\r\n    public static readonly GREATER = Constants.GREATER;\r\n    /** Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is greater than or equal to the stored value */\r\n    public static readonly GEQUAL = Constants.GEQUAL;\r\n    /** Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is not equal to the stored value */\r\n    public static readonly NOTEQUAL = Constants.NOTEQUAL;\r\n\r\n    // Stencil Actions Constants.\r\n    /** Passed to stencilOperation to specify that stencil value must be kept */\r\n    public static readonly KEEP = Constants.KEEP;\r\n    /** Passed to stencilOperation to specify that stencil value must be replaced */\r\n    public static readonly REPLACE = Constants.REPLACE;\r\n    /** Passed to stencilOperation to specify that stencil value must be incremented */\r\n    public static readonly INCR = Constants.INCR;\r\n    /** Passed to stencilOperation to specify that stencil value must be decremented */\r\n    public static readonly DECR = Constants.DECR;\r\n    /** Passed to stencilOperation to specify that stencil value must be inverted */\r\n    public static readonly INVERT = Constants.INVERT;\r\n    /** Passed to stencilOperation to specify that stencil value must be incremented with wrapping */\r\n    public static readonly INCR_WRAP = Constants.INCR_WRAP;\r\n    /** Passed to stencilOperation to specify that stencil value must be decremented with wrapping */\r\n    public static readonly DECR_WRAP = Constants.DECR_WRAP;\r\n\r\n    /** Texture is not repeating outside of 0..1 UVs */\r\n    public static readonly TEXTURE_CLAMP_ADDRESSMODE = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n    /** Texture is repeating outside of 0..1 UVs */\r\n    public static readonly TEXTURE_WRAP_ADDRESSMODE = Constants.TEXTURE_WRAP_ADDRESSMODE;\r\n    /** Texture is repeating and mirrored */\r\n    public static readonly TEXTURE_MIRROR_ADDRESSMODE = Constants.TEXTURE_MIRROR_ADDRESSMODE;\r\n\r\n    /** ALPHA */\r\n    public static readonly TEXTUREFORMAT_ALPHA = Constants.TEXTUREFORMAT_ALPHA;\r\n    /** LUMINANCE */\r\n    public static readonly TEXTUREFORMAT_LUMINANCE = Constants.TEXTUREFORMAT_LUMINANCE;\r\n    /** LUMINANCE_ALPHA */\r\n    public static readonly TEXTUREFORMAT_LUMINANCE_ALPHA = Constants.TEXTUREFORMAT_LUMINANCE_ALPHA;\r\n    /** RGB */\r\n    public static readonly TEXTUREFORMAT_RGB = Constants.TEXTUREFORMAT_RGB;\r\n    /** RGBA */\r\n    public static readonly TEXTUREFORMAT_RGBA = Constants.TEXTUREFORMAT_RGBA;\r\n    /** RED */\r\n    public static readonly TEXTUREFORMAT_RED = Constants.TEXTUREFORMAT_RED;\r\n    /** RED (2nd reference) */\r\n    public static readonly TEXTUREFORMAT_R = Constants.TEXTUREFORMAT_R;\r\n    /** RED unsigned short normed to [0, 1] **/\r\n    public static readonly TEXTUREFORMAT_R16_UNORM = Constants.TEXTUREFORMAT_R16_UNORM;\r\n    /** RG unsigned short normed to [0, 1] **/\r\n    public static readonly TEXTUREFORMAT_RG16_UNORM = Constants.TEXTUREFORMAT_RG16_UNORM;\r\n    /** RGB unsigned short normed to [0, 1] **/\r\n    public static readonly TEXTUREFORMAT_RGB16_UNORM = Constants.TEXTUREFORMAT_RGB16_UNORM;\r\n    /** RGBA unsigned short normed to [0, 1] **/\r\n    public static readonly TEXTUREFORMAT_RGBA16_UNORM = Constants.TEXTUREFORMAT_RGBA16_UNORM;\r\n    /** RED signed short normed to [-1, 1] **/\r\n    public static readonly TEXTUREFORMAT_R16_SNORM = Constants.TEXTUREFORMAT_R16_SNORM;\r\n    /** RG signed short normed to [-1, 1] **/\r\n    public static readonly TEXTUREFORMAT_RG16_SNORM = Constants.TEXTUREFORMAT_RG16_SNORM;\r\n    /** RGB signed short normed to [-1, 1] **/\r\n    public static readonly TEXTUREFORMAT_RGB16_SNORM = Constants.TEXTUREFORMAT_RGB16_SNORM;\r\n    /** RGBA signed short normed to [-1, 1] **/\r\n    public static readonly TEXTUREFORMAT_RGBA16_SNORM = Constants.TEXTUREFORMAT_RGBA16_SNORM;\r\n    /** RG */\r\n    public static readonly TEXTUREFORMAT_RG = Constants.TEXTUREFORMAT_RG;\r\n    /** RED_INTEGER */\r\n    public static readonly TEXTUREFORMAT_RED_INTEGER = Constants.TEXTUREFORMAT_RED_INTEGER;\r\n    /** RED_INTEGER (2nd reference) */\r\n    public static readonly TEXTUREFORMAT_R_INTEGER = Constants.TEXTUREFORMAT_R_INTEGER;\r\n    /** RG_INTEGER */\r\n    public static readonly TEXTUREFORMAT_RG_INTEGER = Constants.TEXTUREFORMAT_RG_INTEGER;\r\n    /** RGB_INTEGER */\r\n    public static readonly TEXTUREFORMAT_RGB_INTEGER = Constants.TEXTUREFORMAT_RGB_INTEGER;\r\n    /** RGBA_INTEGER */\r\n    public static readonly TEXTUREFORMAT_RGBA_INTEGER = Constants.TEXTUREFORMAT_RGBA_INTEGER;\r\n\r\n    /** UNSIGNED_BYTE */\r\n    public static readonly TEXTURETYPE_UNSIGNED_BYTE = Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n    /** @deprecated use more explicit TEXTURETYPE_UNSIGNED_BYTE instead. Use TEXTURETYPE_UNSIGNED_INTEGER for 32bits values.*/\r\n    public static readonly TEXTURETYPE_UNSIGNED_INT = Constants.TEXTURETYPE_UNSIGNED_INT;\r\n    /** FLOAT */\r\n    public static readonly TEXTURETYPE_FLOAT = Constants.TEXTURETYPE_FLOAT;\r\n    /** HALF_FLOAT */\r\n    public static readonly TEXTURETYPE_HALF_FLOAT = Constants.TEXTURETYPE_HALF_FLOAT;\r\n    /** BYTE */\r\n    public static readonly TEXTURETYPE_BYTE = Constants.TEXTURETYPE_BYTE;\r\n    /** SHORT */\r\n    public static readonly TEXTURETYPE_SHORT = Constants.TEXTURETYPE_SHORT;\r\n    /** UNSIGNED_SHORT */\r\n    public static readonly TEXTURETYPE_UNSIGNED_SHORT = Constants.TEXTURETYPE_UNSIGNED_SHORT;\r\n    /** INT */\r\n    public static readonly TEXTURETYPE_INT = Constants.TEXTURETYPE_INT;\r\n    /** UNSIGNED_INT */\r\n    public static readonly TEXTURETYPE_UNSIGNED_INTEGER = Constants.TEXTURETYPE_UNSIGNED_INTEGER;\r\n    /** UNSIGNED_SHORT_4_4_4_4 */\r\n    public static readonly TEXTURETYPE_UNSIGNED_SHORT_4_4_4_4 = Constants.TEXTURETYPE_UNSIGNED_SHORT_4_4_4_4;\r\n    /** UNSIGNED_SHORT_5_5_5_1 */\r\n    public static readonly TEXTURETYPE_UNSIGNED_SHORT_5_5_5_1 = Constants.TEXTURETYPE_UNSIGNED_SHORT_5_5_5_1;\r\n    /** UNSIGNED_SHORT_5_6_5 */\r\n    public static readonly TEXTURETYPE_UNSIGNED_SHORT_5_6_5 = Constants.TEXTURETYPE_UNSIGNED_SHORT_5_6_5;\r\n    /** UNSIGNED_INT_2_10_10_10_REV */\r\n    public static readonly TEXTURETYPE_UNSIGNED_INT_2_10_10_10_REV = Constants.TEXTURETYPE_UNSIGNED_INT_2_10_10_10_REV;\r\n    /** UNSIGNED_INT_24_8 */\r\n    public static readonly TEXTURETYPE_UNSIGNED_INT_24_8 = Constants.TEXTURETYPE_UNSIGNED_INT_24_8;\r\n    /** UNSIGNED_INT_10F_11F_11F_REV */\r\n    public static readonly TEXTURETYPE_UNSIGNED_INT_10F_11F_11F_REV = Constants.TEXTURETYPE_UNSIGNED_INT_10F_11F_11F_REV;\r\n    /** UNSIGNED_INT_5_9_9_9_REV */\r\n    public static readonly TEXTURETYPE_UNSIGNED_INT_5_9_9_9_REV = Constants.TEXTURETYPE_UNSIGNED_INT_5_9_9_9_REV;\r\n    /** FLOAT_32_UNSIGNED_INT_24_8_REV */\r\n    public static readonly TEXTURETYPE_FLOAT_32_UNSIGNED_INT_24_8_REV = Constants.TEXTURETYPE_FLOAT_32_UNSIGNED_INT_24_8_REV;\r\n\r\n    /** nearest is mag = nearest and min = nearest and mip = none */\r\n    public static readonly TEXTURE_NEAREST_SAMPLINGMODE = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n    /** Bilinear is mag = linear and min = linear and mip = nearest */\r\n    public static readonly TEXTURE_BILINEAR_SAMPLINGMODE = Constants.TEXTURE_BILINEAR_SAMPLINGMODE;\r\n    /** Trilinear is mag = linear and min = linear and mip = linear */\r\n    public static readonly TEXTURE_TRILINEAR_SAMPLINGMODE = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE;\r\n    /** nearest is mag = nearest and min = nearest and mip = linear */\r\n    public static readonly TEXTURE_NEAREST_NEAREST_MIPLINEAR = Constants.TEXTURE_NEAREST_NEAREST_MIPLINEAR;\r\n    /** Bilinear is mag = linear and min = linear and mip = nearest */\r\n    public static readonly TEXTURE_LINEAR_LINEAR_MIPNEAREST = Constants.TEXTURE_LINEAR_LINEAR_MIPNEAREST;\r\n    /** Trilinear is mag = linear and min = linear and mip = linear */\r\n    public static readonly TEXTURE_LINEAR_LINEAR_MIPLINEAR = Constants.TEXTURE_LINEAR_LINEAR_MIPLINEAR;\r\n    /** mag = nearest and min = nearest and mip = nearest */\r\n    public static readonly TEXTURE_NEAREST_NEAREST_MIPNEAREST = Constants.TEXTURE_NEAREST_NEAREST_MIPNEAREST;\r\n    /** mag = nearest and min = linear and mip = nearest */\r\n    public static readonly TEXTURE_NEAREST_LINEAR_MIPNEAREST = Constants.TEXTURE_NEAREST_LINEAR_MIPNEAREST;\r\n    /** mag = nearest and min = linear and mip = linear */\r\n    public static readonly TEXTURE_NEAREST_LINEAR_MIPLINEAR = Constants.TEXTURE_NEAREST_LINEAR_MIPLINEAR;\r\n    /** mag = nearest and min = linear and mip = none */\r\n    public static readonly TEXTURE_NEAREST_LINEAR = Constants.TEXTURE_NEAREST_LINEAR;\r\n    /** mag = nearest and min = nearest and mip = none */\r\n    public static readonly TEXTURE_NEAREST_NEAREST = Constants.TEXTURE_NEAREST_NEAREST;\r\n    /** mag = linear and min = nearest and mip = nearest */\r\n    public static readonly TEXTURE_LINEAR_NEAREST_MIPNEAREST = Constants.TEXTURE_LINEAR_NEAREST_MIPNEAREST;\r\n    /** mag = linear and min = nearest and mip = linear */\r\n    public static readonly TEXTURE_LINEAR_NEAREST_MIPLINEAR = Constants.TEXTURE_LINEAR_NEAREST_MIPLINEAR;\r\n    /** mag = linear and min = linear and mip = none */\r\n    public static readonly TEXTURE_LINEAR_LINEAR = Constants.TEXTURE_LINEAR_LINEAR;\r\n    /** mag = linear and min = nearest and mip = none */\r\n    public static readonly TEXTURE_LINEAR_NEAREST = Constants.TEXTURE_LINEAR_NEAREST;\r\n\r\n    /** Explicit coordinates mode */\r\n    public static readonly TEXTURE_EXPLICIT_MODE = Constants.TEXTURE_EXPLICIT_MODE;\r\n    /** Spherical coordinates mode */\r\n    public static readonly TEXTURE_SPHERICAL_MODE = Constants.TEXTURE_SPHERICAL_MODE;\r\n    /** Planar coordinates mode */\r\n    public static readonly TEXTURE_PLANAR_MODE = Constants.TEXTURE_PLANAR_MODE;\r\n    /** Cubic coordinates mode */\r\n    public static readonly TEXTURE_CUBIC_MODE = Constants.TEXTURE_CUBIC_MODE;\r\n    /** Projection coordinates mode */\r\n    public static readonly TEXTURE_PROJECTION_MODE = Constants.TEXTURE_PROJECTION_MODE;\r\n    /** Skybox coordinates mode */\r\n    public static readonly TEXTURE_SKYBOX_MODE = Constants.TEXTURE_SKYBOX_MODE;\r\n    /** Inverse Cubic coordinates mode */\r\n    public static readonly TEXTURE_INVCUBIC_MODE = Constants.TEXTURE_INVCUBIC_MODE;\r\n    /** Equirectangular coordinates mode */\r\n    public static readonly TEXTURE_EQUIRECTANGULAR_MODE = Constants.TEXTURE_EQUIRECTANGULAR_MODE;\r\n    /** Equirectangular Fixed coordinates mode */\r\n    public static readonly TEXTURE_FIXED_EQUIRECTANGULAR_MODE = Constants.TEXTURE_FIXED_EQUIRECTANGULAR_MODE;\r\n    /** Equirectangular Fixed Mirrored coordinates mode */\r\n    public static readonly TEXTURE_FIXED_EQUIRECTANGULAR_MIRRORED_MODE = Constants.TEXTURE_FIXED_EQUIRECTANGULAR_MIRRORED_MODE;\r\n\r\n    // Texture rescaling mode\r\n    /** Defines that texture rescaling will use a floor to find the closer power of 2 size */\r\n    public static readonly SCALEMODE_FLOOR = Constants.SCALEMODE_FLOOR;\r\n    /** Defines that texture rescaling will look for the nearest power of 2 size */\r\n    public static readonly SCALEMODE_NEAREST = Constants.SCALEMODE_NEAREST;\r\n    /** Defines that texture rescaling will use a ceil to find the closer power of 2 size */\r\n    public static readonly SCALEMODE_CEILING = Constants.SCALEMODE_CEILING;\r\n\r\n    /**\r\n     * Returns the current npm package of the sdk\r\n     */\r\n    // Not mixed with Version for tooling purpose.\r\n    public static override get NpmPackage(): string {\r\n        return AbstractEngine.NpmPackage;\r\n    }\r\n\r\n    /**\r\n     * Returns the current version of the framework\r\n     */\r\n    public static override get Version(): string {\r\n        return AbstractEngine.Version;\r\n    }\r\n\r\n    /** Gets the list of created engines */\r\n    public static get Instances(): AbstractEngine[] {\r\n        return EngineStore.Instances;\r\n    }\r\n\r\n    /**\r\n     * Gets the latest created engine\r\n     */\r\n    public static get LastCreatedEngine(): Nullable<AbstractEngine> {\r\n        return EngineStore.LastCreatedEngine;\r\n    }\r\n\r\n    /**\r\n     * Gets the latest created scene\r\n     */\r\n    public static get LastCreatedScene(): Nullable<Scene> {\r\n        return EngineStore.LastCreatedScene;\r\n    }\r\n\r\n    /** @internal */\r\n\r\n    // eslint-disable-next-line jsdoc/require-returns-check\r\n    /**\r\n     * Method called to create the default loading screen.\r\n     * This can be overridden in your own app.\r\n     * @param canvas The rendering canvas element\r\n     * @returns The loading screen\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public static override DefaultLoadingScreenFactory(canvas: HTMLCanvasElement): ILoadingScreen {\r\n        return AbstractEngine.DefaultLoadingScreenFactory(canvas);\r\n    }\r\n\r\n    // Members\r\n\r\n    /**\r\n     * If set, will be used to request the next animation frame for the render loop\r\n     */\r\n    public customAnimationFrameRequester: Nullable<ICustomAnimationFrameRequester> = null;\r\n\r\n    private _rescalePostProcess: Nullable<PostProcess>;\r\n\r\n    protected override get _supportsHardwareTextureRescaling() {\r\n        return !!Engine._RescalePostProcessFactory;\r\n    }\r\n\r\n    private _measureFps(): void {\r\n        this._performanceMonitor.sampleFrame();\r\n        this._fps = this._performanceMonitor.averageFPS;\r\n        this._deltaTime = this._performanceMonitor.instantaneousFrameTime || 0;\r\n    }\r\n\r\n    private _performanceMonitor = new PerformanceMonitor();\r\n    /**\r\n     * Gets the performance monitor attached to this engine\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/optimize_your_scene#engineinstrumentation\r\n     */\r\n    public override get performanceMonitor(): PerformanceMonitor {\r\n        return this._performanceMonitor;\r\n    }\r\n\r\n    // Events\r\n\r\n    /**\r\n     * Creates a new engine\r\n     * @param canvasOrContext defines the canvas or WebGL context to use for rendering. If you provide a WebGL context, Babylon.js will not hook events on the canvas (like pointers, keyboards, etc...) so no event observables will be available. This is mostly used when Babylon.js is used as a plugin on a system which already used the WebGL context\r\n     * @param antialias defines enable antialiasing (default: false)\r\n     * @param options defines further options to be sent to the getContext() function\r\n     * @param adaptToDeviceRatio defines whether to adapt to the device's viewport characteristics (default: false)\r\n     */\r\n    constructor(\r\n        canvasOrContext: Nullable<HTMLCanvasElement | OffscreenCanvas | WebGLRenderingContext | WebGL2RenderingContext>,\r\n        antialias?: boolean,\r\n        options?: EngineOptions,\r\n        adaptToDeviceRatio: boolean = false\r\n    ) {\r\n        super(canvasOrContext, antialias, options, adaptToDeviceRatio);\r\n\r\n        this._drawCalls = new PerfCounter();\r\n\r\n        if (!canvasOrContext) {\r\n            return;\r\n        }\r\n\r\n        this._features.supportRenderPasses = true;\r\n\r\n        options = this._creationOptions;\r\n    }\r\n\r\n    protected override _initGLContext(): void {\r\n        super._initGLContext();\r\n\r\n        this._rescalePostProcess = null;\r\n    }\r\n\r\n    /**\r\n     * Shared initialization across engines types.\r\n     * @param canvas The canvas associated with this instance of the engine.\r\n     */\r\n    protected override _sharedInit(canvas: HTMLCanvasElement) {\r\n        super._sharedInit(canvas);\r\n\r\n        _CommonInit(this, canvas, this._creationOptions);\r\n    }\r\n\r\n    /**\r\n     * Resize an image and returns the image data as an uint8array\r\n     * @param image image to resize\r\n     * @param bufferWidth destination buffer width\r\n     * @param bufferHeight destination buffer height\r\n     * @returns an uint8array containing RGBA values of bufferWidth * bufferHeight size\r\n     */\r\n    public override resizeImageBitmap(image: HTMLImageElement | ImageBitmap, bufferWidth: number, bufferHeight: number): Uint8Array {\r\n        return ResizeImageBitmap(this, image, bufferWidth, bufferHeight);\r\n    }\r\n\r\n    /**\r\n     * Engine abstraction for loading and creating an image bitmap from a given source string.\r\n     * @param imageSource source to load the image from.\r\n     * @param options An object that sets options for the image's extraction.\r\n     * @returns ImageBitmap\r\n     */\r\n    public override _createImageBitmapFromSource(imageSource: string, options?: ImageBitmapOptions): Promise<ImageBitmap> {\r\n        return CreateImageBitmapFromSource(this, imageSource, options);\r\n    }\r\n\r\n    /**\r\n     * Toggle full screen mode\r\n     * @param requestPointerLock defines if a pointer lock should be requested from the user\r\n     */\r\n    public override switchFullscreen(requestPointerLock: boolean): void {\r\n        if (this.isFullscreen) {\r\n            this.exitFullscreen();\r\n        } else {\r\n            this.enterFullscreen(requestPointerLock);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Enters full screen mode\r\n     * @param requestPointerLock defines if a pointer lock should be requested from the user\r\n     */\r\n    public override enterFullscreen(requestPointerLock: boolean): void {\r\n        if (!this.isFullscreen) {\r\n            this._pointerLockRequested = requestPointerLock;\r\n            if (this._renderingCanvas) {\r\n                RequestFullscreen(this._renderingCanvas);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Exits full screen mode\r\n     */\r\n    public override exitFullscreen(): void {\r\n        if (this.isFullscreen) {\r\n            ExitFullscreen();\r\n        }\r\n    }\r\n\r\n    /** States */\r\n\r\n    /**\r\n     * Sets a boolean indicating if the dithering state is enabled or disabled\r\n     * @param value defines the dithering state\r\n     */\r\n    public setDitheringState(value: boolean): void {\r\n        if (value) {\r\n            this._gl.enable(this._gl.DITHER);\r\n        } else {\r\n            this._gl.disable(this._gl.DITHER);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a boolean indicating if the rasterizer state is enabled or disabled\r\n     * @param value defines the rasterizer state\r\n     */\r\n    public setRasterizerState(value: boolean): void {\r\n        if (value) {\r\n            this._gl.disable(this._gl.RASTERIZER_DISCARD);\r\n        } else {\r\n            this._gl.enable(this._gl.RASTERIZER_DISCARD);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Directly set the WebGL Viewport\r\n     * @param x defines the x coordinate of the viewport (in screen space)\r\n     * @param y defines the y coordinate of the viewport (in screen space)\r\n     * @param width defines the width of the viewport (in screen space)\r\n     * @param height defines the height of the viewport (in screen space)\r\n     * @returns the current viewport Object (if any) that is being replaced by this call. You can restore this viewport later on to go back to the original state\r\n     */\r\n    public setDirectViewport(x: number, y: number, width: number, height: number): Nullable<IViewportLike> {\r\n        const currentViewport = this._cachedViewport;\r\n        this._cachedViewport = null;\r\n\r\n        this._viewport(x, y, width, height);\r\n\r\n        return currentViewport;\r\n    }\r\n\r\n    /**\r\n     * Executes a scissor clear (ie. a clear on a specific portion of the screen)\r\n     * @param x defines the x-coordinate of the bottom left corner of the clear rectangle\r\n     * @param y defines the y-coordinate of the corner of the clear rectangle\r\n     * @param width defines the width of the clear rectangle\r\n     * @param height defines the height of the clear rectangle\r\n     * @param clearColor defines the clear color\r\n     */\r\n    public scissorClear(x: number, y: number, width: number, height: number, clearColor: IColor4Like): void {\r\n        this.enableScissor(x, y, width, height);\r\n        this.clear(clearColor, true, true, true);\r\n        this.disableScissor();\r\n    }\r\n\r\n    /**\r\n     * Enable scissor test on a specific rectangle (ie. render will only be executed on a specific portion of the screen)\r\n     * @param x defines the x-coordinate of the bottom left corner of the clear rectangle\r\n     * @param y defines the y-coordinate of the corner of the clear rectangle\r\n     * @param width defines the width of the clear rectangle\r\n     * @param height defines the height of the clear rectangle\r\n     */\r\n    public enableScissor(x: number, y: number, width: number, height: number): void {\r\n        const gl = this._gl;\r\n\r\n        // Change state\r\n        gl.enable(gl.SCISSOR_TEST);\r\n        gl.scissor(x, y, width, height);\r\n    }\r\n\r\n    /**\r\n     * Disable previously set scissor test rectangle\r\n     */\r\n    public disableScissor() {\r\n        const gl = this._gl;\r\n\r\n        gl.disable(gl.SCISSOR_TEST);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _loadFileAsync(url: string, offlineProvider?: IOfflineProvider, useArrayBuffer?: false): Promise<string>;\r\n    public _loadFileAsync(url: string, offlineProvider?: IOfflineProvider, useArrayBuffer?: true): Promise<ArrayBuffer>;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _loadFileAsync(url: string, offlineProvider?: IOfflineProvider, useArrayBuffer?: boolean): Promise<string | ArrayBuffer> {\r\n        return new Promise((resolve, reject) => {\r\n            this._loadFile(\r\n                url,\r\n                (data) => {\r\n                    resolve(data);\r\n                },\r\n                undefined,\r\n                offlineProvider,\r\n                useArrayBuffer,\r\n                (request, exception) => {\r\n                    reject(exception);\r\n                }\r\n            );\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Gets the source code of the vertex shader associated with a specific webGL program\r\n     * @param program defines the program to use\r\n     * @returns a string containing the source code of the vertex shader associated with the program\r\n     */\r\n    public getVertexShaderSource(program: WebGLProgram): Nullable<string> {\r\n        const shaders = this._gl.getAttachedShaders(program);\r\n\r\n        if (!shaders) {\r\n            return null;\r\n        }\r\n\r\n        return this._gl.getShaderSource(shaders[0]);\r\n    }\r\n\r\n    /**\r\n     * Gets the source code of the fragment shader associated with a specific webGL program\r\n     * @param program defines the program to use\r\n     * @returns a string containing the source code of the fragment shader associated with the program\r\n     */\r\n    public getFragmentShaderSource(program: WebGLProgram): Nullable<string> {\r\n        const shaders = this._gl.getAttachedShaders(program);\r\n\r\n        if (!shaders) {\r\n            return null;\r\n        }\r\n\r\n        return this._gl.getShaderSource(shaders[1]);\r\n    }\r\n\r\n    /**\r\n     * sets the object from which width and height will be taken from when getting render width and height\r\n     * Will fallback to the gl object\r\n     * @param dimensions the framebuffer width and height that will be used.\r\n     */\r\n    public override set framebufferDimensionsObject(dimensions: Nullable<{ framebufferWidth: number; framebufferHeight: number }>) {\r\n        this._framebufferDimensionsObject = dimensions;\r\n        if (this._framebufferDimensionsObject) {\r\n            this.onResizeObservable.notifyObservers(this);\r\n        }\r\n    }\r\n\r\n    protected override _rebuildBuffers(): void {\r\n        // Index / Vertex\r\n        for (const scene of this.scenes) {\r\n            scene.resetCachedMaterial();\r\n            scene._rebuildGeometries();\r\n        }\r\n\r\n        for (const scene of this._virtualScenes) {\r\n            scene.resetCachedMaterial();\r\n            scene._rebuildGeometries();\r\n        }\r\n\r\n        super._rebuildBuffers();\r\n    }\r\n\r\n    /**\r\n     * Get Font size information\r\n     * @param font font name\r\n     * @returns an object containing ascent, height and descent\r\n     */\r\n    public override getFontOffset(font: string): { ascent: number; height: number; descent: number } {\r\n        return GetFontOffset(font);\r\n    }\r\n\r\n    protected override _cancelFrame() {\r\n        if (this.customAnimationFrameRequester) {\r\n            if (this._frameHandler !== 0) {\r\n                this._frameHandler = 0;\r\n                const { cancelAnimationFrame } = this.customAnimationFrameRequester;\r\n                if (cancelAnimationFrame) {\r\n                    cancelAnimationFrame(this.customAnimationFrameRequester.requestID);\r\n                }\r\n            }\r\n        } else {\r\n            super._cancelFrame();\r\n        }\r\n    }\r\n\r\n    public override _renderLoop(timestamp?: number): void {\r\n        this._processFrame(timestamp);\r\n\r\n        // The first condition prevents queuing another frame if we no longer have active render loops (e.g., if\r\n        // `stopRenderLoop` is called mid frame). The second condition prevents queuing another frame if one has\r\n        // already been queued (e.g., if `stopRenderLoop` and `runRenderLoop` is called mid frame).\r\n        if (this._activeRenderLoops.length > 0 && this._frameHandler === 0) {\r\n            if (this.customAnimationFrameRequester) {\r\n                this.customAnimationFrameRequester.requestID = this._queueNewFrame(\r\n                    this.customAnimationFrameRequester.renderFunction || this._boundRenderFunction,\r\n                    this.customAnimationFrameRequester\r\n                );\r\n                this._frameHandler = this.customAnimationFrameRequester.requestID;\r\n            } else {\r\n                this._frameHandler = this._queueNewFrame(this._boundRenderFunction, this.getHostWindow());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Enters Pointerlock mode\r\n     */\r\n    public enterPointerlock(): void {\r\n        if (this._renderingCanvas) {\r\n            RequestPointerlock(this._renderingCanvas);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Exits Pointerlock mode\r\n     */\r\n    public exitPointerlock(): void {\r\n        ExitPointerlock();\r\n    }\r\n\r\n    /**\r\n     * Begin a new frame\r\n     */\r\n    public override beginFrame(): void {\r\n        this._measureFps();\r\n        super.beginFrame();\r\n    }\r\n\r\n    public override _deletePipelineContext(pipelineContext: IPipelineContext): void {\r\n        const webGLPipelineContext = pipelineContext as WebGLPipelineContext;\r\n        if (webGLPipelineContext && webGLPipelineContext.program) {\r\n            if (webGLPipelineContext.transformFeedback) {\r\n                this.deleteTransformFeedback(webGLPipelineContext.transformFeedback);\r\n                webGLPipelineContext.transformFeedback = null;\r\n            }\r\n        }\r\n        super._deletePipelineContext(pipelineContext);\r\n    }\r\n\r\n    public override createShaderProgram(\r\n        pipelineContext: IPipelineContext,\r\n        vertexCode: string,\r\n        fragmentCode: string,\r\n        defines: Nullable<string>,\r\n        context?: WebGLRenderingContext,\r\n        transformFeedbackVaryings: Nullable<string[]> = null\r\n    ): WebGLProgram {\r\n        context = context || this._gl;\r\n\r\n        this.onBeforeShaderCompilationObservable.notifyObservers(this);\r\n\r\n        const program = super.createShaderProgram(pipelineContext, vertexCode, fragmentCode, defines, context, transformFeedbackVaryings);\r\n        this.onAfterShaderCompilationObservable.notifyObservers(this);\r\n\r\n        return program;\r\n    }\r\n\r\n    protected override _createShaderProgram(\r\n        pipelineContext: WebGLPipelineContext,\r\n        vertexShader: WebGLShader,\r\n        fragmentShader: WebGLShader,\r\n        context: WebGLRenderingContext,\r\n        transformFeedbackVaryings: Nullable<string[]> = null\r\n    ): WebGLProgram {\r\n        const shaderProgram = context.createProgram();\r\n        pipelineContext.program = shaderProgram;\r\n\r\n        if (!shaderProgram) {\r\n            throw new Error(\"Unable to create program\");\r\n        }\r\n\r\n        context.attachShader(shaderProgram, vertexShader);\r\n        context.attachShader(shaderProgram, fragmentShader);\r\n\r\n        if (this.webGLVersion > 1 && transformFeedbackVaryings) {\r\n            const transformFeedback = this.createTransformFeedback();\r\n\r\n            this.bindTransformFeedback(transformFeedback);\r\n            this.setTranformFeedbackVaryings(shaderProgram, transformFeedbackVaryings);\r\n            pipelineContext.transformFeedback = transformFeedback;\r\n        }\r\n\r\n        context.linkProgram(shaderProgram);\r\n\r\n        if (this.webGLVersion > 1 && transformFeedbackVaryings) {\r\n            this.bindTransformFeedback(null);\r\n        }\r\n\r\n        pipelineContext.context = context;\r\n        pipelineContext.vertexShader = vertexShader;\r\n        pipelineContext.fragmentShader = fragmentShader;\r\n\r\n        if (!pipelineContext.isParallelCompiled) {\r\n            this._finalizePipelineContext(pipelineContext);\r\n        }\r\n\r\n        return shaderProgram;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public override _releaseTexture(texture: InternalTexture): void {\r\n        super._releaseTexture(texture);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public override _releaseRenderTargetWrapper(rtWrapper: RenderTargetWrapper): void {\r\n        super._releaseRenderTargetWrapper(rtWrapper);\r\n\r\n        // Set output texture of post process to null if the framebuffer has been released/disposed\r\n        this.scenes.forEach((scene) => {\r\n            scene.postProcesses.forEach((postProcess) => {\r\n                if (postProcess._outputTexture === rtWrapper) {\r\n                    postProcess._outputTexture = null;\r\n                }\r\n            });\r\n            scene.cameras.forEach((camera) => {\r\n                camera._postProcesses.forEach((postProcess) => {\r\n                    if (postProcess) {\r\n                        if (postProcess._outputTexture === rtWrapper) {\r\n                            postProcess._outputTexture = null;\r\n                        }\r\n                    }\r\n                });\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Rescales a texture\r\n     * @param source input texture\r\n     * @param destination destination texture\r\n     * @param scene scene to use to render the resize\r\n     * @param internalFormat format to use when resizing\r\n     * @param onComplete callback to be called when resize has completed\r\n     */\r\n    public override _rescaleTexture(source: InternalTexture, destination: InternalTexture, scene: Nullable<any>, internalFormat: number, onComplete: () => void): void {\r\n        this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, this._gl.LINEAR);\r\n        this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, this._gl.LINEAR);\r\n        this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_S, this._gl.CLAMP_TO_EDGE);\r\n        this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_T, this._gl.CLAMP_TO_EDGE);\r\n\r\n        const rtt = this.createRenderTargetTexture(\r\n            {\r\n                width: destination.width,\r\n                height: destination.height,\r\n            },\r\n            {\r\n                generateMipMaps: false,\r\n                type: Constants.TEXTURETYPE_UNSIGNED_INT,\r\n                samplingMode: Constants.TEXTURE_BILINEAR_SAMPLINGMODE,\r\n                generateDepthBuffer: false,\r\n                generateStencilBuffer: false,\r\n            }\r\n        );\r\n\r\n        if (!this._rescalePostProcess && Engine._RescalePostProcessFactory) {\r\n            this._rescalePostProcess = Engine._RescalePostProcessFactory(this);\r\n        }\r\n\r\n        if (this._rescalePostProcess) {\r\n            this._rescalePostProcess.externalTextureSamplerBinding = true;\r\n            const onCompiled = () => {\r\n                this._rescalePostProcess!.onApply = function (effect) {\r\n                    effect._bindTexture(\"textureSampler\", source);\r\n                };\r\n\r\n                let hostingScene: Scene = scene;\r\n\r\n                if (!hostingScene) {\r\n                    hostingScene = this.scenes[this.scenes.length - 1];\r\n                }\r\n                hostingScene.postProcessManager.directRender([this._rescalePostProcess!], rtt, true);\r\n\r\n                this._bindTextureDirectly(this._gl.TEXTURE_2D, destination, true);\r\n                this._gl.copyTexImage2D(this._gl.TEXTURE_2D, 0, internalFormat, 0, 0, destination.width, destination.height, 0);\r\n\r\n                this.unBindFramebuffer(rtt);\r\n                rtt.dispose();\r\n\r\n                if (onComplete) {\r\n                    onComplete();\r\n                }\r\n            };\r\n            const effect = this._rescalePostProcess.getEffect();\r\n            if (effect) {\r\n                effect.executeWhenCompiled(onCompiled);\r\n            } else {\r\n                this._rescalePostProcess.onEffectCreatedObservable.addOnce((effect) => {\r\n                    effect.executeWhenCompiled(onCompiled);\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Wraps an external web gl texture in a Babylon texture.\r\n     * @param texture defines the external texture\r\n     * @param hasMipMaps defines whether the external texture has mip maps (default: false)\r\n     * @param samplingMode defines the sampling mode for the external texture (default: Constants.TEXTURE_TRILINEAR_SAMPLINGMODE)\r\n     * @param width defines the width for the external texture (default: 0)\r\n     * @param height defines the height for the external texture (default: 0)\r\n     * @returns the babylon internal texture\r\n     */\r\n    public wrapWebGLTexture(\r\n        texture: WebGLTexture,\r\n        hasMipMaps: boolean = false,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n        width: number = 0,\r\n        height: number = 0\r\n    ): InternalTexture {\r\n        const hardwareTexture = new WebGLHardwareTexture(texture, this._gl);\r\n        const internalTexture = new InternalTexture(this, InternalTextureSource.Unknown, true);\r\n        internalTexture._hardwareTexture = hardwareTexture;\r\n        internalTexture.baseWidth = width;\r\n        internalTexture.baseHeight = height;\r\n        internalTexture.width = width;\r\n        internalTexture.height = height;\r\n        internalTexture.isReady = true;\r\n        internalTexture.useMipMaps = hasMipMaps;\r\n        this.updateTextureSamplingMode(samplingMode, internalTexture);\r\n        return internalTexture;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _uploadImageToTexture(texture: InternalTexture, image: HTMLImageElement | ImageBitmap, faceIndex: number = 0, lod: number = 0) {\r\n        const gl = this._gl;\r\n\r\n        const textureType = this._getWebGLTextureType(texture.type);\r\n        const format = this._getInternalFormat(texture.format);\r\n        const internalFormat = this._getRGBABufferInternalSizedFormat(texture.type, format);\r\n\r\n        const bindTarget = texture.isCube ? gl.TEXTURE_CUBE_MAP : gl.TEXTURE_2D;\r\n\r\n        this._bindTextureDirectly(bindTarget, texture, true);\r\n        this._unpackFlipY(texture.invertY);\r\n\r\n        let target: GLenum = gl.TEXTURE_2D;\r\n        if (texture.isCube) {\r\n            target = gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex;\r\n        }\r\n\r\n        gl.texImage2D(target, lod, internalFormat, format, textureType, image);\r\n        this._bindTextureDirectly(bindTarget, null, true);\r\n    }\r\n\r\n    /**\r\n     * Updates a depth texture Comparison Mode and Function.\r\n     * If the comparison Function is equal to 0, the mode will be set to none.\r\n     * Otherwise, this only works in webgl 2 and requires a shadow sampler in the shader.\r\n     * @param texture The texture to set the comparison function for\r\n     * @param comparisonFunction The comparison function to set, 0 if no comparison required\r\n     */\r\n    public updateTextureComparisonFunction(texture: InternalTexture, comparisonFunction: number): void {\r\n        if (this.webGLVersion === 1) {\r\n            Logger.Error(\"WebGL 1 does not support texture comparison.\");\r\n            return;\r\n        }\r\n\r\n        const gl = this._gl;\r\n\r\n        if (texture.isCube) {\r\n            this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, texture, true);\r\n\r\n            if (comparisonFunction === 0) {\r\n                gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_COMPARE_FUNC, Constants.LEQUAL);\r\n                gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_COMPARE_MODE, gl.NONE);\r\n            } else {\r\n                gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_COMPARE_FUNC, comparisonFunction);\r\n                gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_COMPARE_MODE, gl.COMPARE_REF_TO_TEXTURE);\r\n            }\r\n\r\n            this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null);\r\n        } else {\r\n            this._bindTextureDirectly(this._gl.TEXTURE_2D, texture, true);\r\n\r\n            if (comparisonFunction === 0) {\r\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_COMPARE_FUNC, Constants.LEQUAL);\r\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_COMPARE_MODE, gl.NONE);\r\n            } else {\r\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_COMPARE_FUNC, comparisonFunction);\r\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_COMPARE_MODE, gl.COMPARE_REF_TO_TEXTURE);\r\n            }\r\n\r\n            this._bindTextureDirectly(this._gl.TEXTURE_2D, null);\r\n        }\r\n\r\n        texture._comparisonFunction = comparisonFunction;\r\n    }\r\n\r\n    /**\r\n     * Creates a webGL buffer to use with instantiation\r\n     * @param capacity defines the size of the buffer\r\n     * @returns the webGL buffer\r\n     */\r\n    public createInstancesBuffer(capacity: number): DataBuffer {\r\n        const buffer = this._gl.createBuffer();\r\n\r\n        if (!buffer) {\r\n            throw new Error(\"Unable to create instance buffer\");\r\n        }\r\n\r\n        const result = new WebGLDataBuffer(buffer);\r\n        result.capacity = capacity;\r\n\r\n        this.bindArrayBuffer(result);\r\n        this._gl.bufferData(this._gl.ARRAY_BUFFER, capacity, this._gl.DYNAMIC_DRAW);\r\n\r\n        result.references = 1;\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Delete a webGL buffer used with instantiation\r\n     * @param buffer defines the webGL buffer to delete\r\n     */\r\n    public deleteInstancesBuffer(buffer: WebGLBuffer): void {\r\n        this._gl.deleteBuffer(buffer);\r\n    }\r\n\r\n    private _clientWaitAsync(sync: WebGLSync, flags = 0, intervalms = 10): Promise<void> {\r\n        const gl = <WebGL2RenderingContext>(this._gl as any);\r\n        return new Promise((resolve, reject) => {\r\n            _retryWithInterval(\r\n                () => {\r\n                    const res = gl.clientWaitSync(sync, flags, 0);\r\n                    if (res == gl.WAIT_FAILED) {\r\n                        throw new Error(\"clientWaitSync failed\");\r\n                    }\r\n                    if (res == gl.TIMEOUT_EXPIRED) {\r\n                        return false;\r\n                    }\r\n                    return true;\r\n                },\r\n                resolve,\r\n                reject,\r\n                intervalms\r\n            );\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _readPixelsAsync(x: number, y: number, w: number, h: number, format: number, type: number, outputBuffer: ArrayBufferView): Nullable<Promise<ArrayBufferView>> {\r\n        if (this._webGLVersion < 2) {\r\n            throw new Error(\"_readPixelsAsync only work on WebGL2+\");\r\n        }\r\n\r\n        const gl = <WebGL2RenderingContext>(this._gl as any);\r\n        const buf = gl.createBuffer();\r\n        gl.bindBuffer(gl.PIXEL_PACK_BUFFER, buf);\r\n        gl.bufferData(gl.PIXEL_PACK_BUFFER, outputBuffer.byteLength, gl.STREAM_READ);\r\n        gl.readPixels(x, y, w, h, format, type, 0);\r\n        gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);\r\n\r\n        const sync = gl.fenceSync(gl.SYNC_GPU_COMMANDS_COMPLETE, 0);\r\n        if (!sync) {\r\n            return null;\r\n        }\r\n\r\n        gl.flush();\r\n\r\n        return this._clientWaitAsync(sync, 0, 10).then(() => {\r\n            gl.deleteSync(sync);\r\n\r\n            gl.bindBuffer(gl.PIXEL_PACK_BUFFER, buf);\r\n            gl.getBufferSubData(gl.PIXEL_PACK_BUFFER, 0, outputBuffer);\r\n            gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);\r\n            gl.deleteBuffer(buf);\r\n\r\n            return outputBuffer;\r\n        });\r\n    }\r\n\r\n    public override dispose(): void {\r\n        this.hideLoadingUI();\r\n\r\n        // Rescale PP\r\n        if (this._rescalePostProcess) {\r\n            this._rescalePostProcess.dispose();\r\n        }\r\n\r\n        _CommonDispose(this, this._renderingCanvas);\r\n\r\n        super.dispose();\r\n    }\r\n}\r\n", "// eslint-disable-next-line import/no-internal-modules\r\nimport type { Nullable, EffectWrapperCreationOptions, AbstractEngine } from \"core/index\";\r\nimport { EffectWrapper } from \"core/Materials/effectRenderer\";\r\nimport { Engine } from \"../Engines/engine\";\r\n\r\n/**\r\n * PassPostProcess which produces an output the same as it's input\r\n */\r\nexport class ThinPassPostProcess extends EffectWrapper {\r\n    /**\r\n     * The fragment shader url\r\n     */\r\n    public static readonly FragmentUrl = \"pass\";\r\n\r\n    protected override _gatherImports(useWebGPU: boolean, list: Promise<any>[]) {\r\n        if (useWebGPU) {\r\n            this._webGPUReady = true;\r\n            list.push(Promise.all([import(\"../ShadersWGSL/pass.fragment\")]));\r\n        } else {\r\n            list.push(Promise.all([import(\"../Shaders/pass.fragment\")]));\r\n        }\r\n\r\n        super._gatherImports(useWebGPU, list);\r\n    }\r\n\r\n    /**\r\n     * Constructs a new pass post process\r\n     * @param name Name of the effect\r\n     * @param engine Engine to use to render the effect. If not provided, the last created engine will be used\r\n     * @param options Options to configure the effect\r\n     */\r\n    constructor(name: string, engine: Nullable<AbstractEngine> = null, options?: EffectWrapperCreationOptions) {\r\n        super({\r\n            ...options,\r\n            name,\r\n            engine: engine || Engine.LastCreatedEngine!,\r\n            useShaderStore: true,\r\n            useAsPostProcess: true,\r\n            fragmentShader: ThinPassPostProcess.FragmentUrl,\r\n        });\r\n    }\r\n}\r\n\r\n/**\r\n * PassCubePostProcess which produces an output the same as it's input (which must be a cube texture)\r\n */\r\nexport class ThinPassCubePostProcess extends EffectWrapper {\r\n    /**\r\n     * The fragment shader url\r\n     */\r\n    public static readonly FragmentUrl = \"passCube\";\r\n\r\n    protected override _gatherImports(useWebGPU: boolean, list: Promise<any>[]) {\r\n        if (useWebGPU) {\r\n            this._webGPUReady = true;\r\n            list.push(Promise.all([import(\"../ShadersWGSL/passCube.fragment\")]));\r\n        } else {\r\n            list.push(Promise.all([import(\"../Shaders/passCube.fragment\")]));\r\n        }\r\n\r\n        super._gatherImports(useWebGPU, list);\r\n    }\r\n\r\n    /**\r\n     * Creates the PassCubePostProcess\r\n     * @param name Name of the effect\r\n     * @param engine Engine to use to render the effect. If not provided, the last created engine will be used\r\n     * @param options Options to configure the effect\r\n     */\r\n    constructor(name: string, engine: Nullable<AbstractEngine> = null, options?: EffectWrapperCreationOptions) {\r\n        super({\r\n            ...options,\r\n            name,\r\n            engine: engine || Engine.LastCreatedEngine!,\r\n            useShaderStore: true,\r\n            useAsPostProcess: true,\r\n            fragmentShader: ThinPassCubePostProcess.FragmentUrl,\r\n            defines: \"#define POSITIVEX\",\r\n        });\r\n    }\r\n\r\n    private _face = 0;\r\n\r\n    /**\r\n     * Gets or sets the cube face to display.\r\n     *  * 0 is +X\r\n     *  * 1 is -X\r\n     *  * 2 is +Y\r\n     *  * 3 is -Y\r\n     *  * 4 is +Z\r\n     *  * 5 is -Z\r\n     */\r\n    public get face(): number {\r\n        return this._face;\r\n    }\r\n\r\n    public set face(value: number) {\r\n        if (value < 0 || value > 5) {\r\n            return;\r\n        }\r\n\r\n        this._face = value;\r\n        switch (this._face) {\r\n            case 0:\r\n                this.updateEffect(\"#define POSITIVEX\");\r\n                break;\r\n            case 1:\r\n                this.updateEffect(\"#define NEGATIVEX\");\r\n                break;\r\n            case 2:\r\n                this.updateEffect(\"#define POSITIVEY\");\r\n                break;\r\n            case 3:\r\n                this.updateEffect(\"#define NEGATIVEY\");\r\n                break;\r\n            case 4:\r\n                this.updateEffect(\"#define POSITIVEZ\");\r\n                break;\r\n            case 5:\r\n                this.updateEffect(\"#define NEGATIVEZ\");\r\n                break;\r\n        }\r\n    }\r\n}\r\n", "import type { Nullable } from \"../types\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { PostProcessOptions } from \"./postProcess\";\r\nimport { PostProcess } from \"./postProcess\";\r\nimport { AbstractEngine } from \"../Engines/abstractEngine\";\r\n\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\nimport { SerializationHelper } from \"../Misc/decorators.serialization\";\r\n\r\nimport type { Scene } from \"../scene\";\r\nimport { ThinPassCubePostProcess, ThinPassPostProcess } from \"./thinPassPostProcess\";\r\nimport { serialize } from \"core/Misc/decorators\";\r\n\r\n/**\r\n * PassPostProcess which produces an output the same as it's input\r\n */\r\nexport class PassPostProcess extends PostProcess {\r\n    /**\r\n     * Gets a string identifying the name of the class\r\n     * @returns \"PassPostProcess\" string\r\n     */\r\n    public override getClassName(): string {\r\n        return \"PassPostProcess\";\r\n    }\r\n\r\n    /**\r\n     * Creates the PassPostProcess\r\n     * @param name The name of the effect.\r\n     * @param options The required width/height ratio to downsize to before computing the render pass.\r\n     * @param camera The camera to apply the render pass to.\r\n     * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\r\n     * @param engine The engine which the post process will be applied. (default: current engine)\r\n     * @param reusable If the post process can be reused on the same frame. (default: false)\r\n     * @param textureType The type of texture to be used when performing the post processing.\r\n     * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)\r\n     */\r\n    constructor(\r\n        name: string,\r\n        options: number | PostProcessOptions,\r\n        camera: Nullable<Camera> = null,\r\n        samplingMode?: number,\r\n        engine?: AbstractEngine,\r\n        reusable?: boolean,\r\n        textureType: number = Constants.TEXTURETYPE_UNSIGNED_BYTE,\r\n        blockCompilation = false\r\n    ) {\r\n        const localOptions = {\r\n            size: typeof options === \"number\" ? options : undefined,\r\n            camera,\r\n            samplingMode,\r\n            engine,\r\n            reusable,\r\n            textureType,\r\n            blockCompilation,\r\n            ...(options as PostProcessOptions),\r\n        };\r\n\r\n        super(name, ThinPassPostProcess.FragmentUrl, {\r\n            effectWrapper: typeof options === \"number\" || !options.effectWrapper ? new ThinPassPostProcess(name, engine, localOptions) : undefined,\r\n            ...localOptions,\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static override _Parse(parsedPostProcess: any, targetCamera: Camera, scene: Scene, rootUrl: string) {\r\n        return SerializationHelper.Parse(\r\n            () => {\r\n                return new PassPostProcess(\r\n                    parsedPostProcess.name,\r\n                    parsedPostProcess.options,\r\n                    targetCamera,\r\n                    parsedPostProcess.renderTargetSamplingMode,\r\n                    parsedPostProcess._engine,\r\n                    parsedPostProcess.reusable\r\n                );\r\n            },\r\n            parsedPostProcess,\r\n            scene,\r\n            rootUrl\r\n        );\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.PassPostProcess\", PassPostProcess);\r\n\r\n/**\r\n * PassCubePostProcess which produces an output the same as it's input (which must be a cube texture)\r\n */\r\nexport class PassCubePostProcess extends PostProcess {\r\n    /**\r\n     * Gets or sets the cube face to display.\r\n     *  * 0 is +X\r\n     *  * 1 is -X\r\n     *  * 2 is +Y\r\n     *  * 3 is -Y\r\n     *  * 4 is +Z\r\n     *  * 5 is -Z\r\n     */\r\n    @serialize()\r\n    public get face(): number {\r\n        return this._effectWrapper.face;\r\n    }\r\n\r\n    public set face(value: number) {\r\n        this._effectWrapper.face = value;\r\n    }\r\n\r\n    /**\r\n     * Gets a string identifying the name of the class\r\n     * @returns \"PassCubePostProcess\" string\r\n     */\r\n    public override getClassName(): string {\r\n        return \"PassCubePostProcess\";\r\n    }\r\n\r\n    protected override _effectWrapper: ThinPassCubePostProcess;\r\n\r\n    /**\r\n     * Creates the PassCubePostProcess\r\n     * @param name The name of the effect.\r\n     * @param options The required width/height ratio to downsize to before computing the render pass.\r\n     * @param camera The camera to apply the render pass to.\r\n     * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\r\n     * @param engine The engine which the post process will be applied. (default: current engine)\r\n     * @param reusable If the post process can be reused on the same frame. (default: false)\r\n     * @param textureType The type of texture to be used when performing the post processing.\r\n     * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)\r\n     */\r\n    constructor(\r\n        name: string,\r\n        options: number | PostProcessOptions,\r\n        camera: Nullable<Camera> = null,\r\n        samplingMode?: number,\r\n        engine?: AbstractEngine,\r\n        reusable?: boolean,\r\n        textureType: number = Constants.TEXTURETYPE_UNSIGNED_BYTE,\r\n        blockCompilation = false\r\n    ) {\r\n        const localOptions = {\r\n            size: typeof options === \"number\" ? options : undefined,\r\n            camera,\r\n            samplingMode,\r\n            engine,\r\n            reusable,\r\n            textureType,\r\n            blockCompilation,\r\n            ...(options as PostProcessOptions),\r\n        };\r\n\r\n        super(name, ThinPassPostProcess.FragmentUrl, {\r\n            effectWrapper: typeof options === \"number\" || !options.effectWrapper ? new ThinPassCubePostProcess(name, engine, localOptions) : undefined,\r\n            ...localOptions,\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static override _Parse(parsedPostProcess: any, targetCamera: Camera, scene: Scene, rootUrl: string) {\r\n        return SerializationHelper.Parse(\r\n            () => {\r\n                return new PassCubePostProcess(\r\n                    parsedPostProcess.name,\r\n                    parsedPostProcess.options,\r\n                    targetCamera,\r\n                    parsedPostProcess.renderTargetSamplingMode,\r\n                    parsedPostProcess._engine,\r\n                    parsedPostProcess.reusable\r\n                );\r\n            },\r\n            parsedPostProcess,\r\n            scene,\r\n            rootUrl\r\n        );\r\n    }\r\n}\r\n\r\nAbstractEngine._RescalePostProcessFactory = (engine: AbstractEngine) => {\r\n    return new PassPostProcess(\"rescale\", 1, null, Constants.TEXTURE_BILINEAR_SAMPLINGMODE, engine, false, Constants.TEXTURETYPE_UNSIGNED_BYTE);\r\n};\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport type { InternalTexture } from \"../Materials/Textures/internalTexture\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport { PassPostProcess } from \"../PostProcesses/passPostProcess\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport type { Scene } from \"../scene\";\r\nimport { PostProcess } from \"../PostProcesses/postProcess\";\r\nimport type { AbstractEngine } from \"../Engines/abstractEngine\";\r\nimport { ShaderLanguage } from \"core/Materials\";\r\n\r\n/**\r\n * Uses the GPU to create a copy texture rescaled at a given size\r\n * @param texture Texture to copy from\r\n * @param width defines the desired width\r\n * @param height defines the desired height\r\n * @param useBilinearMode defines if bilinear mode has to be used\r\n * @returns the generated texture\r\n */\r\nexport function CreateResizedCopy(texture: Texture, width: number, height: number, useBilinearMode: boolean = true): Texture {\r\n    const scene = <Scene>texture.getScene();\r\n    const engine = scene.getEngine();\r\n\r\n    const rtt = new RenderTargetTexture(\r\n        \"resized\" + texture.name,\r\n        { width: width, height: height },\r\n        scene,\r\n        !texture.noMipmap,\r\n        true,\r\n        (<InternalTexture>texture._texture).type,\r\n        false,\r\n        texture.samplingMode,\r\n        false\r\n    );\r\n\r\n    rtt.wrapU = texture.wrapU;\r\n    rtt.wrapV = texture.wrapV;\r\n    rtt.uOffset = texture.uOffset;\r\n    rtt.vOffset = texture.vOffset;\r\n    rtt.uScale = texture.uScale;\r\n    rtt.vScale = texture.vScale;\r\n    rtt.uAng = texture.uAng;\r\n    rtt.vAng = texture.vAng;\r\n    rtt.wAng = texture.wAng;\r\n    rtt.coordinatesIndex = texture.coordinatesIndex;\r\n    rtt.level = texture.level;\r\n    rtt.anisotropicFilteringLevel = texture.anisotropicFilteringLevel;\r\n    (<InternalTexture>rtt._texture).isReady = false;\r\n\r\n    texture.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n    texture.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n\r\n    const passPostProcess = new PassPostProcess(\r\n        \"pass\",\r\n        1,\r\n        null,\r\n        useBilinearMode ? Texture.BILINEAR_SAMPLINGMODE : Texture.NEAREST_SAMPLINGMODE,\r\n        engine,\r\n        false,\r\n        Constants.TEXTURETYPE_UNSIGNED_BYTE\r\n    );\r\n    passPostProcess.externalTextureSamplerBinding = true;\r\n    passPostProcess.onEffectCreatedObservable.addOnce((e) => {\r\n        e.executeWhenCompiled(() => {\r\n            passPostProcess.onApply = function (effect) {\r\n                effect.setTexture(\"textureSampler\", texture);\r\n            };\r\n\r\n            const internalTexture = rtt.renderTarget;\r\n\r\n            if (internalTexture) {\r\n                scene.postProcessManager.directRender([passPostProcess], internalTexture);\r\n\r\n                engine.unBindFramebuffer(internalTexture);\r\n                rtt.disposeFramebufferObjects();\r\n                passPostProcess.dispose();\r\n\r\n                rtt.getInternalTexture()!.isReady = true;\r\n            }\r\n        });\r\n    });\r\n\r\n    return rtt;\r\n}\r\n\r\n/**\r\n * Apply a post process to a texture\r\n * @param postProcessName name of the fragment post process\r\n * @param internalTexture the texture to encode\r\n * @param scene the scene hosting the texture\r\n * @param type type of the output texture. If not provided, use the one from internalTexture\r\n * @param samplingMode sampling mode to use to sample the source texture. If not provided, use the one from internalTexture\r\n * @param format format of the output texture. If not provided, use the one from internalTexture\r\n * @param width width of the output texture. If not provided, use the one from internalTexture\r\n * @param height height of the output texture. If not provided, use the one from internalTexture\r\n * @returns a promise with the internalTexture having its texture replaced by the result of the processing\r\n */\r\nexport function ApplyPostProcess(\r\n    postProcessName: string,\r\n    internalTexture: InternalTexture,\r\n    scene: Scene,\r\n    type?: number,\r\n    samplingMode?: number,\r\n    format?: number,\r\n    width?: number,\r\n    height?: number\r\n): Promise<InternalTexture> {\r\n    // Gets everything ready.\r\n    const engine = internalTexture.getEngine() as AbstractEngine;\r\n\r\n    internalTexture.isReady = false;\r\n\r\n    samplingMode = samplingMode ?? internalTexture.samplingMode;\r\n    type = type ?? internalTexture.type;\r\n    format = format ?? internalTexture.format;\r\n    width = width ?? internalTexture.width;\r\n    height = height ?? internalTexture.height;\r\n\r\n    if (type === -1) {\r\n        type = Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n    }\r\n\r\n    return new Promise((resolve) => {\r\n        // Create the post process\r\n        const postProcess = new PostProcess(\"postprocess\", postProcessName, null, null, 1, null, samplingMode, engine, false, undefined, type, undefined, null, false, format);\r\n        postProcess.externalTextureSamplerBinding = true;\r\n\r\n        // Hold the output of the decoding.\r\n        const encodedTexture = engine.createRenderTargetTexture(\r\n            { width: width as number, height: height as number },\r\n            {\r\n                generateDepthBuffer: false,\r\n                generateMipMaps: false,\r\n                generateStencilBuffer: false,\r\n                samplingMode,\r\n                type,\r\n                format,\r\n            }\r\n        );\r\n\r\n        postProcess.onEffectCreatedObservable.addOnce((e) => {\r\n            e.executeWhenCompiled(() => {\r\n                // PP Render Pass\r\n                postProcess.onApply = (effect) => {\r\n                    effect._bindTexture(\"textureSampler\", internalTexture);\r\n                    effect.setFloat2(\"scale\", 1, 1);\r\n                };\r\n                scene.postProcessManager.directRender([postProcess!], encodedTexture, true);\r\n\r\n                // Cleanup\r\n                engine.restoreDefaultFramebuffer();\r\n                engine._releaseTexture(internalTexture);\r\n                if (postProcess) {\r\n                    postProcess.dispose();\r\n                }\r\n\r\n                // Internal Swap\r\n                encodedTexture._swapAndDie(internalTexture);\r\n\r\n                // Ready to get rolling again.\r\n                internalTexture.type = type!;\r\n                internalTexture.format = Constants.TEXTUREFORMAT_RGBA;\r\n                internalTexture.isReady = true;\r\n\r\n                resolve(internalTexture);\r\n            });\r\n        });\r\n    });\r\n}\r\n\r\n// ref: http://stackoverflow.com/questions/32633585/how-do-you-convert-to-half-floats-in-javascript\r\nlet floatView: Float32Array;\r\nlet int32View: Int32Array;\r\n/**\r\n * Converts a number to half float\r\n * @param value number to convert\r\n * @returns converted number\r\n */\r\nexport function ToHalfFloat(value: number): number {\r\n    if (!floatView) {\r\n        floatView = new Float32Array(1);\r\n        int32View = new Int32Array(floatView.buffer);\r\n    }\r\n\r\n    floatView[0] = value;\r\n    const x = int32View[0];\r\n\r\n    let bits = (x >> 16) & 0x8000; /* Get the sign */\r\n    let m = (x >> 12) & 0x07ff; /* Keep one extra bit for rounding */\r\n    const e = (x >> 23) & 0xff; /* Using int is faster here */\r\n\r\n    /* If zero, or denormal, or exponent underflows too much for a denormal\r\n     * half, return signed zero. */\r\n    if (e < 103) {\r\n        return bits;\r\n    }\r\n\r\n    /* If NaN, return NaN. If Inf or exponent overflow, return Inf. */\r\n    if (e > 142) {\r\n        bits |= 0x7c00;\r\n        /* If exponent was 0xff and one mantissa bit was set, it means NaN,\r\n         * not Inf, so make sure we set one mantissa bit too. */\r\n        bits |= (e == 255 ? 0 : 1) && x & 0x007fffff;\r\n        return bits;\r\n    }\r\n\r\n    /* If exponent underflows but not too much, return a denormal */\r\n    if (e < 113) {\r\n        m |= 0x0800;\r\n        /* Extra rounding may overflow and set mantissa to 0 and exponent\r\n         * to 1, which is OK. */\r\n        bits |= (m >> (114 - e)) + ((m >> (113 - e)) & 1);\r\n        return bits;\r\n    }\r\n\r\n    bits |= ((e - 112) << 10) | (m >> 1);\r\n    bits += m & 1;\r\n    return bits;\r\n}\r\n\r\n/**\r\n * Converts a half float to a number\r\n * @param value half float to convert\r\n * @returns converted half float\r\n */\r\nexport function FromHalfFloat(value: number): number {\r\n    const s = (value & 0x8000) >> 15;\r\n    const e = (value & 0x7c00) >> 10;\r\n    const f = value & 0x03ff;\r\n\r\n    if (e === 0) {\r\n        return (s ? -1 : 1) * Math.pow(2, -14) * (f / Math.pow(2, 10));\r\n    } else if (e == 0x1f) {\r\n        return f ? NaN : (s ? -1 : 1) * Infinity;\r\n    }\r\n\r\n    return (s ? -1 : 1) * Math.pow(2, e - 15) * (1 + f / Math.pow(2, 10));\r\n}\r\n\r\nconst ProcessAsync = async (texture: BaseTexture, width: number, height: number, face: number, lod: number): Promise<Uint8Array> => {\r\n    const scene = texture.getScene()!;\r\n    const engine = scene.getEngine();\r\n\r\n    if (!engine.isWebGPU) {\r\n        if (texture.isCube) {\r\n            await import(\"../Shaders/lodCube.fragment\");\r\n        } else {\r\n            await import(\"../Shaders/lod.fragment\");\r\n        }\r\n    } else {\r\n        if (texture.isCube) {\r\n            await import(\"../ShadersWGSL/lodCube.fragment\");\r\n        } else {\r\n            await import(\"../ShadersWGSL/lod.fragment\");\r\n        }\r\n    }\r\n\r\n    let lodPostProcess: PostProcess;\r\n\r\n    if (!texture.isCube) {\r\n        lodPostProcess = new PostProcess(\"lod\", \"lod\", {\r\n            uniforms: [\"lod\", \"gamma\"],\r\n            samplingMode: Texture.NEAREST_NEAREST_MIPNEAREST,\r\n            engine,\r\n            shaderLanguage: engine.isWebGPU ? ShaderLanguage.WGSL : ShaderLanguage.GLSL,\r\n        });\r\n    } else {\r\n        const faceDefines = [\"#define POSITIVEX\", \"#define NEGATIVEX\", \"#define POSITIVEY\", \"#define NEGATIVEY\", \"#define POSITIVEZ\", \"#define NEGATIVEZ\"];\r\n        lodPostProcess = new PostProcess(\"lodCube\", \"lodCube\", {\r\n            uniforms: [\"lod\", \"gamma\"],\r\n            samplingMode: Texture.NEAREST_NEAREST_MIPNEAREST,\r\n            engine,\r\n            defines: faceDefines[face],\r\n            shaderLanguage: engine.isWebGPU ? ShaderLanguage.WGSL : ShaderLanguage.GLSL,\r\n        });\r\n    }\r\n\r\n    await new Promise((resolve) => {\r\n        lodPostProcess.onEffectCreatedObservable.addOnce((e) => {\r\n            e.executeWhenCompiled(() => {\r\n                resolve(0);\r\n            });\r\n        });\r\n    });\r\n\r\n    const rtt = new RenderTargetTexture(\"temp\", { width: width, height: height }, scene, false);\r\n\r\n    lodPostProcess.onApply = function (effect) {\r\n        effect.setTexture(\"textureSampler\", texture);\r\n        effect.setFloat(\"lod\", lod);\r\n        effect.setInt(\"gamma\", texture.gammaSpace ? 1 : 0);\r\n    };\r\n\r\n    const internalTexture = texture.getInternalTexture();\r\n\r\n    try {\r\n        if (rtt.renderTarget && internalTexture) {\r\n            const samplingMode = internalTexture.samplingMode;\r\n            if (lod !== 0) {\r\n                texture.updateSamplingMode(Texture.NEAREST_NEAREST_MIPNEAREST);\r\n            } else {\r\n                texture.updateSamplingMode(Texture.NEAREST_NEAREST);\r\n            }\r\n\r\n            scene.postProcessManager.directRender([lodPostProcess], rtt.renderTarget, true);\r\n            texture.updateSamplingMode(samplingMode);\r\n\r\n            //Reading datas from WebGL\r\n            const bufferView = await engine.readPixels(0, 0, width, height);\r\n            const data = new Uint8Array(bufferView.buffer, 0, bufferView.byteLength);\r\n\r\n            // Unbind\r\n            engine.unBindFramebuffer(rtt.renderTarget);\r\n\r\n            return data;\r\n        } else {\r\n            throw Error(\"Render to texture failed.\");\r\n        }\r\n    } finally {\r\n        rtt.dispose();\r\n        lodPostProcess.dispose();\r\n    }\r\n};\r\n\r\n/**\r\n * Gets the data of the specified texture by rendering it to an intermediate RGBA texture and retrieving the bytes from it.\r\n * This is convienent to get 8-bit RGBA values for a texture in a GPU compressed format.\r\n * @param texture the source texture\r\n * @param width the width of the result, which does not have to match the source texture width\r\n * @param height the height of the result, which does not have to match the source texture height\r\n * @param face if the texture has multiple faces, the face index to use for the source\r\n * @param lod if the texture has multiple LODs, the lod index to use for the source\r\n * @returns the 8-bit texture data\r\n */\r\nexport async function GetTextureDataAsync(texture: BaseTexture, width: number, height: number, face: number = 0, lod: number = 0): Promise<Uint8Array> {\r\n    if (!texture.isReady() && texture._texture) {\r\n        await new Promise((resolve, reject) => {\r\n            if (texture._texture === null) {\r\n                reject(0);\r\n                return;\r\n            }\r\n            texture._texture.onLoadedObservable.addOnce(() => {\r\n                resolve(0);\r\n            });\r\n        });\r\n    }\r\n    return await ProcessAsync(texture, width, height, face, lod);\r\n}\r\n\r\n/**\r\n * Class used to host texture specific utilities\r\n */\r\nexport const TextureTools = {\r\n    /**\r\n     * Uses the GPU to create a copy texture rescaled at a given size\r\n     * @param texture Texture to copy from\r\n     * @param width defines the desired width\r\n     * @param height defines the desired height\r\n     * @param useBilinearMode defines if bilinear mode has to be used\r\n     * @returns the generated texture\r\n     */\r\n    CreateResizedCopy,\r\n\r\n    /**\r\n     * Apply a post process to a texture\r\n     * @param postProcessName name of the fragment post process\r\n     * @param internalTexture the texture to encode\r\n     * @param scene the scene hosting the texture\r\n     * @param type type of the output texture. If not provided, use the one from internalTexture\r\n     * @param samplingMode sampling mode to use to sample the source texture. If not provided, use the one from internalTexture\r\n     * @param format format of the output texture. If not provided, use the one from internalTexture\r\n     * @returns a promise with the internalTexture having its texture replaced by the result of the processing\r\n     */\r\n    ApplyPostProcess,\r\n    /**\r\n     * Converts a number to half float\r\n     * @param value number to convert\r\n     * @returns converted number\r\n     */\r\n    ToHalfFloat,\r\n\r\n    /**\r\n     * Converts a half float to a number\r\n     * @param value half float to convert\r\n     * @returns converted half float\r\n     */\r\n    FromHalfFloat,\r\n\r\n    /**\r\n     * Gets the data of the specified texture by rendering it to an intermediate RGBA texture and retrieving the bytes from it.\r\n     * This is convienent to get 8-bit RGBA values for a texture in a GPU compressed format.\r\n     * @param texture the source texture\r\n     * @param width the width of the result, which does not have to match the source texture width\r\n     * @param height the height of the result, which does not have to match the source texture height\r\n     * @param face if the texture has multiple faces, the face index to use for the source\r\n     * @param channels a filter for which of the RGBA channels to return in the result\r\n     * @param lod if the texture has multiple LODs, the lod index to use for the source\r\n     * @returns the 8-bit texture data\r\n     */\r\n    GetTextureDataAsync,\r\n};\r\n"],
  "mappings": "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",
  "names": ["Space", "Coordinate", "Orientation", "index", "_a", "effect"]
}
