{"version":3,"file":"gaussianSplattingMaterial.js","sourceRoot":"","sources":["../../../../../dev/core/src/Materials/GaussianSplatting/gaussianSplattingMaterial.ts"],"names":[],"mappings":"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","sourcesContent":["import type { SubMesh } from \"../../Meshes/subMesh\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { Mesh } from \"../../Meshes/mesh\";\r\nimport type { Effect, IEffectCreationOptions } from \"../../Materials/effect\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { Matrix } from \"../../Maths/math.vector\";\r\nimport type { GaussianSplattingMesh } from \"core/Meshes\";\r\nimport { SerializationHelper } from \"../../Misc/decorators.serialization\";\r\nimport { VertexBuffer } from \"../../Buffers/buffer\";\r\nimport { MaterialDefines } from \"../../Materials/materialDefines\";\r\nimport { PushMaterial } from \"../../Materials/pushMaterial\";\r\nimport { RegisterClass } from \"../../Misc/typeStore\";\r\nimport { addClipPlaneUniforms, bindClipPlane } from \"../clipPlaneMaterialHelper\";\r\nimport { Camera } from \"core/Cameras/camera\";\r\n\r\nimport \"../../Shaders/gaussianSplatting.fragment\";\r\nimport \"../../Shaders/gaussianSplatting.vertex\";\r\nimport \"../../ShadersWGSL/gaussianSplatting.fragment\";\r\nimport \"../../ShadersWGSL/gaussianSplatting.vertex\";\r\nimport {\r\n    BindFogParameters,\r\n    BindLogDepth,\r\n    PrepareAttributesForInstances,\r\n    PrepareDefinesForAttributes,\r\n    PrepareDefinesForFrameBoundValues,\r\n    PrepareDefinesForMisc,\r\n    PrepareUniformsAndSamplersList,\r\n} from \"../materialHelper.functions\";\r\nimport { ShaderLanguage } from \"../shaderLanguage\";\r\n\r\n/**\r\n * @internal\r\n */\r\nclass GaussianSplattingMaterialDefines extends MaterialDefines {\r\n    public FOG = false;\r\n    public THIN_INSTANCES = true;\r\n    public LOGARITHMICDEPTH = false;\r\n    public CLIPPLANE = false;\r\n    public CLIPPLANE2 = false;\r\n    public CLIPPLANE3 = false;\r\n    public CLIPPLANE4 = false;\r\n    public CLIPPLANE5 = false;\r\n    public CLIPPLANE6 = false;\r\n    public SH_DEGREE = 0;\r\n\r\n    /**\r\n     * Constructor of the defines.\r\n     */\r\n    constructor() {\r\n        super();\r\n        this.rebuild();\r\n    }\r\n}\r\n\r\n/**\r\n * GaussianSplattingMaterial material used to render Gaussian Splatting\r\n * @experimental\r\n */\r\nexport class GaussianSplattingMaterial extends PushMaterial {\r\n    /**\r\n     * Instantiates a Gaussian Splatting Material in the given scene\r\n     * @param name The friendly name of the material\r\n     * @param scene The scene to add the material to\r\n     */\r\n    constructor(name: string, scene?: Scene) {\r\n        super(name, scene);\r\n\r\n        this.backFaceCulling = false;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that current material needs to register RTT\r\n     */\r\n    public override get hasRenderTargetTextures(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Specifies whether or not this material should be rendered in alpha test mode.\r\n     * @returns false\r\n     */\r\n    public override needAlphaTesting(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Specifies whether or not this material should be rendered in alpha blend mode.\r\n     * @returns true\r\n     */\r\n    public override needAlphaBlending(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Checks whether the material is ready to be rendered for a given mesh.\r\n     * @param mesh The mesh to render\r\n     * @param subMesh The submesh to check against\r\n     * @returns true if all the dependencies are ready (Textures, Effects...)\r\n     */\r\n    public override isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh): boolean {\r\n        const useInstances = true;\r\n\r\n        const drawWrapper = subMesh._drawWrapper;\r\n\r\n        if (drawWrapper.effect && this.isFrozen) {\r\n            if (drawWrapper._wasPreviouslyReady && drawWrapper._wasPreviouslyUsingInstances === useInstances) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!subMesh.materialDefines) {\r\n            subMesh.materialDefines = new GaussianSplattingMaterialDefines();\r\n        }\r\n\r\n        const scene = this.getScene();\r\n        const defines = <GaussianSplattingMaterialDefines>subMesh.materialDefines;\r\n\r\n        if (this._isReadyForSubMesh(subMesh)) {\r\n            return true;\r\n        }\r\n\r\n        const engine = scene.getEngine();\r\n\r\n        // Misc.\r\n        PrepareDefinesForMisc(mesh, scene, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, false, defines);\r\n\r\n        // Values that need to be evaluated on every frame\r\n        PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances, null, true);\r\n\r\n        // Attribs\r\n        PrepareDefinesForAttributes(mesh, defines, false, false);\r\n\r\n        // SH is disabled for webGL1\r\n        if (engine.version > 1 || engine.isWebGPU) {\r\n            defines[\"SH_DEGREE\"] = (<GaussianSplattingMesh>mesh).shDegree;\r\n        }\r\n\r\n        // Get correct effect\r\n        if (defines.isDirty) {\r\n            defines.markAsProcessed();\r\n            scene.resetCachedMaterial();\r\n\r\n            //Attributes\r\n            const attribs = [VertexBuffer.PositionKind, \"splatIndex\"];\r\n\r\n            PrepareAttributesForInstances(attribs, defines);\r\n\r\n            const uniforms = [\"world\", \"view\", \"projection\", \"vFogInfos\", \"vFogColor\", \"logarithmicDepthConstant\", \"invViewport\", \"dataTextureSize\", \"focal\", \"vEyePosition\"];\r\n            const samplers = [\"covariancesATexture\", \"covariancesBTexture\", \"centersTexture\", \"colorsTexture\", \"shTexture0\", \"shTexture1\", \"shTexture2\"];\r\n            const uniformBuffers = [\"Scene\", \"Mesh\"];\r\n\r\n            PrepareUniformsAndSamplersList(<IEffectCreationOptions>{\r\n                uniformsNames: uniforms,\r\n                uniformBuffersNames: uniformBuffers,\r\n                samplers: samplers,\r\n                defines: defines,\r\n            });\r\n\r\n            addClipPlaneUniforms(uniforms);\r\n\r\n            const join = defines.toString();\r\n            const effect = scene.getEngine().createEffect(\r\n                \"gaussianSplatting\",\r\n                <IEffectCreationOptions>{\r\n                    attributes: attribs,\r\n                    uniformsNames: uniforms,\r\n                    uniformBuffersNames: uniformBuffers,\r\n                    samplers: samplers,\r\n                    defines: join,\r\n                    onCompiled: this.onCompiled,\r\n                    onError: this.onError,\r\n                    indexParameters: {},\r\n                    shaderLanguage: this._shaderLanguage,\r\n                    extraInitializationsAsync: async () => {\r\n                        if (this._shaderLanguage === ShaderLanguage.WGSL) {\r\n                            await Promise.all([import(\"../../ShadersWGSL/gaussianSplatting.fragment\"), import(\"../../ShadersWGSL/gaussianSplatting.vertex\")]);\r\n                        } else {\r\n                            await Promise.all([import(\"../../Shaders/gaussianSplatting.fragment\"), import(\"../../Shaders/gaussianSplatting.vertex\")]);\r\n                        }\r\n                    },\r\n                },\r\n                engine\r\n            );\r\n            subMesh.setEffect(effect, defines, this._materialContext);\r\n        }\r\n\r\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        defines._renderId = scene.getRenderId();\r\n        drawWrapper._wasPreviouslyReady = true;\r\n        drawWrapper._wasPreviouslyUsingInstances = useInstances;\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Bind material effect for a specific Gaussian Splatting mesh\r\n     * @param mesh Gaussian splatting mesh\r\n     * @param effect Splatting material or node material\r\n     * @param scene scene that contains mesh and camera used for rendering\r\n     */\r\n    public static BindEffect(mesh: Mesh, effect: Effect, scene: Scene): void {\r\n        const engine = scene.getEngine();\r\n        const camera = scene.activeCamera;\r\n\r\n        const renderWidth = engine.getRenderWidth();\r\n        const renderHeight = engine.getRenderHeight();\r\n\r\n        // check if rigcamera, get number of rigs\r\n        const numberOfRigs = camera?.rigParent?.rigCameras.length || 1;\r\n\r\n        effect.setFloat2(\"invViewport\", 1 / (renderWidth / numberOfRigs), 1 / renderHeight);\r\n\r\n        let focal = 1000;\r\n\r\n        if (camera) {\r\n            /*\r\n            more explicit version:\r\n            const t = camera.getProjectionMatrix().m[5];\r\n            const FovY = Math.atan(1.0 / t) * 2.0;\r\n            focal = renderHeight / 2.0 / Math.tan(FovY / 2.0);\r\n            Using a shorter version here to not have tan(atan) and 2.0 factor\r\n            */\r\n            const t = camera.getProjectionMatrix().m[5];\r\n            if (camera.fovMode == Camera.FOVMODE_VERTICAL_FIXED) {\r\n                focal = (renderHeight * t) / 2.0;\r\n            } else {\r\n                focal = (renderWidth * t) / 2.0;\r\n            }\r\n        }\r\n\r\n        effect.setFloat2(\"focal\", focal, focal);\r\n\r\n        const gsMesh = mesh as GaussianSplattingMesh;\r\n\r\n        if (gsMesh.covariancesATexture) {\r\n            const textureSize = gsMesh.covariancesATexture.getSize();\r\n\r\n            effect.setFloat2(\"dataTextureSize\", textureSize.width, textureSize.height);\r\n\r\n            effect.setTexture(\"covariancesATexture\", gsMesh.covariancesATexture);\r\n            effect.setTexture(\"covariancesBTexture\", gsMesh.covariancesBTexture);\r\n            effect.setTexture(\"centersTexture\", gsMesh.centersTexture);\r\n            effect.setTexture(\"colorsTexture\", gsMesh.colorsTexture);\r\n\r\n            if (gsMesh.shTextures) {\r\n                for (let i = 0; i < gsMesh.shTextures?.length; i++) {\r\n                    effect.setTexture(`shTexture${i}`, gsMesh.shTextures[i]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Binds the submesh to this material by preparing the effect and shader to draw\r\n     * @param world defines the world transformation matrix\r\n     * @param mesh defines the mesh containing the submesh\r\n     * @param subMesh defines the submesh to bind the material to\r\n     */\r\n    public override bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        const scene = this.getScene();\r\n\r\n        const defines = <GaussianSplattingMaterialDefines>subMesh.materialDefines;\r\n        if (!defines) {\r\n            return;\r\n        }\r\n\r\n        const effect = subMesh.effect;\r\n        if (!effect) {\r\n            return;\r\n        }\r\n        this._activeEffect = effect;\r\n\r\n        // Matrices Mesh.\r\n        mesh.getMeshUniformBuffer().bindToEffect(effect, \"Mesh\");\r\n        mesh.transferToEffect(world);\r\n\r\n        // Bind data\r\n        const mustRebind = this._mustRebind(scene, effect, subMesh, mesh.visibility);\r\n\r\n        if (mustRebind) {\r\n            this.bindView(effect);\r\n            this.bindViewProjection(effect);\r\n            GaussianSplattingMaterial.BindEffect(mesh, this._activeEffect, scene);\r\n            // Clip plane\r\n            bindClipPlane(effect, this, scene);\r\n        } else if (scene.getEngine()._features.needToAlwaysBindUniformBuffers) {\r\n            this._needToBindSceneUbo = true;\r\n        }\r\n\r\n        // Fog\r\n        BindFogParameters(scene, mesh, effect);\r\n\r\n        // Log. depth\r\n        if (this.useLogarithmicDepth) {\r\n            BindLogDepth(defines, effect, scene);\r\n        }\r\n\r\n        this._afterBind(mesh, this._activeEffect, subMesh);\r\n    }\r\n\r\n    /**\r\n     * Clones the material.\r\n     * @param name The cloned name.\r\n     * @returns The cloned material.\r\n     */\r\n    public override clone(name: string): GaussianSplattingMaterial {\r\n        return SerializationHelper.Clone(() => new GaussianSplattingMaterial(name, this.getScene()), this);\r\n    }\r\n\r\n    /**\r\n     * Serializes the current material to its JSON representation.\r\n     * @returns The JSON representation.\r\n     */\r\n    public override serialize(): any {\r\n        const serializationObject = super.serialize();\r\n        serializationObject.customType = \"BABYLON.GaussianSplattingMaterial\";\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the material\r\n     * @returns \"GaussianSplattingMaterial\"\r\n     */\r\n    public override getClassName(): string {\r\n        return \"GaussianSplattingMaterial\";\r\n    }\r\n\r\n    /**\r\n     * Parse a JSON input to create back a Gaussian Splatting material.\r\n     * @param source The JSON data to parse\r\n     * @param scene The scene to create the parsed material in\r\n     * @param rootUrl The root url of the assets the material depends upon\r\n     * @returns the instantiated GaussianSplattingMaterial.\r\n     */\r\n    public static override Parse(source: any, scene: Scene, rootUrl: string): GaussianSplattingMaterial {\r\n        return SerializationHelper.Parse(() => new GaussianSplattingMaterial(source.name, scene), source, scene, rootUrl);\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.GaussianSplattingMaterial\", GaussianSplattingMaterial);\r\n"]}