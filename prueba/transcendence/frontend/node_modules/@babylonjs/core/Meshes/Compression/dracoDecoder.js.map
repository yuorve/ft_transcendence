{"version":3,"file":"dracoDecoder.js","sourceRoot":"","sources":["../../../../../dev/core/src/Meshes/Compression/dracoDecoder.ts"],"names":[],"mappings":"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","sourcesContent":["import { DracoDecoderModule } from \"draco3dgltf\";\r\nimport { _IsConfigurationAvailable, DracoCodec, type IDracoCodecConfiguration } from \"./dracoCodec\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport { Geometry } from \"../geometry\";\r\nimport { VertexBuffer } from \"../buffer\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport type { BoundingInfo } from \"../../Culling/boundingInfo\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { DecodeMesh, DecoderWorkerFunction } from \"./dracoCompressionWorker\";\r\nimport type { AttributeData, MeshData, DecoderMessage } from \"./dracoDecoder.types\";\r\n\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\ndeclare let DracoDecoderModule: DracoDecoderModule;\r\n\r\n/**\r\n * @experimental This class is an experimental version of `DracoCompression` and is subject to change.\r\n *\r\n * Draco Decoder (https://google.github.io/draco/)\r\n *\r\n * This class wraps the Draco decoder module.\r\n *\r\n * By default, the configuration points to a copy of the Draco decoder files for glTF from the Babylon.js cdn https://cdn.babylonjs.com/draco_wasm_wrapper_gltf.js.\r\n *\r\n * To update the configuration, use the following code:\r\n * ```javascript\r\n *     DracoDecoder.DefaultConfiguration = {\r\n *          wasmUrl: \"<url to the WebAssembly library>\",\r\n *          wasmBinaryUrl: \"<url to the WebAssembly binary>\",\r\n *          fallbackUrl: \"<url to the fallback JavaScript library>\",\r\n *     };\r\n * ```\r\n *\r\n * Draco has two versions, one for WebAssembly and one for JavaScript. The decoder configuration can be set to only support WebAssembly or only support the JavaScript version.\r\n * Decoding will automatically fallback to the JavaScript version if WebAssembly version is not configured or if WebAssembly is not supported by the browser.\r\n * Use `DracoDecoder.DefaultAvailable` to determine if the decoder configuration is available for the current context.\r\n *\r\n * To decode Draco compressed data, get the default DracoDecoder object and call decodeMeshToGeometryAsync:\r\n * ```javascript\r\n *     var geometry = await DracoDecoder.Default.decodeMeshToGeometryAsync(data);\r\n * ```\r\n */\r\nexport class DracoDecoder extends DracoCodec {\r\n    /**\r\n     * Default configuration for the DracoDecoder. Defaults to the following:\r\n     * - numWorkers: 50% of the available logical processors, capped to 4. If no logical processors are available, defaults to 1.\r\n     * - wasmUrl: `\"https://cdn.babylonjs.com/draco_wasm_wrapper_gltf.js\"`\r\n     * - wasmBinaryUrl: `\"https://cdn.babylonjs.com/draco_decoder_gltf.wasm\"`\r\n     * - fallbackUrl: `\"https://cdn.babylonjs.com/draco_decoder_gltf.js\"`\r\n     */\r\n    public static DefaultConfiguration: IDracoCodecConfiguration = {\r\n        wasmUrl: `${Tools._DefaultCdnUrl}/draco_wasm_wrapper_gltf.js`,\r\n        wasmBinaryUrl: `${Tools._DefaultCdnUrl}/draco_decoder_gltf.wasm`,\r\n        fallbackUrl: `${Tools._DefaultCdnUrl}/draco_decoder_gltf.js`,\r\n    };\r\n\r\n    /**\r\n     * Returns true if the decoder's `DefaultConfiguration` is available.\r\n     */\r\n    public static get DefaultAvailable(): boolean {\r\n        return _IsConfigurationAvailable(DracoDecoder.DefaultConfiguration);\r\n    }\r\n\r\n    protected static _Default: Nullable<DracoDecoder> = null;\r\n    /**\r\n     * Default instance for the DracoDecoder.\r\n     */\r\n    public static get Default(): DracoDecoder {\r\n        DracoDecoder._Default ??= new DracoDecoder();\r\n        return DracoDecoder._Default;\r\n    }\r\n\r\n    /**\r\n     * Reset the default DracoDecoder object to null and disposing the removed default instance.\r\n     * Note that if the workerPool is a member of the static DefaultConfiguration object it is recommended not to run dispose,\r\n     * unless the static worker pool is no longer needed.\r\n     * @param skipDispose set to true to not dispose the removed default instance\r\n     */\r\n    public static ResetDefault(skipDispose?: boolean): void {\r\n        if (DracoDecoder._Default) {\r\n            if (!skipDispose) {\r\n                DracoDecoder._Default.dispose();\r\n            }\r\n            DracoDecoder._Default = null;\r\n        }\r\n    }\r\n\r\n    protected override _isModuleAvailable(): boolean {\r\n        return typeof DracoDecoderModule !== \"undefined\";\r\n    }\r\n\r\n    protected override async _createModuleAsync(wasmBinary?: ArrayBuffer, jsModule?: unknown /** DracoDecoderModule */): Promise<{ module: unknown /** DecoderModule */ }> {\r\n        const module = await ((jsModule as DracoDecoderModule) || DracoDecoderModule)({ wasmBinary });\r\n        return { module };\r\n    }\r\n\r\n    protected override _getWorkerContent(): string {\r\n        return `${DecodeMesh}(${DecoderWorkerFunction})()`;\r\n    }\r\n\r\n    /**\r\n     * Creates a new Draco decoder.\r\n     * @param configuration Optional override of the configuration for the DracoDecoder. If not provided, defaults to {@link DracoDecoder.DefaultConfiguration}.\r\n     */\r\n    constructor(configuration: IDracoCodecConfiguration = DracoDecoder.DefaultConfiguration) {\r\n        super(configuration);\r\n    }\r\n\r\n    /**\r\n     * Decode Draco compressed mesh data to mesh data.\r\n     * @param data The ArrayBuffer or ArrayBufferView of the compressed Draco data\r\n     * @param attributes A map of attributes from vertex buffer kinds to Draco unique ids\r\n     * @param gltfNormalizedOverride A map of attributes from vertex buffer kinds to normalized flags to override the Draco normalization\r\n     * @returns A promise that resolves with the decoded mesh data\r\n     */\r\n    public decodeMeshToMeshDataAsync(\r\n        data: ArrayBuffer | ArrayBufferView,\r\n        attributes?: { [kind: string]: number },\r\n        gltfNormalizedOverride?: { [kind: string]: boolean }\r\n    ): Promise<MeshData> {\r\n        const dataView = data instanceof ArrayBuffer ? new Int8Array(data) : new Int8Array(data.buffer, data.byteOffset, data.byteLength);\r\n\r\n        const applyGltfNormalizedOverride = (kind: string, normalized: boolean): boolean => {\r\n            if (gltfNormalizedOverride && gltfNormalizedOverride[kind] !== undefined) {\r\n                if (normalized !== gltfNormalizedOverride[kind]) {\r\n                    Logger.Warn(\r\n                        `Normalized flag from Draco data (${normalized}) does not match normalized flag from glTF accessor (${gltfNormalizedOverride[kind]}). Using flag from glTF accessor.`\r\n                    );\r\n                }\r\n\r\n                return gltfNormalizedOverride[kind];\r\n            } else {\r\n                return normalized;\r\n            }\r\n        };\r\n\r\n        if (this._workerPoolPromise) {\r\n            return this._workerPoolPromise.then((workerPool) => {\r\n                return new Promise<MeshData>((resolve, reject) => {\r\n                    workerPool.push((worker, onComplete) => {\r\n                        let resultIndices: Nullable<Uint16Array | Uint32Array> = null;\r\n                        const resultAttributes: Array<AttributeData> = [];\r\n\r\n                        const onError = (error: ErrorEvent) => {\r\n                            worker.removeEventListener(\"error\", onError);\r\n                            worker.removeEventListener(\"message\", onMessage);\r\n                            reject(error);\r\n                            onComplete();\r\n                        };\r\n\r\n                        const onMessage = (event: MessageEvent<DecoderMessage>) => {\r\n                            const message = event.data;\r\n                            switch (message.id) {\r\n                                case \"indices\": {\r\n                                    resultIndices = message.data;\r\n                                    break;\r\n                                }\r\n                                case \"attribute\": {\r\n                                    resultAttributes.push({\r\n                                        kind: message.kind,\r\n                                        data: message.data,\r\n                                        size: message.size,\r\n                                        byteOffset: message.byteOffset,\r\n                                        byteStride: message.byteStride,\r\n                                        normalized: applyGltfNormalizedOverride(message.kind, message.normalized),\r\n                                    });\r\n                                    break;\r\n                                }\r\n                                case \"decodeMeshDone\": {\r\n                                    worker.removeEventListener(\"error\", onError);\r\n                                    worker.removeEventListener(\"message\", onMessage);\r\n                                    resolve({ indices: resultIndices!, attributes: resultAttributes, totalVertices: message.totalVertices });\r\n                                    onComplete();\r\n                                    break;\r\n                                }\r\n                            }\r\n                        };\r\n\r\n                        worker.addEventListener(\"error\", onError);\r\n                        worker.addEventListener(\"message\", onMessage);\r\n\r\n                        const dataViewCopy = dataView.slice();\r\n                        worker.postMessage({ id: \"decodeMesh\", dataView: dataViewCopy, attributes: attributes }, [dataViewCopy.buffer]);\r\n                    });\r\n                });\r\n            });\r\n        }\r\n\r\n        if (this._modulePromise) {\r\n            return this._modulePromise.then((decoder) => {\r\n                let resultIndices: Nullable<Uint16Array | Uint32Array> = null;\r\n                const resultAttributes: Array<AttributeData> = [];\r\n\r\n                const numPoints = DecodeMesh(\r\n                    decoder.module,\r\n                    dataView,\r\n                    attributes,\r\n                    (indices) => {\r\n                        resultIndices = indices;\r\n                    },\r\n                    (kind, data, size, byteOffset, byteStride, normalized) => {\r\n                        resultAttributes.push({\r\n                            kind,\r\n                            data,\r\n                            size,\r\n                            byteOffset,\r\n                            byteStride,\r\n                            normalized,\r\n                        });\r\n                    }\r\n                );\r\n\r\n                return { indices: resultIndices!, attributes: resultAttributes, totalVertices: numPoints };\r\n            });\r\n        }\r\n\r\n        throw new Error(\"Draco decoder module is not available\");\r\n    }\r\n\r\n    /**\r\n     * Decode Draco compressed mesh data to Babylon geometry.\r\n     * @param name The name to use when creating the geometry\r\n     * @param scene The scene to use when creating the geometry\r\n     * @param data The ArrayBuffer or ArrayBufferView of the Draco compressed data\r\n     * @param attributes A map of attributes from vertex buffer kinds to Draco unique ids\r\n     * @returns A promise that resolves with the decoded geometry\r\n     */\r\n    public async decodeMeshToGeometryAsync(name: string, scene: Scene, data: ArrayBuffer | ArrayBufferView, attributes?: { [kind: string]: number }): Promise<Geometry> {\r\n        const meshData = await this.decodeMeshToMeshDataAsync(data, attributes);\r\n        const geometry = new Geometry(name, scene);\r\n        if (meshData.indices) {\r\n            geometry.setIndices(meshData.indices);\r\n        }\r\n        for (const attribute of meshData.attributes) {\r\n            geometry.setVerticesBuffer(\r\n                new VertexBuffer(\r\n                    scene.getEngine(),\r\n                    attribute.data,\r\n                    attribute.kind,\r\n                    false,\r\n                    undefined,\r\n                    attribute.byteStride,\r\n                    undefined,\r\n                    attribute.byteOffset,\r\n                    attribute.size,\r\n                    undefined,\r\n                    attribute.normalized,\r\n                    true\r\n                ),\r\n                meshData.totalVertices\r\n            );\r\n        }\r\n        return geometry;\r\n    }\r\n\r\n    /** @internal */\r\n    public async _decodeMeshToGeometryForGltfAsync(\r\n        name: string,\r\n        scene: Scene,\r\n        data: ArrayBuffer | ArrayBufferView,\r\n        attributes: { [kind: string]: number },\r\n        gltfNormalizedOverride: { [kind: string]: boolean },\r\n        boundingInfo: Nullable<BoundingInfo>\r\n    ): Promise<Geometry> {\r\n        const meshData = await this.decodeMeshToMeshDataAsync(data, attributes, gltfNormalizedOverride);\r\n        const geometry = new Geometry(name, scene);\r\n        if (boundingInfo) {\r\n            geometry._boundingInfo = boundingInfo;\r\n            geometry.useBoundingInfoFromGeometry = true;\r\n        }\r\n        if (meshData.indices) {\r\n            geometry.setIndices(meshData.indices);\r\n        }\r\n        for (const attribute of meshData.attributes) {\r\n            geometry.setVerticesBuffer(\r\n                new VertexBuffer(\r\n                    scene.getEngine(),\r\n                    attribute.data,\r\n                    attribute.kind,\r\n                    false,\r\n                    undefined,\r\n                    attribute.byteStride,\r\n                    undefined,\r\n                    attribute.byteOffset,\r\n                    attribute.size,\r\n                    undefined,\r\n                    attribute.normalized,\r\n                    true\r\n                ),\r\n                meshData.totalVertices\r\n            );\r\n        }\r\n        return geometry;\r\n    }\r\n}\r\n"]}