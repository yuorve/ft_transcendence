{"version":3,"file":"dracoEncoder.js","sourceRoot":"","sources":["../../../../../dev/core/src/Meshes/Compression/dracoEncoder.ts"],"names":[],"mappings":"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","sourcesContent":["import { _IsConfigurationAvailable, DracoCodec, type IDracoCodecConfiguration } from \"./dracoCodec\";\r\nimport type { EncoderMessage, IDracoAttributeData, IDracoEncodedMeshData, IDracoEncoderOptions, DracoAttributeName } from \"./dracoEncoder.types\";\r\nimport { EncodeMesh, EncoderWorkerFunction } from \"./dracoCompressionWorker\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport { VertexBuffer } from \"../buffer\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Mesh } from \"../mesh\";\r\nimport type { Geometry } from \"../geometry\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport { deepMerge } from \"../../Misc/deepMerger\";\r\nimport type { EncoderModule } from \"draco3d\";\r\nimport { AreIndices32Bits, GetTypedArrayData } from \"core/Buffers/bufferUtils\";\r\n\r\n// Missing type from types/draco3d. Do not use in public scope; UMD tests will fail because of EncoderModule.\r\ntype DracoEncoderModule = (props: { wasmBinary?: ArrayBuffer }) => Promise<EncoderModule>;\r\n\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\ndeclare let DracoEncoderModule: DracoEncoderModule;\r\n\r\n/**\r\n * Map the Babylon.js attribute kind to the Draco attribute kind, defined by the `GeometryAttributeType` enum.\r\n * @internal\r\n */\r\nfunction GetDracoAttributeName(kind: string): DracoAttributeName {\r\n    if (kind === VertexBuffer.PositionKind) {\r\n        return \"POSITION\";\r\n    } else if (kind === VertexBuffer.NormalKind) {\r\n        return \"NORMAL\";\r\n    } else if (kind === VertexBuffer.ColorKind) {\r\n        return \"COLOR\";\r\n    } else if (kind.startsWith(VertexBuffer.UVKind)) {\r\n        return \"TEX_COORD\";\r\n    }\r\n    return \"GENERIC\";\r\n}\r\n\r\n/**\r\n * Get the indices for the geometry, if present. Eventually used as\r\n * `AddFacesToMesh(mesh: Mesh, numFaces: number, faces: Uint16Array | Uint32Array)`;\r\n * where `numFaces = indices.length / 3` and `faces = indices`.\r\n * @internal\r\n */\r\nfunction PrepareIndicesForDraco(input: Mesh | Geometry): Nullable<Uint32Array | Uint16Array> {\r\n    let indices = input.getIndices(undefined, true);\r\n\r\n    // Convert number[] and Int32Array types, if needed\r\n    if (indices && !(indices instanceof Uint32Array) && !(indices instanceof Uint16Array)) {\r\n        indices = (AreIndices32Bits(indices, indices.length) ? Uint32Array : Uint16Array).from(indices);\r\n    }\r\n\r\n    return indices;\r\n}\r\n\r\n/**\r\n * Get relevant information about the geometry's vertex attributes for Draco encoding. Eventually used for each attribute as\r\n * `AddFloatAttribute(mesh: Mesh, attribute: number, count: number, itemSize: number, array: TypedArray)`\r\n * where `attribute = EncoderModule[<dracoAttribute>]`, `itemSize = <size>`, `array = <data>`, and count is the number of position vertices.\r\n * @internal\r\n */\r\nfunction PrepareAttributesForDraco(input: Mesh | Geometry, excludedAttributes?: string[]): Array<IDracoAttributeData> {\r\n    const attributes: Array<IDracoAttributeData> = [];\r\n\r\n    for (const kind of input.getVerticesDataKinds()) {\r\n        if (excludedAttributes?.includes(kind)) {\r\n            if (kind === VertexBuffer.PositionKind) {\r\n                throw new Error(\"Cannot exclude position attribute from Draco encoding.\");\r\n            }\r\n            continue;\r\n        }\r\n\r\n        // Convert number[] to typed array, if needed.\r\n        const vertexBuffer = input.getVertexBuffer(kind)!;\r\n        const size = vertexBuffer.getSize();\r\n        const data = GetTypedArrayData(\r\n            vertexBuffer.getData()!,\r\n            size,\r\n            vertexBuffer.type,\r\n            vertexBuffer.byteOffset,\r\n            vertexBuffer.byteStride,\r\n            vertexBuffer.normalized,\r\n            input.getTotalVertices(),\r\n            true\r\n        );\r\n        attributes.push({ kind: kind, dracoName: GetDracoAttributeName(kind), size: size, data: data });\r\n    }\r\n\r\n    return attributes;\r\n}\r\n\r\nconst DefaultEncoderOptions: IDracoEncoderOptions = {\r\n    decodeSpeed: 5,\r\n    encodeSpeed: 5,\r\n    method: \"MESH_EDGEBREAKER_ENCODING\",\r\n    quantizationBits: {\r\n        POSITION: 14,\r\n        NORMAL: 10,\r\n        COLOR: 8,\r\n        TEX_COORD: 12,\r\n        GENERIC: 12,\r\n    },\r\n};\r\n\r\n/**\r\n * @experimental This class is subject to change.\r\n *\r\n * Draco Encoder (https://google.github.io/draco/)\r\n *\r\n * This class wraps the Draco encoder module.\r\n *\r\n * By default, the configuration points to a copy of the Draco encoder files from the Babylon.js cdn https://cdn.babylonjs.com/draco_encoder_wasm_wrapper.js.\r\n *\r\n * To update the configuration, use the following code:\r\n * ```javascript\r\n *     DracoEncoder.DefaultConfiguration = {\r\n *          wasmUrl: \"<url to the WebAssembly library>\",\r\n *          wasmBinaryUrl: \"<url to the WebAssembly binary>\",\r\n *          fallbackUrl: \"<url to the fallback JavaScript library>\",\r\n *     };\r\n * ```\r\n *\r\n * Draco has two versions, one for WebAssembly and one for JavaScript. The encoder configuration can be set to only support WebAssembly or only support the JavaScript version.\r\n * Decoding will automatically fallback to the JavaScript version if WebAssembly version is not configured or if WebAssembly is not supported by the browser.\r\n * Use `DracoEncoder.DefaultAvailable` to determine if the encoder configuration is available for the current context.\r\n *\r\n * To encode Draco compressed data, get the default DracoEncoder object and call encodeMeshAsync:\r\n * ```javascript\r\n *     var dracoData = await DracoEncoder.Default.encodeMeshAsync(mesh);\r\n * ```\r\n *\r\n * Currently, DracoEncoder only encodes to meshes. Encoding to point clouds is not yet supported.\r\n *\r\n * Only position, normal, color, and UV attributes are supported natively by the encoder. All other attributes are treated as generic. This means that,\r\n * when decoding these generic attributes later, additional information about their original Babylon types will be needed to interpret the data correctly.\r\n * You can use the return value of `encodeMeshAsync` to source this information, specifically the `attributes` field. E.g.,\r\n * ```javascript\r\n *    var dracoData = await DracoEncoder.Default.encodeMeshAsync(mesh);\r\n *    var meshData = await DracoDecoder.Default.decodeMeshToMeshDataAsync(dracoData.data, dracoData.attributes);\r\n * ```\r\n *\r\n * By default, DracoEncoder will encode all available attributes of the mesh. To exclude specific attributes, use the following code:\r\n * ```javascript\r\n *    var options = { excludedAttributes: [VertexBuffer.MatricesIndicesKind, VertexBuffer.MatricesWeightsKind] };\r\n *    var dracoData = await DracoDecoder.Default.encodeMeshAsync(mesh, options);\r\n * ```\r\n */\r\nexport class DracoEncoder extends DracoCodec {\r\n    /**\r\n     * Default configuration for the DracoEncoder. Defaults to the following:\r\n     * - numWorkers: 50% of the available logical processors, capped to 4. If no logical processors are available, defaults to 1.\r\n     * - wasmUrl: `\"https://cdn.babylonjs.com/draco_encoder_wasm_wrapper.js\"`\r\n     * - wasmBinaryUrl: `\"https://cdn.babylonjs.com/draco_encoder.wasm\"`\r\n     * - fallbackUrl: `\"https://cdn.babylonjs.com/draco_encoder.js\"`\r\n     */\r\n    public static DefaultConfiguration: IDracoCodecConfiguration = {\r\n        wasmUrl: `${Tools._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,\r\n        wasmBinaryUrl: `${Tools._DefaultCdnUrl}/draco_encoder.wasm`,\r\n        fallbackUrl: `${Tools._DefaultCdnUrl}/draco_encoder.js`,\r\n    };\r\n\r\n    /**\r\n     * Returns true if the encoder's `DefaultConfiguration` is available.\r\n     */\r\n    public static get DefaultAvailable(): boolean {\r\n        return _IsConfigurationAvailable(DracoEncoder.DefaultConfiguration);\r\n    }\r\n\r\n    protected static _Default: Nullable<DracoEncoder> = null;\r\n    /**\r\n     * Default instance for the DracoEncoder.\r\n     */\r\n    public static get Default(): DracoEncoder {\r\n        DracoEncoder._Default ??= new DracoEncoder();\r\n        return DracoEncoder._Default;\r\n    }\r\n\r\n    /**\r\n     * Reset the default DracoEncoder object to null and disposing the removed default instance.\r\n     * Note that if the workerPool is a member of the static DefaultConfiguration object it is recommended not to run dispose,\r\n     * unless the static worker pool is no longer needed.\r\n     * @param skipDispose set to true to not dispose the removed default instance\r\n     */\r\n    public static ResetDefault(skipDispose?: boolean): void {\r\n        if (DracoEncoder._Default) {\r\n            if (!skipDispose) {\r\n                DracoEncoder._Default.dispose();\r\n            }\r\n            DracoEncoder._Default = null;\r\n        }\r\n    }\r\n\r\n    protected override _isModuleAvailable(): boolean {\r\n        return typeof DracoEncoderModule !== \"undefined\";\r\n    }\r\n\r\n    protected override async _createModuleAsync(wasmBinary?: ArrayBuffer, jsModule?: unknown /** DracoEncoderModule */): Promise<{ module: unknown /** EncoderModule */ }> {\r\n        const module = await ((jsModule as DracoEncoderModule) || DracoEncoderModule)({ wasmBinary });\r\n        return { module };\r\n    }\r\n\r\n    protected override _getWorkerContent(): string {\r\n        return `${EncodeMesh}(${EncoderWorkerFunction})()`;\r\n    }\r\n\r\n    /**\r\n     * Creates a new Draco encoder.\r\n     * @param configuration Optional override of the configuration for the DracoEncoder. If not provided, defaults to {@link DracoEncoder.DefaultConfiguration}.\r\n     */\r\n    constructor(configuration: IDracoCodecConfiguration = DracoEncoder.DefaultConfiguration) {\r\n        super(configuration);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public async _encodeAsync(\r\n        attributes: Array<IDracoAttributeData>,\r\n        indices: Nullable<Uint16Array | Uint32Array>,\r\n        options?: IDracoEncoderOptions\r\n    ): Promise<Nullable<IDracoEncodedMeshData>> {\r\n        const mergedOptions = options ? deepMerge(DefaultEncoderOptions, options) : DefaultEncoderOptions;\r\n\r\n        if (this._workerPoolPromise) {\r\n            const workerPool = await this._workerPoolPromise;\r\n            return new Promise<Nullable<IDracoEncodedMeshData>>((resolve, reject) => {\r\n                workerPool.push((worker, onComplete) => {\r\n                    const onError = (error: ErrorEvent) => {\r\n                        worker.removeEventListener(\"error\", onError);\r\n                        worker.removeEventListener(\"message\", onMessage);\r\n                        reject(error);\r\n                        onComplete();\r\n                    };\r\n\r\n                    const onMessage = (message: MessageEvent<EncoderMessage>) => {\r\n                        if (message.data.id === \"encodeMeshDone\") {\r\n                            worker.removeEventListener(\"error\", onError);\r\n                            worker.removeEventListener(\"message\", onMessage);\r\n                            resolve(message.data.encodedMeshData);\r\n                            onComplete();\r\n                        }\r\n                    };\r\n\r\n                    worker.addEventListener(\"error\", onError);\r\n                    worker.addEventListener(\"message\", onMessage);\r\n\r\n                    // Build the transfer list. No need to copy, as the data was copied in previous steps.\r\n                    const transferList = [];\r\n                    attributes.forEach((attribute) => {\r\n                        transferList.push(attribute.data.buffer);\r\n                    });\r\n                    if (indices) {\r\n                        transferList.push(indices.buffer);\r\n                    }\r\n\r\n                    worker.postMessage({ id: \"encodeMesh\", attributes: attributes, indices: indices, options: mergedOptions }, transferList);\r\n                });\r\n            });\r\n        }\r\n\r\n        if (this._modulePromise) {\r\n            const encoder = await this._modulePromise;\r\n            return EncodeMesh(encoder.module, attributes, indices, mergedOptions);\r\n        }\r\n\r\n        throw new Error(\"Draco encoder module is not available\");\r\n    }\r\n\r\n    /**\r\n     * Encodes a mesh or geometry into a Draco-encoded mesh data.\r\n     * @param input the mesh or geometry to encode\r\n     * @param options options for the encoding\r\n     * @returns a promise that resolves to the newly-encoded data\r\n     */\r\n    public async encodeMeshAsync(input: Mesh | Geometry, options?: IDracoEncoderOptions): Promise<Nullable<IDracoEncodedMeshData>> {\r\n        const verticesCount = input.getTotalVertices();\r\n        if (verticesCount == 0) {\r\n            throw new Error(\"Cannot compress geometry with Draco. There are no vertices.\");\r\n        }\r\n\r\n        // Prepare parameters for encoding\r\n        if (input instanceof Mesh && input.morphTargetManager && options?.method === \"MESH_EDGEBREAKER_ENCODING\") {\r\n            Logger.Warn(\"Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method.\");\r\n            options.method = \"MESH_SEQUENTIAL_ENCODING\";\r\n        }\r\n\r\n        const indices = PrepareIndicesForDraco(input);\r\n        const attributes = PrepareAttributesForDraco(input, options?.excludedAttributes);\r\n\r\n        return this._encodeAsync(attributes, indices, options);\r\n    }\r\n}\r\n"]}