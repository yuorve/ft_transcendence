{"version":3,"file":"iblShadowsAccumulationPass.js","sourceRoot":"","sources":["../../../../../dev/core/src/Rendering/IBLShadows/iblShadowsAccumulationPass.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,SAAS,EAAE,MAAM,yBAAyB,CAAC;AAGpD,OAAO,EAAE,OAAO,EAAE,MAAM,yBAAyB,CAAC;AAClD,OAAO,EAAE,WAAW,EAAE,MAAM,iCAAiC,CAAC;AAG9D,OAAO,EAAE,sBAAsB,EAAE,MAAM,wCAAwC,CAAC;AAChF,OAAO,EAAE,iBAAiB,EAAE,kEAA8D;AAG1F,OAAO,EAAE,UAAU,EAAE,MAAM,uBAAuB,CAAC;AAEnD;;;GAGG;AACH,MAAM,OAAO,2BAA2B;IAmBpC;;;OAGG;IACI,gBAAgB;QACnB,OAAO,IAAI,CAAC,cAAc,CAAC;IAC/B,CAAC;IAOD;;;OAGG;IACI,cAAc;QACjB,IAAI,CAAC,IAAI,CAAC,YAAY,EAAE,CAAC;YACrB,IAAI,CAAC,gBAAgB,EAAE,CAAC;QAC5B,CAAC;QACD,OAAO,IAAI,CAAC,YAAY,CAAC;IAC7B,CAAC;IAID;;;OAGG;IACH,IAAW,aAAa;QACpB,OAAO,IAAI,CAAC,cAAc,CAAC;IAC/B,CAAC;IAED;;;OAGG;IACH,IAAW,SAAS;QAChB,OAAO,IAAI,CAAC,UAAU,CAAC;IAC3B,CAAC;IAED;;;OAGG;IACH,IAAW,SAAS,CAAC,KAAa;QAC9B,IAAI,CAAC,UAAU,GAAG,KAAK,CAAC;IAC5B,CAAC;IAGD;;OAEG;IACH,IAAW,KAAK;QACZ,OAAO,IAAI,CAAC,MAAM,CAAC;IACvB,CAAC;IACD;;OAEG;IACH,IAAW,KAAK,CAAC,KAAc;QAC3B,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC;IACxB,CAAC;IAGD;;;OAGG;IACH,IAAW,QAAQ,CAAC,KAAc;QAC9B,IAAI,CAAC,SAAS,GAAG,KAAK,CAAC;IAC3B,CAAC;IAMD;;;;;;OAMG;IACI,qBAAqB,CAAC,CAAS,EAAE,CAAS,EAAE,UAAkB,EAAE,WAAmB;QACtF,IAAI,CAAC,gBAAgB,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,UAAU,EAAE,WAAW,CAAC,CAAC;IAC7D,CAAC;IAED;;OAEG;IACK,gBAAgB;QACpB,IAAI,CAAC,IAAI,CAAC,YAAY,EAAE,CAAC;YACrB,MAAM,QAAQ,GAAG,IAAI,CAAC,OAAO,CAAC,QAAQ,CAAC;YACvC,MAAM,YAAY,GAAuB;gBACrC,KAAK,EAAE,IAAI,CAAC,OAAO,CAAC,cAAc,EAAE;gBACpC,MAAM,EAAE,IAAI,CAAC,OAAO,CAAC,eAAe,EAAE;gBACtC,aAAa,EAAE,SAAS,CAAC,kBAAkB;gBAC3C,WAAW,EAAE,SAAS,CAAC,yBAAyB;gBAChD,YAAY,EAAE,SAAS,CAAC,4BAA4B;gBACpD,QAAQ,EAAE,CAAC,YAAY,CAAC;gBACxB,QAAQ,EAAE,CAAC,cAAc,CAAC;gBAC1B,MAAM,EAAE,IAAI,CAAC,OAAO;gBACpB,QAAQ,EAAE,KAAK;gBACf,cAAc,EAAE,QAAQ,CAAC,CAAC,6BAAqB,CAAC,4BAAoB;gBACpE,oBAAoB,EAAE,CAAC,SAAkB,EAAE,IAAoB,EAAE,EAAE;oBAC/D,IAAI,SAAS,EAAE,CAAC;wBACZ,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,2CAA2C,CAAC,CAAC,CAAC;oBACnE,CAAC;yBAAM,CAAC;wBACJ,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,uCAAuC,CAAC,CAAC,CAAC;oBAC/D,CAAC;gBACL,CAAC;aACJ,CAAC;YACF,IAAI,CAAC,YAAY,GAAG,IAAI,WAAW,CAAC,IAAI,CAAC,aAAa,EAAE,gBAAgB,EAAE,YAAY,CAAC,CAAC;YACxF,IAAI,CAAC,YAAY,CAAC,SAAS,GAAG,KAAK,CAAC;YACpC,IAAI,CAAC,YAAY,CAAC,iBAAiB,CAAC,GAAG,CAAC,CAAC,MAAM,EAAE,EAAE;gBAC/C,yDAAyD;gBACzD,MAAM,CAAC,UAAU,CAAC,cAAc,EAAE,IAAI,CAAC,cAAc,CAAC,CAAC;gBACvD,MAAM,CAAC,UAAU,CAAC,YAAY,EAAE,IAAI,CAAC,gBAAgB,CAAC,CAAC;YAC3D,CAAC,CAAC,CAAC;QACP,CAAC;IACL,CAAC;IAED;;;;;OAKG;IACH,YAAY,KAAY,EAAE,wBAAkD;QA3IpE,wBAAmB,GAAY,IAAI,OAAO,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC;QAEvE,0CAA0C;QACnC,iBAAY,GAAY,KAAK,CAAC;QAErC;;WAEG;QACI,YAAO,GAAY,IAAI,CAAC;QAU/B;;WAEG;QACI,sBAAiB,GAAqB,IAAI,UAAU,EAAQ,CAAC;QAa5D,mBAAc,GAAW,gCAAgC,CAAC;QAyB1D,eAAU,GAAW,GAAG,CAAC;QAczB,WAAM,GAAY,IAAI,CAAC;QASvB,cAAS,GAAY,KAAK,CAAC;QAG3B,qBAAgB,GAAY,IAAI,OAAO,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC;QAuDhE,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC;QACpB,IAAI,CAAC,OAAO,GAAG,KAAK,CAAC,SAAS,EAAE,CAAC;QACjC,IAAI,CAAC,eAAe,GAAG,wBAAwB,CAAC;QAChD,IAAI,CAAC,eAAe,EAAE,CAAC;IAC3B,CAAC;IAEO,eAAe;QACnB,MAAM,QAAQ,GAAG,IAAI,CAAC,OAAO,CAAC,QAAQ,CAAC;QAEvC,MAAM,oBAAoB,GAAsC;YAC5D,IAAI,EAAE,SAAS,CAAC,sBAAsB;YACtC,MAAM,EAAE,SAAS,CAAC,kBAAkB;YACpC,YAAY,EAAE,SAAS,CAAC,4BAA4B;YACpD,mBAAmB,EAAE,KAAK;YAC1B,eAAe,EAAE,KAAK;YACtB,cAAc,EAAE,QAAQ,CAAC,CAAC,6BAAqB,CAAC,4BAAoB;YACpE,yBAAyB,EAAE,KAAK,IAAI,EAAE;gBAClC,IAAI,QAAQ,EAAE,CAAC;oBACX,MAAM,OAAO,CAAC,GAAG,CAAC,CAAC,MAAM,CAAC,kDAAkD,CAAC,CAAC,CAAC,CAAC;gBACpF,CAAC;qBAAM,CAAC;oBACJ,MAAM,OAAO,CAAC,GAAG,CAAC,CAAC,MAAM,CAAC,8CAA8C,CAAC,CAAC,CAAC,CAAC;gBAChF,CAAC;YACL,CAAC;SACJ,CAAC;QACF,IAAI,CAAC,cAAc,GAAG,IAAI,iBAAiB,CACvC,wBAAwB,EACxB;YACI,KAAK,EAAE,IAAI,CAAC,OAAO,CAAC,cAAc,EAAE;YACpC,MAAM,EAAE,IAAI,CAAC,OAAO,CAAC,eAAe,EAAE;SACzC,EACD,uBAAuB,EACvB,IAAI,CAAC,MAAM,EACX,oBAAoB,CACvB,CAAC;QACF,IAAI,CAAC,cAAc,CAAC,WAAW,GAAG,CAAC,CAAC,CAAC;QACrC,IAAI,CAAC,cAAc,CAAC,SAAS,GAAG,KAAK,CAAC;QACtC,IAAI,CAAC,cAAc,CAAC,qBAAqB,CAAC,OAAO,CAAC,GAAG,EAAE;YACnD,IAAI,CAAC,iBAAiB,CAAC,eAAe,EAAE,CAAC;QAC7C,CAAC,CAAC,CAAC;QAEH,+FAA+F;QAC/F,IAAI,CAAC,yBAAyB,EAAE,CAAC;QAEjC,IAAI,OAAO,GAAG,CAAC,CAAC;QAChB,IAAI,CAAC,MAAM,CAAC,wBAAwB,CAAC,GAAG,CAAC,GAAG,EAAE;YAC1C,OAAO,GAAG,CAAC,CAAC;QAChB,CAAC,CAAC,CAAC;QACH,IAAI,CAAC,MAAM,CAAC,oCAAoC,CAAC,GAAG,CAAC,GAAG,EAAE;YACtD,IAAI,EAAE,OAAO,IAAI,CAAC,EAAE,CAAC;gBACjB,IAAI,IAAI,CAAC,OAAO,IAAI,IAAI,CAAC,cAAc,CAAC,OAAO,EAAE,EAAE,CAAC;oBAChD,IAAI,CAAC,yBAAyB,EAAE,CAAC;oBACjC,IAAI,CAAC,cAAc,CAAC,MAAM,EAAE,CAAC;gBACjC,CAAC;YACL,CAAC;QACL,CAAC,CAAC,CAAC;QAEH,0DAA0D;QAC1D,8FAA8F;QAC9F,MAAM,mBAAmB,GAAsC;YAC3D,IAAI,EAAE,SAAS,CAAC,sBAAsB;YACtC,MAAM,EAAE,SAAS,CAAC,kBAAkB;YACpC,YAAY,EAAE,SAAS,CAAC,4BAA4B;YACpD,mBAAmB,EAAE,KAAK;YAC1B,eAAe,EAAE,KAAK;YACtB,cAAc,EAAE,QAAQ,CAAC,CAAC,6BAAqB,CAAC,4BAAoB;YACpE,yBAAyB,EAAE,KAAK,IAAI,EAAE;gBAClC,IAAI,QAAQ,EAAE,CAAC;oBACX,MAAM,OAAO,CAAC,GAAG,CAAC,CAAC,MAAM,CAAC,iCAAiC,CAAC,CAAC,CAAC,CAAC;gBACnE,CAAC;qBAAM,CAAC;oBACJ,MAAM,OAAO,CAAC,GAAG,CAAC,CAAC,MAAM,CAAC,6BAA6B,CAAC,CAAC,CAAC,CAAC;gBAC/D,CAAC;YACL,CAAC;SACJ,CAAC;QAEF,IAAI,CAAC,oBAAoB,GAAG,IAAI,iBAAiB,CAC7C,mBAAmB,EACnB,EAAE,KAAK,EAAE,IAAI,CAAC,OAAO,CAAC,cAAc,EAAE,EAAE,MAAM,EAAE,IAAI,CAAC,OAAO,CAAC,eAAe,EAAE,EAAE,EAChF,MAAM,EACN,IAAI,CAAC,MAAM,EACX,mBAAmB,EACnB,KAAK,CACR,CAAC;QAEF,IAAI,CAAC,oBAAoB,CAAC,SAAS,GAAG,KAAK,CAAC;QAC5C,IAAI,CAAC,oBAAoB,CAAC,WAAW,GAAG,CAAC,CAAC;QAC1C,IAAI,CAAC,oBAAoB,CAAC,4BAA4B,CAAC,GAAG,CAAC,IAAI,CAAC,4BAA4B,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;QACzG,IAAI,CAAC,4BAA4B,EAAE,CAAC;QAEpC,4DAA4D;QAC5D,8FAA8F;QAC9F,MAAM,oBAAoB,GAAsC;YAC5D,IAAI,EAAE,SAAS,CAAC,sBAAsB;YACtC,MAAM,EAAE,SAAS,CAAC,kBAAkB;YACpC,YAAY,EAAE,SAAS,CAAC,4BAA4B;YACpD,mBAAmB,EAAE,KAAK;YAC1B,eAAe,EAAE,KAAK;YACtB,cAAc,EAAE,QAAQ,CAAC,CAAC,6BAAqB,CAAC,4BAAoB;YACpE,yBAAyB,EAAE,KAAK,IAAI,EAAE;gBAClC,IAAI,QAAQ,EAAE,CAAC;oBACX,MAAM,OAAO,CAAC,GAAG,CAAC,CAAC,MAAM,CAAC,iCAAiC,CAAC,CAAC,CAAC,CAAC;gBACnE,CAAC;qBAAM,CAAC;oBACJ,MAAM,OAAO,CAAC,GAAG,CAAC,CAAC,MAAM,CAAC,6BAA6B,CAAC,CAAC,CAAC,CAAC;gBAC/D,CAAC;YACL,CAAC;SACJ,CAAC;QAEF,IAAI,CAAC,gBAAgB,GAAG,IAAI,iBAAiB,CACzC,oBAAoB,EACpB,EAAE,KAAK,EAAE,IAAI,CAAC,OAAO,CAAC,cAAc,EAAE,EAAE,MAAM,EAAE,IAAI,CAAC,OAAO,CAAC,eAAe,EAAE,EAAE,EAChF,MAAM,EACN,IAAI,CAAC,MAAM,EACX,oBAAoB,EACpB,KAAK,CACR,CAAC;QACF,IAAI,CAAC,mBAAmB,EAAE,CAAC;QAC3B,IAAI,CAAC,gBAAgB,CAAC,SAAS,GAAG,KAAK,CAAC;QACxC,IAAI,CAAC,gBAAgB,CAAC,WAAW,GAAG,CAAC,CAAC;QACtC,IAAI,CAAC,gBAAgB,CAAC,4BAA4B,CAAC,GAAG,CAAC,IAAI,CAAC,mBAAmB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;IAChG,CAAC;IAEO,yBAAyB;QAC7B,MAAM,SAAS,GAAG,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,IAAI,CAAC;QACzD,IAAI,CAAC,mBAAmB,CAAC,GAAG,CAAC,SAAS,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,EAAE,IAAI,CAAC,eAAe,CAAC,aAAa,EAAE,GAAG,CAAC,CAAC;QACzG,IAAI,CAAC,cAAc,CAAC,UAAU,CAAC,oBAAoB,EAAE,IAAI,CAAC,eAAe,CAAC,sBAAsB,EAAE,CAAC,CAAC;QACpG,IAAI,CAAC,cAAc,CAAC,UAAU,CAAC,wBAAwB,EAAE,IAAI,CAAC,mBAAmB,CAAC,CAAC;QACnF,IAAI,CAAC,cAAc,CAAC,UAAU,CAAC,wBAAwB,EAAE,IAAI,CAAC,oBAAoB,CAAC,CAAC,CAAC,IAAI,CAAC,oBAAoB,CAAC,CAAC,CAAC,IAAI,CAAC,eAAe,CAAC,eAAe,CAAC,CAAC;QACvJ,IAAI,CAAC,cAAc,CAAC,UAAU,CAAC,qBAAqB,EAAE,IAAI,CAAC,gBAAgB,CAAC,CAAC,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC,CAAC,IAAI,CAAC,eAAe,CAAC,eAAe,CAAC,CAAC;QAE5I,MAAM,sBAAsB,GAAG,IAAI,CAAC,MAAM,CAAC,sBAAsB,CAAC;QAClE,IAAI,CAAC,sBAAsB,EAAE,CAAC;YAC1B,OAAO;QACX,CAAC;QACD,MAAM,aAAa,GAAG,sBAAsB,CAAC,eAAe,CAAC,sBAAsB,CAAC,4BAA4B,CAAC,CAAC;QAClH,IAAI,CAAC,cAAc,CAAC,UAAU,CAAC,eAAe,EAAE,sBAAsB,CAAC,UAAU,EAAE,CAAC,QAAQ,CAAC,aAAa,CAAC,CAAC,CAAC;QAC7G,MAAM,cAAc,GAAG,sBAAsB,CAAC,eAAe,CAAC,sBAAsB,CAAC,qBAAqB,CAAC,CAAC;QAC5G,IAAI,CAAC,cAAc,CAAC,UAAU,CAAC,iBAAiB,EAAE,sBAAsB,CAAC,UAAU,EAAE,CAAC,QAAQ,CAAC,cAAc,CAAC,CAAC,CAAC;QAEhH,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;QACnB,IAAI,CAAC,SAAS,GAAG,KAAK,CAAC;IAC3B,CAAC;IAEO,mBAAmB;QACvB,MAAM,sBAAsB,GAAG,IAAI,CAAC,MAAM,CAAC,sBAAsB,CAAC;QAClE,MAAM,KAAK,GAAG,sBAAuB,CAAC,eAAe,CAAC,sBAAsB,CAAC,qBAAqB,CAAC,CAAC;QACpG,IAAI,CAAC,gBAAgB,CAAC,UAAU,CAAC,gBAAgB,EAAE,sBAAuB,CAAC,UAAU,EAAE,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC;IAC7G,CAAC;IAEO,4BAA4B;QAChC,IAAI,CAAC,oBAAoB,CAAC,UAAU,CAAC,gBAAgB,EAAE,IAAI,CAAC,cAAc,CAAC,CAAC;IAChF,CAAC;IAED;;;OAGG;IACI,MAAM,CAAC,cAAsB,GAAG;QACnC,MAAM,OAAO,GAAG;YACZ,KAAK,EAAE,IAAI,CAAC,GAAG,CAAC,GAAG,EAAE,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,OAAO,CAAC,cAAc,EAAE,GAAG,WAAW,CAAC,CAAC;YAC7E,MAAM,EAAE,IAAI,CAAC,GAAG,CAAC,GAAG,EAAE,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,OAAO,CAAC,eAAe,EAAE,GAAG,WAAW,CAAC,CAAC;SAClF,CAAC;QACF,IAAI,CAAC,cAAc,CAAC,MAAM,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;QAC3C,IAAI,CAAC,oBAAoB,CAAC,MAAM,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;QACjD,IAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC,EAAE,KAAK,EAAE,IAAI,CAAC,OAAO,CAAC,cAAc,EAAE,EAAE,MAAM,EAAE,IAAI,CAAC,OAAO,CAAC,eAAe,EAAE,EAAE,EAAE,KAAK,CAAC,CAAC;QACtH,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC;IACtB,CAAC;IAEO,gBAAgB;QACpB,IAAI,CAAC,oBAAoB,CAAC,OAAO,EAAE,CAAC;QACpC,IAAI,CAAC,gBAAgB,CAAC,OAAO,EAAE,CAAC;QAChC,IAAI,CAAC,cAAc,CAAC,OAAO,EAAE,CAAC;IAClC,CAAC;IAED;;;OAGG;IACI,OAAO;QACV,OAAO,CACH,IAAI,CAAC,oBAAoB;YACzB,IAAI,CAAC,oBAAoB,CAAC,OAAO,EAAE;YACnC,IAAI,CAAC,gBAAgB;YACrB,IAAI,CAAC,gBAAgB,CAAC,OAAO,EAAE;YAC/B,IAAI,CAAC,cAAc,CAAC,OAAO,EAAE;YAC7B,CAAC,CAAC,IAAI,CAAC,YAAY,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC,OAAO,EAAE,CAAC,CACvD,CAAC;IACN,CAAC;IAED;;OAEG;IACI,OAAO;QACV,IAAI,CAAC,gBAAgB,EAAE,CAAC;QACxB,IAAI,IAAI,CAAC,YAAY,EAAE,CAAC;YACpB,IAAI,CAAC,YAAY,CAAC,OAAO,EAAE,CAAC;QAChC,CAAC;QACD,IAAI,CAAC,iBAAiB,CAAC,KAAK,EAAE,CAAC;IACnC,CAAC;CACJ","sourcesContent":["import { Constants } from \"../../Engines/constants\";\r\nimport type { AbstractEngine } from \"../../Engines/abstractEngine\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Vector4 } from \"../../Maths/math.vector\";\r\nimport { PostProcess } from \"../../PostProcesses/postProcess\";\r\nimport type { PostProcessOptions } from \"../../PostProcesses/postProcess\";\r\nimport { ShaderLanguage } from \"core/Materials/shaderLanguage\";\r\nimport { GeometryBufferRenderer } from \"../../Rendering/geometryBufferRenderer\";\r\nimport { ProceduralTexture } from \"core/Materials/Textures/Procedurals/proceduralTexture\";\r\nimport type { IProceduralTextureCreationOptions } from \"core/Materials/Textures/Procedurals/proceduralTexture\";\r\nimport type { IblShadowsRenderPipeline } from \"./iblShadowsRenderPipeline\";\r\nimport { Observable } from \"../../Misc/observable\";\r\n\r\n/**\r\n * This should not be instanciated directly, as it is part of a scene component\r\n * @internal\r\n */\r\nexport class _IblShadowsAccumulationPass {\r\n    private _scene: Scene;\r\n    private _engine: AbstractEngine;\r\n    private _renderPipeline: IblShadowsRenderPipeline;\r\n\r\n    // First, render the accumulation pass with both position buffers, motion buffer, shadow buffer, and the previous accumulation buffer\r\n    private _outputTexture: ProceduralTexture;\r\n    private _oldAccumulationCopy: ProceduralTexture;\r\n    private _oldPositionCopy: ProceduralTexture;\r\n    private _accumulationParams: Vector4 = new Vector4(0.0, 0.0, 0.0, 0.0);\r\n\r\n    /** Enable the debug view for this pass */\r\n    public debugEnabled: boolean = false;\r\n\r\n    /**\r\n     * Is the effect enabled\r\n     */\r\n    public enabled: boolean = true;\r\n\r\n    /**\r\n     * Returns the output texture of the pass.\r\n     * @returns The output texture.\r\n     */\r\n    public getOutputTexture(): ProceduralTexture {\r\n        return this._outputTexture;\r\n    }\r\n\r\n    /**\r\n     * Observable that triggers when the accumulation texture is ready\r\n     */\r\n    public onReadyObservable: Observable<void> = new Observable<void>();\r\n\r\n    /**\r\n     * Gets the debug pass post process\r\n     * @returns The post process\r\n     */\r\n    public getDebugPassPP(): PostProcess {\r\n        if (!this._debugPassPP) {\r\n            this._createDebugPass();\r\n        }\r\n        return this._debugPassPP;\r\n    }\r\n\r\n    private _debugPassName: string = \"Shadow Accumulation Debug Pass\";\r\n\r\n    /**\r\n     * Gets the name of the debug pass\r\n     * @returns The name of the debug pass\r\n     */\r\n    public get debugPassName(): string {\r\n        return this._debugPassName;\r\n    }\r\n\r\n    /**\r\n     * A value that controls how much of the previous frame's accumulation to keep.\r\n     * The higher the value, the faster the shadows accumulate but the more potential ghosting you'll see.\r\n     */\r\n    public get remanence(): number {\r\n        return this._remanence;\r\n    }\r\n\r\n    /**\r\n     * A value that controls how much of the previous frame's accumulation to keep.\r\n     * The higher the value, the faster the shadows accumulate but the more potential ghosting you'll see.\r\n     */\r\n    public set remanence(value: number) {\r\n        this._remanence = value;\r\n    }\r\n    private _remanence: number = 0.9;\r\n\r\n    /**\r\n     * Reset the accumulation.\r\n     */\r\n    public get reset(): boolean {\r\n        return this._reset;\r\n    }\r\n    /**\r\n     * Reset the accumulation.\r\n     */\r\n    public set reset(value: boolean) {\r\n        this._reset = value;\r\n    }\r\n    private _reset: boolean = true;\r\n\r\n    /**\r\n     * Tell the pass that the camera is moving. This will cause the accumulation\r\n     * rate to change.\r\n     */\r\n    public set isMoving(value: boolean) {\r\n        this._isMoving = value;\r\n    }\r\n    private _isMoving: boolean = false;\r\n\r\n    private _debugPassPP: PostProcess;\r\n    private _debugSizeParams: Vector4 = new Vector4(0.0, 0.0, 0.0, 0.0);\r\n\r\n    /**\r\n     * Sets params that control the position and scaling of the debug display on the screen.\r\n     * @param x Screen X offset of the debug display (0-1)\r\n     * @param y Screen Y offset of the debug display (0-1)\r\n     * @param widthScale X scale of the debug display (0-1)\r\n     * @param heightScale Y scale of the debug display (0-1)\r\n     */\r\n    public setDebugDisplayParams(x: number, y: number, widthScale: number, heightScale: number) {\r\n        this._debugSizeParams.set(x, y, widthScale, heightScale);\r\n    }\r\n\r\n    /**\r\n     * Creates the debug post process effect for this pass\r\n     */\r\n    private _createDebugPass() {\r\n        if (!this._debugPassPP) {\r\n            const isWebGPU = this._engine.isWebGPU;\r\n            const debugOptions: PostProcessOptions = {\r\n                width: this._engine.getRenderWidth(),\r\n                height: this._engine.getRenderHeight(),\r\n                textureFormat: Constants.TEXTUREFORMAT_RGBA,\r\n                textureType: Constants.TEXTURETYPE_UNSIGNED_BYTE,\r\n                samplingMode: Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n                uniforms: [\"sizeParams\"],\r\n                samplers: [\"debugSampler\"],\r\n                engine: this._engine,\r\n                reusable: false,\r\n                shaderLanguage: isWebGPU ? ShaderLanguage.WGSL : ShaderLanguage.GLSL,\r\n                extraInitializations: (useWebGPU: boolean, list: Promise<any>[]) => {\r\n                    if (useWebGPU) {\r\n                        list.push(import(\"../../ShadersWGSL/iblShadowDebug.fragment\"));\r\n                    } else {\r\n                        list.push(import(\"../../Shaders/iblShadowDebug.fragment\"));\r\n                    }\r\n                },\r\n            };\r\n            this._debugPassPP = new PostProcess(this.debugPassName, \"iblShadowDebug\", debugOptions);\r\n            this._debugPassPP.autoClear = false;\r\n            this._debugPassPP.onApplyObservable.add((effect) => {\r\n                // update the caustic texture with what we just rendered.\r\n                effect.setTexture(\"debugSampler\", this._outputTexture);\r\n                effect.setVector4(\"sizeParams\", this._debugSizeParams);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Instantiates the accumulation pass\r\n     * @param scene Scene to attach to\r\n     * @param iblShadowsRenderPipeline The IBL shadows render pipeline\r\n     * @returns The accumulation pass\r\n     */\r\n    constructor(scene: Scene, iblShadowsRenderPipeline: IblShadowsRenderPipeline) {\r\n        this._scene = scene;\r\n        this._engine = scene.getEngine();\r\n        this._renderPipeline = iblShadowsRenderPipeline;\r\n        this._createTextures();\r\n    }\r\n\r\n    private _createTextures() {\r\n        const isWebGPU = this._engine.isWebGPU;\r\n\r\n        const outputTextureOptions: IProceduralTextureCreationOptions = {\r\n            type: Constants.TEXTURETYPE_HALF_FLOAT,\r\n            format: Constants.TEXTUREFORMAT_RGBA,\r\n            samplingMode: Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n            generateDepthBuffer: false,\r\n            generateMipMaps: false,\r\n            shaderLanguage: isWebGPU ? ShaderLanguage.WGSL : ShaderLanguage.GLSL,\r\n            extraInitializationsAsync: async () => {\r\n                if (isWebGPU) {\r\n                    await Promise.all([import(\"../../ShadersWGSL/iblShadowAccumulation.fragment\")]);\r\n                } else {\r\n                    await Promise.all([import(\"../../Shaders/iblShadowAccumulation.fragment\")]);\r\n                }\r\n            },\r\n        };\r\n        this._outputTexture = new ProceduralTexture(\r\n            \"shadowAccumulationPass\",\r\n            {\r\n                width: this._engine.getRenderWidth(),\r\n                height: this._engine.getRenderHeight(),\r\n            },\r\n            \"iblShadowAccumulation\",\r\n            this._scene,\r\n            outputTextureOptions\r\n        );\r\n        this._outputTexture.refreshRate = -1;\r\n        this._outputTexture.autoClear = false;\r\n        this._outputTexture.onGeneratedObservable.addOnce(() => {\r\n            this.onReadyObservable.notifyObservers();\r\n        });\r\n\r\n        // Need to set all the textures first so that the effect gets created with the proper uniforms.\r\n        this._setOutputTextureBindings();\r\n\r\n        let counter = 0;\r\n        this._scene.onBeforeRenderObservable.add(() => {\r\n            counter = 0;\r\n        });\r\n        this._scene.onAfterRenderTargetsRenderObservable.add(() => {\r\n            if (++counter == 2) {\r\n                if (this.enabled && this._outputTexture.isReady()) {\r\n                    this._setOutputTextureBindings();\r\n                    this._outputTexture.render();\r\n                }\r\n            }\r\n        });\r\n\r\n        // Create the accumulation texture for the previous frame.\r\n        // We'll copy the output of the accumulation pass to this texture at the start of every frame.\r\n        const accumulationOptions: IProceduralTextureCreationOptions = {\r\n            type: Constants.TEXTURETYPE_HALF_FLOAT,\r\n            format: Constants.TEXTUREFORMAT_RGBA,\r\n            samplingMode: Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n            generateDepthBuffer: false,\r\n            generateMipMaps: false,\r\n            shaderLanguage: isWebGPU ? ShaderLanguage.WGSL : ShaderLanguage.GLSL,\r\n            extraInitializationsAsync: async () => {\r\n                if (isWebGPU) {\r\n                    await Promise.all([import(\"../../ShadersWGSL/pass.fragment\")]);\r\n                } else {\r\n                    await Promise.all([import(\"../../Shaders/pass.fragment\")]);\r\n                }\r\n            },\r\n        };\r\n\r\n        this._oldAccumulationCopy = new ProceduralTexture(\r\n            \"oldAccumulationRT\",\r\n            { width: this._engine.getRenderWidth(), height: this._engine.getRenderHeight() },\r\n            \"pass\",\r\n            this._scene,\r\n            accumulationOptions,\r\n            false\r\n        );\r\n\r\n        this._oldAccumulationCopy.autoClear = false;\r\n        this._oldAccumulationCopy.refreshRate = 1;\r\n        this._oldAccumulationCopy.onBeforeGenerationObservable.add(this._setAccumulationCopyBindings.bind(this));\r\n        this._setAccumulationCopyBindings();\r\n\r\n        // Create the local position texture for the previous frame.\r\n        // We'll copy the previous local position texture to this texture at the start of every frame.\r\n        const localPositionOptions: IProceduralTextureCreationOptions = {\r\n            type: Constants.TEXTURETYPE_HALF_FLOAT,\r\n            format: Constants.TEXTUREFORMAT_RGBA,\r\n            samplingMode: Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n            generateDepthBuffer: false,\r\n            generateMipMaps: false,\r\n            shaderLanguage: isWebGPU ? ShaderLanguage.WGSL : ShaderLanguage.GLSL,\r\n            extraInitializationsAsync: async () => {\r\n                if (isWebGPU) {\r\n                    await Promise.all([import(\"../../ShadersWGSL/pass.fragment\")]);\r\n                } else {\r\n                    await Promise.all([import(\"../../Shaders/pass.fragment\")]);\r\n                }\r\n            },\r\n        };\r\n\r\n        this._oldPositionCopy = new ProceduralTexture(\r\n            \"oldLocalPositionRT\",\r\n            { width: this._engine.getRenderWidth(), height: this._engine.getRenderHeight() },\r\n            \"pass\",\r\n            this._scene,\r\n            localPositionOptions,\r\n            false\r\n        );\r\n        this._updatePositionCopy();\r\n        this._oldPositionCopy.autoClear = false;\r\n        this._oldPositionCopy.refreshRate = 1;\r\n        this._oldPositionCopy.onBeforeGenerationObservable.add(this._updatePositionCopy.bind(this));\r\n    }\r\n\r\n    private _setOutputTextureBindings() {\r\n        const remanence = this._isMoving ? this.remanence : 0.99;\r\n        this._accumulationParams.set(remanence, this.reset ? 1.0 : 0.0, this._renderPipeline.voxelGridSize, 0.0);\r\n        this._outputTexture.setTexture(\"spatialBlurSampler\", this._renderPipeline._getSpatialBlurTexture());\r\n        this._outputTexture.setVector4(\"accumulationParameters\", this._accumulationParams);\r\n        this._outputTexture.setTexture(\"oldAccumulationSampler\", this._oldAccumulationCopy ? this._oldAccumulationCopy : this._renderPipeline._dummyTexture2d);\r\n        this._outputTexture.setTexture(\"prevPositionSampler\", this._oldPositionCopy ? this._oldPositionCopy : this._renderPipeline._dummyTexture2d);\r\n\r\n        const geometryBufferRenderer = this._scene.geometryBufferRenderer;\r\n        if (!geometryBufferRenderer) {\r\n            return;\r\n        }\r\n        const velocityIndex = geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.VELOCITY_LINEAR_TEXTURE_TYPE);\r\n        this._outputTexture.setTexture(\"motionSampler\", geometryBufferRenderer.getGBuffer().textures[velocityIndex]);\r\n        const wPositionIndex = geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.POSITION_TEXTURE_TYPE);\r\n        this._outputTexture.setTexture(\"positionSampler\", geometryBufferRenderer.getGBuffer().textures[wPositionIndex]);\r\n\r\n        this.reset = false;\r\n        this._isMoving = false;\r\n    }\r\n\r\n    private _updatePositionCopy() {\r\n        const geometryBufferRenderer = this._scene.geometryBufferRenderer;\r\n        const index = geometryBufferRenderer!.getTextureIndex(GeometryBufferRenderer.POSITION_TEXTURE_TYPE);\r\n        this._oldPositionCopy.setTexture(\"textureSampler\", geometryBufferRenderer!.getGBuffer().textures[index]);\r\n    }\r\n\r\n    private _setAccumulationCopyBindings() {\r\n        this._oldAccumulationCopy.setTexture(\"textureSampler\", this._outputTexture);\r\n    }\r\n\r\n    /**\r\n     * Called by render pipeline when canvas resized.\r\n     * @param scaleFactor The factor by which to scale the canvas size.\r\n     */\r\n    public resize(scaleFactor: number = 1.0) {\r\n        const newSize = {\r\n            width: Math.max(1.0, Math.floor(this._engine.getRenderWidth() * scaleFactor)),\r\n            height: Math.max(1.0, Math.floor(this._engine.getRenderHeight() * scaleFactor)),\r\n        };\r\n        this._outputTexture.resize(newSize, false);\r\n        this._oldAccumulationCopy.resize(newSize, false);\r\n        this._oldPositionCopy.resize({ width: this._engine.getRenderWidth(), height: this._engine.getRenderHeight() }, false);\r\n        this.reset = true;\r\n    }\r\n\r\n    private _disposeTextures() {\r\n        this._oldAccumulationCopy.dispose();\r\n        this._oldPositionCopy.dispose();\r\n        this._outputTexture.dispose();\r\n    }\r\n\r\n    /**\r\n     * Checks if the pass is ready\r\n     * @returns true if the pass is ready\r\n     */\r\n    public isReady() {\r\n        return (\r\n            this._oldAccumulationCopy &&\r\n            this._oldAccumulationCopy.isReady() &&\r\n            this._oldPositionCopy &&\r\n            this._oldPositionCopy.isReady() &&\r\n            this._outputTexture.isReady() &&\r\n            !(this._debugPassPP && !this._debugPassPP.isReady())\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Disposes the associated resources\r\n     */\r\n    public dispose() {\r\n        this._disposeTextures();\r\n        if (this._debugPassPP) {\r\n            this._debugPassPP.dispose();\r\n        }\r\n        this.onReadyObservable.clear();\r\n    }\r\n}\r\n"]}