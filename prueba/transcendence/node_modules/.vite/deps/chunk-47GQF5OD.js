import {
  __export
} from "./chunk-PZ5AY32C.js";

// node_modules/@babylonjs/core/Maths/math.scalar.functions.js
var math_scalar_functions_exports = {};
__export(math_scalar_functions_exports, {
  Clamp: () => Clamp,
  DeltaAngle: () => DeltaAngle,
  Denormalize: () => Denormalize,
  ExtractAsInt: () => ExtractAsInt,
  Hermite: () => Hermite,
  Hermite1stDerivative: () => Hermite1stDerivative,
  HighestCommonFactor: () => HighestCommonFactor,
  ILog2: () => ILog2,
  InverseLerp: () => InverseLerp,
  Lerp: () => Lerp,
  LerpAngle: () => LerpAngle,
  MoveTowards: () => MoveTowards,
  MoveTowardsAngle: () => MoveTowardsAngle,
  Normalize: () => Normalize,
  NormalizeRadians: () => NormalizeRadians,
  PercentToRange: () => PercentToRange,
  PingPong: () => PingPong,
  RandomRange: () => RandomRange,
  RangeToPercent: () => RangeToPercent,
  Repeat: () => Repeat,
  SmoothStep: () => SmoothStep,
  ToHex: () => ToHex,
  WithinEpsilon: () => WithinEpsilon
});
function ExtractAsInt(value) {
  return parseInt(value.toString().replace(/\W/g, ""));
}
function WithinEpsilon(a, b, epsilon = 1401298e-51) {
  return Math.abs(a - b) <= epsilon;
}
function RandomRange(min, max) {
  if (min === max) {
    return min;
  }
  return Math.random() * (max - min) + min;
}
function Lerp(start, end, amount) {
  return start + (end - start) * amount;
}
function LerpAngle(start, end, amount) {
  let num = Repeat(end - start, 360);
  if (num > 180) {
    num -= 360;
  }
  return start + num * Clamp(amount);
}
function InverseLerp(a, b, value) {
  let result = 0;
  if (a != b) {
    result = Clamp((value - a) / (b - a));
  } else {
    result = 0;
  }
  return result;
}
function Hermite(value1, tangent1, value2, tangent2, amount) {
  const squared = amount * amount;
  const cubed = amount * squared;
  const part1 = 2 * cubed - 3 * squared + 1;
  const part2 = -2 * cubed + 3 * squared;
  const part3 = cubed - 2 * squared + amount;
  const part4 = cubed - squared;
  return value1 * part1 + value2 * part2 + tangent1 * part3 + tangent2 * part4;
}
function Hermite1stDerivative(value1, tangent1, value2, tangent2, time) {
  const t2 = time * time;
  return (t2 - time) * 6 * value1 + (3 * t2 - 4 * time + 1) * tangent1 + (-t2 + time) * 6 * value2 + (3 * t2 - 2 * time) * tangent2;
}
function Clamp(value, min = 0, max = 1) {
  return Math.min(max, Math.max(min, value));
}
function NormalizeRadians(angle) {
  angle -= Math.PI * 2 * Math.floor((angle + Math.PI) / (Math.PI * 2));
  return angle;
}
function ToHex(i) {
  const str = i.toString(16);
  if (i <= 15) {
    return ("0" + str).toUpperCase();
  }
  return str.toUpperCase();
}
function ILog2(value) {
  if (Math.log2) {
    return Math.floor(Math.log2(value));
  }
  if (value < 0) {
    return NaN;
  } else if (value === 0) {
    return -Infinity;
  }
  let n = 0;
  if (value < 1) {
    while (value < 1) {
      n++;
      value = value * 2;
    }
    n = -n;
  } else if (value > 1) {
    while (value > 1) {
      n++;
      value = Math.floor(value / 2);
    }
  }
  return n;
}
function Repeat(value, length) {
  return value - Math.floor(value / length) * length;
}
function Normalize(value, min, max) {
  return (value - min) / (max - min);
}
function Denormalize(normalized, min, max) {
  return normalized * (max - min) + min;
}
function DeltaAngle(current, target) {
  let num = Repeat(target - current, 360);
  if (num > 180) {
    num -= 360;
  }
  return num;
}
function PingPong(tx, length) {
  const t = Repeat(tx, length * 2);
  return length - Math.abs(t - length);
}
function SmoothStep(from, to, tx) {
  let t = Clamp(tx);
  t = -2 * t * t * t + 3 * t * t;
  return to * t + from * (1 - t);
}
function MoveTowards(current, target, maxDelta) {
  let result = 0;
  if (Math.abs(target - current) <= maxDelta) {
    result = target;
  } else {
    result = current + Math.sign(target - current) * maxDelta;
  }
  return result;
}
function MoveTowardsAngle(current, target, maxDelta) {
  const num = DeltaAngle(current, target);
  let result = 0;
  if (-maxDelta < num && num < maxDelta) {
    result = target;
  } else {
    target = current + num;
    result = MoveTowards(current, target, maxDelta);
  }
  return result;
}
function RangeToPercent(number, min, max) {
  return (number - min) / (max - min);
}
function PercentToRange(percent, min, max) {
  return (max - min) * percent + min;
}
function HighestCommonFactor(a, b) {
  const r = a % b;
  if (r === 0) {
    return b;
  }
  return HighestCommonFactor(b, r);
}

export {
  WithinEpsilon,
  RandomRange,
  Lerp,
  Hermite,
  Clamp,
  NormalizeRadians,
  ToHex,
  ILog2,
  HighestCommonFactor,
  math_scalar_functions_exports
};
//# sourceMappingURL=chunk-47GQF5OD.js.map
