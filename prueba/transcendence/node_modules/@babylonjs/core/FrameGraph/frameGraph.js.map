{"version":3,"file":"frameGraph.js","sourceRoot":"","sources":["../../../../dev/core/src/FrameGraph/frameGraph.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable import/no-internal-modules */\r\nimport type { Scene, AbstractEngine, FrameGraphTask, Nullable } from \"core/index\";\r\nimport { FrameGraphPass } from \"./Passes/pass\";\r\nimport { FrameGraphRenderPass } from \"./Passes/renderPass\";\r\nimport { FrameGraphCullPass } from \"./Passes/cullPass\";\r\nimport { FrameGraphRenderContext } from \"./frameGraphRenderContext\";\r\nimport { FrameGraphContext } from \"./frameGraphContext\";\r\nimport { FrameGraphTextureManager } from \"./frameGraphTextureManager\";\r\nimport { Observable } from \"core/Misc/observable\";\r\nimport { _retryWithInterval } from \"core/Misc/timingTools\";\r\nimport { Logger } from \"core/Misc/logger\";\r\n\r\nenum FrameGraphPassType {\r\n    Normal = 0,\r\n    Render = 1,\r\n    Cull = 2,\r\n}\r\n\r\n/**\r\n * Class used to implement a frame graph\r\n * @experimental\r\n */\r\nexport class FrameGraph {\r\n    /**\r\n     * Gets the texture manager used by the frame graph\r\n     */\r\n    public readonly textureManager: FrameGraphTextureManager;\r\n\r\n    private readonly _engine: AbstractEngine;\r\n    private readonly _tasks: FrameGraphTask[] = [];\r\n    private readonly _passContext: FrameGraphContext;\r\n    private readonly _renderContext: FrameGraphRenderContext;\r\n    private _currentProcessedTask: FrameGraphTask | null = null;\r\n    private _whenReadyAsyncCancel: Nullable<() => void> = null;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that texture allocation should be optimized (that is, reuse existing textures when possible to limit GPU memory usage) (default: true)\r\n     */\r\n    public optimizeTextureAllocation = true;\r\n\r\n    /**\r\n     * Observable raised when the node render graph is built\r\n     */\r\n    public onBuildObservable = new Observable<FrameGraph>();\r\n\r\n    /**\r\n     * Gets the engine used by the frame graph\r\n     */\r\n    public get engine() {\r\n        return this._engine;\r\n    }\r\n\r\n    /**\r\n     * Constructs the frame graph\r\n     * @param engine defines the hosting engine\r\n     * @param debugTextures defines a boolean indicating that textures created by the frame graph should be visible in the inspector\r\n     * @param scene defines the scene the frame graph is associated with\r\n     */\r\n    constructor(engine: AbstractEngine, debugTextures = false, scene: Scene) {\r\n        this._engine = engine;\r\n        this.textureManager = new FrameGraphTextureManager(this._engine, debugTextures, scene);\r\n        this._passContext = new FrameGraphContext();\r\n        this._renderContext = new FrameGraphRenderContext(this._engine, this.textureManager, scene);\r\n    }\r\n\r\n    /**\r\n     * Gets a task by name\r\n     * @param name Name of the task to get\r\n     * @returns The task or undefined if not found\r\n     */\r\n    public getTaskByName<T extends FrameGraphTask>(name: string): T | undefined {\r\n        return this._tasks.find((t) => t.name === name) as T;\r\n    }\r\n\r\n    /**\r\n     * Adds a task to the frame graph\r\n     * @param task Task to add\r\n     */\r\n    public addTask(task: FrameGraphTask): void {\r\n        if (this._currentProcessedTask !== null) {\r\n            throw new Error(`FrameGraph.addTask: Can't add the task \"${task.name}\" while another task is currently building (task: ${this._currentProcessedTask.name}).`);\r\n        }\r\n\r\n        this._tasks.push(task);\r\n    }\r\n\r\n    /**\r\n     * Adds a pass to a task. This method can only be called during a Task.record execution.\r\n     * @param name The name of the pass\r\n     * @param whenTaskDisabled If true, the pass will be added to the list of passes to execute when the task is disabled (default is false)\r\n     * @returns The render pass created\r\n     */\r\n    public addPass(name: string, whenTaskDisabled = false): FrameGraphPass<FrameGraphContext> {\r\n        return this._addPass(name, FrameGraphPassType.Normal, whenTaskDisabled) as FrameGraphPass<FrameGraphContext>;\r\n    }\r\n\r\n    /**\r\n     * Adds a render pass to a task. This method can only be called during a Task.record execution.\r\n     * @param name The name of the pass\r\n     * @param whenTaskDisabled If true, the pass will be added to the list of passes to execute when the task is disabled (default is false)\r\n     * @returns The render pass created\r\n     */\r\n    public addRenderPass(name: string, whenTaskDisabled = false): FrameGraphRenderPass {\r\n        return this._addPass(name, FrameGraphPassType.Render, whenTaskDisabled) as FrameGraphRenderPass;\r\n    }\r\n\r\n    /**\r\n     * Adds a cull pass to a task. This method can only be called during a Task.record execution.\r\n     * @param name The name of the pass\r\n     * @param whenTaskDisabled If true, the pass will be added to the list of passes to execute when the task is disabled (default is false)\r\n     * @returns The cull pass created\r\n     */\r\n    public addCullPass(name: string, whenTaskDisabled = false): FrameGraphCullPass {\r\n        return this._addPass(name, FrameGraphPassType.Cull, whenTaskDisabled) as FrameGraphCullPass;\r\n    }\r\n\r\n    private _addPass(name: string, passType: FrameGraphPassType, whenTaskDisabled = false): FrameGraphPass<FrameGraphContext> | FrameGraphRenderPass {\r\n        if (!this._currentProcessedTask) {\r\n            throw new Error(\"FrameGraph: A pass must be created during a Task.record execution only.\");\r\n        }\r\n\r\n        let pass: FrameGraphPass<FrameGraphContext> | FrameGraphRenderPass;\r\n\r\n        switch (passType) {\r\n            case FrameGraphPassType.Render:\r\n                pass = new FrameGraphRenderPass(name, this._currentProcessedTask, this._renderContext, this._engine);\r\n                break;\r\n            case FrameGraphPassType.Cull:\r\n                pass = new FrameGraphCullPass(name, this._currentProcessedTask, this._passContext, this._engine);\r\n                break;\r\n            default:\r\n                pass = new FrameGraphPass(name, this._currentProcessedTask, this._passContext);\r\n                break;\r\n        }\r\n\r\n        this._currentProcessedTask._addPass(pass, whenTaskDisabled);\r\n\r\n        return pass;\r\n    }\r\n\r\n    /**\r\n     * Builds the frame graph.\r\n     * This method should be called after all tasks have been added to the frame graph (FrameGraph.addTask) and before the graph is executed (FrameGraph.execute).\r\n     */\r\n    public build(): void {\r\n        this.textureManager._releaseTextures(false);\r\n\r\n        try {\r\n            for (const task of this._tasks) {\r\n                task._reset();\r\n\r\n                this._currentProcessedTask = task;\r\n                this.textureManager._isRecordingTask = true;\r\n\r\n                task.record();\r\n\r\n                this.textureManager._isRecordingTask = false;\r\n                this._currentProcessedTask = null;\r\n            }\r\n\r\n            this.textureManager._allocateTextures(this.optimizeTextureAllocation ? this._tasks : undefined);\r\n\r\n            for (const task of this._tasks) {\r\n                task._checkTask();\r\n            }\r\n\r\n            for (const task of this._tasks) {\r\n                task.onTexturesAllocatedObservable.notifyObservers(this._renderContext);\r\n            }\r\n\r\n            this.onBuildObservable.notifyObservers(this);\r\n        } catch (e) {\r\n            this._tasks.length = 0;\r\n            this._currentProcessedTask = null;\r\n            this.textureManager._isRecordingTask = false;\r\n            throw e;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns a promise that resolves when the frame graph is ready to be executed\r\n     * This method must be called after the graph has been built (FrameGraph.build called)!\r\n     * @param timeStep Time step in ms between retries (default is 16)\r\n     * @param maxTimeout Maximum time in ms to wait for the graph to be ready (default is 30000)\r\n     * @returns The promise that resolves when the graph is ready\r\n     */\r\n    public whenReadyAsync(timeStep = 16, maxTimeout = 30000): Promise<void> {\r\n        let firstNotReadyTask: FrameGraphTask | null = null;\r\n        return new Promise((resolve) => {\r\n            this._whenReadyAsyncCancel = _retryWithInterval(\r\n                () => {\r\n                    let ready = this._renderContext._isReady();\r\n                    for (const task of this._tasks) {\r\n                        const taskIsReady = task.isReady();\r\n                        if (!taskIsReady && !firstNotReadyTask) {\r\n                            firstNotReadyTask = task;\r\n                        }\r\n                        ready &&= taskIsReady;\r\n                    }\r\n                    return ready;\r\n                },\r\n                () => {\r\n                    this._whenReadyAsyncCancel = null;\r\n                    resolve();\r\n                },\r\n                (err, isTimeout) => {\r\n                    this._whenReadyAsyncCancel = null;\r\n                    if (!isTimeout) {\r\n                        Logger.Error(\"FrameGraph: An unexpected error occurred while waiting for the frame graph to be ready.\");\r\n                        if (err) {\r\n                            Logger.Error(err);\r\n                            if (err.stack) {\r\n                                Logger.Error(err.stack);\r\n                            }\r\n                        }\r\n                    } else {\r\n                        Logger.Error(\r\n                            `FrameGraph: Timeout while waiting for the frame graph to be ready.${firstNotReadyTask ? ` First task not ready: ${firstNotReadyTask.name}` : \"\"}`\r\n                        );\r\n                        if (err) {\r\n                            Logger.Error(err);\r\n                        }\r\n                    }\r\n                },\r\n                timeStep,\r\n                maxTimeout\r\n            );\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Executes the frame graph.\r\n     */\r\n    public execute(): void {\r\n        this._renderContext.bindRenderTarget();\r\n\r\n        this.textureManager._updateHistoryTextures();\r\n\r\n        for (const task of this._tasks) {\r\n            const passes = task._getPasses();\r\n\r\n            for (const pass of passes) {\r\n                pass._execute();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clears the frame graph (remove the tasks and release the textures).\r\n     * The frame graph can be built again after this method is called.\r\n     */\r\n    public clear(): void {\r\n        this._whenReadyAsyncCancel?.();\r\n        this._whenReadyAsyncCancel = null;\r\n\r\n        for (const task of this._tasks) {\r\n            task._reset();\r\n        }\r\n\r\n        this._tasks.length = 0;\r\n        this.textureManager._releaseTextures();\r\n        this._currentProcessedTask = null;\r\n    }\r\n\r\n    /**\r\n     * Disposes the frame graph\r\n     */\r\n    public dispose(): void {\r\n        this._whenReadyAsyncCancel?.();\r\n        this._whenReadyAsyncCancel = null;\r\n        this.clear();\r\n        this.textureManager._dispose();\r\n        this._renderContext._dispose();\r\n    }\r\n}\r\n"]}