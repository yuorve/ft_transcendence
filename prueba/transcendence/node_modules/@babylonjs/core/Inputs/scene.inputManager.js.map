{"version":3,"file":"scene.inputManager.js","sourceRoot":"","sources":["../../../../dev/core/src/Inputs/scene.inputManager.ts"],"names":[],"mappings":"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","sourcesContent":["import type { EventState, Observable, Observer } from \"../Misc/observable\";\r\nimport { PointerInfoPre, PointerInfo, PointerEventTypes } from \"../Events/pointerEvents\";\r\nimport type { Nullable } from \"../types\";\r\nimport { AbstractActionManager } from \"../Actions/abstractActionManager\";\r\nimport { PickingInfo } from \"../Collisions/pickingInfo\";\r\nimport { Vector2, Matrix } from \"../Maths/math.vector\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { ActionEvent } from \"../Actions/actionEvent\";\r\nimport { KeyboardEventTypes, KeyboardInfoPre, KeyboardInfo } from \"../Events/keyboardEvents\";\r\nimport { DeviceType, PointerInput } from \"../DeviceInput/InputDevices/deviceEnums\";\r\nimport type { IKeyboardEvent, IMouseEvent, IPointerEvent } from \"../Events/deviceInputEvents\";\r\nimport { DeviceSourceManager } from \"../DeviceInput/InputDevices/deviceSourceManager\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\n\r\nimport type { Scene } from \"../scene\";\r\nimport { _ImportHelper } from \"core/import.helper\";\r\n\r\n/** @internal */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nclass _ClickInfo {\r\n    private _singleClick = false;\r\n    private _doubleClick = false;\r\n    private _hasSwiped = false;\r\n    private _ignore = false;\r\n\r\n    public get singleClick(): boolean {\r\n        return this._singleClick;\r\n    }\r\n    public get doubleClick(): boolean {\r\n        return this._doubleClick;\r\n    }\r\n    public get hasSwiped(): boolean {\r\n        return this._hasSwiped;\r\n    }\r\n    public get ignore(): boolean {\r\n        return this._ignore;\r\n    }\r\n\r\n    public set singleClick(b: boolean) {\r\n        this._singleClick = b;\r\n    }\r\n    public set doubleClick(b: boolean) {\r\n        this._doubleClick = b;\r\n    }\r\n    public set hasSwiped(b: boolean) {\r\n        this._hasSwiped = b;\r\n    }\r\n    public set ignore(b: boolean) {\r\n        this._ignore = b;\r\n    }\r\n}\r\n\r\n/** @internal */\r\ninterface _IClickEvent {\r\n    clickInfo: _ClickInfo;\r\n    evt: IPointerEvent;\r\n    timeoutId: number;\r\n}\r\n\r\n/**\r\n * Class used to manage all inputs for the scene.\r\n */\r\nexport class InputManager {\r\n    /** The distance in pixel that you have to move to prevent some events */\r\n    public static DragMovementThreshold = 10; // in pixels\r\n    /** Time in milliseconds to wait to raise long press events if button is still pressed */\r\n    public static LongPressDelay = 500; // in milliseconds\r\n    /** Time in milliseconds with two consecutive clicks will be considered as a double click */\r\n    public static DoubleClickDelay = 300; // in milliseconds\r\n    /**\r\n     * This flag will modify the behavior so that, when true, a click will happen if and only if\r\n     * another click DOES NOT happen within the DoubleClickDelay time frame.  If another click does\r\n     * happen within that time frame, the first click will not fire an event and and a double click will occur.\r\n     */\r\n    public static ExclusiveDoubleClickMode = false;\r\n\r\n    /** This is a defensive check to not allow control attachment prior to an already active one. If already attached, previous control is unattached before attaching the new one. */\r\n    private _alreadyAttached = false;\r\n    private _alreadyAttachedTo: Nullable<HTMLElement>;\r\n\r\n    // Pointers\r\n    private _onPointerMove: (evt: IMouseEvent) => void;\r\n    private _onPointerDown: (evt: IPointerEvent) => void;\r\n    private _onPointerUp: (evt: IPointerEvent) => void;\r\n\r\n    private _initClickEvent: (\r\n        obs1: Observable<PointerInfoPre>,\r\n        obs2: Observable<PointerInfo>,\r\n        evt: IPointerEvent,\r\n        cb: (clickInfo: _ClickInfo, pickResult: Nullable<PickingInfo>) => void\r\n    ) => void;\r\n    private _initActionManager: (act: Nullable<AbstractActionManager>, clickInfo: _ClickInfo) => Nullable<AbstractActionManager>;\r\n    private _delayedSimpleClick: (btn: number, clickInfo: _ClickInfo, cb: (clickInfo: _ClickInfo, pickResult: Nullable<PickingInfo>) => void) => void;\r\n    private _meshPickProceed = false;\r\n\r\n    private _previousButtonPressed: number;\r\n    private _currentPickResult: Nullable<PickingInfo> = null;\r\n    private _previousPickResult: Nullable<PickingInfo> = null;\r\n\r\n    private _activePointerIds: Array<number> = new Array<number>();\r\n    /** Tracks the count of used slots in _activePointerIds for perf */\r\n    private _activePointerIdsCount: number = 0;\r\n\r\n    private _doubleClickOccured = false;\r\n    private _isSwiping: boolean = false;\r\n    private _swipeButtonPressed: number = -1;\r\n    private _skipPointerTap: boolean = false;\r\n    private _isMultiTouchGesture: boolean = false;\r\n\r\n    private _pointerOverMesh: Nullable<AbstractMesh>;\r\n\r\n    private _pickedDownMesh: Nullable<AbstractMesh>;\r\n    private _pickedUpMesh: Nullable<AbstractMesh>;\r\n\r\n    private _pointerX: number = 0;\r\n    private _pointerY: number = 0;\r\n    private _unTranslatedPointerX: number;\r\n    private _unTranslatedPointerY: number;\r\n    private _startingPointerPosition = new Vector2(0, 0);\r\n    private _previousStartingPointerPosition = new Vector2(0, 0);\r\n    private _startingPointerTime = 0;\r\n    private _previousStartingPointerTime = 0;\r\n    private _pointerCaptures: { [pointerId: number]: boolean } = {};\r\n    private _meshUnderPointerId: { [pointerId: number]: Nullable<AbstractMesh> } = {};\r\n    private _movePointerInfo: Nullable<PointerInfo> = null;\r\n    private _cameraObserverCount = 0;\r\n    private _delayedClicks: Array<Nullable<_IClickEvent>> = [null, null, null, null, null];\r\n\r\n    // Keyboard\r\n    private _onKeyDown: (evt: IKeyboardEvent) => void;\r\n    private _onKeyUp: (evt: IKeyboardEvent) => void;\r\n\r\n    private _scene: Scene;\r\n    private _deviceSourceManager: Nullable<DeviceSourceManager> = null;\r\n\r\n    // origin MouseEvent\r\n    _originMouseEvent: IMouseEvent;\r\n    /**\r\n     * Creates a new InputManager\r\n     * @param scene - defines the hosting scene\r\n     */\r\n    constructor(scene?: Scene) {\r\n        this._scene = scene || <Scene>EngineStore.LastCreatedScene;\r\n        if (!this._scene) {\r\n            return;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the mesh that is currently under the pointer\r\n     * @returns Mesh that the pointer is pointer is hovering over\r\n     */\r\n    public get meshUnderPointer(): Nullable<AbstractMesh> {\r\n        if (this._movePointerInfo) {\r\n            // Because _pointerOverMesh is populated as part of _pickMove, we need to force a pick to update it.\r\n            // Calling _pickMove calls _setCursorAndPointerOverMesh which calls setPointerOverMesh\r\n            this._movePointerInfo._generatePickInfo();\r\n            // Once we have what we need, we can clear _movePointerInfo because we don't need it anymore\r\n            this._movePointerInfo = null;\r\n        }\r\n        return this._pointerOverMesh;\r\n    }\r\n\r\n    /**\r\n     * When using more than one pointer (for example in XR) you can get the mesh under the specific pointer\r\n     * @param pointerId - the pointer id to use\r\n     * @returns The mesh under this pointer id or null if not found\r\n     */\r\n    public getMeshUnderPointerByPointerId(pointerId: number): Nullable<AbstractMesh> {\r\n        return this._meshUnderPointerId[pointerId] || null;\r\n    }\r\n\r\n    /**\r\n     * Gets the pointer coordinates in 2D without any translation (ie. straight out of the pointer event)\r\n     * @returns Vector with X/Y values directly from pointer event\r\n     */\r\n    public get unTranslatedPointer(): Vector2 {\r\n        return new Vector2(this._unTranslatedPointerX, this._unTranslatedPointerY);\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the current on-screen X position of the pointer\r\n     * @returns Translated X with respect to screen\r\n     */\r\n    public get pointerX(): number {\r\n        return this._pointerX;\r\n    }\r\n\r\n    public set pointerX(value: number) {\r\n        this._pointerX = value;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the current on-screen Y position of the pointer\r\n     * @returns Translated Y with respect to screen\r\n     */\r\n    public get pointerY(): number {\r\n        return this._pointerY;\r\n    }\r\n\r\n    public set pointerY(value: number) {\r\n        this._pointerY = value;\r\n    }\r\n\r\n    private _updatePointerPosition(evt: IPointerEvent): void {\r\n        const canvasRect = this._scene.getEngine().getInputElementClientRect();\r\n\r\n        if (!canvasRect) {\r\n            return;\r\n        }\r\n\r\n        this._pointerX = evt.clientX - canvasRect.left;\r\n        this._pointerY = evt.clientY - canvasRect.top;\r\n\r\n        this._unTranslatedPointerX = this._pointerX;\r\n        this._unTranslatedPointerY = this._pointerY;\r\n    }\r\n\r\n    private _processPointerMove(pickResult: Nullable<PickingInfo>, evt: IPointerEvent) {\r\n        const scene = this._scene;\r\n        const engine = scene.getEngine();\r\n        const canvas = engine.getInputElement();\r\n\r\n        if (canvas) {\r\n            canvas.tabIndex = engine.canvasTabIndex;\r\n\r\n            // Restore pointer\r\n            if (!scene.doNotHandleCursors) {\r\n                canvas.style.cursor = scene.defaultCursor;\r\n            }\r\n        }\r\n\r\n        this._setCursorAndPointerOverMesh(pickResult, evt, scene);\r\n\r\n        for (const step of scene._pointerMoveStage) {\r\n            // If _pointerMoveState is defined, we have an active spriteManager and can't use Lazy Picking\r\n            // Therefore, we need to force a pick to update the pickResult\r\n            pickResult = pickResult || this._pickMove(evt);\r\n            const isMeshPicked = pickResult?.pickedMesh ? true : false;\r\n            pickResult = step.action(this._unTranslatedPointerX, this._unTranslatedPointerY, pickResult, isMeshPicked, canvas);\r\n        }\r\n\r\n        const type = evt.inputIndex >= PointerInput.MouseWheelX && evt.inputIndex <= PointerInput.MouseWheelZ ? PointerEventTypes.POINTERWHEEL : PointerEventTypes.POINTERMOVE;\r\n\r\n        if (scene.onPointerMove) {\r\n            // Because of lazy picking, we need to force a pick to update the pickResult\r\n            pickResult = pickResult || this._pickMove(evt);\r\n            scene.onPointerMove(evt, pickResult, type);\r\n        }\r\n\r\n        let pointerInfo: PointerInfo;\r\n        if (pickResult) {\r\n            pointerInfo = new PointerInfo(type, evt, pickResult);\r\n            this._setRayOnPointerInfo(pickResult, evt);\r\n        } else {\r\n            pointerInfo = new PointerInfo(type, evt, null, this);\r\n            this._movePointerInfo = pointerInfo;\r\n        }\r\n\r\n        if (scene.onPointerObservable.hasObservers()) {\r\n            scene.onPointerObservable.notifyObservers(pointerInfo, type);\r\n        }\r\n    }\r\n\r\n    // Pointers handling\r\n    /** @internal */\r\n    public _setRayOnPointerInfo(pickInfo: Nullable<PickingInfo>, event: IMouseEvent) {\r\n        const scene = this._scene;\r\n        if (pickInfo && _ImportHelper._IsPickingAvailable) {\r\n            if (!pickInfo.ray) {\r\n                pickInfo.ray = scene.createPickingRay(event.offsetX, event.offsetY, Matrix.Identity(), scene.activeCamera);\r\n            }\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _addCameraPointerObserver(observer: (p: PointerInfo, s: EventState) => void, mask?: number): Nullable<Observer<PointerInfo>> {\r\n        this._cameraObserverCount++;\r\n        return this._scene.onPointerObservable.add(observer, mask);\r\n    }\r\n\r\n    /** @internal */\r\n    public _removeCameraPointerObserver(observer: Observer<PointerInfo>): boolean {\r\n        this._cameraObserverCount--;\r\n        return this._scene.onPointerObservable.remove(observer);\r\n    }\r\n\r\n    private _checkForPicking(): boolean {\r\n        return !!(this._scene.onPointerObservable.observers.length > this._cameraObserverCount || this._scene.onPointerPick);\r\n    }\r\n\r\n    private _checkPrePointerObservable(pickResult: Nullable<PickingInfo>, evt: IPointerEvent, type: number) {\r\n        const scene = this._scene;\r\n        const pi = new PointerInfoPre(type, evt, this._unTranslatedPointerX, this._unTranslatedPointerY);\r\n        if (pickResult) {\r\n            pi.originalPickingInfo = pickResult;\r\n            pi.ray = pickResult.ray;\r\n            if (evt.pointerType === \"xr-near\" && pickResult.originMesh) {\r\n                pi.nearInteractionPickingInfo = pickResult;\r\n            }\r\n        }\r\n\r\n        scene.onPrePointerObservable.notifyObservers(pi, type);\r\n        if (pi.skipOnPointerObservable) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _pickMove(evt: IPointerEvent): PickingInfo {\r\n        const scene = this._scene;\r\n        const pickResult = scene.pick(\r\n            this._unTranslatedPointerX,\r\n            this._unTranslatedPointerY,\r\n            scene.pointerMovePredicate,\r\n            scene.pointerMoveFastCheck,\r\n            scene.cameraToUseForPointers,\r\n            scene.pointerMoveTrianglePredicate\r\n        );\r\n\r\n        this._setCursorAndPointerOverMesh(pickResult, evt, scene);\r\n\r\n        return pickResult;\r\n    }\r\n\r\n    private _setCursorAndPointerOverMesh(pickResult: Nullable<PickingInfo>, evt: IPointerEvent, scene: Scene) {\r\n        const engine = scene.getEngine();\r\n        const canvas = engine.getInputElement();\r\n\r\n        if (pickResult?.pickedMesh) {\r\n            this.setPointerOverMesh(pickResult.pickedMesh, evt.pointerId, pickResult, evt);\r\n\r\n            if (!scene.doNotHandleCursors && canvas && this._pointerOverMesh) {\r\n                const actionManager = this._pointerOverMesh._getActionManagerForTrigger();\r\n                if (actionManager && actionManager.hasPointerTriggers) {\r\n                    canvas.style.cursor = actionManager.hoverCursor || scene.hoverCursor;\r\n                }\r\n            }\r\n        } else {\r\n            this.setPointerOverMesh(null, evt.pointerId, pickResult, evt);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Use this method to simulate a pointer move on a mesh\r\n     * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay\r\n     * @param pickResult - pickingInfo of the object wished to simulate pointer event on\r\n     * @param pointerEventInit - pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)\r\n     */\r\n    public simulatePointerMove(pickResult: PickingInfo, pointerEventInit?: PointerEventInit): void {\r\n        const evt = new PointerEvent(\"pointermove\", pointerEventInit);\r\n        evt.inputIndex = PointerInput.Move;\r\n\r\n        if (this._checkPrePointerObservable(pickResult, evt, PointerEventTypes.POINTERMOVE)) {\r\n            return;\r\n        }\r\n        this._processPointerMove(pickResult, evt);\r\n    }\r\n\r\n    /**\r\n     * Use this method to simulate a pointer down on a mesh\r\n     * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay\r\n     * @param pickResult - pickingInfo of the object wished to simulate pointer event on\r\n     * @param pointerEventInit - pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)\r\n     */\r\n    public simulatePointerDown(pickResult: PickingInfo, pointerEventInit?: PointerEventInit): void {\r\n        const evt = new PointerEvent(\"pointerdown\", pointerEventInit);\r\n        evt.inputIndex = evt.button + 2;\r\n\r\n        if (this._checkPrePointerObservable(pickResult, evt, PointerEventTypes.POINTERDOWN)) {\r\n            return;\r\n        }\r\n\r\n        this._processPointerDown(pickResult, evt);\r\n    }\r\n\r\n    private _processPointerDown(pickResult: Nullable<PickingInfo>, evt: IPointerEvent): void {\r\n        const scene = this._scene;\r\n        if (pickResult?.pickedMesh) {\r\n            this._pickedDownMesh = pickResult.pickedMesh;\r\n            const actionManager = pickResult.pickedMesh._getActionManagerForTrigger();\r\n            if (actionManager) {\r\n                if (actionManager.hasPickTriggers) {\r\n                    actionManager.processTrigger(Constants.ACTION_OnPickDownTrigger, ActionEvent.CreateNew(pickResult.pickedMesh, evt, pickResult));\r\n                    switch (evt.button) {\r\n                        case 0:\r\n                            actionManager.processTrigger(Constants.ACTION_OnLeftPickTrigger, ActionEvent.CreateNew(pickResult.pickedMesh, evt, pickResult));\r\n                            break;\r\n                        case 1:\r\n                            actionManager.processTrigger(Constants.ACTION_OnCenterPickTrigger, ActionEvent.CreateNew(pickResult.pickedMesh, evt, pickResult));\r\n                            break;\r\n                        case 2:\r\n                            actionManager.processTrigger(Constants.ACTION_OnRightPickTrigger, ActionEvent.CreateNew(pickResult.pickedMesh, evt, pickResult));\r\n                            break;\r\n                    }\r\n                }\r\n\r\n                if (actionManager.hasSpecificTrigger(Constants.ACTION_OnLongPressTrigger)) {\r\n                    window.setTimeout(() => {\r\n                        const pickResult = scene.pick(\r\n                            this._unTranslatedPointerX,\r\n                            this._unTranslatedPointerY,\r\n                            (mesh: AbstractMesh): boolean =>\r\n                                <boolean>(\r\n                                    (mesh.isPickable &&\r\n                                        mesh.isVisible &&\r\n                                        mesh.isReady() &&\r\n                                        mesh.actionManager &&\r\n                                        mesh.actionManager.hasSpecificTrigger(Constants.ACTION_OnLongPressTrigger) &&\r\n                                        mesh === this._pickedDownMesh)\r\n                                ),\r\n                            false,\r\n                            scene.cameraToUseForPointers\r\n                        );\r\n\r\n                        if (pickResult?.pickedMesh && actionManager) {\r\n                            if (this._activePointerIdsCount !== 0 && Date.now() - this._startingPointerTime > InputManager.LongPressDelay && !this._isPointerSwiping()) {\r\n                                this._startingPointerTime = 0;\r\n                                actionManager.processTrigger(Constants.ACTION_OnLongPressTrigger, ActionEvent.CreateNew(pickResult.pickedMesh, evt));\r\n                            }\r\n                        }\r\n                    }, InputManager.LongPressDelay);\r\n                }\r\n            }\r\n        } else {\r\n            for (const step of scene._pointerDownStage) {\r\n                pickResult = step.action(this._unTranslatedPointerX, this._unTranslatedPointerY, pickResult, evt, false);\r\n            }\r\n        }\r\n\r\n        let pointerInfo: PointerInfo;\r\n        const type = PointerEventTypes.POINTERDOWN;\r\n\r\n        if (pickResult) {\r\n            if (scene.onPointerDown) {\r\n                scene.onPointerDown(evt, pickResult, type);\r\n            }\r\n\r\n            pointerInfo = new PointerInfo(type, evt, pickResult);\r\n            this._setRayOnPointerInfo(pickResult, evt);\r\n        } else {\r\n            pointerInfo = new PointerInfo(type, evt, null, this);\r\n        }\r\n\r\n        if (scene.onPointerObservable.hasObservers()) {\r\n            scene.onPointerObservable.notifyObservers(pointerInfo, type);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * @internals Boolean if delta for pointer exceeds drag movement threshold\r\n     */\r\n    public _isPointerSwiping(): boolean {\r\n        return this._isSwiping;\r\n    }\r\n\r\n    /**\r\n     * Use this method to simulate a pointer up on a mesh\r\n     * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay\r\n     * @param pickResult - pickingInfo of the object wished to simulate pointer event on\r\n     * @param pointerEventInit - pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)\r\n     * @param doubleTap - indicates that the pointer up event should be considered as part of a double click (false by default)\r\n     */\r\n    public simulatePointerUp(pickResult: PickingInfo, pointerEventInit?: PointerEventInit, doubleTap?: boolean): void {\r\n        const evt = new PointerEvent(\"pointerup\", pointerEventInit);\r\n        evt.inputIndex = PointerInput.Move;\r\n        const clickInfo = new _ClickInfo();\r\n\r\n        if (doubleTap) {\r\n            clickInfo.doubleClick = true;\r\n        } else {\r\n            clickInfo.singleClick = true;\r\n        }\r\n\r\n        if (this._checkPrePointerObservable(pickResult, evt, PointerEventTypes.POINTERUP)) {\r\n            return;\r\n        }\r\n\r\n        this._processPointerUp(pickResult, evt, clickInfo);\r\n    }\r\n\r\n    private _processPointerUp(pickResult: Nullable<PickingInfo>, evt: IPointerEvent, clickInfo: _ClickInfo): void {\r\n        const scene = this._scene;\r\n        if (pickResult?.pickedMesh) {\r\n            this._pickedUpMesh = pickResult.pickedMesh;\r\n            if (this._pickedDownMesh === this._pickedUpMesh) {\r\n                if (scene.onPointerPick) {\r\n                    scene.onPointerPick(evt, pickResult);\r\n                }\r\n                if (clickInfo.singleClick && !clickInfo.ignore && scene.onPointerObservable.observers.length > this._cameraObserverCount) {\r\n                    const type = PointerEventTypes.POINTERPICK;\r\n                    const pi = new PointerInfo(type, evt, pickResult);\r\n                    this._setRayOnPointerInfo(pickResult, evt);\r\n                    scene.onPointerObservable.notifyObservers(pi, type);\r\n                }\r\n            }\r\n            const actionManager = pickResult.pickedMesh._getActionManagerForTrigger();\r\n            if (actionManager && !clickInfo.ignore) {\r\n                actionManager.processTrigger(Constants.ACTION_OnPickUpTrigger, ActionEvent.CreateNew(pickResult.pickedMesh, evt, pickResult));\r\n\r\n                if (!clickInfo.hasSwiped && clickInfo.singleClick) {\r\n                    actionManager.processTrigger(Constants.ACTION_OnPickTrigger, ActionEvent.CreateNew(pickResult.pickedMesh, evt, pickResult));\r\n                }\r\n\r\n                const doubleClickActionManager = pickResult.pickedMesh._getActionManagerForTrigger(Constants.ACTION_OnDoublePickTrigger);\r\n                if (clickInfo.doubleClick && doubleClickActionManager) {\r\n                    doubleClickActionManager.processTrigger(Constants.ACTION_OnDoublePickTrigger, ActionEvent.CreateNew(pickResult.pickedMesh, evt, pickResult));\r\n                }\r\n            }\r\n        } else {\r\n            if (!clickInfo.ignore) {\r\n                for (const step of scene._pointerUpStage) {\r\n                    pickResult = step.action(this._unTranslatedPointerX, this._unTranslatedPointerY, pickResult, evt, clickInfo.doubleClick);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (this._pickedDownMesh && this._pickedDownMesh !== this._pickedUpMesh) {\r\n            const pickedDownActionManager = this._pickedDownMesh._getActionManagerForTrigger(Constants.ACTION_OnPickOutTrigger);\r\n            if (pickedDownActionManager) {\r\n                pickedDownActionManager.processTrigger(Constants.ACTION_OnPickOutTrigger, ActionEvent.CreateNew(this._pickedDownMesh, evt));\r\n            }\r\n        }\r\n\r\n        if (!clickInfo.ignore) {\r\n            const pi = new PointerInfo(PointerEventTypes.POINTERUP, evt, pickResult);\r\n            // Set ray on picking info.  Note that this info will also be reused for the tap notification.\r\n            this._setRayOnPointerInfo(pickResult, evt);\r\n            scene.onPointerObservable.notifyObservers(pi, PointerEventTypes.POINTERUP);\r\n\r\n            if (scene.onPointerUp) {\r\n                scene.onPointerUp(evt, pickResult, PointerEventTypes.POINTERUP);\r\n            }\r\n\r\n            if (!clickInfo.hasSwiped && !this._skipPointerTap && !this._isMultiTouchGesture) {\r\n                let type = 0;\r\n                if (clickInfo.singleClick) {\r\n                    type = PointerEventTypes.POINTERTAP;\r\n                } else if (clickInfo.doubleClick) {\r\n                    type = PointerEventTypes.POINTERDOUBLETAP;\r\n                }\r\n\r\n                if (type) {\r\n                    const pi = new PointerInfo(type, evt, pickResult);\r\n                    if (scene.onPointerObservable.hasObservers() && scene.onPointerObservable.hasSpecificMask(type)) {\r\n                        scene.onPointerObservable.notifyObservers(pi, type);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if the current pointer event is captured (meaning that the scene has already handled the pointer down)\r\n     * @param pointerId - defines the pointer id to use in a multi-touch scenario (0 by default)\r\n     * @returns true if the pointer was captured\r\n     */\r\n    public isPointerCaptured(pointerId = 0): boolean {\r\n        return this._pointerCaptures[pointerId];\r\n    }\r\n\r\n    /**\r\n     * Attach events to the canvas (To handle actionManagers triggers and raise onPointerMove, onPointerDown and onPointerUp\r\n     * @param attachUp - defines if you want to attach events to pointerup\r\n     * @param attachDown - defines if you want to attach events to pointerdown\r\n     * @param attachMove - defines if you want to attach events to pointermove\r\n     * @param elementToAttachTo - defines the target DOM element to attach to (will use the canvas by default)\r\n     */\r\n    public attachControl(attachUp = true, attachDown = true, attachMove = true, elementToAttachTo: Nullable<HTMLElement> = null): void {\r\n        const scene = this._scene;\r\n        const engine = scene.getEngine();\r\n\r\n        if (!elementToAttachTo) {\r\n            elementToAttachTo = engine.getInputElement();\r\n        }\r\n\r\n        if (this._alreadyAttached) {\r\n            this.detachControl();\r\n        }\r\n\r\n        if (elementToAttachTo) {\r\n            this._alreadyAttachedTo = elementToAttachTo;\r\n        }\r\n        this._deviceSourceManager = new DeviceSourceManager(engine);\r\n\r\n        // Because this is only called from _initClickEvent, which is called in _onPointerUp, we'll use the pointerUpPredicate for the pick call\r\n        this._initActionManager = (act: Nullable<AbstractActionManager>): Nullable<AbstractActionManager> => {\r\n            if (!this._meshPickProceed) {\r\n                const pickResult =\r\n                    scene.skipPointerUpPicking || (scene._registeredActions === 0 && !this._checkForPicking() && !scene.onPointerUp)\r\n                        ? null\r\n                        : scene.pick(\r\n                              this._unTranslatedPointerX,\r\n                              this._unTranslatedPointerY,\r\n                              scene.pointerUpPredicate,\r\n                              scene.pointerUpFastCheck,\r\n                              scene.cameraToUseForPointers,\r\n                              scene.pointerUpTrianglePredicate\r\n                          );\r\n                this._currentPickResult = pickResult;\r\n                if (pickResult) {\r\n                    act = pickResult.hit && pickResult.pickedMesh ? pickResult.pickedMesh._getActionManagerForTrigger() : null;\r\n                }\r\n                this._meshPickProceed = true;\r\n            }\r\n            return act;\r\n        };\r\n\r\n        this._delayedSimpleClick = (btn: number, clickInfo: _ClickInfo, cb: (clickInfo: _ClickInfo, pickResult: Nullable<PickingInfo>) => void) => {\r\n            // double click delay is over and that no double click has been raised since, or the 2 consecutive keys pressed are different\r\n            if ((Date.now() - this._previousStartingPointerTime > InputManager.DoubleClickDelay && !this._doubleClickOccured) || btn !== this._previousButtonPressed) {\r\n                this._doubleClickOccured = false;\r\n                clickInfo.singleClick = true;\r\n                clickInfo.ignore = false;\r\n\r\n                // If we have a delayed click, we need to resolve the TAP event\r\n                if (this._delayedClicks[btn]) {\r\n                    const evt = this._delayedClicks[btn]!.evt;\r\n                    const type = PointerEventTypes.POINTERTAP;\r\n                    const pi = new PointerInfo(type, evt, this._currentPickResult);\r\n                    if (scene.onPointerObservable.hasObservers() && scene.onPointerObservable.hasSpecificMask(type)) {\r\n                        scene.onPointerObservable.notifyObservers(pi, type);\r\n                    }\r\n\r\n                    // Clear the delayed click\r\n                    this._delayedClicks[btn] = null;\r\n                }\r\n            }\r\n        };\r\n\r\n        this._initClickEvent = (\r\n            obs1: Observable<PointerInfoPre>,\r\n            obs2: Observable<PointerInfo>,\r\n            evt: IPointerEvent,\r\n            cb: (clickInfo: _ClickInfo, pickResult: Nullable<PickingInfo>) => void\r\n        ): void => {\r\n            const clickInfo = new _ClickInfo();\r\n            this._currentPickResult = null;\r\n            let act: Nullable<AbstractActionManager> = null;\r\n\r\n            let checkPicking =\r\n                obs1.hasSpecificMask(PointerEventTypes.POINTERPICK) ||\r\n                obs2.hasSpecificMask(PointerEventTypes.POINTERPICK) ||\r\n                obs1.hasSpecificMask(PointerEventTypes.POINTERTAP) ||\r\n                obs2.hasSpecificMask(PointerEventTypes.POINTERTAP) ||\r\n                obs1.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP) ||\r\n                obs2.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP);\r\n            if (!checkPicking && AbstractActionManager) {\r\n                act = this._initActionManager(act, clickInfo);\r\n                if (act) {\r\n                    checkPicking = act.hasPickTriggers;\r\n                }\r\n            }\r\n\r\n            let needToIgnoreNext = false;\r\n\r\n            // Never pick if this is a multi-touch gesture (e.g. pinch)\r\n            checkPicking = checkPicking && !this._isMultiTouchGesture;\r\n\r\n            if (checkPicking) {\r\n                const btn = evt.button;\r\n                clickInfo.hasSwiped = this._isPointerSwiping();\r\n\r\n                if (!clickInfo.hasSwiped) {\r\n                    let checkSingleClickImmediately = !InputManager.ExclusiveDoubleClickMode;\r\n\r\n                    if (!checkSingleClickImmediately) {\r\n                        checkSingleClickImmediately = !obs1.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP) && !obs2.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP);\r\n\r\n                        if (checkSingleClickImmediately && !AbstractActionManager.HasSpecificTrigger(Constants.ACTION_OnDoublePickTrigger)) {\r\n                            act = this._initActionManager(act, clickInfo);\r\n                            if (act) {\r\n                                checkSingleClickImmediately = !act.hasSpecificTrigger(Constants.ACTION_OnDoublePickTrigger);\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    if (checkSingleClickImmediately) {\r\n                        // single click detected if double click delay is over or two different successive keys pressed without exclusive double click or no double click required\r\n                        if (Date.now() - this._previousStartingPointerTime > InputManager.DoubleClickDelay || btn !== this._previousButtonPressed) {\r\n                            clickInfo.singleClick = true;\r\n                            cb(clickInfo, this._currentPickResult);\r\n                            needToIgnoreNext = true;\r\n                        }\r\n                    }\r\n                    // at least one double click is required to be check and exclusive double click is enabled\r\n                    else {\r\n                        // Queue up a delayed click, just in case this isn't a double click\r\n                        // It should be noted that while this delayed event happens\r\n                        // because of user input, it shouldn't be considered as a direct,\r\n                        // timing-dependent result of that input.  It's meant to just fire the TAP event\r\n                        const delayedClick = {\r\n                            evt: evt,\r\n                            clickInfo: clickInfo,\r\n                            timeoutId: window.setTimeout(this._delayedSimpleClick.bind(this, btn, clickInfo, cb), InputManager.DoubleClickDelay),\r\n                        };\r\n\r\n                        this._delayedClicks[btn] = delayedClick;\r\n                    }\r\n\r\n                    let checkDoubleClick = obs1.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP) || obs2.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP);\r\n                    if (!checkDoubleClick && AbstractActionManager.HasSpecificTrigger(Constants.ACTION_OnDoublePickTrigger)) {\r\n                        act = this._initActionManager(act, clickInfo);\r\n                        if (act) {\r\n                            checkDoubleClick = act.hasSpecificTrigger(Constants.ACTION_OnDoublePickTrigger);\r\n                        }\r\n                    }\r\n                    if (checkDoubleClick) {\r\n                        // two successive keys pressed are equal, double click delay is not over and double click has not just occurred\r\n                        if (btn === this._previousButtonPressed && Date.now() - this._previousStartingPointerTime < InputManager.DoubleClickDelay && !this._doubleClickOccured) {\r\n                            // pointer has not moved for 2 clicks, it's a double click\r\n                            if (!clickInfo.hasSwiped && !this._isPointerSwiping()) {\r\n                                this._previousStartingPointerTime = 0;\r\n                                this._doubleClickOccured = true;\r\n                                clickInfo.doubleClick = true;\r\n                                clickInfo.ignore = false;\r\n                                // If we have a pending click, we need to cancel it\r\n                                if (InputManager.ExclusiveDoubleClickMode && this._delayedClicks[btn]) {\r\n                                    clearTimeout(this._delayedClicks[btn]?.timeoutId);\r\n                                    this._delayedClicks[btn] = null;\r\n                                }\r\n\r\n                                cb(clickInfo, this._currentPickResult);\r\n                            }\r\n                            // if the two successive clicks are too far, it's just two simple clicks\r\n                            else {\r\n                                this._doubleClickOccured = false;\r\n                                this._previousStartingPointerTime = this._startingPointerTime;\r\n                                this._previousStartingPointerPosition.x = this._startingPointerPosition.x;\r\n                                this._previousStartingPointerPosition.y = this._startingPointerPosition.y;\r\n                                this._previousButtonPressed = btn;\r\n                                if (InputManager.ExclusiveDoubleClickMode) {\r\n                                    // If we have a delayed click, we need to cancel it\r\n                                    if (this._delayedClicks[btn]) {\r\n                                        clearTimeout(this._delayedClicks[btn]?.timeoutId);\r\n                                        this._delayedClicks[btn] = null;\r\n                                    }\r\n                                    cb(clickInfo, this._previousPickResult);\r\n                                } else {\r\n                                    cb(clickInfo, this._currentPickResult);\r\n                                }\r\n                            }\r\n                            needToIgnoreNext = true;\r\n                        }\r\n                        // just the first click of the double has been raised\r\n                        else {\r\n                            this._doubleClickOccured = false;\r\n                            this._previousStartingPointerTime = this._startingPointerTime;\r\n                            this._previousStartingPointerPosition.x = this._startingPointerPosition.x;\r\n                            this._previousStartingPointerPosition.y = this._startingPointerPosition.y;\r\n                            this._previousButtonPressed = btn!;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Even if ExclusiveDoubleClickMode is true, we need to always handle\r\n            // up events at time of execution, unless we're explicitly ignoring them.\r\n            if (!needToIgnoreNext) {\r\n                cb(clickInfo, this._currentPickResult);\r\n            }\r\n        };\r\n\r\n        this._onPointerMove = (evt: IMouseEvent) => {\r\n            this._updatePointerPosition(evt as IPointerEvent);\r\n\r\n            // Check if pointer leaves DragMovementThreshold range to determine if swipe is occurring\r\n            if (!this._isSwiping && this._swipeButtonPressed !== -1) {\r\n                this._isSwiping =\r\n                    Math.abs(this._startingPointerPosition.x - this._pointerX) > InputManager.DragMovementThreshold ||\r\n                    Math.abs(this._startingPointerPosition.y - this._pointerY) > InputManager.DragMovementThreshold;\r\n            }\r\n\r\n            // Because there's a race condition between pointermove and pointerlockchange events, we need to\r\n            // verify that the pointer is still locked after each pointermove event.\r\n            if (engine.isPointerLock) {\r\n                engine._verifyPointerLock();\r\n            }\r\n\r\n            // PreObservable support\r\n            if (\r\n                this._checkPrePointerObservable(\r\n                    null,\r\n                    evt as IPointerEvent,\r\n                    evt.inputIndex >= PointerInput.MouseWheelX && evt.inputIndex <= PointerInput.MouseWheelZ ? PointerEventTypes.POINTERWHEEL : PointerEventTypes.POINTERMOVE\r\n                )\r\n            ) {\r\n                return;\r\n            }\r\n\r\n            if (!scene.cameraToUseForPointers && !scene.activeCamera) {\r\n                return;\r\n            }\r\n\r\n            if (scene.skipPointerMovePicking) {\r\n                this._processPointerMove(new PickingInfo(), evt as IPointerEvent);\r\n                return;\r\n            }\r\n\r\n            if (!scene.pointerMovePredicate) {\r\n                scene.pointerMovePredicate = (mesh: AbstractMesh): boolean =>\r\n                    mesh.isPickable &&\r\n                    mesh.isVisible &&\r\n                    mesh.isReady() &&\r\n                    mesh.isEnabled() &&\r\n                    (mesh.enablePointerMoveEvents || scene.constantlyUpdateMeshUnderPointer || mesh._getActionManagerForTrigger() !== null) &&\r\n                    (!scene.cameraToUseForPointers || (scene.cameraToUseForPointers.layerMask & mesh.layerMask) !== 0);\r\n            }\r\n\r\n            const pickResult = scene._registeredActions > 0 || scene.constantlyUpdateMeshUnderPointer ? this._pickMove(evt as IPointerEvent) : null;\r\n            this._processPointerMove(pickResult, evt as IPointerEvent);\r\n        };\r\n\r\n        this._onPointerDown = (evt: IPointerEvent) => {\r\n            const freeIndex = this._activePointerIds.indexOf(-1);\r\n            if (freeIndex === -1) {\r\n                this._activePointerIds.push(evt.pointerId);\r\n            } else {\r\n                this._activePointerIds[freeIndex] = evt.pointerId;\r\n            }\r\n            this._activePointerIdsCount++;\r\n            this._pickedDownMesh = null;\r\n            this._meshPickProceed = false;\r\n\r\n            // If ExclusiveDoubleClickMode is true, we need to resolve any pending delayed clicks\r\n            if (InputManager.ExclusiveDoubleClickMode) {\r\n                for (let i = 0; i < this._delayedClicks.length; i++) {\r\n                    if (this._delayedClicks[i]) {\r\n                        // If the button that was pressed is the same as the one that was released,\r\n                        // just clear the timer.  This will be resolved in the up event.\r\n                        if (evt.button === i) {\r\n                            clearTimeout(this._delayedClicks[i]?.timeoutId);\r\n                        } else {\r\n                            // Otherwise, we need to resolve the click\r\n                            const clickInfo = this._delayedClicks[i]!.clickInfo;\r\n                            this._doubleClickOccured = false;\r\n                            clickInfo.singleClick = true;\r\n                            clickInfo.ignore = false;\r\n\r\n                            const prevEvt = this._delayedClicks[i]!.evt;\r\n                            const type = PointerEventTypes.POINTERTAP;\r\n                            const pi = new PointerInfo(type, prevEvt, this._currentPickResult);\r\n                            if (scene.onPointerObservable.hasObservers() && scene.onPointerObservable.hasSpecificMask(type)) {\r\n                                scene.onPointerObservable.notifyObservers(pi, type);\r\n                            }\r\n\r\n                            // Clear the delayed click\r\n                            this._delayedClicks[i] = null;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            this._updatePointerPosition(evt);\r\n\r\n            if (this._swipeButtonPressed === -1) {\r\n                this._swipeButtonPressed = evt.button;\r\n            }\r\n\r\n            if (scene.preventDefaultOnPointerDown && elementToAttachTo) {\r\n                evt.preventDefault();\r\n                elementToAttachTo.focus();\r\n            }\r\n\r\n            this._startingPointerPosition.x = this._pointerX;\r\n            this._startingPointerPosition.y = this._pointerY;\r\n            this._startingPointerTime = Date.now();\r\n\r\n            // PreObservable support\r\n            if (this._checkPrePointerObservable(null, evt, PointerEventTypes.POINTERDOWN)) {\r\n                return;\r\n            }\r\n\r\n            if (!scene.cameraToUseForPointers && !scene.activeCamera) {\r\n                return;\r\n            }\r\n\r\n            this._pointerCaptures[evt.pointerId] = true;\r\n\r\n            if (!scene.pointerDownPredicate) {\r\n                scene.pointerDownPredicate = (mesh: AbstractMesh): boolean => {\r\n                    return (\r\n                        mesh.isPickable &&\r\n                        mesh.isVisible &&\r\n                        mesh.isReady() &&\r\n                        mesh.isEnabled() &&\r\n                        (!scene.cameraToUseForPointers || (scene.cameraToUseForPointers.layerMask & mesh.layerMask) !== 0)\r\n                    );\r\n                };\r\n            }\r\n\r\n            // Meshes\r\n            this._pickedDownMesh = null;\r\n            let pickResult;\r\n            if (scene.skipPointerDownPicking || (scene._registeredActions === 0 && !this._checkForPicking() && !scene.onPointerDown)) {\r\n                pickResult = new PickingInfo();\r\n            } else {\r\n                pickResult = scene.pick(\r\n                    this._unTranslatedPointerX,\r\n                    this._unTranslatedPointerY,\r\n                    scene.pointerDownPredicate,\r\n                    scene.pointerDownFastCheck,\r\n                    scene.cameraToUseForPointers,\r\n                    scene.pointerDownTrianglePredicate\r\n                );\r\n            }\r\n\r\n            this._processPointerDown(pickResult, evt);\r\n        };\r\n\r\n        this._onPointerUp = (evt: IPointerEvent) => {\r\n            const pointerIdIndex = this._activePointerIds.indexOf(evt.pointerId);\r\n            if (pointerIdIndex === -1) {\r\n                // We are attaching the pointer up to windows because of a bug in FF\r\n                // If this pointerId is not paired with an _onPointerDown call, ignore it\r\n                return;\r\n            }\r\n\r\n            this._activePointerIds[pointerIdIndex] = -1;\r\n            this._activePointerIdsCount--;\r\n            this._pickedUpMesh = null;\r\n            this._meshPickProceed = false;\r\n\r\n            this._updatePointerPosition(evt);\r\n\r\n            if (scene.preventDefaultOnPointerUp && elementToAttachTo) {\r\n                evt.preventDefault();\r\n                elementToAttachTo.focus();\r\n            }\r\n\r\n            this._initClickEvent(scene.onPrePointerObservable, scene.onPointerObservable, evt, (clickInfo: _ClickInfo, pickResult: Nullable<PickingInfo>) => {\r\n                // PreObservable support\r\n                if (scene.onPrePointerObservable.hasObservers()) {\r\n                    this._skipPointerTap = false;\r\n                    if (!clickInfo.ignore) {\r\n                        if (this._checkPrePointerObservable(null, evt, PointerEventTypes.POINTERUP)) {\r\n                            // If we're skipping the next observable, we need to reset the swipe state before returning\r\n                            if (this._swipeButtonPressed === evt.button) {\r\n                                this._isSwiping = false;\r\n                                this._swipeButtonPressed = -1;\r\n                            }\r\n\r\n                            // If we're going to skip the POINTERUP, we need to reset the pointer capture\r\n                            if (evt.buttons === 0) {\r\n                                this._pointerCaptures[evt.pointerId] = false;\r\n                            }\r\n\r\n                            return;\r\n                        }\r\n                        if (!clickInfo.hasSwiped) {\r\n                            if (clickInfo.singleClick && scene.onPrePointerObservable.hasSpecificMask(PointerEventTypes.POINTERTAP)) {\r\n                                if (this._checkPrePointerObservable(null, evt, PointerEventTypes.POINTERTAP)) {\r\n                                    this._skipPointerTap = true;\r\n                                }\r\n                            }\r\n                            if (clickInfo.doubleClick && scene.onPrePointerObservable.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP)) {\r\n                                if (this._checkPrePointerObservable(null, evt, PointerEventTypes.POINTERDOUBLETAP)) {\r\n                                    this._skipPointerTap = true;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // There should be a pointer captured at this point so if there isn't we should reset and return\r\n                if (!this._pointerCaptures[evt.pointerId]) {\r\n                    if (this._swipeButtonPressed === evt.button) {\r\n                        this._isSwiping = false;\r\n                        this._swipeButtonPressed = -1;\r\n                    }\r\n                    return;\r\n                }\r\n\r\n                // Only release capture if all buttons are released\r\n                if (evt.buttons === 0) {\r\n                    this._pointerCaptures[evt.pointerId] = false;\r\n                }\r\n                if (!scene.cameraToUseForPointers && !scene.activeCamera) {\r\n                    return;\r\n                }\r\n\r\n                if (!scene.pointerUpPredicate) {\r\n                    scene.pointerUpPredicate = (mesh: AbstractMesh): boolean => {\r\n                        return (\r\n                            mesh.isPickable &&\r\n                            mesh.isVisible &&\r\n                            mesh.isReady() &&\r\n                            mesh.isEnabled() &&\r\n                            (!scene.cameraToUseForPointers || (scene.cameraToUseForPointers.layerMask & mesh.layerMask) !== 0)\r\n                        );\r\n                    };\r\n                }\r\n\r\n                // Meshes\r\n                if (!this._meshPickProceed && ((AbstractActionManager && AbstractActionManager.HasTriggers) || this._checkForPicking() || scene.onPointerUp)) {\r\n                    this._initActionManager(null, clickInfo);\r\n                }\r\n                if (!pickResult) {\r\n                    pickResult = this._currentPickResult;\r\n                }\r\n\r\n                this._processPointerUp(pickResult, evt, clickInfo);\r\n\r\n                this._previousPickResult = this._currentPickResult;\r\n\r\n                if (this._swipeButtonPressed === evt.button) {\r\n                    this._isSwiping = false;\r\n                    this._swipeButtonPressed = -1;\r\n                }\r\n            });\r\n        };\r\n\r\n        this._onKeyDown = (evt: IKeyboardEvent) => {\r\n            const type = KeyboardEventTypes.KEYDOWN;\r\n            if (scene.onPreKeyboardObservable.hasObservers()) {\r\n                const pi = new KeyboardInfoPre(type, evt);\r\n                scene.onPreKeyboardObservable.notifyObservers(pi, type);\r\n                if (pi.skipOnKeyboardObservable) {\r\n                    return;\r\n                }\r\n            }\r\n\r\n            if (scene.onKeyboardObservable.hasObservers()) {\r\n                const pi = new KeyboardInfo(type, evt);\r\n                scene.onKeyboardObservable.notifyObservers(pi, type);\r\n            }\r\n\r\n            if (scene.actionManager) {\r\n                scene.actionManager.processTrigger(Constants.ACTION_OnKeyDownTrigger, ActionEvent.CreateNewFromScene(scene, evt));\r\n            }\r\n        };\r\n\r\n        this._onKeyUp = (evt: IKeyboardEvent) => {\r\n            const type = KeyboardEventTypes.KEYUP;\r\n            if (scene.onPreKeyboardObservable.hasObservers()) {\r\n                const pi = new KeyboardInfoPre(type, evt);\r\n                scene.onPreKeyboardObservable.notifyObservers(pi, type);\r\n                if (pi.skipOnKeyboardObservable) {\r\n                    return;\r\n                }\r\n            }\r\n\r\n            if (scene.onKeyboardObservable.hasObservers()) {\r\n                const pi = new KeyboardInfo(type, evt);\r\n                scene.onKeyboardObservable.notifyObservers(pi, type);\r\n            }\r\n\r\n            if (scene.actionManager) {\r\n                scene.actionManager.processTrigger(Constants.ACTION_OnKeyUpTrigger, ActionEvent.CreateNewFromScene(scene, evt));\r\n            }\r\n        };\r\n\r\n        // If a device connects that we can handle, wire up the observable\r\n        this._deviceSourceManager.onDeviceConnectedObservable.add((deviceSource) => {\r\n            if (deviceSource.deviceType === DeviceType.Mouse) {\r\n                deviceSource.onInputChangedObservable.add((eventData) => {\r\n                    this._originMouseEvent = eventData;\r\n                    if (\r\n                        eventData.inputIndex === PointerInput.LeftClick ||\r\n                        eventData.inputIndex === PointerInput.MiddleClick ||\r\n                        eventData.inputIndex === PointerInput.RightClick ||\r\n                        eventData.inputIndex === PointerInput.BrowserBack ||\r\n                        eventData.inputIndex === PointerInput.BrowserForward\r\n                    ) {\r\n                        if (attachDown && deviceSource.getInput(eventData.inputIndex) === 1) {\r\n                            this._onPointerDown(eventData);\r\n                        } else if (attachUp && deviceSource.getInput(eventData.inputIndex) === 0) {\r\n                            this._onPointerUp(eventData);\r\n                        }\r\n                    } else if (attachMove) {\r\n                        if (eventData.inputIndex === PointerInput.Move) {\r\n                            this._onPointerMove(eventData);\r\n                        } else if (\r\n                            eventData.inputIndex === PointerInput.MouseWheelX ||\r\n                            eventData.inputIndex === PointerInput.MouseWheelY ||\r\n                            eventData.inputIndex === PointerInput.MouseWheelZ\r\n                        ) {\r\n                            this._onPointerMove(eventData);\r\n                        }\r\n                    }\r\n                });\r\n            } else if (deviceSource.deviceType === DeviceType.Touch) {\r\n                deviceSource.onInputChangedObservable.add((eventData) => {\r\n                    if (eventData.inputIndex === PointerInput.LeftClick) {\r\n                        if (attachDown && deviceSource.getInput(eventData.inputIndex) === 1) {\r\n                            this._onPointerDown(eventData);\r\n                            if (this._activePointerIdsCount > 1) {\r\n                                this._isMultiTouchGesture = true;\r\n                            }\r\n                        } else if (attachUp && deviceSource.getInput(eventData.inputIndex) === 0) {\r\n                            this._onPointerUp(eventData);\r\n                            if (this._activePointerIdsCount === 0) {\r\n                                this._isMultiTouchGesture = false;\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    if (attachMove && eventData.inputIndex === PointerInput.Move) {\r\n                        this._onPointerMove(eventData);\r\n                    }\r\n                });\r\n            } else if (deviceSource.deviceType === DeviceType.Keyboard) {\r\n                deviceSource.onInputChangedObservable.add((eventData) => {\r\n                    if (eventData.type === \"keydown\") {\r\n                        this._onKeyDown(eventData);\r\n                    } else if (eventData.type === \"keyup\") {\r\n                        this._onKeyUp(eventData);\r\n                    }\r\n                });\r\n            }\r\n        });\r\n\r\n        this._alreadyAttached = true;\r\n    }\r\n\r\n    /**\r\n     * Detaches all event handlers\r\n     */\r\n    public detachControl() {\r\n        if (this._alreadyAttached) {\r\n            this._deviceSourceManager!.dispose();\r\n            this._deviceSourceManager = null;\r\n\r\n            // Cursor\r\n            if (this._alreadyAttachedTo && !this._scene.doNotHandleCursors) {\r\n                this._alreadyAttachedTo.style.cursor = this._scene.defaultCursor;\r\n            }\r\n\r\n            this._alreadyAttached = false;\r\n            this._alreadyAttachedTo = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the value of meshUnderPointer for a given pointerId\r\n     * @param mesh - defines the mesh to use\r\n     * @param pointerId - optional pointer id when using more than one pointer. Defaults to 0\r\n     * @param pickResult - optional pickingInfo data used to find mesh\r\n     * @param evt - optional pointer event\r\n     */\r\n    public setPointerOverMesh(mesh: Nullable<AbstractMesh>, pointerId: number = 0, pickResult?: Nullable<PickingInfo>, evt?: IPointerEvent): void {\r\n        if (this._meshUnderPointerId[pointerId] === mesh && (!mesh || !mesh._internalAbstractMeshDataInfo._pointerOverDisableMeshTesting)) {\r\n            return;\r\n        }\r\n\r\n        const underPointerMesh = this._meshUnderPointerId[pointerId];\r\n\r\n        let actionManager: Nullable<AbstractActionManager>;\r\n        if (underPointerMesh) {\r\n            actionManager = underPointerMesh._getActionManagerForTrigger(Constants.ACTION_OnPointerOutTrigger);\r\n            if (actionManager) {\r\n                actionManager.processTrigger(Constants.ACTION_OnPointerOutTrigger, new ActionEvent(underPointerMesh, this._pointerX, this._pointerY, mesh, evt, { pointerId }));\r\n            }\r\n        }\r\n\r\n        if (mesh) {\r\n            this._meshUnderPointerId[pointerId] = mesh;\r\n            this._pointerOverMesh = mesh;\r\n\r\n            actionManager = mesh._getActionManagerForTrigger(Constants.ACTION_OnPointerOverTrigger);\r\n            if (actionManager) {\r\n                actionManager.processTrigger(Constants.ACTION_OnPointerOverTrigger, new ActionEvent(mesh, this._pointerX, this._pointerY, mesh, evt, { pointerId, pickResult }));\r\n            }\r\n        } else {\r\n            delete this._meshUnderPointerId[pointerId];\r\n            this._pointerOverMesh = null;\r\n        }\r\n        // if we reached this point, meshUnderPointerId has been updated. We need to notify observers that are registered.\r\n        if (this._scene.onMeshUnderPointerUpdatedObservable.hasObservers()) {\r\n            this._scene.onMeshUnderPointerUpdatedObservable.notifyObservers({\r\n                mesh,\r\n                pointerId,\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the mesh under the pointer\r\n     * @returns a Mesh or null if no mesh is under the pointer\r\n     */\r\n    public getPointerOverMesh(): Nullable<AbstractMesh> {\r\n        return this.meshUnderPointer;\r\n    }\r\n\r\n    /**\r\n     * @param mesh - Mesh to invalidate\r\n     * @internal\r\n     */\r\n    public _invalidateMesh(mesh: AbstractMesh) {\r\n        if (this._pointerOverMesh === mesh) {\r\n            this._pointerOverMesh = null;\r\n        }\r\n        if (this._pickedDownMesh === mesh) {\r\n            this._pickedDownMesh = null;\r\n        }\r\n        if (this._pickedUpMesh === mesh) {\r\n            this._pickedUpMesh = null;\r\n        }\r\n        for (const pointerId in this._meshUnderPointerId) {\r\n            if (this._meshUnderPointerId[pointerId] === mesh) {\r\n                delete this._meshUnderPointerId[pointerId];\r\n            }\r\n        }\r\n    }\r\n}\r\n"]}