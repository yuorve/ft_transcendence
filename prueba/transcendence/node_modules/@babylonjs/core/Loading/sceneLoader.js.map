{"version":3,"file":"sceneLoader.js","sourceRoot":"","sources":["../../../../dev/core/src/Loading/sceneLoader.ts"],"names":[],"mappings":"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","sourcesContent":["import { Tools } from \"../Misc/tools\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { Nullable } from \"../types\";\r\nimport { Scene } from \"../scene\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { AnimationGroup } from \"../Animations/animationGroup\";\r\nimport type { AssetContainer } from \"../assetContainer\";\r\nimport type { IParticleSystem } from \"../Particles/IParticleSystem\";\r\nimport type { Skeleton } from \"../Bones/skeleton\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { SceneLoaderFlags } from \"./sceneLoaderFlags\";\r\nimport type { IFileRequest } from \"../Misc/fileRequest\";\r\nimport type { WebRequest } from \"../Misc/webRequest\";\r\nimport type { LoadFileError } from \"../Misc/fileTools\";\r\nimport { IsBase64DataUrl } from \"../Misc/fileTools\";\r\nimport type { TransformNode } from \"../Meshes/transformNode\";\r\nimport type { Geometry } from \"../Meshes/geometry\";\r\nimport type { Light } from \"../Lights/light\";\r\nimport { RuntimeError, ErrorCodes } from \"../Misc/error\";\r\nimport type { ISpriteManager } from \"../Sprites/spriteManager\";\r\nimport { RandomGUID } from \"../Misc/guid\";\r\nimport { AbstractEngine } from \"../Engines/abstractEngine\";\r\nimport { _FetchAsync } from \"core/Misc/webRequest.fetch\";\r\n\r\n/**\r\n * Type used for the success callback of ImportMesh\r\n */\r\nexport type SceneLoaderSuccessCallback = (\r\n    meshes: AbstractMesh[],\r\n    particleSystems: IParticleSystem[],\r\n    skeletons: Skeleton[],\r\n    animationGroups: AnimationGroup[],\r\n    transformNodes: TransformNode[],\r\n    geometries: Geometry[],\r\n    lights: Light[],\r\n    spriteManagers: ISpriteManager[]\r\n) => void;\r\n\r\n/**\r\n * Interface used for the result of ImportMeshAsync\r\n */\r\nexport interface ISceneLoaderAsyncResult {\r\n    /**\r\n     * The array of loaded meshes\r\n     */\r\n    readonly meshes: AbstractMesh[];\r\n\r\n    /**\r\n     * The array of loaded particle systems\r\n     */\r\n    readonly particleSystems: IParticleSystem[];\r\n\r\n    /**\r\n     * The array of loaded skeletons\r\n     */\r\n    readonly skeletons: Skeleton[];\r\n\r\n    /**\r\n     * The array of loaded animation groups\r\n     */\r\n    readonly animationGroups: AnimationGroup[];\r\n\r\n    /**\r\n     * The array of loaded transform nodes\r\n     */\r\n    readonly transformNodes: TransformNode[];\r\n\r\n    /**\r\n     * The array of loaded geometries\r\n     */\r\n    readonly geometries: Geometry[];\r\n\r\n    /**\r\n     * The array of loaded lights\r\n     */\r\n    readonly lights: Light[];\r\n\r\n    /**\r\n     * The array of loaded sprite managers\r\n     */\r\n    readonly spriteManagers: ISpriteManager[];\r\n}\r\n\r\n/**\r\n * Interface used to represent data loading progression\r\n */\r\nexport interface ISceneLoaderProgressEvent {\r\n    /**\r\n     * Defines if data length to load can be evaluated\r\n     */\r\n    readonly lengthComputable: boolean;\r\n\r\n    /**\r\n     * Defines the loaded data length\r\n     */\r\n    readonly loaded: number;\r\n\r\n    /**\r\n     * Defines the data length to load\r\n     */\r\n    readonly total: number;\r\n}\r\n\r\n/**\r\n * Interface used by SceneLoader plugins to define supported file extensions\r\n */\r\nexport interface ISceneLoaderPluginExtensions {\r\n    /**\r\n     * Defines the list of supported extensions\r\n     */\r\n    readonly [extension: string]: {\r\n        readonly isBinary: boolean;\r\n        readonly mimeType?: string;\r\n    };\r\n}\r\n\r\n/**\r\n * Metadata for a SceneLoader plugin that must also be provided by a plugin factory\r\n */\r\nexport interface ISceneLoaderPluginMetadata {\r\n    /**\r\n     * The friendly name of the plugin.\r\n     */\r\n    readonly name: string;\r\n\r\n    /**\r\n     * The file extensions supported by the plugin.\r\n     */\r\n    readonly extensions: string | ISceneLoaderPluginExtensions;\r\n\r\n    /**\r\n     * The callback that returns true if the data can be directly loaded.\r\n     * @param data string containing the file data\r\n     * @returns if the data can be loaded directly\r\n     */\r\n    canDirectLoad?(data: string): boolean;\r\n}\r\n\r\n/**\r\n * Interface used by SceneLoader plugin factory\r\n */\r\nexport interface ISceneLoaderPluginFactory extends ISceneLoaderPluginMetadata {\r\n    /**\r\n     * Function called to create a new plugin\r\n     * @param options plugin options that were passed to the SceneLoader operation\r\n     * @returns the new plugin\r\n     */\r\n    createPlugin(options: SceneLoaderPluginOptions): ISceneLoaderPlugin | ISceneLoaderPluginAsync | Promise<ISceneLoaderPlugin | ISceneLoaderPluginAsync>;\r\n}\r\n\r\n/**\r\n * Interface used to define the base of ISceneLoaderPlugin and ISceneLoaderPluginAsync\r\n */\r\nexport interface ISceneLoaderPluginBase extends ISceneLoaderPluginMetadata {\r\n    /**\r\n     * The callback called when loading from a url.\r\n     * @param scene scene loading this url\r\n     * @param fileOrUrl file or url to load\r\n     * @param rootUrl root url to use to load assets\r\n     * @param onSuccess callback called when the file successfully loads\r\n     * @param onProgress callback called while file is loading (if the server supports this mode)\r\n     * @param useArrayBuffer defines a boolean indicating that date must be returned as ArrayBuffer\r\n     * @param onError callback called when the file fails to load\r\n     * @param name defines the name of the file when loading a binary file\r\n     * @returns a file request object\r\n     */\r\n    loadFile?(\r\n        scene: Scene,\r\n        fileOrUrl: File | string | ArrayBufferView,\r\n        rootUrl: string,\r\n        onSuccess: (data: unknown, responseURL?: string) => void,\r\n        onProgress?: (ev: ISceneLoaderProgressEvent) => void,\r\n        useArrayBuffer?: boolean,\r\n        onError?: (request?: WebRequest, exception?: LoadFileError) => void,\r\n        name?: string\r\n    ): Nullable<IFileRequest>;\r\n\r\n    /**\r\n     * The callback that returns the data to pass to the plugin if the data can be directly loaded.\r\n     * @param scene scene loading this data\r\n     * @param data string containing the data\r\n     * @returns data to pass to the plugin\r\n     */\r\n    directLoad?(scene: Scene, data: string): unknown | Promise<unknown>;\r\n\r\n    /**\r\n     * The callback that allows custom handling of the root url based on the response url.\r\n     * @param rootUrl the original root url\r\n     * @param responseURL the response url if available\r\n     * @returns the new root url\r\n     */\r\n    rewriteRootURL?(rootUrl: string, responseURL?: string): string;\r\n}\r\n\r\n/**\r\n * Interface used to define a SceneLoader plugin\r\n */\r\nexport interface ISceneLoaderPlugin extends ISceneLoaderPluginBase {\r\n    /**\r\n     * Import meshes into a scene.\r\n     * @param meshesNames An array of mesh names, a single mesh name, or empty string for all meshes that filter what meshes are imported\r\n     * @param scene The scene to import into\r\n     * @param data The data to import\r\n     * @param rootUrl The root url for scene and resources\r\n     * @param meshes The meshes array to import into\r\n     * @param particleSystems The particle systems array to import into\r\n     * @param skeletons The skeletons array to import into\r\n     * @param onError The callback when import fails\r\n     * @returns True if successful or false otherwise\r\n     */\r\n    importMesh(\r\n        meshesNames: string | readonly string[] | null | undefined,\r\n        scene: Scene,\r\n        data: unknown,\r\n        rootUrl: string,\r\n        meshes: AbstractMesh[],\r\n        particleSystems: IParticleSystem[],\r\n        skeletons: Skeleton[],\r\n        onError?: (message: string, exception?: any) => void\r\n    ): boolean;\r\n\r\n    /**\r\n     * Load into a scene.\r\n     * @param scene The scene to load into\r\n     * @param data The data to import\r\n     * @param rootUrl The root url for scene and resources\r\n     * @param onError The callback when import fails\r\n     * @returns True if successful or false otherwise\r\n     */\r\n    load(scene: Scene, data: unknown, rootUrl: string, onError?: (message: string, exception?: any) => void): boolean;\r\n\r\n    /**\r\n     * Load into an asset container.\r\n     * @param scene The scene to load into\r\n     * @param data The data to import\r\n     * @param rootUrl The root url for scene and resources\r\n     * @param onError The callback when import fails\r\n     * @returns The loaded asset container\r\n     */\r\n    loadAssetContainer(scene: Scene, data: unknown, rootUrl: string, onError?: (message: string, exception?: any) => void): AssetContainer;\r\n}\r\n\r\n/**\r\n * Interface used to define an async SceneLoader plugin\r\n */\r\nexport interface ISceneLoaderPluginAsync extends ISceneLoaderPluginBase {\r\n    /**\r\n     * Import meshes into a scene.\r\n     * @param meshesNames An array of mesh names, a single mesh name, or empty string for all meshes that filter what meshes are imported\r\n     * @param scene The scene to import into\r\n     * @param data The data to import\r\n     * @param rootUrl The root url for scene and resources\r\n     * @param onProgress The callback when the load progresses\r\n     * @param fileName Defines the name of the file to load\r\n     * @returns The loaded objects (e.g. meshes, particle systems, skeletons, animation groups, etc.)\r\n     */\r\n    importMeshAsync(\r\n        meshesNames: string | readonly string[] | null | undefined,\r\n        scene: Scene,\r\n        data: unknown,\r\n        rootUrl: string,\r\n        onProgress?: (event: ISceneLoaderProgressEvent) => void,\r\n        fileName?: string\r\n    ): Promise<ISceneLoaderAsyncResult>;\r\n\r\n    /**\r\n     * Load into a scene.\r\n     * @param scene The scene to load into\r\n     * @param data The data to import\r\n     * @param rootUrl The root url for scene and resources\r\n     * @param onProgress The callback when the load progresses\r\n     * @param fileName Defines the name of the file to load\r\n     * @returns Nothing\r\n     */\r\n    loadAsync(scene: Scene, data: unknown, rootUrl: string, onProgress?: (event: ISceneLoaderProgressEvent) => void, fileName?: string): Promise<void>;\r\n\r\n    /**\r\n     * Load into an asset container.\r\n     * @param scene The scene to load into\r\n     * @param data The data to import\r\n     * @param rootUrl The root url for scene and resources\r\n     * @param onProgress The callback when the load progresses\r\n     * @param fileName Defines the name of the file to load\r\n     * @returns The loaded asset container\r\n     */\r\n    loadAssetContainerAsync(scene: Scene, data: unknown, rootUrl: string, onProgress?: (event: ISceneLoaderProgressEvent) => void, fileName?: string): Promise<AssetContainer>;\r\n}\r\n\r\n/**\r\n * Mode that determines how to handle old animation groups before loading new ones.\r\n */\r\nexport const enum SceneLoaderAnimationGroupLoadingMode {\r\n    /**\r\n     * Reset all old animations to initial state then dispose them.\r\n     */\r\n    Clean = 0,\r\n\r\n    /**\r\n     * Stop all old animations.\r\n     */\r\n    Stop = 1,\r\n\r\n    /**\r\n     * Restart old animations from first frame.\r\n     */\r\n    Sync = 2,\r\n\r\n    /**\r\n     * Old animations remains untouched.\r\n     */\r\n    NoSync = 3,\r\n}\r\n\r\n/**\r\n * Defines internal only plugin members.\r\n */\r\ninterface ISceneLoaderPluginInternal {\r\n    /**\r\n     * An optional observable to notify when the plugin is disposed\r\n     */\r\n    readonly onDisposeObservable: Observable<void>;\r\n}\r\n\r\n/**\r\n * Defines a plugin registered by the SceneLoader\r\n */\r\ninterface IRegisteredPlugin {\r\n    /**\r\n     * Defines the plugin to use\r\n     */\r\n    plugin: ((ISceneLoaderPlugin | ISceneLoaderPluginAsync) & Partial<ISceneLoaderPluginInternal>) | ISceneLoaderPluginFactory;\r\n    /**\r\n     * Defines if the plugin supports binary data\r\n     */\r\n    isBinary: boolean;\r\n    mimeType?: string;\r\n}\r\n\r\nfunction isFactory(pluginOrFactory: IRegisteredPlugin[\"plugin\"]): pluginOrFactory is ISceneLoaderPluginFactory {\r\n    return !!(pluginOrFactory as ISceneLoaderPluginFactory).createPlugin;\r\n}\r\n\r\n/**\r\n * Defines file information\r\n */\r\ninterface IFileInfo {\r\n    /**\r\n     * Gets the file url\r\n     */\r\n    url: string;\r\n    /**\r\n     * Gets the root url\r\n     */\r\n    rootUrl: string;\r\n    /**\r\n     * Gets filename\r\n     */\r\n    name: string;\r\n    /**\r\n     * Gets the file\r\n     */\r\n    file: Nullable<File>;\r\n\r\n    /**\r\n     * Gets raw binary data.\r\n     */\r\n    rawData: Nullable<ArrayBufferView>;\r\n}\r\n\r\n/**\r\n * Defines options for SceneLoader plugins. This interface is extended by specific plugins.\r\n */\r\nexport interface SceneLoaderPluginOptions extends Record<string, Record<string, unknown> | undefined> {}\r\n\r\n/**\r\n * Adds default/implicit options to plugin specific options.\r\n */\r\ntype DefaultPluginOptions<BasePluginOptions> = {\r\n    /**\r\n     * Defines if the plugin is enabled\r\n     */\r\n    enabled?: boolean;\r\n} & BasePluginOptions;\r\n\r\n// This captures the type defined inline for the pluginOptions property, which is just SceneLoaderPluginOptions wrapped with DefaultPluginOptions.\r\n// We do it this way rather than explicitly defining the type here and then using it in SceneLoaderOptions because we want the full expanded type\r\n// to show up in the user's intellisense to make it easier to understand what options are available.\r\ntype PluginOptions = SceneLoaderOptions[\"pluginOptions\"];\r\n\r\ntype SceneSource = string | File | ArrayBufferView;\r\n\r\n/**\r\n * Defines common options for loading operations performed by SceneLoader.\r\n */\r\ninterface SceneLoaderOptions {\r\n    /**\r\n     * A string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n     */\r\n    rootUrl?: string;\r\n\r\n    /**\r\n     * A callback with a progress event for each file being loaded\r\n     */\r\n    onProgress?: (event: ISceneLoaderProgressEvent) => void;\r\n\r\n    /**\r\n     * The extension used to determine the plugin\r\n     */\r\n    pluginExtension?: string;\r\n\r\n    /**\r\n     * Defines the filename, if the data is binary\r\n     */\r\n    name?: string;\r\n\r\n    /**\r\n     * Defines options for the registered plugins\r\n     */\r\n    pluginOptions?: {\r\n        // NOTE: This type is doing two things:\r\n        // 1. Adding an implicit 'enabled' property to the options for each plugin.\r\n        // 2. Creating a mapped type of all the options of all the plugins to make it just look like a consolidated plain object in intellisense for the user.\r\n        [Plugin in keyof SceneLoaderPluginOptions]?: {\r\n            [Option in keyof DefaultPluginOptions<SceneLoaderPluginOptions[Plugin]>]: DefaultPluginOptions<SceneLoaderPluginOptions[Plugin]>[Option];\r\n        };\r\n    };\r\n}\r\n\r\n/**\r\n * Defines options for ImportMeshAsync.\r\n */\r\nexport interface ImportMeshOptions extends SceneLoaderOptions {\r\n    /**\r\n     * An array of mesh names, a single mesh name, or empty string for all meshes that filter what meshes are imported\r\n     */\r\n    meshNames?: string | readonly string[] | null | undefined;\r\n}\r\n\r\n/**\r\n * Defines options for LoadAsync.\r\n */\r\nexport interface LoadOptions extends SceneLoaderOptions {}\r\n\r\n/**\r\n * Defines options for AppendAsync.\r\n */\r\nexport interface AppendOptions extends SceneLoaderOptions {}\r\n\r\n/**\r\n * Defines options for LoadAssetContainerAsync.\r\n */\r\nexport interface LoadAssetContainerOptions extends SceneLoaderOptions {}\r\n\r\n/**\r\n * Defines options for ImportAnimationsAsync.\r\n */\r\nexport interface ImportAnimationsOptions extends SceneLoaderOptions {\r\n    /**\r\n     * When true, animations are cleaned before importing new ones. Animations are appended otherwise\r\n     */\r\n    overwriteAnimations?: boolean;\r\n\r\n    /**\r\n     * Defines how to handle old animations groups before importing new ones\r\n     */\r\n    animationGroupLoadingMode?: SceneLoaderAnimationGroupLoadingMode;\r\n\r\n    /**\r\n     * defines a function used to convert animation targets from loaded scene to current scene (default: search node by name)\r\n     */\r\n    targetConverter?: Nullable<(target: unknown) => unknown>;\r\n}\r\n\r\nfunction isFile(value: unknown): value is File {\r\n    return !!(value as File).name;\r\n}\r\n\r\nconst onPluginActivatedObservable = new Observable<ISceneLoaderPlugin | ISceneLoaderPluginAsync>();\r\nconst registeredPlugins: { [extension: string]: IRegisteredPlugin } = {};\r\nlet showingLoadingScreen = false;\r\n\r\nfunction getDefaultPlugin(): IRegisteredPlugin | undefined {\r\n    return registeredPlugins[\".babylon\"];\r\n}\r\n\r\nfunction getPluginForMimeType(mimeType: string): IRegisteredPlugin | undefined {\r\n    for (const registeredPluginKey in registeredPlugins) {\r\n        const registeredPlugin = registeredPlugins[registeredPluginKey];\r\n        if (registeredPlugin.mimeType === mimeType) {\r\n            return registeredPlugin;\r\n        }\r\n    }\r\n    return undefined;\r\n}\r\n\r\nfunction getPluginForExtension(extension: string, returnDefault: boolean): IRegisteredPlugin | undefined {\r\n    const registeredPlugin = registeredPlugins[extension];\r\n    if (registeredPlugin) {\r\n        return registeredPlugin;\r\n    }\r\n    Logger.Warn(\r\n        \"Unable to find a plugin to load \" +\r\n            extension +\r\n            \" files. Trying to use .babylon default plugin. To load from a specific filetype (eg. gltf) see: https://doc.babylonjs.com/features/featuresDeepDive/importers/loadingFileTypes\"\r\n    );\r\n    return returnDefault ? getDefaultPlugin() : undefined;\r\n}\r\n\r\nfunction isPluginForExtensionAvailable(extension: string): boolean {\r\n    return !!registeredPlugins[extension];\r\n}\r\n\r\nfunction getPluginForDirectLoad(data: string): IRegisteredPlugin | undefined {\r\n    for (const extension in registeredPlugins) {\r\n        const plugin = registeredPlugins[extension].plugin;\r\n\r\n        if (plugin.canDirectLoad && plugin.canDirectLoad(data)) {\r\n            return registeredPlugins[extension];\r\n        }\r\n    }\r\n\r\n    return getDefaultPlugin();\r\n}\r\n\r\nfunction getFilenameExtension(sceneFilename: string): string {\r\n    const queryStringPosition = sceneFilename.indexOf(\"?\");\r\n\r\n    if (queryStringPosition !== -1) {\r\n        sceneFilename = sceneFilename.substring(0, queryStringPosition);\r\n    }\r\n\r\n    const dotPosition = sceneFilename.lastIndexOf(\".\");\r\n\r\n    return sceneFilename.substring(dotPosition, sceneFilename.length).toLowerCase();\r\n}\r\n\r\nfunction getDirectLoad(sceneFilename: string): Nullable<string> {\r\n    if (sceneFilename.substring(0, 5) === \"data:\") {\r\n        return sceneFilename.substring(5);\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\nfunction formatErrorMessage(fileInfo: IFileInfo, message?: string, exception?: any): string {\r\n    const fromLoad = fileInfo.rawData ? \"binary data\" : fileInfo.url;\r\n    let errorMessage = \"Unable to load from \" + fromLoad;\r\n\r\n    if (message) {\r\n        errorMessage += `: ${message}`;\r\n    } else if (exception) {\r\n        errorMessage += `: ${exception}`;\r\n    }\r\n\r\n    return errorMessage;\r\n}\r\n\r\nasync function loadDataAsync(\r\n    fileInfo: IFileInfo,\r\n    scene: Scene,\r\n    onSuccess: (plugin: ISceneLoaderPlugin | ISceneLoaderPluginAsync, data: unknown, responseURL?: string) => void,\r\n    onProgress: ((event: ISceneLoaderProgressEvent) => void) | undefined,\r\n    onError: (message?: string, exception?: any) => void,\r\n    onDispose: () => void,\r\n    pluginExtension: Nullable<string>,\r\n    name: string,\r\n    pluginOptions: PluginOptions\r\n): Promise<Nullable<ISceneLoaderPlugin | ISceneLoaderPluginAsync>> {\r\n    const directLoad = getDirectLoad(fileInfo.url);\r\n\r\n    if (fileInfo.rawData && !pluginExtension) {\r\n        // eslint-disable-next-line no-throw-literal\r\n        throw \"When using ArrayBufferView to load data the file extension must be provided.\";\r\n    }\r\n\r\n    const fileExtension = !directLoad && !pluginExtension ? getFilenameExtension(fileInfo.url) : \"\";\r\n\r\n    let registeredPlugin = pluginExtension\r\n        ? getPluginForExtension(pluginExtension, true)\r\n        : directLoad\r\n          ? getPluginForDirectLoad(fileInfo.url)\r\n          : getPluginForExtension(fileExtension, false);\r\n\r\n    if (!registeredPlugin && fileExtension) {\r\n        if (fileInfo.url && !fileInfo.url.startsWith(\"blob:\")) {\r\n            // Fetching head content to get the mime type\r\n            const response = await _FetchAsync(fileInfo.url, { method: \"HEAD\", responseHeaders: [\"Content-Type\"] });\r\n            const mimeType = response.headerValues ? response.headerValues[\"Content-Type\"] : \"\";\r\n            if (mimeType) {\r\n                registeredPlugin = getPluginForMimeType(mimeType);\r\n            }\r\n        }\r\n\r\n        if (!registeredPlugin) {\r\n            registeredPlugin = getDefaultPlugin();\r\n        }\r\n    }\r\n\r\n    if (!registeredPlugin) {\r\n        throw new Error(`No plugin or fallback for ${pluginExtension ?? fileInfo.url}`);\r\n    }\r\n\r\n    if (pluginOptions?.[registeredPlugin.plugin.name]?.enabled === false) {\r\n        throw new Error(`The '${registeredPlugin.plugin.name}' plugin is disabled via the loader options passed to the loading operation.`);\r\n    }\r\n\r\n    if (fileInfo.rawData && !registeredPlugin.isBinary) {\r\n        // eslint-disable-next-line no-throw-literal\r\n        throw \"Loading from ArrayBufferView can not be used with plugins that don't support binary loading.\";\r\n    }\r\n\r\n    const getPluginInstance = (callback: (plugin: (ISceneLoaderPlugin | ISceneLoaderPluginAsync) & Partial<ISceneLoaderPluginInternal>) => void) => {\r\n        // For plugin factories, the plugin is instantiated on each SceneLoader operation. This makes options handling\r\n        // much simpler as we can just pass the options to the factory, rather than passing options through to every possible\r\n        // plugin call. Given this, options are only supported for plugins that provide a factory function.\r\n        if (isFactory(registeredPlugin!.plugin)) {\r\n            const pluginFactory = registeredPlugin!.plugin;\r\n            const partialPlugin = pluginFactory.createPlugin(pluginOptions ?? {});\r\n            if (partialPlugin instanceof Promise) {\r\n                partialPlugin.then(callback).catch((error) => {\r\n                    onError(\"Error instantiating plugin.\", error);\r\n                });\r\n                // When async factories are used, the plugin instance cannot be returned synchronously.\r\n                // In this case, the legacy loader functions will return null.\r\n                return null;\r\n            } else {\r\n                callback(partialPlugin);\r\n                return partialPlugin;\r\n            }\r\n        } else {\r\n            callback(registeredPlugin!.plugin);\r\n            return registeredPlugin!.plugin;\r\n        }\r\n    };\r\n\r\n    return getPluginInstance((plugin) => {\r\n        if (!plugin) {\r\n            // eslint-disable-next-line no-throw-literal\r\n            throw `The loader plugin corresponding to the '${pluginExtension}' file type has not been found. If using es6, please import the plugin you wish to use before.`;\r\n        }\r\n\r\n        onPluginActivatedObservable.notifyObservers(plugin);\r\n\r\n        // Check if we have a direct load url. If the plugin is registered to handle\r\n        // it or it's not a base64 data url, then pass it through the direct load path.\r\n        if (directLoad && ((plugin.canDirectLoad && plugin.canDirectLoad(fileInfo.url)) || !IsBase64DataUrl(fileInfo.url))) {\r\n            if (plugin.directLoad) {\r\n                const result = plugin.directLoad(scene, directLoad);\r\n                if (result instanceof Promise) {\r\n                    result\r\n                        .then((data: unknown) => {\r\n                            onSuccess(plugin, data);\r\n                        })\r\n                        .catch((error: any) => {\r\n                            onError(\"Error in directLoad of _loadData: \" + error, error);\r\n                        });\r\n                } else {\r\n                    onSuccess(plugin, result);\r\n                }\r\n            } else {\r\n                onSuccess(plugin, directLoad);\r\n            }\r\n            return;\r\n        }\r\n\r\n        const useArrayBuffer = registeredPlugin!.isBinary;\r\n\r\n        const dataCallback = (data: unknown, responseURL?: string) => {\r\n            if (scene.isDisposed) {\r\n                onError(\"Scene has been disposed\");\r\n                return;\r\n            }\r\n\r\n            onSuccess(plugin, data, responseURL);\r\n        };\r\n\r\n        let request: Nullable<IFileRequest> = null;\r\n        let pluginDisposed = false;\r\n        plugin.onDisposeObservable?.add(() => {\r\n            pluginDisposed = true;\r\n\r\n            if (request) {\r\n                request.abort();\r\n                request = null;\r\n            }\r\n\r\n            onDispose();\r\n        });\r\n\r\n        const manifestChecked = () => {\r\n            if (pluginDisposed) {\r\n                return;\r\n            }\r\n\r\n            const errorCallback = (request?: WebRequest, exception?: LoadFileError) => {\r\n                onError(request?.statusText, exception);\r\n            };\r\n\r\n            if (!plugin.loadFile && fileInfo.rawData) {\r\n                // eslint-disable-next-line no-throw-literal\r\n                throw \"Plugin does not support loading ArrayBufferView.\";\r\n            }\r\n\r\n            request = plugin.loadFile\r\n                ? plugin.loadFile(scene, fileInfo.rawData || fileInfo.file || fileInfo.url, fileInfo.rootUrl, dataCallback, onProgress, useArrayBuffer, errorCallback, name)\r\n                : scene._loadFile(fileInfo.file || fileInfo.url, dataCallback, onProgress, true, useArrayBuffer, errorCallback);\r\n        };\r\n\r\n        const engine = scene.getEngine();\r\n        let canUseOfflineSupport = engine.enableOfflineSupport;\r\n        if (canUseOfflineSupport) {\r\n            // Also check for exceptions\r\n            let exceptionFound = false;\r\n            for (const regex of scene.disableOfflineSupportExceptionRules) {\r\n                if (regex.test(fileInfo.url)) {\r\n                    exceptionFound = true;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            canUseOfflineSupport = !exceptionFound;\r\n        }\r\n\r\n        if (canUseOfflineSupport && AbstractEngine.OfflineProviderFactory) {\r\n            // Checking if a manifest file has been set for this scene and if offline mode has been requested\r\n            scene.offlineProvider = AbstractEngine.OfflineProviderFactory(fileInfo.url, manifestChecked, engine.disableManifestCheck);\r\n        } else {\r\n            manifestChecked();\r\n        }\r\n    });\r\n}\r\n\r\nfunction _getFileInfo(rootUrl: string, sceneSource: SceneSource): Nullable<IFileInfo> {\r\n    let url: string;\r\n    let name: string;\r\n    let file: Nullable<File> = null;\r\n    let rawData: Nullable<ArrayBufferView> = null;\r\n\r\n    if (!sceneSource) {\r\n        url = rootUrl;\r\n        name = Tools.GetFilename(rootUrl);\r\n        rootUrl = Tools.GetFolderPath(rootUrl);\r\n    } else if (isFile(sceneSource)) {\r\n        url = `file:${sceneSource.name}`;\r\n        name = sceneSource.name;\r\n        file = sceneSource;\r\n    } else if (ArrayBuffer.isView(sceneSource)) {\r\n        url = \"\";\r\n        name = RandomGUID();\r\n        rawData = sceneSource;\r\n    } else if (sceneSource.startsWith(\"data:\")) {\r\n        url = sceneSource;\r\n        name = \"\";\r\n    } else if (rootUrl) {\r\n        const filename = sceneSource;\r\n        if (filename.substring(0, 1) === \"/\") {\r\n            Tools.Error(\"Wrong sceneFilename parameter\");\r\n            return null;\r\n        }\r\n\r\n        url = rootUrl + filename;\r\n        name = filename;\r\n    } else {\r\n        url = sceneSource;\r\n        name = Tools.GetFilename(sceneSource);\r\n        rootUrl = Tools.GetFolderPath(sceneSource);\r\n    }\r\n\r\n    return {\r\n        url: url,\r\n        rootUrl: rootUrl,\r\n        name: name,\r\n        file: file,\r\n        rawData,\r\n    };\r\n}\r\n\r\n/**\r\n * Adds a new plugin to the list of registered plugins\r\n * @param plugin defines the plugin to add\r\n */\r\nexport function registerSceneLoaderPlugin(plugin: ISceneLoaderPlugin | ISceneLoaderPluginAsync | ISceneLoaderPluginFactory): void {\r\n    if (typeof plugin.extensions === \"string\") {\r\n        const extension = plugin.extensions;\r\n        registeredPlugins[extension.toLowerCase()] = {\r\n            plugin: plugin,\r\n            isBinary: false,\r\n        };\r\n    } else {\r\n        const extensions = plugin.extensions;\r\n        Object.keys(extensions).forEach((extension) => {\r\n            registeredPlugins[extension.toLowerCase()] = {\r\n                plugin: plugin,\r\n                isBinary: extensions[extension].isBinary,\r\n                mimeType: extensions[extension].mimeType,\r\n            };\r\n        });\r\n    }\r\n}\r\n\r\nasync function importMeshAsync(\r\n    meshNames: string | readonly string[] | null | undefined,\r\n    rootUrl: string,\r\n    sceneFilename: SceneSource = \"\",\r\n    scene: Nullable<Scene> = EngineStore.LastCreatedScene,\r\n    onSuccess: Nullable<SceneLoaderSuccessCallback> = null,\r\n    onProgress: Nullable<(event: ISceneLoaderProgressEvent) => void> = null,\r\n    onError: Nullable<(scene: Scene, message: string, exception?: any) => void> = null,\r\n    pluginExtension: Nullable<string> = null,\r\n    name = \"\",\r\n    pluginOptions: PluginOptions = {}\r\n): Promise<Nullable<ISceneLoaderPlugin | ISceneLoaderPluginAsync>> {\r\n    if (!scene) {\r\n        Logger.Error(\"No scene available to import mesh to\");\r\n        return null;\r\n    }\r\n\r\n    const fileInfo = _getFileInfo(rootUrl, sceneFilename);\r\n    if (!fileInfo) {\r\n        return null;\r\n    }\r\n\r\n    const loadingToken = {};\r\n    scene.addPendingData(loadingToken);\r\n\r\n    const disposeHandler = () => {\r\n        scene.removePendingData(loadingToken);\r\n    };\r\n\r\n    const errorHandler = (message?: string, exception?: any) => {\r\n        const errorMessage = formatErrorMessage(fileInfo, message, exception);\r\n\r\n        if (onError) {\r\n            onError(scene, errorMessage, new RuntimeError(errorMessage, ErrorCodes.SceneLoaderError, exception));\r\n        } else {\r\n            Logger.Error(errorMessage);\r\n            // should the exception be thrown?\r\n        }\r\n\r\n        disposeHandler();\r\n    };\r\n\r\n    const progressHandler = onProgress\r\n        ? (event: ISceneLoaderProgressEvent) => {\r\n              try {\r\n                  onProgress(event);\r\n              } catch (e) {\r\n                  errorHandler(\"Error in onProgress callback: \" + e, e);\r\n              }\r\n          }\r\n        : undefined;\r\n\r\n    const successHandler: SceneLoaderSuccessCallback = (meshes, particleSystems, skeletons, animationGroups, transformNodes, geometries, lights, spriteManagers) => {\r\n        scene.importedMeshesFiles.push(fileInfo.url);\r\n\r\n        if (onSuccess) {\r\n            try {\r\n                onSuccess(meshes, particleSystems, skeletons, animationGroups, transformNodes, geometries, lights, spriteManagers);\r\n            } catch (e) {\r\n                errorHandler(\"Error in onSuccess callback: \" + e, e);\r\n            }\r\n        }\r\n\r\n        scene.removePendingData(loadingToken);\r\n    };\r\n\r\n    return await loadDataAsync(\r\n        fileInfo,\r\n        scene,\r\n        (plugin, data, responseURL) => {\r\n            if (plugin.rewriteRootURL) {\r\n                fileInfo.rootUrl = plugin.rewriteRootURL(fileInfo.rootUrl, responseURL);\r\n            }\r\n\r\n            if ((plugin as ISceneLoaderPlugin).importMesh) {\r\n                const syncedPlugin = <ISceneLoaderPlugin>plugin;\r\n                const meshes: AbstractMesh[] = [];\r\n                const particleSystems: IParticleSystem[] = [];\r\n                const skeletons: Skeleton[] = [];\r\n\r\n                if (!syncedPlugin.importMesh(meshNames, scene, data, fileInfo.rootUrl, meshes, particleSystems, skeletons, errorHandler)) {\r\n                    return;\r\n                }\r\n\r\n                scene.loadingPluginName = plugin.name;\r\n                successHandler(meshes, particleSystems, skeletons, [], [], [], [], []);\r\n            } else {\r\n                const asyncedPlugin = <ISceneLoaderPluginAsync>plugin;\r\n                asyncedPlugin\r\n                    .importMeshAsync(meshNames, scene, data, fileInfo.rootUrl, progressHandler, fileInfo.name)\r\n                    .then((result) => {\r\n                        scene.loadingPluginName = plugin.name;\r\n                        successHandler(\r\n                            result.meshes,\r\n                            result.particleSystems,\r\n                            result.skeletons,\r\n                            result.animationGroups,\r\n                            result.transformNodes,\r\n                            result.geometries,\r\n                            result.lights,\r\n                            result.spriteManagers\r\n                        );\r\n                    })\r\n                    .catch((error) => {\r\n                        errorHandler(error.message, error);\r\n                    });\r\n            }\r\n        },\r\n        progressHandler,\r\n        errorHandler,\r\n        disposeHandler,\r\n        pluginExtension,\r\n        name,\r\n        pluginOptions\r\n    );\r\n}\r\n\r\nfunction importMeshAsyncCore(\r\n    meshNames: string | readonly string[] | null | undefined,\r\n    rootUrl: string,\r\n    sceneFilename?: SceneSource,\r\n    scene?: Nullable<Scene>,\r\n    onProgress?: Nullable<(event: ISceneLoaderProgressEvent) => void>,\r\n    pluginExtension?: Nullable<string>,\r\n    name?: string,\r\n    pluginOptions?: PluginOptions\r\n): Promise<ISceneLoaderAsyncResult> {\r\n    return new Promise((resolve, reject) => {\r\n        importMeshAsync(\r\n            meshNames,\r\n            rootUrl,\r\n            sceneFilename,\r\n            scene,\r\n            (meshes, particleSystems, skeletons, animationGroups, transformNodes, geometries, lights, spriteManagers) => {\r\n                resolve({\r\n                    meshes: meshes,\r\n                    particleSystems: particleSystems,\r\n                    skeletons: skeletons,\r\n                    animationGroups: animationGroups,\r\n                    transformNodes: transformNodes,\r\n                    geometries: geometries,\r\n                    lights: lights,\r\n                    spriteManagers: spriteManagers,\r\n                });\r\n            },\r\n            onProgress,\r\n            (scene, message, exception) => {\r\n                reject(exception || new Error(message));\r\n            },\r\n            pluginExtension,\r\n            name,\r\n            pluginOptions\r\n        );\r\n    });\r\n}\r\n\r\nfunction loadScene(\r\n    rootUrl: string,\r\n    sceneFilename: SceneSource = \"\",\r\n    engine: Nullable<AbstractEngine> = EngineStore.LastCreatedEngine,\r\n    onSuccess: Nullable<(scene: Scene) => void> = null,\r\n    onProgress: Nullable<(event: ISceneLoaderProgressEvent) => void> = null,\r\n    onError: Nullable<(scene: Scene, message: string, exception?: any) => void> = null,\r\n    pluginExtension: Nullable<string> = null,\r\n    name = \"\",\r\n    pluginOptions: PluginOptions = {}\r\n): void {\r\n    if (!engine) {\r\n        Tools.Error(\"No engine available\");\r\n        return;\r\n    }\r\n\r\n    appendAsync(rootUrl, sceneFilename, new Scene(engine), onSuccess, onProgress, onError, pluginExtension, name, pluginOptions);\r\n}\r\n\r\n/**\r\n * Load a scene\r\n * @experimental\r\n * @param source a string that defines the name of the scene file, or starts with \"data:\" following by the stringified version of the scene, or a File object, or an ArrayBufferView\r\n * @param engine is the instance of BABYLON.Engine to use to create the scene\r\n * @param options an object that configures aspects of how the scene is loaded\r\n * @returns The loaded scene\r\n */\r\nexport function loadSceneAsync(source: SceneSource, engine: AbstractEngine, options?: LoadOptions): Promise<Scene> {\r\n    const { rootUrl = \"\", onProgress, pluginExtension, name, pluginOptions } = options ?? {};\r\n    return loadSceneAsyncCore(rootUrl, source, engine, onProgress, pluginExtension, name, pluginOptions);\r\n}\r\n\r\nfunction loadSceneAsyncCore(\r\n    rootUrl: string,\r\n    sceneFilename?: SceneSource,\r\n    engine?: Nullable<AbstractEngine>,\r\n    onProgress?: Nullable<(event: ISceneLoaderProgressEvent) => void>,\r\n    pluginExtension?: Nullable<string>,\r\n    name?: string,\r\n    pluginOptions?: PluginOptions\r\n): Promise<Scene> {\r\n    return new Promise((resolve, reject) => {\r\n        loadScene(\r\n            rootUrl,\r\n            sceneFilename,\r\n            engine,\r\n            (scene) => {\r\n                resolve(scene);\r\n            },\r\n            onProgress,\r\n            (scene, message, exception) => {\r\n                reject(exception || new Error(message));\r\n            },\r\n            pluginExtension,\r\n            name,\r\n            pluginOptions\r\n        );\r\n    });\r\n}\r\n\r\nasync function appendAsync(\r\n    rootUrl: string,\r\n    sceneFilename: SceneSource = \"\",\r\n    scene: Nullable<Scene> = EngineStore.LastCreatedScene,\r\n    onSuccess: Nullable<(scene: Scene) => void> = null,\r\n    onProgress: Nullable<(event: ISceneLoaderProgressEvent) => void> = null,\r\n    onError: Nullable<(scene: Scene, message: string, exception?: any) => void> = null,\r\n    pluginExtension: Nullable<string> = null,\r\n    name = \"\",\r\n    pluginOptions: PluginOptions = {}\r\n): Promise<Nullable<ISceneLoaderPlugin | ISceneLoaderPluginAsync>> {\r\n    if (!scene) {\r\n        Logger.Error(\"No scene available to append to\");\r\n        return null;\r\n    }\r\n\r\n    const fileInfo = _getFileInfo(rootUrl, sceneFilename);\r\n    if (!fileInfo) {\r\n        return null;\r\n    }\r\n\r\n    const loadingToken = {};\r\n    scene.addPendingData(loadingToken);\r\n\r\n    const disposeHandler = () => {\r\n        scene.removePendingData(loadingToken);\r\n    };\r\n\r\n    if (SceneLoaderFlags.ShowLoadingScreen && !showingLoadingScreen) {\r\n        showingLoadingScreen = true;\r\n        scene.getEngine().displayLoadingUI();\r\n        scene.executeWhenReady(() => {\r\n            scene.getEngine().hideLoadingUI();\r\n            showingLoadingScreen = false;\r\n        });\r\n    }\r\n\r\n    const errorHandler = (message?: string, exception?: any) => {\r\n        const errorMessage = formatErrorMessage(fileInfo, message, exception);\r\n\r\n        if (onError) {\r\n            onError(scene, errorMessage, new RuntimeError(errorMessage, ErrorCodes.SceneLoaderError, exception));\r\n        } else {\r\n            Logger.Error(errorMessage);\r\n            // should the exception be thrown?\r\n        }\r\n\r\n        disposeHandler();\r\n    };\r\n\r\n    const progressHandler = onProgress\r\n        ? (event: ISceneLoaderProgressEvent) => {\r\n              try {\r\n                  onProgress(event);\r\n              } catch (e) {\r\n                  errorHandler(\"Error in onProgress callback\", e);\r\n              }\r\n          }\r\n        : undefined;\r\n\r\n    const successHandler = () => {\r\n        if (onSuccess) {\r\n            try {\r\n                onSuccess(scene);\r\n            } catch (e) {\r\n                errorHandler(\"Error in onSuccess callback\", e);\r\n            }\r\n        }\r\n\r\n        scene.removePendingData(loadingToken);\r\n    };\r\n\r\n    return await loadDataAsync(\r\n        fileInfo,\r\n        scene,\r\n        (plugin, data) => {\r\n            if ((plugin as ISceneLoaderPlugin).load) {\r\n                const syncedPlugin = <ISceneLoaderPlugin>plugin;\r\n                if (!syncedPlugin.load(scene, data, fileInfo.rootUrl, errorHandler)) {\r\n                    return;\r\n                }\r\n\r\n                scene.loadingPluginName = plugin.name;\r\n                successHandler();\r\n            } else {\r\n                const asyncedPlugin = <ISceneLoaderPluginAsync>plugin;\r\n                asyncedPlugin\r\n                    .loadAsync(scene, data, fileInfo.rootUrl, progressHandler, fileInfo.name)\r\n                    .then(() => {\r\n                        scene.loadingPluginName = plugin.name;\r\n                        successHandler();\r\n                    })\r\n                    .catch((error) => {\r\n                        errorHandler(error.message, error);\r\n                    });\r\n            }\r\n        },\r\n        progressHandler,\r\n        errorHandler,\r\n        disposeHandler,\r\n        pluginExtension,\r\n        name,\r\n        pluginOptions\r\n    );\r\n}\r\n\r\n/**\r\n * Append a scene\r\n * @experimental\r\n * @param source a string that defines the name of the scene file, or starts with \"data:\" following by the stringified version of the scene, or a File object, or an ArrayBufferView\r\n * @param scene is the instance of BABYLON.Scene to append to\r\n * @param options an object that configures aspects of how the scene is loaded\r\n */\r\nexport async function appendSceneAsync(source: SceneSource, scene: Scene, options?: AppendOptions): Promise<void> {\r\n    const { rootUrl = \"\", onProgress, pluginExtension, name, pluginOptions } = options ?? {};\r\n    await appendSceneAsyncCore(rootUrl, source, scene, onProgress, pluginExtension, name, pluginOptions);\r\n}\r\n\r\nfunction appendSceneAsyncCore(\r\n    rootUrl: string,\r\n    sceneFilename?: SceneSource,\r\n    scene?: Nullable<Scene>,\r\n    onProgress?: Nullable<(event: ISceneLoaderProgressEvent) => void>,\r\n    pluginExtension?: Nullable<string>,\r\n    name?: string,\r\n    pluginOptions?: PluginOptions\r\n): Promise<Scene> {\r\n    return new Promise((resolve, reject) => {\r\n        appendAsync(\r\n            rootUrl,\r\n            sceneFilename,\r\n            scene,\r\n            (scene) => {\r\n                resolve(scene);\r\n            },\r\n            onProgress,\r\n            (scene, message, exception) => {\r\n                reject(exception || new Error(message));\r\n            },\r\n            pluginExtension,\r\n            name,\r\n            pluginOptions\r\n        );\r\n    });\r\n}\r\n\r\nasync function loadAssetContainerCoreAsync(\r\n    rootUrl: string,\r\n    sceneFilename: SceneSource = \"\",\r\n    scene: Nullable<Scene> = EngineStore.LastCreatedScene,\r\n    onSuccess: Nullable<(assets: AssetContainer) => void> = null,\r\n    onProgress: Nullable<(event: ISceneLoaderProgressEvent) => void> = null,\r\n    onError: Nullable<(scene: Scene, message: string, exception?: any) => void> = null,\r\n    pluginExtension: Nullable<string> = null,\r\n    name = \"\",\r\n    pluginOptions: PluginOptions = {}\r\n): Promise<Nullable<ISceneLoaderPlugin | ISceneLoaderPluginAsync>> {\r\n    if (!scene) {\r\n        Logger.Error(\"No scene available to load asset container to\");\r\n        return null;\r\n    }\r\n\r\n    const fileInfo = _getFileInfo(rootUrl, sceneFilename);\r\n    if (!fileInfo) {\r\n        return null;\r\n    }\r\n\r\n    const loadingToken = {};\r\n    scene.addPendingData(loadingToken);\r\n\r\n    const disposeHandler = () => {\r\n        scene.removePendingData(loadingToken);\r\n    };\r\n\r\n    const errorHandler = (message?: string, exception?: any) => {\r\n        const errorMessage = formatErrorMessage(fileInfo, message, exception);\r\n\r\n        if (onError) {\r\n            onError(scene, errorMessage, new RuntimeError(errorMessage, ErrorCodes.SceneLoaderError, exception));\r\n        } else {\r\n            Logger.Error(errorMessage);\r\n            // should the exception be thrown?\r\n        }\r\n\r\n        disposeHandler();\r\n    };\r\n\r\n    const progressHandler = onProgress\r\n        ? (event: ISceneLoaderProgressEvent) => {\r\n              try {\r\n                  onProgress(event);\r\n              } catch (e) {\r\n                  errorHandler(\"Error in onProgress callback\", e);\r\n              }\r\n          }\r\n        : undefined;\r\n\r\n    const successHandler = (assets: AssetContainer) => {\r\n        if (onSuccess) {\r\n            try {\r\n                onSuccess(assets);\r\n            } catch (e) {\r\n                errorHandler(\"Error in onSuccess callback\", e);\r\n            }\r\n        }\r\n\r\n        scene.removePendingData(loadingToken);\r\n    };\r\n\r\n    return await loadDataAsync(\r\n        fileInfo,\r\n        scene,\r\n        (plugin, data) => {\r\n            if ((plugin as ISceneLoaderPlugin).loadAssetContainer) {\r\n                const syncedPlugin = <ISceneLoaderPlugin>plugin;\r\n                const assetContainer = syncedPlugin.loadAssetContainer(scene, data, fileInfo.rootUrl, errorHandler);\r\n                if (!assetContainer) {\r\n                    return;\r\n                }\r\n                assetContainer.populateRootNodes();\r\n                scene.loadingPluginName = plugin.name;\r\n                successHandler(assetContainer);\r\n            } else if ((plugin as ISceneLoaderPluginAsync).loadAssetContainerAsync) {\r\n                const asyncedPlugin = <ISceneLoaderPluginAsync>plugin;\r\n                asyncedPlugin\r\n                    .loadAssetContainerAsync(scene, data, fileInfo.rootUrl, progressHandler, fileInfo.name)\r\n                    .then((assetContainer) => {\r\n                        assetContainer.populateRootNodes();\r\n                        scene.loadingPluginName = plugin.name;\r\n                        successHandler(assetContainer);\r\n                    })\r\n                    .catch((error) => {\r\n                        errorHandler(error.message, error);\r\n                    });\r\n            } else {\r\n                errorHandler(\"LoadAssetContainer is not supported by this plugin. Plugin did not provide a loadAssetContainer or loadAssetContainerAsync method.\");\r\n            }\r\n        },\r\n        progressHandler,\r\n        errorHandler,\r\n        disposeHandler,\r\n        pluginExtension,\r\n        name,\r\n        pluginOptions\r\n    );\r\n}\r\n\r\n/**\r\n * Load a scene into an asset container\r\n * @experimental\r\n * @param source a string that defines the name of the scene file, or starts with \"data:\" following by the stringified version of the scene, or a File object, or an ArrayBufferView\r\n * @param scene is the instance of Scene to append to\r\n * @param options an object that configures aspects of how the scene is loaded\r\n * @returns The loaded asset container\r\n */\r\nexport function loadAssetContainerAsync(source: SceneSource, scene: Scene, options?: LoadAssetContainerOptions): Promise<AssetContainer> {\r\n    const { rootUrl = \"\", onProgress, pluginExtension, name, pluginOptions } = options ?? {};\r\n    return internalLoadAssetContainerAsync(rootUrl, source, scene, onProgress, pluginExtension, name, pluginOptions);\r\n}\r\n\r\nfunction internalLoadAssetContainerAsync(\r\n    rootUrl: string,\r\n    sceneFilename?: SceneSource,\r\n    scene?: Nullable<Scene>,\r\n    onProgress?: Nullable<(event: ISceneLoaderProgressEvent) => void>,\r\n    pluginExtension?: Nullable<string>,\r\n    name?: string,\r\n    pluginOptions?: PluginOptions\r\n): Promise<AssetContainer> {\r\n    return new Promise((resolve, reject) => {\r\n        loadAssetContainerCoreAsync(\r\n            rootUrl,\r\n            sceneFilename,\r\n            scene,\r\n            (assets) => {\r\n                resolve(assets);\r\n            },\r\n            onProgress,\r\n            (scene, message, exception) => {\r\n                reject(exception || new Error(message));\r\n            },\r\n            pluginExtension,\r\n            name,\r\n            pluginOptions\r\n        );\r\n    });\r\n}\r\n\r\nfunction importAnimations(\r\n    rootUrl: string,\r\n    sceneFilename: SceneSource = \"\",\r\n    scene: Nullable<Scene> = EngineStore.LastCreatedScene,\r\n    overwriteAnimations = true,\r\n    animationGroupLoadingMode = SceneLoaderAnimationGroupLoadingMode.Clean,\r\n    targetConverter: Nullable<(target: any) => any> = null,\r\n    onSuccess: Nullable<(scene: Scene) => void> = null,\r\n    onProgress: Nullable<(event: ISceneLoaderProgressEvent) => void> = null,\r\n    onError: Nullable<(scene: Scene, message: string, exception?: any) => void> = null,\r\n    pluginExtension: Nullable<string> = null,\r\n    name = \"\",\r\n    pluginOptions: PluginOptions = {}\r\n): void {\r\n    if (!scene) {\r\n        Logger.Error(\"No scene available to load animations to\");\r\n        return;\r\n    }\r\n\r\n    if (overwriteAnimations) {\r\n        // Reset, stop and dispose all animations before loading new ones\r\n        for (const animatable of scene.animatables) {\r\n            animatable.reset();\r\n        }\r\n        scene.stopAllAnimations();\r\n        scene.animationGroups.slice().forEach((animationGroup) => {\r\n            animationGroup.dispose();\r\n        });\r\n        const nodes = scene.getNodes();\r\n        nodes.forEach((node) => {\r\n            if (node.animations) {\r\n                node.animations = [];\r\n            }\r\n        });\r\n    } else {\r\n        switch (animationGroupLoadingMode) {\r\n            case SceneLoaderAnimationGroupLoadingMode.Clean:\r\n                scene.animationGroups.slice().forEach((animationGroup) => {\r\n                    animationGroup.dispose();\r\n                });\r\n                break;\r\n            case SceneLoaderAnimationGroupLoadingMode.Stop:\r\n                scene.animationGroups.forEach((animationGroup) => {\r\n                    animationGroup.stop();\r\n                });\r\n                break;\r\n            case SceneLoaderAnimationGroupLoadingMode.Sync:\r\n                scene.animationGroups.forEach((animationGroup) => {\r\n                    animationGroup.reset();\r\n                    animationGroup.restart();\r\n                });\r\n                break;\r\n            case SceneLoaderAnimationGroupLoadingMode.NoSync:\r\n                // nothing to do\r\n                break;\r\n            default:\r\n                Logger.Error(\"Unknown animation group loading mode value '\" + animationGroupLoadingMode + \"'\");\r\n                return;\r\n        }\r\n    }\r\n\r\n    const startingIndexForNewAnimatables = scene.animatables.length;\r\n\r\n    const onAssetContainerLoaded = (container: AssetContainer) => {\r\n        container.mergeAnimationsTo(scene, scene.animatables.slice(startingIndexForNewAnimatables), targetConverter);\r\n\r\n        container.dispose();\r\n\r\n        scene.onAnimationFileImportedObservable.notifyObservers(scene);\r\n\r\n        if (onSuccess) {\r\n            onSuccess(scene);\r\n        }\r\n    };\r\n\r\n    loadAssetContainerCoreAsync(rootUrl, sceneFilename, scene, onAssetContainerLoaded, onProgress, onError, pluginExtension, name, pluginOptions);\r\n}\r\n\r\n/**\r\n * Import animations from a file into a scene\r\n * @experimental\r\n * @param source a string that defines the name of the scene file, or starts with \"data:\" following by the stringified version of the scene, or a File object, or an ArrayBufferView\r\n * @param scene is the instance of BABYLON.Scene to append to\r\n * @param options an object that configures aspects of how the scene is loaded\r\n */\r\nexport async function importAnimationsAsync(source: SceneSource, scene: Scene, options?: ImportAnimationsOptions): Promise<void> {\r\n    const { rootUrl = \"\", overwriteAnimations, animationGroupLoadingMode, targetConverter, onProgress, pluginExtension, name, pluginOptions } = options ?? {};\r\n    await importAnimationsAsyncCore(rootUrl, source, scene, overwriteAnimations, animationGroupLoadingMode, targetConverter, onProgress, pluginExtension, name, pluginOptions);\r\n}\r\n\r\nfunction importAnimationsAsyncCore(\r\n    rootUrl: string,\r\n    sceneFilename?: SceneSource,\r\n    scene?: Nullable<Scene>,\r\n    overwriteAnimations?: boolean,\r\n    animationGroupLoadingMode?: SceneLoaderAnimationGroupLoadingMode,\r\n    targetConverter?: Nullable<(target: any) => any>,\r\n    onProgress?: Nullable<(event: ISceneLoaderProgressEvent) => void>,\r\n    pluginExtension?: Nullable<string>,\r\n    name?: string,\r\n    pluginOptions?: PluginOptions\r\n): Promise<Scene> {\r\n    return new Promise((resolve, reject) => {\r\n        importAnimations(\r\n            rootUrl,\r\n            sceneFilename,\r\n            scene,\r\n            overwriteAnimations,\r\n            animationGroupLoadingMode,\r\n            targetConverter,\r\n            (scene) => {\r\n                resolve(scene);\r\n            },\r\n            onProgress,\r\n            (scene, message, exception) => {\r\n                reject(exception || new Error(message));\r\n            },\r\n            pluginExtension,\r\n            name,\r\n            pluginOptions\r\n        );\r\n    });\r\n}\r\n\r\n/**\r\n * Class used to load scene from various file formats using registered plugins\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/importers/loadingFileTypes\r\n */\r\nexport class SceneLoader {\r\n    /**\r\n     * No logging while loading\r\n     */\r\n    public static readonly NO_LOGGING = Constants.SCENELOADER_NO_LOGGING;\r\n\r\n    /**\r\n     * Minimal logging while loading\r\n     */\r\n    public static readonly MINIMAL_LOGGING = Constants.SCENELOADER_MINIMAL_LOGGING;\r\n\r\n    /**\r\n     * Summary logging while loading\r\n     */\r\n    public static readonly SUMMARY_LOGGING = Constants.SCENELOADER_SUMMARY_LOGGING;\r\n\r\n    /**\r\n     * Detailed logging while loading\r\n     */\r\n    public static readonly DETAILED_LOGGING = Constants.SCENELOADER_DETAILED_LOGGING;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if entire scene must be loaded even if scene contains incremental data\r\n     */\r\n    public static get ForceFullSceneLoadingForIncremental() {\r\n        return SceneLoaderFlags.ForceFullSceneLoadingForIncremental;\r\n    }\r\n\r\n    public static set ForceFullSceneLoadingForIncremental(value: boolean) {\r\n        SceneLoaderFlags.ForceFullSceneLoadingForIncremental = value;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if loading screen must be displayed while loading a scene\r\n     */\r\n    public static get ShowLoadingScreen(): boolean {\r\n        return SceneLoaderFlags.ShowLoadingScreen;\r\n    }\r\n\r\n    public static set ShowLoadingScreen(value: boolean) {\r\n        SceneLoaderFlags.ShowLoadingScreen = value;\r\n    }\r\n\r\n    /**\r\n     * Defines the current logging level (while loading the scene)\r\n     * @ignorenaming\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public static get loggingLevel(): number {\r\n        return SceneLoaderFlags.loggingLevel;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public static set loggingLevel(value: number) {\r\n        SceneLoaderFlags.loggingLevel = value;\r\n    }\r\n\r\n    /**\r\n     * Gets or set a boolean indicating if matrix weights must be cleaned upon loading\r\n     */\r\n    public static get CleanBoneMatrixWeights(): boolean {\r\n        return SceneLoaderFlags.CleanBoneMatrixWeights;\r\n    }\r\n\r\n    public static set CleanBoneMatrixWeights(value: boolean) {\r\n        SceneLoaderFlags.CleanBoneMatrixWeights = value;\r\n    }\r\n\r\n    // Members\r\n\r\n    /**\r\n     * Event raised when a plugin is used to load a scene\r\n     */\r\n    public static readonly OnPluginActivatedObservable = onPluginActivatedObservable;\r\n\r\n    /**\r\n     * Gets the default plugin (used to load Babylon files)\r\n     * @returns the .babylon plugin\r\n     */\r\n    public static GetDefaultPlugin(): IRegisteredPlugin | undefined {\r\n        return getDefaultPlugin();\r\n    }\r\n\r\n    // Public functions\r\n\r\n    /**\r\n     * Gets a plugin that can load the given extension\r\n     * @param extension defines the extension to load\r\n     * @returns a plugin or null if none works\r\n     */\r\n    public static GetPluginForExtension(extension: string): ISceneLoaderPlugin | ISceneLoaderPluginAsync | ISceneLoaderPluginFactory | undefined {\r\n        return getPluginForExtension(extension, true)?.plugin;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that the given extension can be loaded\r\n     * @param extension defines the extension to load\r\n     * @returns true if the extension is supported\r\n     */\r\n    public static IsPluginForExtensionAvailable(extension: string): boolean {\r\n        return isPluginForExtensionAvailable(extension);\r\n    }\r\n\r\n    /**\r\n     * Adds a new plugin to the list of registered plugins\r\n     * @param plugin defines the plugin to add\r\n     */\r\n    public static RegisterPlugin(plugin: ISceneLoaderPlugin | ISceneLoaderPluginAsync | ISceneLoaderPluginFactory): void {\r\n        registerSceneLoaderPlugin(plugin);\r\n    }\r\n\r\n    /**\r\n     * Import meshes into a scene\r\n     * @param meshNames an array of mesh names, a single mesh name, or empty string for all meshes that filter what meshes are imported\r\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n     * @param scene the instance of BABYLON.Scene to append to\r\n     * @param onSuccess a callback with a list of imported meshes, particleSystems, skeletons, and animationGroups when import succeeds\r\n     * @param onProgress a callback with a progress event for each file being loaded\r\n     * @param onError a callback with the scene, a message, and possibly an exception when import fails\r\n     * @param pluginExtension the extension used to determine the plugin\r\n     * @param name defines the name of the file, if the data is binary\r\n     * @deprecated Please use ImportMeshAsync instead\r\n     */\r\n    public static ImportMesh(\r\n        meshNames: string | readonly string[] | null | undefined,\r\n        rootUrl: string,\r\n        sceneFilename?: SceneSource,\r\n        scene?: Nullable<Scene>,\r\n        onSuccess?: Nullable<SceneLoaderSuccessCallback>,\r\n        onProgress?: Nullable<(event: ISceneLoaderProgressEvent) => void>,\r\n        onError?: Nullable<(scene: Scene, message: string, exception?: any) => void>,\r\n        pluginExtension?: Nullable<string>,\r\n        name?: string\r\n    ): void {\r\n        importMeshAsync(meshNames, rootUrl, sceneFilename, scene, onSuccess, onProgress, onError, pluginExtension, name);\r\n    }\r\n\r\n    /**\r\n     * Import meshes into a scene\r\n     * @param meshNames an array of mesh names, a single mesh name, or empty string for all meshes that filter what meshes are imported\r\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n     * @param scene the instance of BABYLON.Scene to append to\r\n     * @param onProgress a callback with a progress event for each file being loaded\r\n     * @param pluginExtension the extension used to determine the plugin\r\n     * @param name defines the name of the file\r\n     * @returns The loaded list of imported meshes, particle systems, skeletons, and animation groups\r\n     */\r\n    public static ImportMeshAsync(\r\n        meshNames: string | readonly string[] | null | undefined,\r\n        rootUrl: string,\r\n        sceneFilename?: SceneSource,\r\n        scene?: Nullable<Scene>,\r\n        onProgress?: Nullable<(event: ISceneLoaderProgressEvent) => void>,\r\n        pluginExtension?: Nullable<string>,\r\n        name?: string\r\n    ): Promise<ISceneLoaderAsyncResult> {\r\n        return importMeshAsyncCore(meshNames, rootUrl, sceneFilename, scene, onProgress, pluginExtension, name);\r\n    }\r\n\r\n    /**\r\n     * Load a scene\r\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n     * @param engine is the instance of BABYLON.Engine to use to create the scene\r\n     * @param onSuccess a callback with the scene when import succeeds\r\n     * @param onProgress a callback with a progress event for each file being loaded\r\n     * @param onError a callback with the scene, a message, and possibly an exception when import fails\r\n     * @param pluginExtension the extension used to determine the plugin\r\n     * @param name defines the filename, if the data is binary\r\n     * @deprecated Please use LoadAsync instead\r\n     */\r\n    public static Load(\r\n        rootUrl: string,\r\n        sceneFilename?: SceneSource,\r\n        engine?: Nullable<AbstractEngine>,\r\n        onSuccess?: Nullable<(scene: Scene) => void>,\r\n        onProgress?: Nullable<(event: ISceneLoaderProgressEvent) => void>,\r\n        onError?: Nullable<(scene: Scene, message: string, exception?: any) => void>,\r\n        pluginExtension?: Nullable<string>,\r\n        name?: string\r\n    ) {\r\n        loadScene(rootUrl, sceneFilename, engine, onSuccess, onProgress, onError, pluginExtension, name);\r\n    }\r\n\r\n    /**\r\n     * Load a scene\r\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n     * @param engine is the instance of BABYLON.Engine to use to create the scene\r\n     * @param onProgress a callback with a progress event for each file being loaded\r\n     * @param pluginExtension the extension used to determine the plugin\r\n     * @param name defines the filename, if the data is binary\r\n     * @returns The loaded scene\r\n     */\r\n    public static LoadAsync(\r\n        rootUrl: string,\r\n        sceneFilename?: SceneSource,\r\n        engine?: Nullable<AbstractEngine>,\r\n        onProgress?: Nullable<(event: ISceneLoaderProgressEvent) => void>,\r\n        pluginExtension?: Nullable<string>,\r\n        name?: string\r\n    ): Promise<Scene> {\r\n        return loadSceneAsyncCore(rootUrl, sceneFilename, engine, onProgress, pluginExtension, name);\r\n    }\r\n\r\n    /**\r\n     * Append a scene\r\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n     * @param scene is the instance of BABYLON.Scene to append to\r\n     * @param onSuccess a callback with the scene when import succeeds\r\n     * @param onProgress a callback with a progress event for each file being loaded\r\n     * @param onError a callback with the scene, a message, and possibly an exception when import fails\r\n     * @param pluginExtension the extension used to determine the plugin\r\n     * @param name defines the name of the file, if the data is binary\r\n     * @deprecated Please use AppendAsync instead\r\n     */\r\n    public static Append(\r\n        rootUrl: string,\r\n        sceneFilename?: SceneSource,\r\n        scene?: Nullable<Scene>,\r\n        onSuccess?: Nullable<(scene: Scene) => void>,\r\n        onProgress?: Nullable<(event: ISceneLoaderProgressEvent) => void>,\r\n        onError?: Nullable<(scene: Scene, message: string, exception?: any) => void>,\r\n        pluginExtension?: Nullable<string>,\r\n        name?: string\r\n    ) {\r\n        appendAsync(rootUrl, sceneFilename, scene, onSuccess, onProgress, onError, pluginExtension, name);\r\n    }\r\n\r\n    /**\r\n     * Append a scene\r\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n     * @param scene is the instance of BABYLON.Scene to append to\r\n     * @param onProgress a callback with a progress event for each file being loaded\r\n     * @param pluginExtension the extension used to determine the plugin\r\n     * @param name defines the name of the file, if the data is binary\r\n     * @returns The given scene\r\n     */\r\n    public static AppendAsync(\r\n        rootUrl: string,\r\n        sceneFilename?: SceneSource,\r\n        scene?: Nullable<Scene>,\r\n        onProgress?: Nullable<(event: ISceneLoaderProgressEvent) => void>,\r\n        pluginExtension?: Nullable<string>,\r\n        name?: string\r\n    ): Promise<Scene> {\r\n        return appendSceneAsyncCore(rootUrl, sceneFilename, scene, onProgress, pluginExtension, name);\r\n    }\r\n\r\n    /**\r\n     * Load a scene into an asset container\r\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n     * @param scene is the instance of BABYLON.Scene to append to (default: last created scene)\r\n     * @param onSuccess a callback with the scene when import succeeds\r\n     * @param onProgress a callback with a progress event for each file being loaded\r\n     * @param onError a callback with the scene, a message, and possibly an exception when import fails\r\n     * @param pluginExtension the extension used to determine the plugin\r\n     * @param name defines the filename, if the data is binary\r\n     * @deprecated Please use LoadAssetContainerAsync instead\r\n     */\r\n    public static LoadAssetContainer(\r\n        rootUrl: string,\r\n        sceneFilename?: SceneSource,\r\n        scene?: Nullable<Scene>,\r\n        onSuccess?: Nullable<(assets: AssetContainer) => void>,\r\n        onProgress?: Nullable<(event: ISceneLoaderProgressEvent) => void>,\r\n        onError?: Nullable<(scene: Scene, message: string, exception?: any) => void>,\r\n        pluginExtension?: Nullable<string>,\r\n        name?: string\r\n    ) {\r\n        loadAssetContainerCoreAsync(rootUrl, sceneFilename, scene, onSuccess, onProgress, onError, pluginExtension, name);\r\n    }\r\n\r\n    /**\r\n     * Load a scene into an asset container\r\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene (default: empty string)\r\n     * @param scene is the instance of Scene to append to\r\n     * @param onProgress a callback with a progress event for each file being loaded\r\n     * @param pluginExtension the extension used to determine the plugin\r\n     * @param name defines the filename, if the data is binary\r\n     * @returns The loaded asset container\r\n     */\r\n    public static LoadAssetContainerAsync(\r\n        rootUrl: string,\r\n        sceneFilename?: SceneSource,\r\n        scene?: Nullable<Scene>,\r\n        onProgress?: Nullable<(event: ISceneLoaderProgressEvent) => void>,\r\n        pluginExtension?: Nullable<string>,\r\n        name?: string\r\n    ): Promise<AssetContainer> {\r\n        return internalLoadAssetContainerAsync(rootUrl, sceneFilename, scene, onProgress, pluginExtension, name);\r\n    }\r\n\r\n    /**\r\n     * Import animations from a file into a scene\r\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n     * @param scene is the instance of BABYLON.Scene to append to (default: last created scene)\r\n     * @param overwriteAnimations when true, animations are cleaned before importing new ones. Animations are appended otherwise\r\n     * @param animationGroupLoadingMode defines how to handle old animations groups before importing new ones\r\n     * @param targetConverter defines a function used to convert animation targets from loaded scene to current scene (default: search node by name)\r\n     * @param onSuccess a callback with the scene when import succeeds\r\n     * @param onProgress a callback with a progress event for each file being loaded\r\n     * @param onError a callback with the scene, a message, and possibly an exception when import fails\r\n     * @param pluginExtension the extension used to determine the plugin\r\n     * @param name defines the filename, if the data is binary\r\n     * @deprecated Please use ImportAnimationsAsync instead\r\n     */\r\n    public static ImportAnimations(\r\n        rootUrl: string,\r\n        sceneFilename?: SceneSource,\r\n        scene?: Nullable<Scene>,\r\n        overwriteAnimations?: boolean,\r\n        animationGroupLoadingMode?: SceneLoaderAnimationGroupLoadingMode,\r\n        targetConverter?: Nullable<(target: any) => any>,\r\n        onSuccess?: Nullable<(scene: Scene) => void>,\r\n        onProgress?: Nullable<(event: ISceneLoaderProgressEvent) => void>,\r\n        onError?: Nullable<(scene: Scene, message: string, exception?: any) => void>,\r\n        pluginExtension?: Nullable<string>,\r\n        name?: string\r\n    ): void {\r\n        importAnimations(rootUrl, sceneFilename, scene, overwriteAnimations, animationGroupLoadingMode, targetConverter, onSuccess, onProgress, onError, pluginExtension, name);\r\n    }\r\n\r\n    /**\r\n     * Import animations from a file into a scene\r\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n     * @param scene is the instance of BABYLON.Scene to append to (default: last created scene)\r\n     * @param overwriteAnimations when true, animations are cleaned before importing new ones. Animations are appended otherwise\r\n     * @param animationGroupLoadingMode defines how to handle old animations groups before importing new ones\r\n     * @param targetConverter defines a function used to convert animation targets from loaded scene to current scene (default: search node by name)\r\n     * @param onSuccess a callback with the scene when import succeeds\r\n     * @param onProgress a callback with a progress event for each file being loaded\r\n     * @param onError a callback with the scene, a message, and possibly an exception when import fails\r\n     * @param pluginExtension the extension used to determine the plugin\r\n     * @param name defines the filename, if the data is binary\r\n     * @returns the updated scene with imported animations\r\n     */\r\n    public static ImportAnimationsAsync(\r\n        rootUrl: string,\r\n        sceneFilename?: SceneSource,\r\n        scene?: Nullable<Scene>,\r\n        overwriteAnimations?: boolean,\r\n        animationGroupLoadingMode?: SceneLoaderAnimationGroupLoadingMode,\r\n        targetConverter?: Nullable<(target: any) => any>,\r\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n        onSuccess?: Nullable<(scene: Scene) => void>,\r\n        onProgress?: Nullable<(event: ISceneLoaderProgressEvent) => void>,\r\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n        onError?: Nullable<(scene: Scene, message: string, exception?: any) => void>,\r\n        pluginExtension?: Nullable<string>,\r\n        name?: string\r\n    ): Promise<Scene> {\r\n        return importAnimationsAsyncCore(rootUrl, sceneFilename, scene, overwriteAnimations, animationGroupLoadingMode, targetConverter, onProgress, pluginExtension, name);\r\n    }\r\n}\r\n"]}