{"version":3,"file":"greasedLinePluginMaterialShadersGLSL.js","sourceRoot":"","sources":["../../../../../dev/core/src/Materials/GreasedLine/greasedLinePluginMaterialShadersGLSL.ts"],"names":[],"mappings":"AAGA;;;;;GAKG;AACH,gBAAgB;AAChB,MAAM,UAAU,aAAa,CAAC,UAAkB,EAAE,YAAqB;IACnE,IAAI,UAAU,KAAK,QAAQ,EAAE,CAAC;QAC1B,MAAM,GAAG,GAAQ;YACb,yBAAyB,EAAE;;;;;;;;;;;;;;;;;;;;iBAoBtB;YACL,6BAA6B,EAAE;;;;;;;iBAO1B;YACL,sBAAsB,EAAE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iBAyDnB;SACR,CAAC;QACF,YAAY,IAAI,CAAC,GAAG,CAAC,2CAA2C,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC,mCAAmC;QAC9G,OAAO,GAAG,CAAC;IACf,CAAC;IAED,IAAI,UAAU,KAAK,UAAU,EAAE,CAAC;QAC5B,OAAO;YACH,2BAA2B,EAAE;;;;;;;;;;iBAUxB;YACL,gCAAgC,EAAE;;;;;;;;;;;;;;;;;;;;8CAoBA,+CAAuC;;qDAEhC,+CAAuC;;qDAEvC,oDAA4C;;;;;;;;;;;kDAW/C,+CAAuC;;yDAEhC,+CAAuC;;yDAEvC,oDAA4C;;;;;iBAKpF;SACR,CAAC;IACN,CAAC;IAED,OAAO,IAAI,CAAC;AAChB,CAAC","sourcesContent":["import type { Nullable } from \"../../types\";\nimport { GreasedLineMeshColorMode } from \"./greasedLineMaterialInterfaces\";\n\n/**\n * Returns GLSL custom shader code\n * @param shaderType vertex or fragment\n * @param cameraFacing is in camera facing mode?\n * @returns GLSL custom shader code\n */\n/** @internal */\nexport function GetCustomCode(shaderType: string, cameraFacing: boolean): Nullable<{ [pointName: string]: string }> {\n    if (shaderType === \"vertex\") {\n        const obj: any = {\n            CUSTOM_VERTEX_DEFINITIONS: `\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                `,\n            CUSTOM_VERTEX_UPDATE_POSITION: `\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                `,\n            CUSTOM_VERTEX_MAIN_END: `\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated, 1.0);\n                    vec4 grlPrevPos = grlMatrix * vec4(grlPrevious + grlPositionOffset, 1.0);\n                    vec4 grlNextPos = grlMatrix * vec4(grlNext + grlPositionOffset, 1.0);\n\n                    vec2 grlCurrentP = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlPrevP = grlFix(grlPrevPos, grlAspect);\n                    vec2 grlNextP = grlFix(grlNextPos, grlAspect);\n\n                    float grlWidth = grlBaseWidth * grl_widths;\n\n                    vec2 grlDir;\n                    if (grlNextP == grlCurrentP) {\n                        grlDir = normalize(grlCurrentP - grlPrevP);\n                    } else if (grlPrevP == grlCurrentP) {\n                        grlDir = normalize(grlNextP - grlCurrentP);\n                    } else {\n                        vec2 grlDir1 = normalize(grlCurrentP - grlPrevP);\n                        vec2 grlDir2 = normalize(grlNextP - grlCurrentP);\n                        grlDir = normalize(grlDir1 + grlDir2);\n                    }\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                `,\n        };\n        cameraFacing && (obj[\"!gl_Position\\\\=viewProjection\\\\*worldPos;\"] = \"//\"); // not needed for camera facing GRL\n        return obj;\n    }\n\n    if (shaderType === \"fragment\") {\n        return {\n            CUSTOM_FRAGMENT_DEFINITIONS: `\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                `,\n            CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR: `\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == ${GreasedLineMeshColorMode.COLOR_MODE_SET}.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == ${GreasedLineMeshColorMode.COLOR_MODE_ADD}.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == ${GreasedLineMeshColorMode.COLOR_MODE_MULTIPLY}.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == ${GreasedLineMeshColorMode.COLOR_MODE_SET}.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == ${GreasedLineMeshColorMode.COLOR_MODE_ADD}.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == ${GreasedLineMeshColorMode.COLOR_MODE_MULTIPLY}.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                `,\n        };\n    }\n\n    return null;\n}\n"]}