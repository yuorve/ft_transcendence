{"version":3,"file":"greasedLinePluginMaterialShadersWGSL.js","sourceRoot":"","sources":["../../../../../dev/core/src/Materials/GreasedLine/greasedLinePluginMaterialShadersWGSL.ts"],"names":[],"mappings":"AAGA;;;;;GAKG;AACH,gBAAgB;AAChB,MAAM,UAAU,aAAa,CAAC,UAAkB,EAAE,YAAqB;IACnE,IAAI,UAAU,KAAK,QAAQ,EAAE,CAAC;QAC1B,MAAM,GAAG,GAAQ;YACb,yBAAyB,EAAE;;;;;;;;;;;;;;;;;;;;;;;;;iBAyBtB;YACL,6BAA6B,EAAE;;;;;;;;;;;;iBAY1B;YACL,sBAAsB,EAAE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iBAgEnB;SACR,CAAC;QAEF,YAAY,IAAI,CAAC,GAAG,CAAC,0EAA0E,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC,mCAAmC;QAC7I,OAAO,GAAG,CAAC;IACf,CAAC;IAED,IAAI,UAAU,KAAK,UAAU,EAAE,CAAC;QAC5B,OAAO;YACH,2BAA2B,EAAE;;;;;;;;;;;;iBAYxB;YACL,gCAAgC,EAAE;;;;;;;;;;;;;;;;;;;;;;;;;;8CA0BA,+CAAuC;;qDAEhC,+CAAuC;;qDAEvC,oDAA4C;;;;;;;;;;;kDAW/C,+CAAuC;;yDAEhC,+CAAuC;;yDAEvC,oDAA4C;;;;;;;iBAOpF;SACR,CAAC;IACN,CAAC;IAED,OAAO,IAAI,CAAC;AAChB,CAAC","sourcesContent":["import type { Nullable } from \"../../types\";\nimport { GreasedLineMeshColorMode } from \"./greasedLineMaterialInterfaces\";\n\n/**\n * Returns WGSL custom shader code\n * @param shaderType vertex or fragment\n * @param cameraFacing is in camera facing mode?\n * @returns WGSL custom shader code\n */\n/** @internal */\nexport function GetCustomCode(shaderType: string, cameraFacing: boolean): Nullable<{ [pointName: string]: string }> {\n    if (shaderType === \"vertex\") {\n        const obj: any = {\n            CUSTOM_VERTEX_DEFINITIONS: `\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                `,\n            CUSTOM_VERTEX_UPDATE_POSITION: `\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                `,\n            CUSTOM_VERTEX_MAIN_END: `\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    var grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0);\n                    let grlPrevPos: vec4f = grlMatrix * vec4f(grlPrevious + grlPositionOffset, 1.0);\n                    let grlNextPos: vec4f = grlMatrix * vec4f(grlNext + grlPositionOffset, 1.0);\n\n                    let grlCurrentP: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlPrevP: vec2f = grlFix(grlPrevPos, grlAspect);\n                    let grlNextP: vec2f = grlFix(grlNextPos, grlAspect);\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    var grlDir: vec2f;\n                    if (all(grlNextP == grlCurrentP)) {\n                        grlDir = normalize(grlCurrentP - grlPrevP);\n                    } else if (all(grlPrevP == grlCurrentP)) {\n                        grlDir = normalize(grlNextP - grlCurrentP);\n                    } else {\n                        let grlDir1: vec2f = normalize(grlCurrentP - grlPrevP);\n                        let grlDir2: vec2f = normalize(grlNextP - grlCurrentP);\n                        grlDir = normalize(grlDir1 + grlDir2);\n                    }\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                `,\n        };\n\n        cameraFacing && (obj[\"!vertexOutputs\\\\.position\\\\s=\\\\sscene\\\\.viewProjection\\\\s\\\\*\\\\sworldPos;\"] = \"//\"); // not needed for camera facing GRL\n        return obj;\n    }\n\n    if (shaderType === \"fragment\") {\n        return {\n            CUSTOM_FRAGMENT_DEFINITIONS: `\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                `,\n            CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR: `\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == ${GreasedLineMeshColorMode.COLOR_MODE_SET}.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == ${GreasedLineMeshColorMode.COLOR_MODE_ADD}.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == ${GreasedLineMeshColorMode.COLOR_MODE_MULTIPLY}.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == ${GreasedLineMeshColorMode.COLOR_MODE_SET}.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == ${GreasedLineMeshColorMode.COLOR_MODE_ADD}.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == ${GreasedLineMeshColorMode.COLOR_MODE_MULTIPLY}.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                `,\n        };\n    }\n\n    return null;\n}\n"]}