{"version":3,"file":"exrLoader.decoder.js","sourceRoot":"","sources":["../../../../../../../dev/core/src/Materials/Textures/Loaders/EXR/exrLoader.decoder.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,gBAAgB,EAAE,aAAa,EAAE,YAAY,EAAE,YAAY,EAAE,UAAU,EAAE,UAAU,EAAE,WAAW,EAAE,WAAW,EAAE,MAAM,kBAAkB,CAAC;AACjJ,OAAO,EAAE,aAAa,EAAE,aAAa,EAAE,aAAa,EAAE,aAAa,EAAE,aAAa,EAAE,MAAM,yBAAyB,CAAC;AACpH,OAAO,EAAE,YAAY,EAAE,UAAU,EAAqC,MAAM,wBAAwB,CAAC;AACrG,OAAO,EAAE,SAAS,EAAE,yCAA+B;AACnD,OAAO,EAAE,KAAK,EAAE,kCAAwB;AACxC,OAAO,EAAE,4BAA4B,EAAE,aAAa,EAAE,MAAM,2BAA2B,CAAC;AAExF;;;;GAIG;AAEH,KAAK;AACL,0CAA0C;AAC1C,uBAAuB;AAEvB,qEAAqE;AACrE,8EAA8E;AAC9E,uEAAuE;AACvE,sEAAsE;AACtE,0EAA0E;AAC1E,4EAA4E;AAC5E,6EAA6E;AAC7E,qDAAqD;AACrD,6EAA6E;AAC7E,8EAA8E;AAE9E,kFAAkF;AAClF,gFAAgF;AAChF,yEAAyE;AACzE,qEAAqE;AACrE,6EAA6E;AAC7E,+EAA+E;AAC/E,8EAA8E;AAC9E,6EAA6E;AAC7E,gFAAgF;AAChF,+DAA+D;AAC/D,KAAK;AAEL,8EAA8E;AAE9E,8EAA8E;AAC9E,KAAK;AACL,uEAAuE;AACvE,sBAAsB;AACtB,KAAK;AACL,0BAA0B;AAC1B,KAAK;AACL,wEAAwE;AACxE,4EAA4E;AAC5E,UAAU;AACV,4EAA4E;AAC5E,mEAAmE;AACnE,qEAAqE;AACrE,4EAA4E;AAC5E,mEAAmE;AACnE,mBAAmB;AACnB,2EAA2E;AAC3E,yEAAyE;AACzE,mEAAmE;AACnE,KAAK;AACL,yEAAyE;AACzE,uEAAuE;AACvE,2EAA2E;AAC3E,0EAA0E;AAC1E,2EAA2E;AAC3E,sEAAsE;AACtE,2EAA2E;AAC3E,2EAA2E;AAC3E,yEAAyE;AACzE,2EAA2E;AAC3E,0EAA0E;AAC1E,KAAK;AACL,8EAA8E;AAE9E,8EAA8E;AAE9E;;;;;;;GAOG;AACH,MAAM,CAAC,KAAK,UAAU,kBAAkB,CAAC,MAAkB,EAAE,QAAkB,EAAE,MAAkB,EAAE,UAAyB;IAC1H,MAAM,OAAO,GAAgB;QACzB,IAAI,EAAE,CAAC;QACP,MAAM,EAAE,QAAQ;QAChB,KAAK,EAAE,IAAI,UAAU,CAAC,QAAQ,CAAC,MAAM,CAAC;QACtC,MAAM,EAAE,MAAM;QACd,KAAK,EAAE,MAAM,CAAC,UAAU,CAAC,IAAI,GAAG,MAAM,CAAC,UAAU,CAAC,IAAI,GAAG,CAAC;QAC1D,MAAM,EAAE,MAAM,CAAC,UAAU,CAAC,IAAI,GAAG,MAAM,CAAC,UAAU,CAAC,IAAI,GAAG,CAAC;QAC3D,QAAQ,EAAE,MAAM,CAAC,QAAQ,CAAC,MAAM;QAChC,kBAAkB,EAAE,EAAE;QACtB,SAAS,EAAE,GAAG,EAAE,CAAC,CAAC;QAClB,YAAY,EAAE,CAAC;QACf,YAAY,EAAE,CAAC;QACf,KAAK,EAAE,CAAC;QACR,iBAAiB,EAAE,CAAC;QACpB,SAAS,EAAE,IAAI;QACf,IAAI,EAAE,CAAC;QACP,UAAU,EAAE,IAAI;QAChB,MAAM,EAAE,GAAG,EAAE,CAAC,CAAC;QACf,MAAM,EAAE,SAAS,CAAC,kBAAkB;QACpC,cAAc,EAAE,CAAC;QACjB,cAAc,EAAE,EAAE;QAClB,UAAU,EAAE,IAAI;QAChB,SAAS,EAAE,IAAI;QACf,WAAW,EAAE,KAAK;QAClB,WAAW,EAAE,CAAC;KACjB,CAAC;IAEF,QAAQ,MAAM,CAAC,WAAW,EAAE,CAAC;QACzB,KAAK,gBAAgB,CAAC,cAAc;YAChC,OAAO,CAAC,KAAK,GAAG,CAAC,CAAC;YAClB,OAAO,CAAC,UAAU,GAAG,aAAa,CAAC;YACnC,MAAM;QAEV,KAAK,gBAAgB,CAAC,eAAe;YACjC,OAAO,CAAC,KAAK,GAAG,CAAC,CAAC;YAClB,OAAO,CAAC,UAAU,GAAG,aAAa,CAAC;YACnC,MAAM;QAEV,KAAK,gBAAgB,CAAC,gBAAgB;YAClC,OAAO,CAAC,KAAK,GAAG,CAAC,CAAC;YAClB,OAAO,CAAC,UAAU,GAAG,aAAa,CAAC;YACnC,MAAM,KAAK,CAAC,eAAe,CAAC,4BAA4B,CAAC,SAAS,CAAC,CAAC;YACpE,MAAM;QAEV,KAAK,gBAAgB,CAAC,eAAe;YACjC,OAAO,CAAC,KAAK,GAAG,EAAE,CAAC;YACnB,OAAO,CAAC,UAAU,GAAG,aAAa,CAAC;YACnC,MAAM,KAAK,CAAC,eAAe,CAAC,4BAA4B,CAAC,SAAS,CAAC,CAAC;YACpE,MAAM;QAEV,KAAK,gBAAgB,CAAC,eAAe;YACjC,OAAO,CAAC,KAAK,GAAG,EAAE,CAAC;YACnB,OAAO,CAAC,UAAU,GAAG,aAAa,CAAC;YACnC,MAAM;QAEV,KAAK,gBAAgB,CAAC,iBAAiB;YACnC,OAAO,CAAC,KAAK,GAAG,EAAE,CAAC;YACnB,OAAO,CAAC,UAAU,GAAG,aAAa,CAAC;YACnC,MAAM,KAAK,CAAC,eAAe,CAAC,4BAA4B,CAAC,SAAS,CAAC,CAAC;YACpE,MAAM;QAEV;YACI,MAAM,IAAI,KAAK,CAAC,gBAAgB,CAAC,MAAM,CAAC,WAAW,CAAC,GAAG,iBAAiB,CAAC,CAAC;IAClF,CAAC;IAED,OAAO,CAAC,iBAAiB,GAAG,OAAO,CAAC,KAAK,CAAC;IAE1C,MAAM,QAAQ,GAEV,EAAE,CAAC;IACP,KAAK,MAAM,OAAO,IAAI,MAAM,CAAC,QAAQ,EAAE,CAAC;QACpC,QAAQ,OAAO,CAAC,IAAI,EAAE,CAAC;YACnB,KAAK,GAAG,CAAC;YACT,KAAK,GAAG,CAAC;YACT,KAAK,GAAG,CAAC;YACT,KAAK,GAAG,CAAC;YACT,KAAK,GAAG;gBACJ,QAAQ,CAAC,OAAO,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC;gBAC9B,OAAO,CAAC,IAAI,GAAG,OAAO,CAAC,SAAS,CAAC;QACzC,CAAC;IACL,CAAC;IAED,gGAAgG;IAChG,IAAI,SAAS,GAAG,KAAK,CAAC;IAEtB,IAAI,QAAQ,CAAC,CAAC,IAAI,QAAQ,CAAC,CAAC,IAAI,QAAQ,CAAC,CAAC,EAAE,CAAC;QACzC,SAAS,GAAG,CAAC,QAAQ,CAAC,CAAC,CAAC;QACxB,OAAO,CAAC,cAAc,GAAG,CAAC,CAAC;QAC3B,OAAO,CAAC,cAAc,GAAG,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC;IACxD,CAAC;SAAM,IAAI,QAAQ,CAAC,CAAC,EAAE,CAAC;QACpB,OAAO,CAAC,cAAc,GAAG,CAAC,CAAC;QAC3B,OAAO,CAAC,cAAc,GAAG,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC;IACtC,CAAC;SAAM,CAAC;QACJ,MAAM,IAAI,KAAK,CAAC,2DAA2D,CAAC,CAAC;IACjF,CAAC;IAED,IAAI,OAAO,CAAC,IAAI,KAAK,CAAC,EAAE,CAAC;QACrB,OAAO;QACP,QAAQ,UAAU,EAAE,CAAC;YACjB,KAAK,aAAa,CAAC,KAAK;gBACpB,OAAO,CAAC,MAAM,GAAG,YAAY,CAAC;gBAC9B,OAAO,CAAC,SAAS,GAAG,UAAU,CAAC;gBAC/B,MAAM;YAEV,KAAK,aAAa,CAAC,SAAS;gBACxB,OAAO,CAAC,MAAM,GAAG,WAAW,CAAC;gBAC7B,OAAO,CAAC,SAAS,GAAG,UAAU,CAAC;gBAC/B,MAAM;QACd,CAAC;IACL,CAAC;SAAM,IAAI,OAAO,CAAC,IAAI,KAAK,CAAC,EAAE,CAAC;QAC5B,QAAQ;QACR,QAAQ,UAAU,EAAE,CAAC;YACjB,KAAK,aAAa,CAAC,KAAK;gBACpB,OAAO,CAAC,MAAM,GAAG,YAAY,CAAC;gBAC9B,OAAO,CAAC,SAAS,GAAG,YAAY,CAAC;gBACjC,MAAM;YAEV,KAAK,aAAa,CAAC,SAAS;gBACxB,OAAO,CAAC,MAAM,GAAG,aAAa,CAAC;gBAC/B,OAAO,CAAC,SAAS,GAAG,YAAY,CAAC;QACzC,CAAC;IACL,CAAC;SAAM,CAAC;QACJ,MAAM,IAAI,KAAK,CAAC,wBAAwB,GAAG,OAAO,CAAC,IAAI,GAAG,OAAO,GAAG,MAAM,CAAC,WAAW,CAAC,CAAC;IAC5F,CAAC;IAED,OAAO,CAAC,UAAU,GAAG,OAAO,CAAC,MAAM,GAAG,OAAO,CAAC,iBAAiB,CAAC;IAEhE,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC,UAAU,EAAE,CAAC,EAAE,EAAE,CAAC;QAC1C,UAAU,CAAC,QAAQ,EAAE,MAAM,CAAC,CAAC,CAAC,iBAAiB;IACnD,CAAC;IAED,oFAAoF;IACpF,MAAM,IAAI,GAAG,OAAO,CAAC,KAAK,GAAG,OAAO,CAAC,MAAM,GAAG,OAAO,CAAC,cAAc,CAAC;IAErE,QAAQ,UAAU,EAAE,CAAC;QACjB,KAAK,aAAa,CAAC,KAAK;YACpB,OAAO,CAAC,SAAS,GAAG,IAAI,YAAY,CAAC,IAAI,CAAC,CAAC;YAC3C,OAAO,CAAC,WAAW,GAAG,SAAS,CAAC,iBAAiB,CAAC;YAElD,wGAAwG;YACxG,IAAI,SAAS,EAAE,CAAC;gBACZ,OAAO,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC,EAAE,CAAC,EAAE,IAAI,CAAC,CAAC;YACvC,CAAC;YAED,MAAM;QAEV,KAAK,aAAa,CAAC,SAAS;YACxB,OAAO,CAAC,SAAS,GAAG,IAAI,WAAW,CAAC,IAAI,CAAC,CAAC;YAC1C,OAAO,CAAC,WAAW,GAAG,SAAS,CAAC,sBAAsB,CAAC;YAEvD,IAAI,SAAS,EAAE,CAAC;gBACZ,OAAO,CAAC,SAAS,CAAC,IAAI,CAAC,MAAM,EAAE,CAAC,EAAE,IAAI,CAAC,CAAC,CAAC,iDAAiD;YAC9F,CAAC;YAED,MAAM;QAEV;YACI,MAAM,IAAI,KAAK,CAAC,oBAAoB,GAAG,UAAU,CAAC,CAAC;IAC3D,CAAC;IAED,IAAI,UAAU,GAAG,CAAC,CAAC;IACnB,KAAK,MAAM,OAAO,IAAI,MAAM,CAAC,QAAQ,EAAE,CAAC;QACpC,IAAI,OAAO,CAAC,cAAc,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK,SAAS,EAAE,CAAC;YACrD,OAAO,CAAC,kBAAkB,CAAC,OAAO,CAAC,IAAI,CAAC,GAAG,UAAU,GAAG,OAAO,CAAC,KAAK,CAAC;QAC1E,CAAC;QAED,UAAU,IAAI,OAAO,CAAC,SAAS,GAAG,CAAC,CAAC;IACxC,CAAC;IAED,OAAO,CAAC,YAAY,GAAG,OAAO,CAAC,KAAK,GAAG,UAAU,CAAC;IAClD,OAAO,CAAC,YAAY,GAAG,OAAO,CAAC,KAAK,GAAG,OAAO,CAAC,cAAc,CAAC;IAE9D,IAAI,MAAM,CAAC,SAAS,KAAK,cAAc,EAAE,CAAC;QACtC,OAAO,CAAC,SAAS,GAAG,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC;IACjC,CAAC;SAAM,CAAC;QACJ,OAAO,CAAC,SAAS,GAAG,CAAC,CAAC,EAAE,EAAE,CAAC,OAAO,CAAC,MAAM,GAAG,CAAC,GAAG,CAAC,CAAC;IACtD,CAAC;IAED,IAAI,OAAO,CAAC,cAAc,IAAI,CAAC,EAAE,CAAC;QAC9B,OAAO,CAAC,MAAM,GAAG,SAAS,CAAC,kBAAkB,CAAC;QAC9C,OAAO,CAAC,WAAW,GAAG,IAAI,CAAC;IAC/B,CAAC;SAAM,CAAC;QACJ,OAAO,CAAC,MAAM,GAAG,SAAS,CAAC,eAAe,CAAC;QAC3C,OAAO,CAAC,WAAW,GAAG,KAAK,CAAC;IAChC,CAAC;IAED,OAAO,OAAO,CAAC;AACnB,CAAC;AAED;;;;;;GAMG;AACH,MAAM,UAAU,QAAQ,CAAC,OAAoB,EAAE,MAAkB,EAAE,QAAkB,EAAE,MAAkB;IACrG,MAAM,SAAS,GAAG,EAAE,KAAK,EAAE,CAAC,EAAE,CAAC;IAE/B,KAAK,IAAI,gBAAgB,GAAG,CAAC,EAAE,gBAAgB,GAAG,OAAO,CAAC,MAAM,GAAG,OAAO,CAAC,iBAAiB,EAAE,gBAAgB,EAAE,EAAE,CAAC;QAC/G,MAAM,IAAI,GAAG,UAAU,CAAC,QAAQ,EAAE,MAAM,CAAC,GAAG,MAAM,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC,UAAU;QAC9E,OAAO,CAAC,IAAI,GAAG,WAAW,CAAC,QAAQ,EAAE,MAAM,CAAC,CAAC,CAAC,WAAW;QACzD,OAAO,CAAC,KAAK,GAAG,IAAI,GAAG,OAAO,CAAC,iBAAiB,GAAG,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,OAAO,CAAC,MAAM,GAAG,IAAI,CAAC,CAAC,CAAC,OAAO,CAAC,iBAAiB,CAAC;QAEtH,MAAM,YAAY,GAAG,OAAO,CAAC,IAAI,GAAG,OAAO,CAAC,KAAK,GAAG,OAAO,CAAC,YAAY,CAAC;QACzE,MAAM,MAAM,GAAG,YAAY,IAAI,OAAO,CAAC,UAAU,CAAC,CAAC,CAAC,OAAO,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,aAAa,CAAC,OAAO,CAAC,CAAC;QAEzG,MAAM,CAAC,KAAK,IAAI,OAAO,CAAC,IAAI,CAAC;QAE7B,KAAK,IAAI,MAAM,GAAG,CAAC,EAAE,MAAM,GAAG,OAAO,CAAC,iBAAiB,EAAE,MAAM,EAAE,EAAE,CAAC;YAChE,MAAM,MAAM,GAAG,gBAAgB,GAAG,OAAO,CAAC,iBAAiB,CAAC;YAC5D,MAAM,MAAM,GAAG,MAAM,GAAG,OAAO,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC;YAClD,IAAI,MAAM,IAAI,OAAO,CAAC,MAAM,EAAE,CAAC;gBAC3B,SAAS;YACb,CAAC;YAED,MAAM,UAAU,GAAG,MAAM,GAAG,OAAO,CAAC,YAAY,CAAC;YACjD,MAAM,aAAa,GAAG,CAAC,OAAO,CAAC,MAAM,GAAG,CAAC,GAAG,MAAM,CAAC,GAAG,OAAO,CAAC,YAAY,CAAC;YAE3E,KAAK,IAAI,SAAS,GAAG,CAAC,EAAE,SAAS,GAAG,OAAO,CAAC,QAAQ,EAAE,SAAS,EAAE,EAAE,CAAC;gBAChE,MAAM,IAAI,GAAG,MAAM,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC,IAAI,CAAC;gBAC7C,MAAM,IAAI,GAAG,OAAO,CAAC,kBAAkB,CAAC,IAAI,CAAC,CAAC;gBAC9C,MAAM,IAAI,GAAG,OAAO,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC;gBAE1C,IAAI,IAAI,KAAK,SAAS,EAAE,CAAC;oBACrB,SAAS;gBACb,CAAC;gBAED,SAAS,CAAC,KAAK,GAAG,UAAU,GAAG,IAAI,CAAC;gBAEpC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC,KAAK,EAAE,CAAC,EAAE,EAAE,CAAC;oBACrC,MAAM,QAAQ,GAAG,aAAa,GAAG,CAAC,GAAG,OAAO,CAAC,cAAc,GAAG,IAAI,CAAC;oBACnE,IAAI,OAAO,CAAC,SAAS,EAAE,CAAC;wBACpB,OAAO,CAAC,SAAS,CAAC,QAAQ,CAAC,GAAG,OAAO,CAAC,MAAM,CAAC,MAAM,EAAE,SAAS,CAAC,CAAC;oBACpE,CAAC;gBACL,CAAC;YACL,CAAC;QACL,CAAC;IACL,CAAC;AACL,CAAC","sourcesContent":["import type { DataCursor } from \"./exrLoader.core\";\r\nimport { CompressionCodes, DecodeFloat32, ParseFloat16, ParseFloat32, ParseInt32, ParseInt64, ParseUint16, ParseUint32 } from \"./exrLoader.core\";\r\nimport { UncompressPIZ, UncompressPXR, UncompressRAW, UncompressRLE, UncompressZIP } from \"./exrLoader.compression\";\r\nimport { FLOAT32_SIZE, INT16_SIZE, type IEXRDecoder, type IEXRHeader } from \"./exrLoader.interfaces\";\r\nimport { Constants } from \"core/Engines/constants\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport { ExrLoaderGlobalConfiguration, EXROutputType } from \"./exrLoader.configuration\";\r\n\r\n/**\r\n * Inspired by https://github.com/sciecode/three.js/blob/dev/examples/jsm/loaders/EXRLoader.js\r\n * Referred to the original Industrial Light & Magic OpenEXR implementation and the TinyEXR / Syoyo Fujita\r\n * implementation.\r\n */\r\n\r\n// /*\r\n// Copyright (c) 2014 - 2017, Syoyo Fujita\r\n// All rights reserved.\r\n\r\n// Redistribution and use in source and binary forms, with or without\r\n// modification, are permitted provided that the following conditions are met:\r\n//     * Redistributions of source code must retain the above copyright\r\n//       notice, this list of conditions and the following disclaimer.\r\n//     * Redistributions in binary form must reproduce the above copyright\r\n//       notice, this list of conditions and the following disclaimer in the\r\n//       documentation and/or other materials provided with the distribution.\r\n//     * Neither the name of the Syoyo Fujita nor the\r\n//       names of its contributors may be used to endorse or promote products\r\n//       derived from this software without specific prior written permission.\r\n\r\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\r\n// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n// DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\r\n// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\r\n// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\r\n// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\r\n// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\r\n// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n// */\r\n\r\n// // TinyEXR contains some OpenEXR code, which is licensed under ------------\r\n\r\n// ///////////////////////////////////////////////////////////////////////////\r\n// //\r\n// // Copyright (c) 2002, Industrial Light & Magic, a division of Lucas\r\n// // Digital Ltd. LLC\r\n// //\r\n// // All rights reserved.\r\n// //\r\n// // Redistribution and use in source and binary forms, with or without\r\n// // modification, are permitted provided that the following conditions are\r\n// // met:\r\n// // *       Redistributions of source code must retain the above copyright\r\n// // notice, this list of conditions and the following disclaimer.\r\n// // *       Redistributions in binary form must reproduce the above\r\n// // copyright notice, this list of conditions and the following disclaimer\r\n// // in the documentation and/or other materials provided with the\r\n// // distribution.\r\n// // *       Neither the name of Industrial Light & Magic nor the names of\r\n// // its contributors may be used to endorse or promote products derived\r\n// // from this software without specific prior written permission.\r\n// //\r\n// // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\r\n// // \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\r\n// // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\r\n// // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\r\n// // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n// // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\r\n// // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\r\n// // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\r\n// // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n// // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\r\n// // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n// //\r\n// ///////////////////////////////////////////////////////////////////////////\r\n\r\n// // End of OpenEXR license -------------------------------------------------\r\n\r\n/**\r\n * Create a decoder for the exr file\r\n * @param header header of the exr file\r\n * @param dataView dataview of the exr file\r\n * @param offset current offset\r\n * @param outputType expected output type (float or half float)\r\n * @returns a promise that resolves with the decoder\r\n */\r\nexport async function CreateDecoderAsync(header: IEXRHeader, dataView: DataView, offset: DataCursor, outputType: EXROutputType): Promise<IEXRDecoder> {\r\n    const decoder: IEXRDecoder = {\r\n        size: 0,\r\n        viewer: dataView,\r\n        array: new Uint8Array(dataView.buffer),\r\n        offset: offset,\r\n        width: header.dataWindow.xMax - header.dataWindow.xMin + 1,\r\n        height: header.dataWindow.yMax - header.dataWindow.yMin + 1,\r\n        channels: header.channels.length,\r\n        channelLineOffsets: {},\r\n        scanOrder: () => 0,\r\n        bytesPerLine: 0,\r\n        outLineWidth: 0,\r\n        lines: 0,\r\n        scanlineBlockSize: 0,\r\n        inputSize: null,\r\n        type: 0,\r\n        uncompress: null,\r\n        getter: () => 0,\r\n        format: Constants.TEXTUREFORMAT_RGBA,\r\n        outputChannels: 0,\r\n        decodeChannels: {},\r\n        blockCount: null,\r\n        byteArray: null,\r\n        linearSpace: false,\r\n        textureType: 0,\r\n    };\r\n\r\n    switch (header.compression) {\r\n        case CompressionCodes.NO_COMPRESSION:\r\n            decoder.lines = 1;\r\n            decoder.uncompress = UncompressRAW;\r\n            break;\r\n\r\n        case CompressionCodes.RLE_COMPRESSION:\r\n            decoder.lines = 1;\r\n            decoder.uncompress = UncompressRLE;\r\n            break;\r\n\r\n        case CompressionCodes.ZIPS_COMPRESSION:\r\n            decoder.lines = 1;\r\n            decoder.uncompress = UncompressZIP;\r\n            await Tools.LoadScriptAsync(ExrLoaderGlobalConfiguration.FFLATEUrl);\r\n            break;\r\n\r\n        case CompressionCodes.ZIP_COMPRESSION:\r\n            decoder.lines = 16;\r\n            decoder.uncompress = UncompressZIP;\r\n            await Tools.LoadScriptAsync(ExrLoaderGlobalConfiguration.FFLATEUrl);\r\n            break;\r\n\r\n        case CompressionCodes.PIZ_COMPRESSION:\r\n            decoder.lines = 32;\r\n            decoder.uncompress = UncompressPIZ;\r\n            break;\r\n\r\n        case CompressionCodes.PXR24_COMPRESSION:\r\n            decoder.lines = 16;\r\n            decoder.uncompress = UncompressPXR;\r\n            await Tools.LoadScriptAsync(ExrLoaderGlobalConfiguration.FFLATEUrl);\r\n            break;\r\n\r\n        default:\r\n            throw new Error(CompressionCodes[header.compression] + \" is unsupported\");\r\n    }\r\n\r\n    decoder.scanlineBlockSize = decoder.lines;\r\n\r\n    const channels: {\r\n        [key: string]: boolean;\r\n    } = {};\r\n    for (const channel of header.channels) {\r\n        switch (channel.name) {\r\n            case \"Y\":\r\n            case \"R\":\r\n            case \"G\":\r\n            case \"B\":\r\n            case \"A\":\r\n                channels[channel.name] = true;\r\n                decoder.type = channel.pixelType;\r\n        }\r\n    }\r\n\r\n    // RGB images will be converted to RGBA format, preventing software emulation in select devices.\r\n    let fillAlpha = false;\r\n\r\n    if (channels.R && channels.G && channels.B) {\r\n        fillAlpha = !channels.A;\r\n        decoder.outputChannels = 4;\r\n        decoder.decodeChannels = { R: 0, G: 1, B: 2, A: 3 };\r\n    } else if (channels.Y) {\r\n        decoder.outputChannels = 1;\r\n        decoder.decodeChannels = { Y: 0 };\r\n    } else {\r\n        throw new Error(\"EXRLoader.parse: file contains unsupported data channels.\");\r\n    }\r\n\r\n    if (decoder.type === 1) {\r\n        // half\r\n        switch (outputType) {\r\n            case EXROutputType.Float:\r\n                decoder.getter = ParseFloat16;\r\n                decoder.inputSize = INT16_SIZE;\r\n                break;\r\n\r\n            case EXROutputType.HalfFloat:\r\n                decoder.getter = ParseUint16;\r\n                decoder.inputSize = INT16_SIZE;\r\n                break;\r\n        }\r\n    } else if (decoder.type === 2) {\r\n        // float\r\n        switch (outputType) {\r\n            case EXROutputType.Float:\r\n                decoder.getter = ParseFloat32;\r\n                decoder.inputSize = FLOAT32_SIZE;\r\n                break;\r\n\r\n            case EXROutputType.HalfFloat:\r\n                decoder.getter = DecodeFloat32;\r\n                decoder.inputSize = FLOAT32_SIZE;\r\n        }\r\n    } else {\r\n        throw new Error(\"Unsupported pixelType \" + decoder.type + \" for \" + header.compression);\r\n    }\r\n\r\n    decoder.blockCount = decoder.height / decoder.scanlineBlockSize;\r\n\r\n    for (let i = 0; i < decoder.blockCount; i++) {\r\n        ParseInt64(dataView, offset); // scanlineOffset\r\n    }\r\n\r\n    // we should be passed the scanline offset table, ready to start reading pixel data.\r\n    const size = decoder.width * decoder.height * decoder.outputChannels;\r\n\r\n    switch (outputType) {\r\n        case EXROutputType.Float:\r\n            decoder.byteArray = new Float32Array(size);\r\n            decoder.textureType = Constants.TEXTURETYPE_FLOAT;\r\n\r\n            // Fill initially with 1s for the alpha value if the texture is not RGBA, RGB values will be overwritten\r\n            if (fillAlpha) {\r\n                decoder.byteArray.fill(1, 0, size);\r\n            }\r\n\r\n            break;\r\n\r\n        case EXROutputType.HalfFloat:\r\n            decoder.byteArray = new Uint16Array(size);\r\n            decoder.textureType = Constants.TEXTURETYPE_HALF_FLOAT;\r\n\r\n            if (fillAlpha) {\r\n                decoder.byteArray.fill(0x3c00, 0, size); // Uint16Array holds half float data, 0x3C00 is 1\r\n            }\r\n\r\n            break;\r\n\r\n        default:\r\n            throw new Error(\"Unsupported type: \" + outputType);\r\n    }\r\n\r\n    let byteOffset = 0;\r\n    for (const channel of header.channels) {\r\n        if (decoder.decodeChannels[channel.name] !== undefined) {\r\n            decoder.channelLineOffsets[channel.name] = byteOffset * decoder.width;\r\n        }\r\n\r\n        byteOffset += channel.pixelType * 2;\r\n    }\r\n\r\n    decoder.bytesPerLine = decoder.width * byteOffset;\r\n    decoder.outLineWidth = decoder.width * decoder.outputChannels;\r\n\r\n    if (header.lineOrder === \"INCREASING_Y\") {\r\n        decoder.scanOrder = (y) => y;\r\n    } else {\r\n        decoder.scanOrder = (y) => decoder.height - 1 - y;\r\n    }\r\n\r\n    if (decoder.outputChannels == 4) {\r\n        decoder.format = Constants.TEXTUREFORMAT_RGBA;\r\n        decoder.linearSpace = true;\r\n    } else {\r\n        decoder.format = Constants.TEXTUREFORMAT_R;\r\n        decoder.linearSpace = false;\r\n    }\r\n\r\n    return decoder;\r\n}\r\n\r\n/**\r\n * Scan the data of the exr file\r\n * @param decoder decoder to use\r\n * @param header header of the exr file\r\n * @param dataView dataview of the exr file\r\n * @param offset current offset\r\n */\r\nexport function ScanData(decoder: IEXRDecoder, header: IEXRHeader, dataView: DataView, offset: DataCursor): void {\r\n    const tmpOffset = { value: 0 };\r\n\r\n    for (let scanlineBlockIdx = 0; scanlineBlockIdx < decoder.height / decoder.scanlineBlockSize; scanlineBlockIdx++) {\r\n        const line = ParseInt32(dataView, offset) - header.dataWindow.yMin; // line_no\r\n        decoder.size = ParseUint32(dataView, offset); // data_len\r\n        decoder.lines = line + decoder.scanlineBlockSize > decoder.height ? decoder.height - line : decoder.scanlineBlockSize;\r\n\r\n        const isCompressed = decoder.size < decoder.lines * decoder.bytesPerLine;\r\n        const viewer = isCompressed && decoder.uncompress ? decoder.uncompress(decoder) : UncompressRAW(decoder);\r\n\r\n        offset.value += decoder.size;\r\n\r\n        for (let line_y = 0; line_y < decoder.scanlineBlockSize; line_y++) {\r\n            const scan_y = scanlineBlockIdx * decoder.scanlineBlockSize;\r\n            const true_y = line_y + decoder.scanOrder(scan_y);\r\n            if (true_y >= decoder.height) {\r\n                continue;\r\n            }\r\n\r\n            const lineOffset = line_y * decoder.bytesPerLine;\r\n            const outLineOffset = (decoder.height - 1 - true_y) * decoder.outLineWidth;\r\n\r\n            for (let channelID = 0; channelID < decoder.channels; channelID++) {\r\n                const name = header.channels[channelID].name;\r\n                const lOff = decoder.channelLineOffsets[name];\r\n                const cOff = decoder.decodeChannels[name];\r\n\r\n                if (cOff === undefined) {\r\n                    continue;\r\n                }\r\n\r\n                tmpOffset.value = lineOffset + lOff;\r\n\r\n                for (let x = 0; x < decoder.width; x++) {\r\n                    const outIndex = outLineOffset + x * decoder.outputChannels + cOff;\r\n                    if (decoder.byteArray) {\r\n                        decoder.byteArray[outIndex] = decoder.getter(viewer, tmpOffset);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n"]}