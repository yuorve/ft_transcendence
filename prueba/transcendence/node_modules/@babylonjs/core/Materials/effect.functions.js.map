{"version":3,"file":"effect.functions.js","sourceRoot":"","sources":["../../../../dev/core/src/Materials/effect.functions.ts"],"names":[],"mappings":"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","sourcesContent":["import type { ProcessingOptions, ShaderCustomProcessingFunction, ShaderProcessingContext } from \"core/Engines/Processors/shaderProcessingOptions\";\r\nimport { GetDOMTextContent, IsWindowObjectExist } from \"core/Misc/domManagement\";\r\nimport type { Nullable } from \"core/types\";\r\nimport { ShaderLanguage } from \"./shaderLanguage\";\r\nimport type { WebGLContext } from \"core/Engines/thinEngine.functions\";\r\nimport { getStateObject } from \"core/Engines/thinEngine.functions\";\r\nimport { ShaderStore } from \"core/Engines/shaderStore\";\r\nimport type { AbstractEngine } from \"core/Engines/abstractEngine\";\r\nimport type { Effect, IShaderPath } from \"./effect\";\r\nimport type { IPipelineContext } from \"core/Engines/IPipelineContext\";\r\nimport { Logger } from \"core/Misc/logger\";\r\nimport { Finalize, Initialize, Process } from \"core/Engines/Processors/shaderProcessor\";\r\nimport { _loadFile } from \"core/Engines/abstractEngine.functions\";\r\nimport type { WebGLPipelineContext } from \"core/Engines/WebGL/webGLPipelineContext\";\r\n\r\n/**\r\n * Options to be used when creating a pipeline\r\n */\r\nexport interface IPipelineGenerationOptions {\r\n    /**\r\n     * The definition of the shader content.\r\n     * Can be either a unified name, name per vertex and frament or the shader code content itself\r\n     */\r\n    shaderNameOrContent: string | IShaderPath;\r\n    /**\r\n     * Unique key to identify the pipeline.\r\n     * Note that though not mandatory, it's recommended to provide a key to be able to use the automated pipeline loading system.\r\n     */\r\n    key?: string;\r\n    /**\r\n     * The list of defines to be used in the shader\r\n     */\r\n    defines?: string[];\r\n\r\n    /**\r\n     * If true, the global defines will be added to the defines array\r\n     */\r\n    addGlobalDefines?: boolean;\r\n    /**\r\n     * The shader language.\r\n     * Defaults to the language suiting the platform name (GLSL for WEBGL2, WGSL for WEBGPU)\r\n     */\r\n    shaderLanguage?: ShaderLanguage;\r\n\r\n    /**\r\n     * The name of the platform to be used when processing the shader\r\n     * defaults to WEBGL2\r\n     */\r\n    platformName?: string /* \"WEBGL2\" | \"WEBGL1\" | \"WEBGPU\" */;\r\n\r\n    /**\r\n     * extend the processing options when running code processing\r\n     */\r\n    extendedProcessingOptions?: Partial<ProcessingOptions>;\r\n\r\n    /**\r\n     * extend the pipeline generation options\r\n     */\r\n    extendedCreatePipelineOptions?: Partial<ICreateAndPreparePipelineContextOptions>;\r\n\r\n    /**\r\n     * If true, generating a new pipeline will return when the pipeline is ready to be used\r\n     */\r\n    waitForIsReady?: boolean;\r\n\r\n    /**\r\n     * If true, the pipeline will be created synchronously, even if parallel shader compilation is available\r\n     */\r\n    disableParallelCompilation?: boolean;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport interface ICreateAndPreparePipelineContextOptions {\r\n    parallelShaderCompile?: { COMPLETION_STATUS_KHR: number };\r\n    shaderProcessingContext: Nullable<ShaderProcessingContext>;\r\n    existingPipelineContext?: Nullable<IPipelineContext>;\r\n    name?: string;\r\n    rebuildRebind?: (vertexSourceCode: string, fragmentSourceCode: string, onCompiled: (pipelineContext: IPipelineContext) => void, onError: (message: string) => void) => void;\r\n    onRenderingStateCompiled?: (pipelineContext?: IPipelineContext) => void;\r\n    context?: WebGL2RenderingContext | WebGLRenderingContext;\r\n    // preparePipeline options\r\n    createAsRaw?: boolean;\r\n    vertex: string;\r\n    fragment: string;\r\n    defines: Nullable<string>;\r\n    transformFeedbackVaryings: Nullable<string[]>;\r\n    disableParallelCompilation?: boolean;\r\n}\r\n\r\n/**\r\n * Get a cached pipeline context\r\n * @param name the pipeline name\r\n * @param context the context to be used when creating the pipeline\r\n * @returns the cached pipeline context if it exists\r\n * @internal\r\n */\r\nexport function getCachedPipeline(name: string, context: WebGLContext): IPipelineContext | undefined {\r\n    const stateObject = getStateObject(context);\r\n    return stateObject.cachedPipelines[name];\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function resetCachedPipeline(pipeline: IPipelineContext): void {\r\n    const name = pipeline._name;\r\n    const context = (pipeline as WebGLPipelineContext).context;\r\n    if (name && context) {\r\n        const stateObject = getStateObject(context!);\r\n        const cachedPipeline = stateObject.cachedPipelines[name];\r\n        cachedPipeline?.dispose();\r\n        delete stateObject.cachedPipelines[name];\r\n    }\r\n}\r\n\r\n/** @internal */\r\nexport function _processShaderCode(\r\n    processorOptions: ProcessingOptions,\r\n    baseName: any,\r\n    processFinalCode?: Nullable<ShaderCustomProcessingFunction>,\r\n    onFinalCodeReady?: (vertexCode: string, fragmentCode: string) => void,\r\n    shaderLanguage?: ShaderLanguage,\r\n    engine?: AbstractEngine,\r\n    effectContext?: Effect\r\n) {\r\n    let vertexSource: string | HTMLElement | IShaderPath;\r\n    let fragmentSource: string | HTMLElement | IShaderPath;\r\n\r\n    // const baseName = this.name;\r\n    const hostDocument = IsWindowObjectExist() ? engine?.getHostDocument() : null;\r\n\r\n    if (typeof baseName === \"string\") {\r\n        vertexSource = baseName;\r\n    } else if (baseName.vertexSource) {\r\n        vertexSource = \"source:\" + baseName.vertexSource;\r\n    } else if (baseName.vertexElement) {\r\n        vertexSource = hostDocument?.getElementById(baseName.vertexElement) || baseName.vertexElement;\r\n    } else {\r\n        vertexSource = baseName.vertex || baseName;\r\n    }\r\n    if (typeof baseName === \"string\") {\r\n        fragmentSource = baseName;\r\n    } else if (baseName.fragmentSource) {\r\n        fragmentSource = \"source:\" + baseName.fragmentSource;\r\n    } else if (baseName.fragmentElement) {\r\n        fragmentSource = hostDocument?.getElementById(baseName.fragmentElement) || baseName.fragmentElement;\r\n    } else {\r\n        fragmentSource = baseName.fragment || baseName;\r\n    }\r\n\r\n    const shaderCodes: [string | undefined, string | undefined] = [undefined, undefined];\r\n    const shadersLoaded = () => {\r\n        if (shaderCodes[0] && shaderCodes[1]) {\r\n            processorOptions.isFragment = true;\r\n            const [migratedVertexCode, fragmentCode] = shaderCodes;\r\n            Process(\r\n                fragmentCode,\r\n                processorOptions,\r\n                (migratedFragmentCode, codeBeforeMigration) => {\r\n                    if (effectContext) {\r\n                        effectContext._fragmentSourceCodeBeforeMigration = codeBeforeMigration;\r\n                    }\r\n                    if (processFinalCode) {\r\n                        migratedFragmentCode = processFinalCode(\"fragment\", migratedFragmentCode);\r\n                    }\r\n                    const finalShaders = Finalize(migratedVertexCode, migratedFragmentCode, processorOptions);\r\n                    processorOptions = null as any;\r\n                    const finalCode = _useFinalCode(finalShaders.vertexCode, finalShaders.fragmentCode, baseName, shaderLanguage);\r\n                    onFinalCodeReady?.(finalCode.vertexSourceCode, finalCode.fragmentSourceCode);\r\n                },\r\n                engine\r\n            );\r\n        }\r\n    };\r\n    _loadShader(\r\n        vertexSource,\r\n        \"Vertex\",\r\n        \"\",\r\n        (vertexCode) => {\r\n            Initialize(processorOptions);\r\n            Process(\r\n                vertexCode,\r\n                processorOptions,\r\n                (migratedVertexCode, codeBeforeMigration) => {\r\n                    if (effectContext) {\r\n                        effectContext._rawVertexSourceCode = vertexCode;\r\n                        effectContext._vertexSourceCodeBeforeMigration = codeBeforeMigration;\r\n                    }\r\n                    if (processFinalCode) {\r\n                        migratedVertexCode = processFinalCode(\"vertex\", migratedVertexCode);\r\n                    }\r\n                    shaderCodes[0] = migratedVertexCode;\r\n                    shadersLoaded();\r\n                },\r\n                engine\r\n            );\r\n        },\r\n        shaderLanguage\r\n    );\r\n    _loadShader(\r\n        fragmentSource,\r\n        \"Fragment\",\r\n        \"Pixel\",\r\n        (fragmentCode) => {\r\n            if (effectContext) {\r\n                effectContext._rawFragmentSourceCode = fragmentCode;\r\n            }\r\n            shaderCodes[1] = fragmentCode;\r\n            shadersLoaded();\r\n        },\r\n        shaderLanguage\r\n    );\r\n}\r\n\r\nfunction _loadShader(shader: any, key: string, optionalKey: string, callback: (data: any) => void, shaderLanguage?: ShaderLanguage, _loadFileInjection?: typeof _loadFile) {\r\n    if (typeof HTMLElement !== \"undefined\") {\r\n        // DOM element ?\r\n        if (shader instanceof HTMLElement) {\r\n            const shaderCode = GetDOMTextContent(shader);\r\n            callback(shaderCode);\r\n            return;\r\n        }\r\n    }\r\n\r\n    // Direct source ?\r\n    if (shader.substring(0, 7) === \"source:\") {\r\n        callback(shader.substring(7));\r\n        return;\r\n    }\r\n\r\n    // Base64 encoded ?\r\n    if (shader.substring(0, 7) === \"base64:\") {\r\n        const shaderBinary = window.atob(shader.substring(7));\r\n        callback(shaderBinary);\r\n        return;\r\n    }\r\n\r\n    const shaderStore = ShaderStore.GetShadersStore(shaderLanguage);\r\n\r\n    // Is in local store ?\r\n    if (shaderStore[shader + key + \"Shader\"]) {\r\n        callback(shaderStore[shader + key + \"Shader\"]);\r\n        return;\r\n    }\r\n\r\n    if (optionalKey && shaderStore[shader + optionalKey + \"Shader\"]) {\r\n        callback(shaderStore[shader + optionalKey + \"Shader\"]);\r\n        return;\r\n    }\r\n\r\n    let shaderUrl;\r\n\r\n    if (shader[0] === \".\" || shader[0] === \"/\" || shader.indexOf(\"http\") > -1) {\r\n        shaderUrl = shader;\r\n    } else {\r\n        shaderUrl = ShaderStore.GetShadersRepository(shaderLanguage) + shader;\r\n    }\r\n    _loadFileInjection = _loadFileInjection || _loadFile;\r\n    if (!_loadFileInjection) {\r\n        // we got to this point and loadFile was not injected - throw an error\r\n        throw new Error(\"loadFileInjection is not defined\");\r\n    }\r\n    // Vertex shader\r\n    _loadFileInjection(shaderUrl + \".\" + key.toLowerCase() + \".fx\", callback);\r\n}\r\n\r\nfunction _useFinalCode(migratedVertexCode: string, migratedFragmentCode: string, baseName: any, shaderLanguage?: ShaderLanguage) {\r\n    if (baseName) {\r\n        const vertex = baseName.vertexElement || baseName.vertex || baseName.spectorName || baseName;\r\n        const fragment = baseName.fragmentElement || baseName.fragment || baseName.spectorName || baseName;\r\n\r\n        return {\r\n            vertexSourceCode: (shaderLanguage === ShaderLanguage.WGSL ? \"//\" : \"\") + \"#define SHADER_NAME vertex:\" + vertex + \"\\n\" + migratedVertexCode,\r\n            fragmentSourceCode: (shaderLanguage === ShaderLanguage.WGSL ? \"//\" : \"\") + \"#define SHADER_NAME fragment:\" + fragment + \"\\n\" + migratedFragmentCode,\r\n        };\r\n    } else {\r\n        return {\r\n            vertexSourceCode: migratedVertexCode,\r\n            fragmentSourceCode: migratedFragmentCode,\r\n        };\r\n    }\r\n}\r\n\r\n/**\r\n * Creates and prepares a pipeline context\r\n * @internal\r\n */\r\nexport const createAndPreparePipelineContext = (\r\n    options: ICreateAndPreparePipelineContextOptions,\r\n    createPipelineContext: typeof AbstractEngine.prototype.createPipelineContext,\r\n    _preparePipelineContext: typeof AbstractEngine.prototype._preparePipelineContext,\r\n    _executeWhenRenderingStateIsCompiled: typeof AbstractEngine.prototype._executeWhenRenderingStateIsCompiled\r\n): IPipelineContext => {\r\n    try {\r\n        const stateObject = options.context ? getStateObject(options.context) : null;\r\n        if (stateObject) {\r\n            // will not remove the reference to parallelShaderPrecompile, but will prevent it from being used in the next shader compilation\r\n            stateObject.disableParallelShaderCompile = options.disableParallelCompilation;\r\n        }\r\n        const pipelineContext: IPipelineContext = options.existingPipelineContext || createPipelineContext(options.shaderProcessingContext);\r\n        pipelineContext._name = options.name;\r\n        if (options.name && stateObject) {\r\n            stateObject.cachedPipelines[options.name] = pipelineContext;\r\n        }\r\n\r\n        // Flagged as async as we may need to delay load some processing tools\r\n        // This does not break anything as the execution is waiting for _executeWhenRenderingStateIsCompiled\r\n        _preparePipelineContext(\r\n            pipelineContext,\r\n            options.vertex,\r\n            options.fragment,\r\n            !!options.createAsRaw,\r\n            \"\",\r\n            \"\",\r\n            options.rebuildRebind,\r\n            options.defines,\r\n            options.transformFeedbackVaryings,\r\n            \"\",\r\n            () => {\r\n                _executeWhenRenderingStateIsCompiled(pipelineContext, () => {\r\n                    options.onRenderingStateCompiled?.(pipelineContext);\r\n                });\r\n            }\r\n        );\r\n\r\n        return pipelineContext;\r\n    } catch (e) {\r\n        Logger.Error(\"Error compiling effect\");\r\n        throw e;\r\n    }\r\n};\r\n"]}