{"version":3,"file":"tools.internals.js","sourceRoot":"","sources":["../../../../dev/core/src/Misc/tools.internals.ts"],"names":[],"mappings":"AAAA,yDAAyD;AACzD;;GAEG;AAEH,OAAO,EAAE,mBAAmB,EAAE,MAAM,iBAAiB,CAAC;AACtD,OAAO,EAAE,KAAK,EAAE,MAAM,SAAS,CAAC;AAEhC,IAAI,gBAAgB,GAAG,CAAC,CAAC;AAEzB;;;;;;;;GAQG;AACH,MAAM,UAAU,sBAAsB,CAAC,SAAiB,EAAE,QAAiB;IACvE,OAAO,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;QACnC,eAAe;QACf,IAAI,WAAgB,CAAC;QACrB,IAAI,YAAoB,CAAC;QAEzB,IAAI,mBAAmB,EAAE,EAAE,CAAC;YACxB,WAAW,GAAG,MAAM,CAAC;YACrB,YAAY,GAAG,QAAQ,CAAC;QAC5B,CAAC;aAAM,IAAI,OAAO,IAAI,KAAK,WAAW,EAAE,CAAC;YACrC,WAAW,GAAG,IAAI,CAAC;YACnB,YAAY,GAAG,MAAM,CAAC;QAC1B,CAAC;aAAM,CAAC;YACJ,MAAM,CAAC,IAAI,KAAK,CAAC,2DAA2D,CAAC,CAAC,CAAC;YAC/E,OAAO;QACX,CAAC;QAED,IAAI,CAAC,WAAW,CAAC,wBAAwB,EAAE,CAAC;YACxC,WAAW,CAAC,wBAAwB,GAAG,EAAE,CAAC;QAC9C,CAAC;QACD,WAAW,CAAC,wBAAwB,CAAC,gBAAgB,CAAC,GAAG,OAAO,CAAC;QAEjE,SAAS,IAAI;cACP,YAAY,6BAA6B,gBAAgB;cACzD,YAAY,6BAA6B,gBAAgB;SAC9D,CAAC;QACF,gBAAgB,EAAE,CAAC;QAEnB,KAAK,CAAC,UAAU,CACZ,SAAS,EACT,SAAS,EACT,CAAC,OAAO,EAAE,SAAS,EAAE,EAAE;YACnB,MAAM,CAAC,SAAS,IAAI,IAAI,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC;QAC5C,CAAC,EACD,QAAQ,EACR,IAAI,CACP,CAAC;IACN,CAAC,CAAC,CAAC;AACP,CAAC","sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\r\n/**\r\n * This file is only for internal use only and should not be used in your code\r\n */\r\n\r\nimport { IsWindowObjectExist } from \"./domManagement\";\r\nimport { Tools } from \"./tools\";\r\n\r\nlet _UniqueResolveID = 0;\r\n\r\n/**\r\n * Load an asynchronous script (identified by an url) in a module way. When the url returns, the\r\n * content of this file is added into a new script element, attached to the DOM (body element)\r\n * @param scriptUrl defines the url of the script to load\r\n * @param scriptId defines the id of the script element\r\n * @returns a promise request object\r\n * It is up to the caller to provide a script that will do the import and prepare a \"returnedValue\" variable\r\n * @internal DO NOT USE outside of Babylon.js core\r\n */\r\nexport function _LoadScriptModuleAsync(scriptUrl: string, scriptId?: string): Promise<any> {\r\n    return new Promise((resolve, reject) => {\r\n        // Need a relay\r\n        let windowAsAny: any;\r\n        let windowString: string;\r\n\r\n        if (IsWindowObjectExist()) {\r\n            windowAsAny = window;\r\n            windowString = \"window\";\r\n        } else if (typeof self !== \"undefined\") {\r\n            windowAsAny = self;\r\n            windowString = \"self\";\r\n        } else {\r\n            reject(new Error(\"Cannot load script module outside of a window or a worker\"));\r\n            return;\r\n        }\r\n\r\n        if (!windowAsAny._LoadScriptModuleResolve) {\r\n            windowAsAny._LoadScriptModuleResolve = {};\r\n        }\r\n        windowAsAny._LoadScriptModuleResolve[_UniqueResolveID] = resolve;\r\n\r\n        scriptUrl += `\r\n            ${windowString}._LoadScriptModuleResolve[${_UniqueResolveID}](returnedValue);\r\n            ${windowString}._LoadScriptModuleResolve[${_UniqueResolveID}] = undefined;\r\n        `;\r\n        _UniqueResolveID++;\r\n\r\n        Tools.LoadScript(\r\n            scriptUrl,\r\n            undefined,\r\n            (message, exception) => {\r\n                reject(exception || new Error(message));\r\n            },\r\n            scriptId,\r\n            true\r\n        );\r\n    });\r\n}\r\n"]}