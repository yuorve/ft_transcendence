{"version":3,"file":"iblShadowsVoxelTracingPass.js","sourceRoot":"","sources":["../../../../../dev/core/src/Rendering/IBLShadows/iblShadowsVoxelTracingPass.ts"],"names":[],"mappings":"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","sourcesContent":["import { Constants } from \"../../Engines/constants\";\r\nimport type { AbstractEngine } from \"../../Engines/abstractEngine\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Matrix, Vector4 } from \"../../Maths/math.vector\";\r\nimport { PostProcess } from \"../../PostProcesses/postProcess\";\r\nimport type { PostProcessOptions } from \"../../PostProcesses/postProcess\";\r\nimport type { IblShadowsRenderPipeline } from \"./iblShadowsRenderPipeline\";\r\nimport type { Camera } from \"../../Cameras/camera\";\r\nimport { ShaderLanguage } from \"core/Materials/shaderLanguage\";\r\nimport { GeometryBufferRenderer } from \"../../Rendering/geometryBufferRenderer\";\r\nimport { ProceduralTexture } from \"core/Materials/Textures/Procedurals/proceduralTexture\";\r\nimport type { IProceduralTextureCreationOptions } from \"core/Materials/Textures/Procedurals/proceduralTexture\";\r\nimport type { CubeTexture } from \"../../Materials/Textures/cubeTexture\";\r\n\r\n/**\r\n * Build cdf maps for IBL importance sampling during IBL shadow computation.\r\n * This should not be instanciated directly, as it is part of a scene component\r\n * @internal\r\n */\r\nexport class _IblShadowsVoxelTracingPass {\r\n    private _scene: Scene;\r\n    private _engine: AbstractEngine;\r\n    private _renderPipeline: IblShadowsRenderPipeline;\r\n    private _voxelShadowOpacity: number = 1.0;\r\n    /**\r\n     * The opacity of the shadow cast from the voxel grid\r\n     */\r\n    public get voxelShadowOpacity(): number {\r\n        return this._voxelShadowOpacity;\r\n    }\r\n    /**\r\n     * The opacity of the shadow cast from the voxel grid\r\n     */\r\n    public set voxelShadowOpacity(value: number) {\r\n        this._voxelShadowOpacity = value;\r\n    }\r\n    private _sssSamples: number = 16;\r\n    private _sssStride: number = 8;\r\n    private _sssMaxDist: number = 0.05;\r\n    private _sssThickness: number = 0.5;\r\n\r\n    private _ssShadowOpacity: number = 1.0;\r\n    /**\r\n     * The opacity of the screen-space shadow\r\n     */\r\n    public get ssShadowOpacity(): number {\r\n        return this._ssShadowOpacity;\r\n    }\r\n    /**\r\n     * The opacity of the screen-space shadow\r\n     */\r\n    public set ssShadowOpacity(value: number) {\r\n        this._ssShadowOpacity = value;\r\n    }\r\n\r\n    /**\r\n     * The number of samples used in the screen space shadow pass.\r\n     */\r\n    public get sssSamples(): number {\r\n        return this._sssSamples;\r\n    }\r\n\r\n    /**\r\n     * The number of samples used in the screen space shadow pass.\r\n     */\r\n    public set sssSamples(value: number) {\r\n        this._sssSamples = value;\r\n    }\r\n\r\n    /**\r\n     * The stride used in the screen space shadow pass. This controls the distance between samples.\r\n     */\r\n    public get sssStride(): number {\r\n        return this._sssStride;\r\n    }\r\n\r\n    /**\r\n     * The stride used in the screen space shadow pass. This controls the distance between samples.\r\n     */\r\n    public set sssStride(value: number) {\r\n        this._sssStride = value;\r\n    }\r\n\r\n    /**\r\n     * The maximum distance that the screen-space shadow will be able to occlude.\r\n     */\r\n    public get sssMaxDist(): number {\r\n        return this._sssMaxDist;\r\n    }\r\n\r\n    /**\r\n     * The maximum distance that the screen-space shadow will be able to occlude.\r\n     */\r\n    public set sssMaxDist(value: number) {\r\n        this._sssMaxDist = value;\r\n    }\r\n\r\n    /**\r\n     * The thickness of the screen-space shadow\r\n     */\r\n    public get sssThickness(): number {\r\n        return this._sssThickness;\r\n    }\r\n\r\n    /**\r\n     * The thickness of the screen-space shadow\r\n     */\r\n    public set sssThickness(value: number) {\r\n        this._sssThickness = value;\r\n    }\r\n\r\n    private _outputTexture: ProceduralTexture;\r\n    private _cameraInvView: Matrix = Matrix.Identity();\r\n    private _cameraInvProj: Matrix = Matrix.Identity();\r\n    private _invWorldScaleMatrix: Matrix = Matrix.Identity();\r\n    private _frameId: number = 0;\r\n    private _sampleDirections: number = 4;\r\n    private _shadowParameters: Vector4 = new Vector4(0.0, 0.0, 0.0, 0.0);\r\n    private _sssParameters: Vector4 = new Vector4(0.0, 0.0, 0.0, 0.0);\r\n    private _opacityParameters: Vector4 = new Vector4(0.0, 0.0, 0.0, 0.0);\r\n    private _voxelBiasParameters: Vector4 = new Vector4(0.0, 0.0, 0.0, 0.0);\r\n    private _voxelNormalBias: number = 1.4;\r\n    /**\r\n     * The bias to apply to the voxel sampling in the direction of the surface normal of the geometry.\r\n     */\r\n    public get voxelNormalBias(): number {\r\n        return this._voxelNormalBias;\r\n    }\r\n    public set voxelNormalBias(value: number) {\r\n        this._voxelNormalBias = value;\r\n    }\r\n\r\n    private _voxelDirectionBias: number = 1.75;\r\n    /**\r\n     * The bias to apply to the voxel sampling in the direction of the light.\r\n     */\r\n    public get voxelDirectionBias(): number {\r\n        return this._voxelDirectionBias;\r\n    }\r\n    public set voxelDirectionBias(value: number) {\r\n        this._voxelDirectionBias = value;\r\n    }\r\n\r\n    /**\r\n     * Is the effect enabled\r\n     */\r\n    public enabled: boolean = true;\r\n\r\n    /**\r\n     * The number of directions to sample for the voxel tracing.\r\n     */\r\n    public get sampleDirections(): number {\r\n        return this._sampleDirections;\r\n    }\r\n\r\n    /**\r\n     * The number of directions to sample for the voxel tracing.\r\n     */\r\n    public set sampleDirections(value: number) {\r\n        this._sampleDirections = value;\r\n    }\r\n\r\n    /**\r\n     * The current rotation of the environment map, in radians.\r\n     */\r\n    public get envRotation(): number {\r\n        return this._envRotation;\r\n    }\r\n\r\n    /**\r\n     * The current rotation of the environment map, in radians.\r\n     */\r\n    public set envRotation(value: number) {\r\n        this._envRotation = value;\r\n    }\r\n\r\n    /** Enable the debug view for this pass */\r\n    public debugEnabled: boolean = false;\r\n\r\n    /**\r\n     * Returns the output texture of the pass.\r\n     * @returns The output texture.\r\n     */\r\n    public getOutputTexture(): ProceduralTexture {\r\n        return this._outputTexture;\r\n    }\r\n\r\n    /**\r\n     * Gets the debug pass post process. This will create the resources for the pass\r\n     * if they don't already exist.\r\n     * @returns The post process\r\n     */\r\n    public getDebugPassPP(): PostProcess {\r\n        if (!this._debugPassPP) {\r\n            this._createDebugPass();\r\n        }\r\n        return this._debugPassPP;\r\n    }\r\n\r\n    private _debugPassName: string = \"Voxel Tracing Debug Pass\";\r\n\r\n    /**\r\n     * The name of the debug pass\r\n     */\r\n    public get debugPassName(): string {\r\n        return this._debugPassName;\r\n    }\r\n\r\n    /** The default rotation of the environment map will align the shadows with the default lighting orientation */\r\n    private _envRotation: number = 0.0;\r\n\r\n    /**\r\n     * Set the matrix to use for scaling the world space to voxel space\r\n     * @param matrix The matrix to use for scaling the world space to voxel space\r\n     */\r\n    public setWorldScaleMatrix(matrix: Matrix) {\r\n        this._invWorldScaleMatrix = matrix;\r\n    }\r\n\r\n    /**\r\n     * Render the shadows in color rather than black and white.\r\n     * This is slightly more expensive than black and white shadows but can be much\r\n     * more accurate when the strongest lights in the IBL are non-white.\r\n     */\r\n    public set coloredShadows(value: boolean) {\r\n        this._coloredShadows = value;\r\n    }\r\n    public get coloredShadows(): boolean {\r\n        return this._coloredShadows;\r\n    }\r\n    private _coloredShadows: boolean = false;\r\n\r\n    private _debugVoxelMarchEnabled: boolean = false;\r\n    private _debugPassPP: PostProcess;\r\n    private _debugSizeParams: Vector4 = new Vector4(0.0, 0.0, 0.0, 0.0);\r\n\r\n    /**\r\n     * Sets params that control the position and scaling of the debug display on the screen.\r\n     * @param x Screen X offset of the debug display (0-1)\r\n     * @param y Screen Y offset of the debug display (0-1)\r\n     * @param widthScale X scale of the debug display (0-1)\r\n     * @param heightScale Y scale of the debug display (0-1)\r\n     */\r\n    public setDebugDisplayParams(x: number, y: number, widthScale: number, heightScale: number) {\r\n        this._debugSizeParams.set(x, y, widthScale, heightScale);\r\n    }\r\n\r\n    /**\r\n     * Creates the debug post process effect for this pass\r\n     */\r\n    private _createDebugPass() {\r\n        const isWebGPU = this._engine.isWebGPU;\r\n        if (!this._debugPassPP) {\r\n            const debugOptions: PostProcessOptions = {\r\n                width: this._engine.getRenderWidth(),\r\n                height: this._engine.getRenderHeight(),\r\n                uniforms: [\"sizeParams\"],\r\n                samplers: [\"debugSampler\"],\r\n                engine: this._engine,\r\n                reusable: true,\r\n                shaderLanguage: isWebGPU ? ShaderLanguage.WGSL : ShaderLanguage.GLSL,\r\n                extraInitializations: (useWebGPU: boolean, list: Promise<any>[]) => {\r\n                    if (useWebGPU) {\r\n                        list.push(import(\"../../ShadersWGSL/iblShadowDebug.fragment\"));\r\n                    } else {\r\n                        list.push(import(\"../../Shaders/iblShadowDebug.fragment\"));\r\n                    }\r\n                },\r\n            };\r\n            this._debugPassPP = new PostProcess(this.debugPassName, \"iblShadowDebug\", debugOptions);\r\n            this._debugPassPP.autoClear = false;\r\n            this._debugPassPP.onApplyObservable.add((effect) => {\r\n                // update the caustic texture with what we just rendered.\r\n                effect.setTexture(\"debugSampler\", this._outputTexture);\r\n                effect.setVector4(\"sizeParams\", this._debugSizeParams);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Instantiates the shadow voxel-tracing pass\r\n     * @param scene Scene to attach to\r\n     * @param iblShadowsRenderPipeline The IBL shadows render pipeline\r\n     * @returns The shadow voxel-tracing pass\r\n     */\r\n    constructor(scene: Scene, iblShadowsRenderPipeline: IblShadowsRenderPipeline) {\r\n        this._scene = scene;\r\n        this._engine = scene.getEngine();\r\n        this._renderPipeline = iblShadowsRenderPipeline;\r\n        this._createTextures();\r\n    }\r\n\r\n    private _createTextures() {\r\n        const defines = this._createDefines();\r\n        const isWebGPU = this._engine.isWebGPU;\r\n        const textureOptions: IProceduralTextureCreationOptions = {\r\n            type: Constants.TEXTURETYPE_UNSIGNED_BYTE,\r\n            format: Constants.TEXTUREFORMAT_RGBA,\r\n            samplingMode: Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n            generateDepthBuffer: false,\r\n            shaderLanguage: isWebGPU ? ShaderLanguage.WGSL : ShaderLanguage.GLSL,\r\n            extraInitializationsAsync: async () => {\r\n                if (isWebGPU) {\r\n                    await Promise.all([import(\"../../ShadersWGSL/iblShadowVoxelTracing.fragment\")]);\r\n                } else {\r\n                    await Promise.all([import(\"../../Shaders/iblShadowVoxelTracing.fragment\")]);\r\n                }\r\n            },\r\n        };\r\n        this._outputTexture = new ProceduralTexture(\r\n            \"voxelTracingPass\",\r\n            {\r\n                width: this._engine.getRenderWidth(),\r\n                height: this._engine.getRenderHeight(),\r\n            },\r\n            \"iblShadowVoxelTracing\",\r\n            this._scene,\r\n            textureOptions\r\n        );\r\n        this._outputTexture.refreshRate = -1;\r\n        this._outputTexture.autoClear = false;\r\n        this._outputTexture.defines = defines;\r\n        // Need to set all the textures first so that the effect gets created with the proper uniforms.\r\n        this._setBindings(this._scene.activeCamera!);\r\n\r\n        let counter = 0;\r\n        this._scene.onBeforeRenderObservable.add(() => {\r\n            counter = 0;\r\n        });\r\n        this._scene.onAfterRenderTargetsRenderObservable.add(() => {\r\n            if (++counter == 2) {\r\n                if (this.enabled && this._outputTexture.isReady()) {\r\n                    this._setBindings(this._scene.activeCamera!);\r\n                    this._outputTexture.render();\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    private _createDefines(): string {\r\n        let defines = \"\";\r\n        if (this._scene.useRightHandedSystem) {\r\n            defines += \"#define RIGHT_HANDED\\n\";\r\n        }\r\n        if (this._debugVoxelMarchEnabled) {\r\n            defines += \"#define VOXEL_MARCH_DIAGNOSTIC_INFO_OPTION 1u\\n\";\r\n        }\r\n        if (this._coloredShadows) {\r\n            defines += \"#define COLOR_SHADOWS 1u\\n\";\r\n        }\r\n        return defines;\r\n    }\r\n\r\n    private _setBindings(camera: Camera) {\r\n        this._outputTexture.defines = this._createDefines();\r\n        this._outputTexture.setMatrix(\"viewMtx\", camera.getViewMatrix());\r\n        this._outputTexture.setMatrix(\"projMtx\", camera.getProjectionMatrix());\r\n        camera.getProjectionMatrix().invertToRef(this._cameraInvProj);\r\n        camera.getViewMatrix().invertToRef(this._cameraInvView);\r\n        this._outputTexture.setMatrix(\"invProjMtx\", this._cameraInvProj);\r\n        this._outputTexture.setMatrix(\"invViewMtx\", this._cameraInvView);\r\n        this._outputTexture.setMatrix(\"wsNormalizationMtx\", this._invWorldScaleMatrix);\r\n\r\n        this._frameId++;\r\n\r\n        let rotation = 0.0;\r\n        if (this._scene.environmentTexture) {\r\n            rotation = (this._scene.environmentTexture as CubeTexture).rotationY ?? 0;\r\n        }\r\n        rotation = this._scene.useRightHandedSystem ? -(rotation + 0.5 * Math.PI) : rotation - 0.5 * Math.PI;\r\n        rotation = rotation % (2.0 * Math.PI);\r\n        this._shadowParameters.set(this._sampleDirections, this._frameId, 1.0, rotation);\r\n        this._outputTexture.setVector4(\"shadowParameters\", this._shadowParameters);\r\n        const voxelGrid = this._renderPipeline!._getVoxelGridTexture();\r\n        const highestMip = Math.floor(Math.log2(voxelGrid!.getSize().width));\r\n        this._voxelBiasParameters.set(this._voxelNormalBias, this._voxelDirectionBias, highestMip, 0.0);\r\n        this._outputTexture.setVector4(\"voxelBiasParameters\", this._voxelBiasParameters);\r\n\r\n        // SSS Options.\r\n        this._sssParameters.set(this._sssSamples, this._sssStride, this._sssMaxDist, this._sssThickness);\r\n        this._outputTexture.setVector4(\"sssParameters\", this._sssParameters);\r\n        this._opacityParameters.set(this._voxelShadowOpacity, this._ssShadowOpacity, 0.0, 0.0);\r\n        this._outputTexture.setVector4(\"shadowOpacity\", this._opacityParameters);\r\n        this._outputTexture.setTexture(\"voxelGridSampler\", voxelGrid);\r\n        this._outputTexture.setTexture(\"blueNoiseSampler\", this._renderPipeline!._getNoiseTexture());\r\n        const cdfGenerator = this._scene.iblCdfGenerator;\r\n        if (cdfGenerator) {\r\n            this._outputTexture.setTexture(\"icdfSampler\", cdfGenerator.getIcdfTexture());\r\n        }\r\n        if (this._coloredShadows && this._scene.environmentTexture) {\r\n            this._outputTexture.setTexture(\"iblSampler\", this._scene.environmentTexture);\r\n        }\r\n\r\n        const geometryBufferRenderer = this._scene.geometryBufferRenderer;\r\n        if (!geometryBufferRenderer) {\r\n            return;\r\n        }\r\n        const depthIndex = geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.SCREENSPACE_DEPTH_TEXTURE_TYPE);\r\n        this._outputTexture.setTexture(\"depthSampler\", geometryBufferRenderer.getGBuffer().textures[depthIndex]);\r\n        const wnormalIndex = geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.NORMAL_TEXTURE_TYPE);\r\n        this._outputTexture.setTexture(\"worldNormalSampler\", geometryBufferRenderer.getGBuffer().textures[wnormalIndex]);\r\n    }\r\n\r\n    /**\r\n     * Called by render pipeline when canvas resized.\r\n     * @param scaleFactor The factor by which to scale the canvas size.\r\n     */\r\n    public resize(scaleFactor: number = 1.0) {\r\n        const newSize = {\r\n            width: Math.max(1.0, Math.floor(this._engine.getRenderWidth() * scaleFactor)),\r\n            height: Math.max(1.0, Math.floor(this._engine.getRenderHeight() * scaleFactor)),\r\n        };\r\n        this._outputTexture.resize(newSize, false);\r\n    }\r\n\r\n    /**\r\n     * Checks if the pass is ready\r\n     * @returns true if the pass is ready\r\n     */\r\n    public isReady() {\r\n        return (\r\n            this._outputTexture.isReady() &&\r\n            !(this._debugPassPP && !this._debugPassPP.isReady()) &&\r\n            this._scene.iblCdfGenerator &&\r\n            this._scene.iblCdfGenerator.getIcdfTexture().isReady() &&\r\n            this._renderPipeline!._getVoxelGridTexture().isReady()\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Disposes the associated resources\r\n     */\r\n    public dispose() {\r\n        this._outputTexture.dispose();\r\n        if (this._debugPassPP) {\r\n            this._debugPassPP.dispose();\r\n        }\r\n    }\r\n}\r\n"]}