<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Pong con Babylon.js</title>
  <style>
    html, body {
      overflow: hidden;
      width: 100%;
      height: 100%;
      margin: 0;
      padding: 0;
      background: black;
    }
    #renderCanvas {
      width: 100%;
      height: 100%;
      touch-action: none;
      display: block;
    }
    #score {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 24px;
      color: white;
      font-family: Arial, sans-serif;
    }
  </style>
</head>
<body>
  <canvas id="renderCanvas"></canvas>
  <div id="score">0 - 0</div>
  <!-- Se incluye Babylon.js desde el CDN -->
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script>
    // Crear el motor y la escena
    var canvas = document.getElementById("renderCanvas");
    var engine = new BABYLON.Engine(canvas, true);
    var scene = new BABYLON.Scene(engine);
    scene.clearColor = new BABYLON.Color4(0, 0, 0, 1); // fondo negro

    // Crear una cámara ortográfica para simular un entorno 2D
    var camera = new BABYLON.FreeCamera("camera", new BABYLON.Vector3(0, 0, -20), scene);
    camera.mode = BABYLON.Camera.ORTHOGRAPHIC_CAMERA;
    // Definir el tamaño de la vista: viewSize determina la mitad de la altura visible
    var viewSize = 10;
    var aspect = engine.getRenderWidth() / engine.getRenderHeight();
    camera.orthoLeft  = -viewSize * aspect;
    camera.orthoRight = viewSize * aspect;
    camera.orthoTop   = viewSize;
    camera.orthoBottom= -viewSize;
    camera.setTarget(BABYLON.Vector3.Zero());

    // Agregar luz
    var light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);
    light.intensity = 1;

    // Definir los límites del campo de juego (según la cámara)
    var fieldLeft   = camera.orthoLeft;
    var fieldRight  = camera.orthoRight;
    var fieldTop    = camera.orthoTop;
    var fieldBottom = camera.orthoBottom;

    // Opcional: crear un plano de fondo para simular la cancha
    var fieldPlane = BABYLON.MeshBuilder.CreatePlane("field", {width: fieldRight - fieldLeft, height: fieldTop - fieldBottom}, scene);
    fieldPlane.position.z = 1; // se ubica detrás de las paletas y la pelota
    var fieldMaterial = new BABYLON.StandardMaterial("fieldMat", scene);
    fieldMaterial.diffuseColor = new BABYLON.Color3(0.1, 0.1, 0.1);
    fieldPlane.material = fieldMaterial;

    // Parámetros de las paletas
    var paddleWidth  = 0.5;
    var paddleHeight = 3;
    var paddleDepth  = 1;

    // Paleta izquierda (jugador izquierdo)
    var leftPaddle = BABYLON.MeshBuilder.CreateBox("leftPaddle", {width: paddleWidth, height: paddleHeight, depth: paddleDepth}, scene);
    leftPaddle.position.x = fieldLeft + paddleWidth; // un poco dentro del límite
    leftPaddle.position.y = 0;
    leftPaddle.position.z = 0;

    // Paleta derecha (jugador derecho)
    var rightPaddle = BABYLON.MeshBuilder.CreateBox("rightPaddle", {width: paddleWidth, height: paddleHeight, depth: paddleDepth}, scene);
    rightPaddle.position.x = fieldRight - paddleWidth;
    rightPaddle.position.y = 0;
    rightPaddle.position.z = 0;

    // Crear la pelota
    var ballRadius = 0.3;
    var ball = BABYLON.MeshBuilder.CreateSphere("ball", {diameter: ballRadius * 2}, scene);
    ball.position = new BABYLON.Vector3(0, 0, 0);

    // Velocidad inicial de la pelota (dirección aleatoria)
    var ballSpeed = 0.2;
    var ballVelocity = new BABYLON.Vector3(
      ballSpeed * (Math.random() > 0.5 ? 1 : -1),
      ballSpeed * (Math.random() > 0.5 ? 1 : -1),
      0
    );

    // Variables para el puntaje
    var scoreLeft = 0;
    var scoreRight = 0;
    function updateScore() {
      document.getElementById("score").innerText = scoreLeft + " - " + scoreRight;
    }
    updateScore();

    // Manejo de entradas de teclado
    var inputMap = {};
    window.addEventListener("keydown", function(evt) {
      inputMap[evt.key] = true;
    });
    window.addEventListener("keyup", function(evt) {
      inputMap[evt.key] = false;
    });

    // Velocidad de movimiento de las paletas
    var paddleSpeed = 0.3;

    // Función para reiniciar la pelota cuando se anota
    function resetBall() {
      ball.position.x = 0;
      ball.position.y = 0;
      // Asignar una nueva dirección aleatoria (ángulo pequeño)
      var angle = (Math.random() - 0.5) * Math.PI / 4;
      var direction = Math.random() > 0.5 ? 1 : -1;
      ballVelocity.x = ballSpeed * direction * Math.cos(angle);
      ballVelocity.y = ballSpeed * Math.sin(angle);
    }

    // Bucle principal de juego (se ejecuta antes de cada render)
    scene.onBeforeRenderObservable.add(function () {
      // Movimiento de la paleta izquierda: teclas "w" (arriba) y "s" (abajo)
      if (inputMap["w"] && leftPaddle.position.y + paddleHeight / 2 < fieldTop) {
        leftPaddle.position.y += paddleSpeed;
      }
      if (inputMap["s"] && leftPaddle.position.y - paddleHeight / 2 > fieldBottom) {
        leftPaddle.position.y -= paddleSpeed;
      }

      // Movimiento de la paleta derecha: teclas "ArrowUp" (arriba) y "ArrowDown" (abajo)
      if (inputMap["ArrowUp"] && rightPaddle.position.y + paddleHeight / 2 < fieldTop) {
        rightPaddle.position.y += paddleSpeed;
      }
      if (inputMap["ArrowDown"] && rightPaddle.position.y - paddleHeight / 2 > fieldBottom) {
        rightPaddle.position.y -= paddleSpeed;
      }

      // Actualizar la posición de la pelota
      ball.position.x += ballVelocity.x;
      ball.position.y += ballVelocity.y;

      // Rebote en las paredes superior e inferior
      if (ball.position.y + ballRadius > fieldTop) {
        ball.position.y = fieldTop - ballRadius;
        ballVelocity.y *= -1;
      } else if (ball.position.y - ballRadius < fieldBottom) {
        ball.position.y = fieldBottom + ballRadius;
        ballVelocity.y *= -1;
      }

      // Colisión con la paleta izquierda
      if (ball.position.x - ballRadius < leftPaddle.position.x + paddleWidth / 2) {
        if (ball.position.y < leftPaddle.position.y + paddleHeight / 2 &&
            ball.position.y > leftPaddle.position.y - paddleHeight / 2) {
          ball.position.x = leftPaddle.position.x + paddleWidth / 2 + ballRadius;
          ballVelocity.x *= -1;
        }
      }

      // Colisión con la paleta derecha
      if (ball.position.x + ballRadius > rightPaddle.position.x - paddleWidth / 2) {
        if (ball.position.y < rightPaddle.position.y + paddleHeight / 2 &&
            ball.position.y > rightPaddle.position.y - paddleHeight / 2) {
          ball.position.x = rightPaddle.position.x - paddleWidth / 2 - ballRadius;
          ballVelocity.x *= -1;
        }
      }

      // Verificar si la pelota sale del campo para anotar
      if (ball.position.x - ballRadius < fieldLeft) {
        // Anota el jugador derecho
        scoreRight++;
        updateScore();
        resetBall();
      }
      if (ball.position.x + ballRadius > fieldRight) {
        // Anota el jugador izquierdo
        scoreLeft++;
        updateScore();
        resetBall();
      }
    });

    // Iniciar el render loop
    engine.runRenderLoop(function () {
      scene.render();
    });

    // Ajustar el tamaño del canvas si la ventana cambia de tamaño
    window.addEventListener("resize", function () {
      engine.resize();
    });
  </script>
</body>
</html>